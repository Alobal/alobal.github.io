[{"title":"2020.8.22 随便写写","url":"/2020/08/22/2020-8-22%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/","content":"<p>是在 hexo 写的第一篇生活记录吧（大概也是几年来写的第一篇 hhhh</p>\r\n<p>随便写写看看能写出啥</p>\r\n<h2 id=\"博客的坑\">博客的坑 (╯‵□′)╯︵┻━┻</h2>\r\n<p>自从开始 Hexo\r\n搭建博客，不知道多少时间都拿去填了这该死的坑！！一开始只是想着，能跑起来就好，技术专业嘛，注重文本可读性，纯粹是想当个可以远程看的文本笔记来着。什么主题不重要，什么字体不重要，只要给我白底黑字，我能读能复习就\r\nok！！</p>\r\n<p>结果！网站能跑了！想想要不给搞个主题配置吧！直接默认风格也太寒颤了！好像隔壁\r\nNext 主题清新的就很和我胃口，装了！ （虽然 Next\r\n主题用的人比默认主题多多了，十个 Hexo 九个\r\nNext，剩下一个是学前端的自定义主题。</p>\r\n<p>博客多了看起来多麻烦，想想要不添加个分类和标签功能吧！嗯嗯都是为了方便找归档博客！诶诶隔壁博客还能放网易云背景音乐啊，带\r\nBGM\r\n看博客肯定很舒服我要了我要了！噢作为一个程序员，大家肯定能理解，别的不折腾，代码高亮主题肯定要折腾一下！！是用\r\nHighlightJS 呢，还是 prismJS 呢，还是 hexo-prism 插件呢！还是一贯的\r\nGoogle 信仰加持的 Google-code-prettify 呢！折腾了半天还出 BUG\r\n了，甚至不能改回正常的普普通通朴素高亮，重新安了一个 Next 主题。..</p>\r\n<p><span id=\"more\"></span></p>\r\n<p>这次重新安装顺带把 Next 从 2020 8.0 版本换成了 7.8，毕竟 8.0\r\n实在没有教程带。... 放心孩子们，虽然我是帮不了你们 8.0 了，但是 7.8\r\n的建站和自定义过程我写的很详细！！全部都是保鲜保质！！有需求的话，最好远离网上的新瓶抄馊饭的博客，请看这里：</p>\r\n<ul>\r\n<li><a\r\nhref=\"https://alobal.github.io/Blog/2020/07/15/Github-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/\">GitHub+Hexo\r\n搭建博客</a></li>\r\n<li><a\r\nhref=\"https://alobal.github.io/Blog/2020/07/23/Next7-8-%E5%8A%9F%E8%83%BD%E6%80%A7%E9%85%8D%E7%BD%AE/\">Next7.8\r\n功能性配置</a></li>\r\n<li><a\r\nhref=\"https://alobal.github.io/Blog/2020/07/24/Next7-8-%E7%BE%8E%E5%8C%96%E6%80%A7%E9%85%8D%E7%BD%AE/\">Next7.8\r\n美化性配置</a></li>\r\n</ul>\r\n<blockquote>\r\n<p>　那些馊饭博客我能吐槽无数遍啊无数遍，虽然有参考价值，但是 2020\r\n请拿出 2020 的样子好吗！</p>\r\n</blockquote>\r\n<p>另外以前是在简书写博客笔记的，那些之前的博客肯定要搬过来的！要不然新建的\r\nHexo 多孤单！于是又折腾了一天的 <a\r\nhref=\"https://alobal.github.io/Blog/2020/07/16/%E7%AE%80%E4%B9%A6%E5%8D%9A%E5%AE%A2%E5%AF%BC%E5%85%A5hexo/\">简书博客导入\r\nHexo</a>...\r\n算是成功搬运了，只不过有些小问题，但也不打紧，过了过了，再折腾这玩意要疯了。</p>\r\n<p>虽然这些导入的博客时间全都设置在 2020.2.17 怪尴尬的 hhhhh\r\n我懒，不想一个一个改了，写个程序一天天递增设置也意义不大。<del>懒得写</del></p>\r\n<blockquote>\r\n<p>　？那你咋不会懒得写博客，每次折腾博客都是半天半天浪费了。——不晓得。脑子不太对就开始写了。</p>\r\n</blockquote>\r\n<p>回到主线，BGM\r\n和代码高亮都折腾了，一切看起来都是适合读书的样子！....？</p>\r\n<ul>\r\n<li>一篇文章怎么能没有字数统计和阅读时长！看着自己码了多少字的博客多有成就感！搞！</li>\r\n<li>刚建站搜索引擎是没有收录的，看不到访客的博客失去了灵魂！百度分析和\r\nGoogle 收录，搞！</li>\r\n<li>喜欢安利 AVG\r\n的我，怎么能不搞点东西记录自己看过的玩过的东西呢！一开始用的是文本形式，记起一个写一个上去，但是看着看着觉得文本太枯燥了，要不要加个详情页链接？加个图片展示？（噢说到图片展示要不要做个相册页面。...\r\n该死，被挖掘机传染了）最后搜着搜着发现可以导入豆瓣影评页面，搞。..\r\n昨天晚上搞这玩意搞到凌晨。<del>其实是聊天为主</del></li>\r\n</ul>\r\n<p>豆瓣也是个大坑... 今天写日记前在豆瓣创了个号补了 45\r\n个电影动漫的【看过+短评】，算是把【影片】这一栏导入完毕了吧。结果刚想动手导【游戏】这一栏的之前在\r\nsteam 写的评测，发现 steam 评测是 steam-bbcode 格式啊！不是 markdown\r\n格式啊！豆瓣游戏评价甚至连 markdown\r\n也不支持啊！！！！在考虑单独开个分类，把每篇评测改造成一篇博客，还是缩减成几句话的短评写在豆瓣里.....然后纠结着发现又是一个浩大的工程啊！！滚过来写了第一篇日记。</p>\r\n<blockquote>\r\n<p>　昨天晚上在我以为能装的功能都折腾完了之后，某个人提了一句，“会有人讨论吗？”...\r\n行行行，评论系统的坑我挖了。</p>\r\n</blockquote>\r\n<p>博客功能配置算是告一段落。..\r\n中间还花了大笔时间去美化性自定义，标题怎么搞好看显眼，默认正文字体怎么感觉不够清新。..\r\n这个美化的坑虽然也埋葬了大笔时光，不过目前还算是满意了，归档！</p>\r\n<p>美化过程中搜到一段话，觉得写的很好哈哈哈哈哈，献给中英文混杂不留白的你：</p>\r\n<blockquote>\r\n<p>　打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在\r\n34\r\n岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。——<a\r\nhref=\"https://github.com/mzlogin/chinese-copywriting-guidelines\">mzlogin</a></p>\r\n</blockquote>\r\n<h2 id=\"心路\">心路</h2>\r\n<p>考研复习停在了那段时间，每天闲着就找子卿守望，不闲也找子卿守望，快乐原生土著队，没事挂着等个路人进来陪我们两憨憨玩。结果</p>\r\n<blockquote>\r\n<p>　靠！你说你烦躁归烦躁！你停考研复习干嘛啊！？</p>\r\n</blockquote>\r\n<p>碰到了个十四老师。这人是真的好有活力=\r\n=每天闪闪发光蹦跶优秀。虽然憨憨也憨憨地快\r\nhhh。人醒了，不敲了，第一篇日记告一段落。</p>\r\n","categories":["生活"]},{"title":"Attention Is All You Need","url":"/2021/12/23/AttentionIsAllYouNeed/","content":"<ul>\r\n<li>Vaswani A, Shazeer N, Parmar N, et al. Attention is all you\r\nneed[C]//Advances in neural information processing systems. 2017:\r\n5998-6008.</li>\r\n<li>Google</li>\r\n</ul>\r\n<h1 id=\"introduction\">Introduction</h1>\r\n<p>大名鼎鼎的Transformer，仅依赖于注意力机制，完全不使用RNN和CNN的序列模型</p>\r\n<p>RNN，LSTM，GNU是处理序列模型的几种最优方法。然而循环神经网络中总是沿着词元位置进行计算，这种<strong>顺序性阻碍了训练的并行化</strong>，这也严重影响了内存对batch的限制程度。</p>\r\n<p>注意力机制也是成功的模型中必不可少的一部分，其可以考虑到模型中的依赖关系。<strong>大部分情况下注意力都和RNN捆绑在了一起</strong>。</p>\r\n<p><strong>Transformer</strong>，完全避开了RNN，并且完全依赖注意力机制来抽取输入和输出的全局关系。并且能有更好的并行化。</p>\r\n<p>相关工作：</p>\r\n<ul>\r\n<li>Self-Attention：提取序列不同位置联系的一种方式，可以计算出一个序列的表示形式。</li>\r\n<li>End-to-end memory\r\n：基于循环注意力机制，而不是序列循环网络，在语言建模任务上有优秀表现。</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<h1 id=\"model-architecture\">Model Architecture</h1>\r\n<p>大部分序列转换模型都是 <strong>编码器-解码器</strong>\r\n框架。其中编码器将输入序列从离散的符号表示映射到一个连续表示<span\r\nclass=\"math inline\">\\(z\\)</span>。得到<span\r\nclass=\"math inline\">\\(z\\)</span>之后，解码器逐时间步去生成输出序列<span\r\nclass=\"math inline\">\\((y_1,....,y_m)\\)</span>。Transformer也是在这个大框架之下：</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/mLvciTv.jpg\" alt=\"Model Architecture\" />\r\n<figcaption aria-hidden=\"true\">Model Architecture</figcaption>\r\n</figure>\r\n<p><strong>编码器-解码器</strong>：</p>\r\n<ol type=\"1\">\r\n<li>编码器：主要模块由两个子层<strong>Multi-head\r\nself-attention</strong>和<strong>position-wise\r\n全连接</strong>构成，并且每个子层都是用了一个残差连接。</li>\r\n<li>解码器：增加了一个Masked层，用于处理编码器的输出。同样每层都是用了残差连接设计。另外修改了self-attention层防止前面的元素受到后面的元素的影响。<strong>这样对位置i的预测仅能依赖于位置小于i的编码器输出。</strong></li>\r\n</ol>\r\n<h2 id=\"attention\">Attention</h2>\r\n<h3 id=\"scaled-dot-product-attention\">Scaled Dot-Product Attention</h3>\r\n<figure>\r\n<img src=\"https://i.imgur.com/GIL399v.png\" alt=\"放缩点积注意力\" />\r\n<figcaption aria-hidden=\"true\">放缩点积注意力</figcaption>\r\n</figure>\r\n<p>两种最常用的注意力评分函数是 加性注意力 和\r\n点积注意力。点积由于矩阵计算的优化，计算上更加效率。然而在大批量上加性注意力效果往往能够超越点积注意力。论文认为这是因为在大批量下，<strong>点积结果会数量级膨胀，导致softmax达到一个梯度极小的区域</strong>，因此为了解决这种现象，提出了<strong>放缩的点积注意力</strong>。</p>\r\n<p><span class=\"math display\">\\[\r\na(\\mathbf{q}, \\mathbf{k})=\\mathbf{q}^{\\top}\\mathbf{k}/\\sqrt{d}\r\n\\]</span></p>\r\n<p>其中<span\r\nclass=\"math inline\">\\(d\\)</span>为向量长度（显然query和key需要相同长度）。</p>\r\n<h3 id=\"multi-head-attention\">Multi-Head Attention</h3>\r\n<figure>\r\n<img src=\"https://i.imgur.com/Pg1hq7H.png\" alt=\"多头注意力\" />\r\n<figcaption aria-hidden=\"true\">多头注意力</figcaption>\r\n</figure>\r\n<p>相比于在数据上使用单一的一个注意力机制，Multi-Head\r\nAttention可以联合多种方式学到的不同信息。其<strong>通过<span\r\nclass=\"math inline\">\\(h\\)</span>个可学习的线性变换将query，key，value分别进行线性投影到<span\r\nclass=\"math inline\">\\(h\\)</span>个空间的<span\r\nclass=\"math inline\">\\(d_k,d_k,d_v\\)</span>维度</strong>。再在这<span\r\nclass=\"math inline\">\\(h\\)</span>种数据上并行使用注意力机制，最终每个空间都得到<span\r\nclass=\"math inline\">\\(d_v\\)</span>维的output\r\nvalues。将它们都连接起来，并且再进行一次投影，生成最终的values：</p>\r\n<p><span class=\"math display\">\\[\r\nMultiHead(Q,K,V)=Concat(h_1,...,h_h)W^O \\\\\r\nwhere \\ h_i=Attention(QW_i^Q,KW_I^K,VW_I^V)\r\n\\]</span></p>\r\n<p>实践中使用了8个head，每个维度都相应的除以8进行降维：<span\r\nclass=\"math inline\">\\(d_k=d_k=d_{model}/8=64\\)</span>。因为由于每个head都降维了，因此实际总计算花费和一个单一的注意力机制差不多。</p>\r\n<h3 id=\"模型中attention的使用\">模型中Attention的使用</h3>\r\n<ul>\r\n<li>编码器-解码器：query来自解码器的上一个输出，key和value来自编码器的输出。这使得解码器中每个位置都能与输入序列的所有位置产生联系，这基本上是经典的编码器解码器注意力机制。</li>\r\n<li>编码器中的self-attention层：key，value，query都来自编码器的上一个输出。这样编码器中的每个位置都能和之前所有位置产生联系。</li>\r\n<li>解码器中的self-attention层：同样，让解码器中的每个位置能和之前(包括自己)的所有位置产生联系。另外解码器中还需要避免使用后方的信息，因此在放缩点积注意力的softmax之前，设置了一个mask来掩盖掉当前位置对后方位置的连接。</li>\r\n</ul>\r\n<h2 id=\"position-wise-feed-forward-networks\">Position-wise Feed-Forward\r\nNetworks</h2>\r\n<p>在注意力层之后使用了一个共享参数的全连接层(两个线性层+ReLU)，对每个位置单独进行变换(它们参数一样)：</p>\r\n<p><span class=\"math display\">\\[\r\nFFN(X)=max(0,xW_1+b_1)W_2+b_2\r\n\\]</span></p>\r\n<h2 id=\"positional-encoding\">Positional Encoding</h2>\r\n<p>由于没有使用卷积和循环框架，想要使用位置信息，则需要在embeddings的基础上与一个\r\n<strong>Positional encodings</strong>相加：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{split}\\begin{aligned} p_{pos, 2i} &amp;=\r\n\\sin\\left(\\frac{pos}{10000^{2i/d}}\\right),\\\\p_{pos, 2i+1} &amp;=\r\n\\cos\\left(\\frac{pos}{10000^{2i/d}}\\right).\\end{aligned}\\end{split}\r\n\\]</span></p>\r\n<p>其中pos是编码的位置，i是编码目标维度(类似于embedding后的维度)。每个维度<span\r\nclass=\"math inline\">\\(i\\)</span>都对应一种正弦波，显然沿着维度升高，正弦波的频率单调降低，波长单调升高。因此也可以知道，对较低的维度，特征重合大，并且变换频率快。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/pGRZDCv.png\"\r\nalt=\"编码正弦波示意图。Col表示编码的不同维度，Row表示不同的位置。同一维度下的位置信息在同一条正弦波上。同一位置的不同维度(即不同正弦波)计算出不同的值。\" />\r\n<figcaption\r\naria-hidden=\"true\">编码正弦波示意图。Col表示编码的不同维度，Row表示不同的位置。同一维度下的位置信息在同一条正弦波上。同一位置的不同维度(即不同正弦波)计算出不同的值。</figcaption>\r\n</figure>\r\n<p>并且这种positional encoding可以很好表示相对位置。对于同样的维度<span\r\nclass=\"math inline\">\\(2i,2i+1\\)</span>上，位置 <span\r\nclass=\"math inline\">\\(pos+\\delta\\)</span> 和位置 <span\r\nclass=\"math inline\">\\(pos\\)</span>\r\n之间是线性变换的关系。即<strong>通过线性变换，就可以把<span\r\nclass=\"math inline\">\\((p_{i, 2j}, p_{i, 2j+1})\\)</span>投影到<span\r\nclass=\"math inline\">\\((p_{i+\\delta, 2i}, p_{i+\\delta,\r\n2i+1})\\)</span></strong>。证明如下：令<span\r\nclass=\"math inline\">\\(\\omega_j = 1/10000^{2j/d}\\)</span></p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{split}\\begin{aligned}\r\n&amp;\\begin{bmatrix} \\cos(\\delta \\omega_j) &amp; \\sin(\\delta \\omega_j)\r\n\\\\  -\\sin(\\delta \\omega_j) &amp; \\cos(\\delta \\omega_j) \\\\ \\end{bmatrix}\r\n\\begin{bmatrix} p_{i, 2j} \\\\  p_{i, 2j+1} \\\\ \\end{bmatrix}\\\\\r\n=&amp;\\begin{bmatrix} \\cos(\\delta \\omega_j) \\sin(i \\omega_j) +\r\n\\sin(\\delta \\omega_j) \\cos(i \\omega_j) \\\\  -\\sin(\\delta \\omega_j) \\sin(i\r\n\\omega_j) + \\cos(\\delta \\omega_j) \\cos(i \\omega_j) \\\\ \\end{bmatrix}\\\\\r\n=&amp;\\begin{bmatrix} \\sin\\left((i+\\delta) \\omega_j\\right)\r\n\\\\  \\cos\\left((i+\\delta) \\omega_j\\right) \\\\ \\end{bmatrix}\\\\\r\n=&amp;\r\n\\begin{bmatrix} p_{i+\\delta, 2j} \\\\  p_{i+\\delta, 2j+1} \\\\\r\n\\end{bmatrix},\r\n\\end{aligned}\\end{split}\r\n\\]</span></p>\r\n<p>另外，虽然这种编码和positional\r\nembeddings效果差不多，<strong>但是正弦编码可以生成比训练数据更长的序列。</strong>\r\n(因为是直接定义式，没有需要学习的参数)</p>\r\n<h1 id=\"self-attention-优势\">Self-Attention 优势</h1>\r\n<p>从三个方面进行性能分析：<strong>计算复杂度</strong>，<strong>可并行操作数</strong>，<strong>长距离依赖路径长度</strong>(路径越短，学习到长距离依赖更容易)</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/nnxHIIj.png\"\r\nalt=\"不同特征抽取方式的性能分析。n为序列长度，d为数据表示维度，k为核大小，r为邻域大小\" />\r\n<figcaption\r\naria-hidden=\"true\">不同特征抽取方式的性能分析。n为序列长度，d为数据表示维度，k为核大小，r为邻域大小</figcaption>\r\n</figure>\r\n<p>在<span\r\nclass=\"math inline\">\\(n&lt;d\\)</span>时，self-attention计算复杂度优于RNN，并且实际中<span\r\nclass=\"math inline\">\\(n&lt;d\\)</span>是大多数情况。针对特别大的<span\r\nclass=\"math inline\">\\(n\\)</span>的情况，self-attention需要被限制在一个<span\r\nclass=\"math inline\">\\(r\\)</span>的邻域之中，但是这增加了长距离依赖路径长度，论文尚未解决。</p>\r\n<p><span\r\nclass=\"math inline\">\\(k&lt;n\\)</span>的卷积层不能连接所有的元素，因此需要<span\r\nclass=\"math inline\">\\(O(n/k)\\)</span>层连续卷积，或者<span\r\nclass=\"math inline\">\\(O(\\log_k\r\nn)\\)</span>的空洞卷积，也会导致依赖路径的变长。</p>\r\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"408错题集","url":"/2020/12/05/408%E9%94%99%E9%A2%98%E9%9B%86/","content":"<h2 id=\"数据结构\">数据结构</h2>\r\n<p>C语言标识符需要 字母 / 下划线 开头，不能数字开头</p>\r\n<p>中序和层序才能构成唯一的二叉树，先序和层序不能。</p>\r\n<p>完全二叉树的叶子节点不一定在最后一层，最后两层都可能。下(n/2)为最后的父节点。</p>\r\n<h3 id=\"查找\">查找</h3>\r\n<p>分块查找，块内取√n长度，ASL达到最小值。</p>\r\n<p>Hash表删除元素，不能简单地删除，而是标记为删除。因为在开放定址法里面，会影响到后面的元素查找。\r\nHash表平均失败长度是对mod出的位置算，不是对所有表的位置都算。</p>\r\n<p>B树支持随机查找，B+支持随机和顺序。注意基础的是随机查找，特有的是顺序查找。</p>\r\n<p><strong>折半查找判定树</strong>\r\n是一种平衡二叉排序树，判定树的结构和总节点数N一一对应。 高度H=下(log2\r\nn)+1=查找成功最多比较次数=查找失败最多比较次数 N节点建树方法： -\r\n先判断高度H，构建好H-1层的满二叉树 - 对于剩下的节点： -\r\nmid<strong>向下</strong>取整时，从根节点开始，按照<strong>先右后左</strong>的顺序判断往哪边挂新节点。对子树也是递归同样的规则判断。\r\n- mid<strong>向上</strong>取整时，<strong>先左后右</strong> -\r\n最后按照中值遍历的顺序填充节点值。\r\n&gt;向上取整和向下取整体现在树中就是哪侧会多一个节点。</p>\r\n<h3 id=\"排序\">排序</h3>\r\n<p>所有元素相等时的排序：简单选择排序是n^2, 基数排序是nd。</p>\r\n<p>插入排序，注意n趟之后是有n+1个元素有序。初始一个不算趟数。</p>\r\n<p>堆排序向下调整，先找出两个子节点中最厉害的那个，再换，递归继续向下。</p>\r\n<p>平衡二叉树[节点最少/层数最多]情况的递推：N1=1 N2=2\r\nNh=N(h-1)+N(h-2)+1</p>\r\n<p>排序序列原始状态只影响快排的效率，不影响趟数，事实上每一趟确定一个数的位置。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"计组\">计组</h2>\r\n<p>小心，CPI和时钟频率无关，只和执行速度有关</p>\r\n<p>RISC的体系结构并不等同于早期计算机的简单结构</p>\r\n<p>数据总线的位数一般等于机器字长，但也不绝对。大于的时候CPU可以分两次取数。</p>\r\n<p>翻译程序 -\r\n编译程序：将高级语言程序一次全部翻译成目标程序。每次执行只执行目标程序文件\r\n- 解释程序：将源程序每条语句翻译成机器目标代码，并立即执行。不产生文件。\r\n- 汇编程序：将汇编语言翻译成机器语言，和机器语言一一对应。</p>\r\n<h3 id=\"编码\">编码</h3>\r\n<p>不是所有十进制小数都可以用二进制表示，如0.3</p>\r\n<p><strong>浮点数</strong></p>\r\n<p>浮点数运算，阶码双符号位判断溢出，尾数双符号位决定正负。\r\n阶码上溢需要中断处理，阶码小于最小阶码即下溢，看作机器零处理。</p>\r\n<p>最简单的浮点数舍入处理方法是直接截断法。</p>\r\n<p>IEEE754浮点数乘法运算结果肯定不需要左规处理。左规是数往左移动，好让小数点前面有个1。因为754尾数必然≥1，尾数运算结果也必然≥1，显然不会需要左规。</p>\r\n<p>IEEE754\r\n阶码全1尾数全0是±∞，阶码全0尾数全0是±0。如果尾数此时不是0，则是NaN非规格数。</p>\r\n<h3 id=\"存储系统\">存储系统</h3>\r\n<p><strong>Cache</strong>\r\nCache不能作为指令地址码，一般都是主存单元作为地址码，系统自动在Cache中查找，Cache对程序员透明。\r\n指令地址码一般是 主存单元/数据寄存器。</p>\r\n<p>Cache每行位数：数据bit+Tag位+(LRU 1)+(修改位 1)+(有效位\r\n1)。注意不需要组号位，假如是组相联映射，主存地址结构中间几位是组号，但是Cache每行里面不需要装组号，多路分组是地址结构解析的事。</p>\r\n<p>Cache采用N路组相联映射：组内有N行，组数=数据区容量/每组容量</p>\r\n<p>Cache完全由硬件实现，且Cache透明。\r\n虚存由软硬件实现。虚存对系统程序员不透明，对应用程序员也透明。虚存大小≤内存+外存\r\nCache和TLB缺失都可以由硬件处理。</p>\r\n<p>对a[k]=a[k]+32;\r\n赋值也需要访问Cache，即需要访问两次Cache里的a[k]。</p>\r\n<p><strong>RAM</strong> RAM都是易失性存储器 SRAM 非破坏性读出，DRAM\r\n破坏性读出，。 SRAM 双稳态触发器，不需要再生，DRAM电容存储，需要再生。\r\nSRAM 更贵，功耗更大，集成度更低，速度更快。 DRAM\r\n地址复用，分两次送行列地址。</p>\r\n<p>高位交叉存储器也可能在一个存储周期内连续访问几个模块，只不过概率比较小...</p>\r\n<p>存取周期和存取时间是不同的概念，周期是连续两次操作的间隔，时间是一次操作的时间。周期＞时间。</p>\r\n<p><strong>分页管理和虚拟存储器</strong>\r\nTLB里存的是页表，访问完TLB还要访存访问页面。\r\n注意在统计TLB和主存访问次数的时候，缺页中断后，对原数据重新访问一次。</p>\r\n<p>分页存储解决的是不连续存储的问题，注意虚拟存储器的请求分页机制才是逻辑扩充容量。</p>\r\n<p>页面置换算法中，只有FIFO会出现Belady现象，队列类算法。\r\nLRU性能好，但需要寄存器和栈的硬件支持，是堆栈类算法。\r\nNRU=CLOCK，用较小的开销接近LRU性能。</p>\r\n<p>工作集窗口k是从当前时刻往前k个之内，是集合。不需要因为重复继续往前延伸。重复时工作集大小就小于k了。</p>\r\n<h3 id=\"指令系统\">指令系统</h3>\r\n<p>指令字长通常都是存储字长的整数k倍，k≥1。注意只说一样长是错误的。</p>\r\n<h3 id=\"cpu\">CPU</h3>\r\n<p>CPU数据通路由控制部件控制，因此数据通路内不包括控制部件。</p>\r\n<p>无论执行什么指令，CPU在指令周期首先是 取指，(PC)-&gt;MAR。</p>\r\n<p>CM控制存储器存储的是\r\n所有机器指令的微程序，也即所有微程序的所有微指令。\r\nCM容量=微指令数X微指令字长 注意水平型微指令字长 -\r\n操作控制字段，字段直接编码——互斥性微命令放在同一段进行编码，相容性微命令放在不同段。\r\n- 判断测试字段位数=外部条件数。比如外部条件3个，应该是3位，而不是2位。 -\r\n下地址字段位数N：即2^N≥所有微指令数。</p>\r\n<h3 id=\"总线\">总线</h3>\r\n<p>地址总线是单向的，数据、控制总线是双向的。</p>\r\n<p>异步定时方式适合速度差异较大的设备之间。完全依靠双方的握手信号来实行定时控制。</p>\r\n<h3 id=\"io\">IO</h3>\r\n<p>DMA中断只用来向CPU提出传输结束，可能报告数据错误，不会检查数据错误，不用来实现数据传送和申请总线。</p>\r\n<p>DMA中断请求可以在每个机器周期介乎，而普通中断需要在每条指令执行后。</p>\r\n<p>初始化中断向量表由操作系统完成，找中断向量由隐指令硬件完成。</p>\r\n<p>CPU通过IO指令控制通道。通道在通道程序执行结束产生IO中断向CPU报告。\r\n程序中断和通道都是软硬件结合的方式</p>\r\n<p>设备独立性=设备无关性=用户程序独立于具体物理设备=使用逻辑设备号\r\n设备驱动程序：与硬件直接相关，隐藏同类设备的设备控制器之间的差异。\r\n虚拟设备是指把一个物理设备变换成多个逻辑设备，但不是指把独占设备改成共享设备。</p>\r\n<h2 id=\"操作系统\">操作系统</h2>\r\n<p>微内核比起单一大内核效率更低，因为需要频繁切换核心态和用户态，开销大。</p>\r\n<p>从操作系统内核空间读数据或指令是静态的，不需要保护。</p>\r\n<h3 id=\"进程管理\">进程管理</h3>\r\n<p>线程共享进程的虚拟地址空间，但每个线程有自己的栈空间。\r\n子进程不共享父进程的虚拟地址空间，仅共享一部分资源。创建子进程时会分配相关资源。</p>\r\n<p>进程打开定时器是需要保护的操作，否则可能修改时间片。</p>\r\n<p>设备分配不会创建新进程，只是设置对应数据结构。</p>\r\n<p>死锁处理 -\r\n死锁避免：银行家算法，在进程执行过程中动态规避可能导致死锁的分配。 -\r\n死锁预防：从根本上破坏死锁条件，使死锁不可能成立。如限制进程申请资源的顺序，给资源编号分配。\r\n- 死锁检测：啥都不管，真死锁了检测到了，就强行处理掉...</p>\r\n<h3 id=\"内存管理\">内存管理</h3>\r\n<p>地址变换时，可能因缺页、地址越界、内存保护发生中断，不会发生内存溢出。</p>\r\n<h3 id=\"文件系统\">文件系统</h3>\r\n<p>Open()系统调用打开文件，读入文件的控制管理信息。文件内容是在打开之后，需要使用文件的时候，再读入。\r\nFAT表是在挂载文件系统的时候就读入到系统了。\r\n超级快是系统自举用，启动系统时读入。</p>\r\n<p>逻辑记录是对文件进行存取的基本单位。</p>\r\n<p>索引文件的表项装的是记录<strong>逻辑地址</strong>，不是物理地址，因为索引文件是逻辑结构。</p>\r\n<p>对文件访问权限的管理，通常由用户访问权限+文件属性限制，注意和用户优先级无关。</p>\r\n<p>直接存取是介于随机存取和顺序存取（磁带）之间的方式，直接存取存储器，例如磁盘，一般也可以顺序访问，但是比较低效。</p>\r\n<p>磁盘调度算法中，不会导致磁臂黏着的只有FCFS，考虑同一个磁道不停地申请。</p>\r\n<p>磁盘初始化：物理/低级格式化：扇区+校验码————柱面分磁盘区————逻辑格式化：文件系统+空闲盘块数据结构</p>\r\n<h2 id=\"计网\">计网</h2>\r\n<p>虚电路分为永久性虚电路和交换型虚电路，所以不是所有虚电路都会在会话结束释放链接。</p>\r\n<p>网络线路吞吐量=单位时间内通过的数据量=发送bit/(发送时延+往返时延)</p>\r\n<p>OSI 网络层两种方式，传输层仅面向连接。 TCP/IP\r\n网络层无连接，传输层两种方式。</p>\r\n<p>交换机和路由器的线路，即没有主机的线路，也算交换机分割的一个冲突域。</p>\r\n<p>按照对等层通信原则，IP分组的重组由网络层完成，而排序则由传输层完成。</p>\r\n<p>端到端是指进程端口到进程端口，即TCP/IP传输层。\r\n点到点是网络节点到网络节点，数据链路层。</p>\r\n<p>计算信道最高数据传输率的时候，注意看清给的是信道频率还是信道带宽。两个公式要求的W都是带宽。例如给频率3.5~3.9MHz，带宽=3.9-3.5=0.4MHz</p>\r\n<h3 id=\"数据链路层\">数据链路层</h3>\r\n<p>CSMA/CD 冲突时间=往返时间，最小帧长=最大帧碎片长</p>\r\n<p>以太网冲突时间=2τ=51.2μs 10Mb/s以太网最小帧长=10Mb/s X\r\n51.2μs=512bit=64B</p>\r\n<p>连续ARQ包括两种：GBN和SR选择重传</p>\r\n<p>以太网最小数据长度46B，因此封装的IP数据包总长度字段要≥46</p>\r\n<p><strong>无线局域网</strong>\r\nCTS和ACK确认帧的IFS都是SIFS。RTS之前有DIFS。 帧格式地址：RA(BSSID)+SA+DA\r\n= 目的地接入站地址+ 源地址 + 目的地址</p>\r\n<h3 id=\"网络层\">网络层</h3>\r\n<p>ARP请求是广播的，ARP响应是单播的。作为对比，DHCP是四个广播：DHCP发现，DHCP提供，DHCP请求，DHCP确认。</p>\r\n<p>路由表中配置到互联网的路由即一般默认路由项：目的IP 0.0.0.0 + 子网掩码\r\n0.0.0.0 + 下一跳IP + 接口</p>\r\n<h3 id=\"传输层\">传输层</h3>\r\n<p>TCP连接时，默认只有第一个序号是消耗的，第三次握手的序号也可以用作数据传送。</p>\r\n<p>注意IP分片需要是8B整数倍，偏移量=x/8B</p>\r\n<h3 id=\"应用层\">应用层</h3>\r\n<p>HTTP 服务器是80端口，客户端不确定。</p>\r\n<p>WWW高速缓存将最近的一些请求和响应暂存在本地磁盘中，可以有效降低WWW延迟。</p>\r\n","tags":["杂记"]},{"title":"C++构造函数初始化列表","url":"/2020/08/05/C++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/","content":"<h1 id=\"语法\">语法</h1>\r\n<p>在构造函数的（）之后，冒号开头，逗号分隔，括号传参，这一段就是初始化列表，随后是在{}里写构造函数内容。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Example</span>(argv):<span class=\"built_in\">a</span>(<span class=\"number\">1</span>),<span class=\"built_in\">b</span>(<span class=\"number\">2</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"初始化作用\">初始化作用</h1>\r\n<h2\r\nid=\"无法赋值的成员必须使用初始化列表进行初始化\">无法赋值的成员，必须使用初始化列表进行初始化</h2>\r\n<p>例如假设有个类成员，它本身是个没有默认构造函数的类。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CMember</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">CMember</span>(<span class=\"keyword\">int</span> x)&#123;···&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>我们都知道此时<code>CMember* pm=new CMember;</code>是错误的，必须调用有参数的构造函数。</p>\r\n<p>此时 CMember 是另一个类的成员时，我们怎么初始化呢？</p>\r\n<p><span id=\"more\"></span></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CMyClass</span> &#123;</span> </span><br><span class=\"line\">CMember m_member; </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>: </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">CMyClass</span>(); </span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//必须使用成员初始化列表 </span></span><br><span class=\"line\">CMyClass::<span class=\"built_in\">CMyClass</span>() : <span class=\"built_in\">m_member</span>(<span class=\"number\">2</span>) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">...</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\r\n<p>因为 m_member 不存在默认构造函数，所以不能在构造函数里\r\n默认初始化后再对其赋值，<strong>只能使用初始化列表的方式</strong>。</p>\r\n<p>常量对象和引用对象也是一样，只能被初始化。</p>\r\n<h2 id=\"效率相关\">效率相关</h2>\r\n<p>和上例类似，假如 CMember 存在默认构造函数呢？那我们是可以在 CMyClass\r\n函数体内对其赋值的。</p>\r\n<p>但是此时编译过程是————先调用 CMember\r\n的默认构造函数，再调用拷贝构造函数，即需两次函数运算。</p>\r\n<p>而假如是初始化列表，则直接调用相应的带参数的构造函数。</p>\r\n","categories":["C++"],"tags":["C++"]},{"title":"C++函数","url":"/2020/08/17/C++%E5%87%BD%E6%95%B0/","content":"<h2 id=\"局部静态对象\">局部静态对象</h2>\r\n<p>有些时候，我们需要保留一些对象在函数体结束后依然使用，定义时使用<code>static</code>将其声明为静态类型，直到程序终止才销毁。</p>\r\n<blockquote>\r\n<p>虽然在函数外没有销毁，但是其仍然是局部变量，外部不可访问，只不过其内存也不释放。</p>\r\n</blockquote>\r\n<p>局部静态变量如果没有显式的初始化值，将执行<strong>值初始化</strong>，内置类型的值初始化为0。</p>\r\n<p>一个简单的例子，这个程序会输出 1~10 的数字。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">count_calls</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">size_t</span> num=<span class=\"number\">0</span>;</span><br><span class=\"line\">    num++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"built_in\">count_calls</span>()&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"指针变量传递\">指针变量传递</h2>\r\n<p>指针变量作为参数和普通变量作为参数一样，都是值传递。即形参和实参是两个不同的指针变量，两个指针自己的地址不一样，但是它们的值一样——即它们指向的地址是一样的。因此可以通过传递指针修改实参。</p>\r\n<h2 id=\"const-参数\">const 参数</h2>\r\n<p>实参传给形参会忽略掉<strong>顶层const</strong>，即从函数外部看函数，我们不知道这个函数的参数究竟有没有顶层const，也因此<strong>不能通过顶层const来重载函数</strong>。例如：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn1</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> i)</span></span>&#123;···&#125;     <span class=\"comment\">//忽略顶层 const</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn1</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;···&#125;           <span class=\"comment\">//错误，重复定义</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn2</span><span class=\"params\">( <span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> i)</span></span>&#123;···&#125;  <span class=\"comment\">//忽略顶层 const</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn2</span><span class=\"params\">(<span class=\"keyword\">int</span> * i)</span></span>&#123;···&#125;         <span class=\"comment\">//错误，重复定义</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn3</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * i)</span></span>&#123;···&#125;   <span class=\"comment\">//这是底层 const，不会造成重复定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn3</span><span class=\"params\">(<span class=\"keyword\">int</span> * i)</span></span>&#123;···&#125;         <span class=\"comment\">//正确</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn4</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;i)</span></span>&#123;···&#125;    <span class=\"comment\">//正确，也类似于底层const，const int 算作一种独立类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn4</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;i)</span></span>&#123;···&#125;          <span class=\"comment\">//int优先匹配int&amp;，其次匹配const int&amp;。 const int只能匹配const int&amp;</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>顶层可以理解为离变量最近的一层，顶层 const\r\n修饰指针本身的值，即指向哪一个地址不能被修改，底层 const\r\n修饰指针指向的对象的值不能被修改。</p>\r\n</blockquote>\r\n<p>形参初始化和变量初始化一样，关于 const\r\n的要求都是可<strong>降格兼容，不能升格</strong>。即如上<code>int</code>可用于初始化<code>const int</code>变量，<code>const int</code>不能初始化<code>int</code>变量。引用和指针层面也是类似，<code>cont int</code>引用可绑定到<code>int</code>对象，<code>int</code>引用不可绑定到<code>const int</code>对象。</p>\r\n<p><strong>尽量使用常量引用</strong>。使用常量引用可以避免拷贝数据，同时阻止非必要的修改操作。另一方面由于外部的\r\nconst 类型不能升格传参给非 const 形参，容易发生类型匹配错误。而外部的非\r\nconst 类型可以传给 const 形参，因此使用 const\r\n引用，也可以有效减少这种类型错误的情况。</p>\r\n<h2 id=\"数组形参\">数组形参</h2>\r\n<p>数组有两个特殊性质，影响我们对数组的传参操作：</p>\r\n<ul>\r\n<li>数组不能进行拷贝</li>\r\n<li>使用数组时相当于使用指针</li>\r\n</ul>\r\n<p>所以我们不能值传递数组，但是我们可以通过指针进行传递，如下三个等价的传递数组的函数，看起来不一样，其实都是形参都是\r\nconst int*，导致重复定义：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//会互相造成重复定义错误</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * a)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> a[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> a[<span class=\"number\">10</span>])</span></span>;<span class=\"comment\">//这里数组大小只是一个期望大小，有没有完全一样，和没有的会造成重复定义。</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>但是正如示例所述，只传递指针的话，我们不知道传进来的数组有多大，因此可以通过别的途径传递长度信息：</p>\r\n<ul>\r\n<li>加一个length变量\r\n<code>void fcn(const int a[],int length);//用另一个变量标记长度</code></li>\r\n<li>取得尾后迭代器\r\n<code>void fcn(const int *begin,const int * end)//标准库规范做法，传递尾后元素，进行尾后检测</code></li>\r\n</ul>\r\n<h3 id=\"多维数组\">多维数组</h3>\r\n<p>我们知道多维数组其实就是一维数组，只不过数组元素是新数组指针而已。多维数组即看作指针的指针进行传递。如下，首先明确传参的只是一个指针，指向首元素，这个指针的类型是首元素类型。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn</span><span class=\"params\">(<span class=\"keyword\">int</span> (* matrix)[<span class=\"number\">10</span>])</span></span>;   <span class=\"comment\">//matrix 是一个指针，指向首元素类型为 int[10]</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn</span><span class=\"params\">(<span class=\"keyword\">int</span> matrix[][<span class=\"number\">10</span>])</span></span>;     <span class=\"comment\">//等价形式，前面示例知道 matrix[] 其实也是看作指针。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn</span><span class=\"params\">(<span class=\"keyword\">int</span> * matrix[<span class=\"number\">10</span>])</span>      <span class=\"comment\">//错误，这是一个一维数组，数组元素类型是 int*</span></span></span><br></pre></td></tr></table></figure>\r\n<p>注意，虽然上述传递一维数组会忽略数组大小，但是<strong>第二维及以上的数组大小算作一种数据类型</strong>，需要严格对应:</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn</span><span class=\"params\">(<span class=\"keyword\">int</span> a[][<span class=\"number\">2</span>])</span> <span class=\"comment\">// == int (*a) [2]  , != int *a[2]</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> b[<span class=\"number\">2</span>][<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">fcn</span>(b);<span class=\"comment\">//错误，int (*)[4] 和 int(*)[2] 类型的形参不兼容。a指向int [2],b指向int[4]。</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>另外注意 int ** 和 int (*) [10] 不是同一个类型。</p>\r\n</blockquote>\r\n<h2 id=\"变长形参\">变长形参</h2>\r\n<p>有时候我们不确定要传递几个实参给函数，因此 C++提供了两种方法。</p>\r\n<h3 id=\"initializer_list\">Initializer_list</h3>\r\n<p>Initializer_list\r\n是一个很简单的列表容器，有点像python的<code>*args</code>。</p>\r\n<ul>\r\n<li>形参使用<code>initializer_list&lt;T&gt;</code>来接受列表参数</li>\r\n<li>实参使用初始化列表传参<code>&#123;T1,T2,T3&#125;</code></li>\r\n<li>函数体内则和其他容器一样访问。</li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">error_msg</span><span class=\"params\">(<span class=\"keyword\">int</span> count,initializer_list&lt;string&gt; msg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> arg =msg.<span class=\"built_in\">begin</span>();arg!=msg.<span class=\"built_in\">end</span>();++arg)</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">error_msg</span>(<span class=\"number\">217</span>,&#123;<span class=\"string\">&quot;Hello&quot;</span>,<span class=\"string\">&quot;,&quot;</span>,<span class=\"string\">&quot;World&quot;</span>,<span class=\"string\">&quot;!&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"省略符\">省略符</h3>\r\n<p>省略符是为了兼容 C 而设置的。通常<strong>不建议在 C\r\n之外使用</strong>。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(parm_list,...)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(...)</span></span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"返回值\">返回值</h2>\r\n<h3 id=\"返回数组指针\">返回数组指针</h3>\r\n<p>函数返回一个普通指针很简单，返回值 <code>type *</code>\r\n即可，但是返回一个指向数组的指针呢？正常声明数组指针变量是<code>type (*var)[size]</code>\r\n： var是一个指针，指向一个大小为size的数组，数组元素类型是type。</p>\r\n<p>那么函数返回同理：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">type</span> (* <span class=\"built_in\">func</span>(param...)) [size]</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"decltype返回\">decltype返回</h3>\r\n<p>如果已知返回的是什么变量的类型，可以使用decltype来推断返回类型：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">decltype</span>(somevar) * <span class=\"built_in\">func</span>(<span class=\"keyword\">int</span> i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    retrun &amp;somevar;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"尾置返回\">尾置返回</h3>\r\n<p>C++11更方便的尾置返回，在返回复杂的东西时显得很方便，例如返回数组指针：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> -&gt; <span class=\"title\">int</span><span class=\"params\">(*)</span> [size]</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"函数指针\">函数指针</h2>\r\n<p>和普通类型的指针<code>type *</code>一样，把函数看作一种类型，可以定义函数指针如下，并且可以将函数名赋值给该指针，然后当做函数一样使用：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">func</span> <span class=\"params\">(string,string)</span></span>;<span class=\"comment\">//原函数</span></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">bool</span></span> (*p) (string,string);<span class=\"comment\">//定义该函数的指针,注意括号，没有括号则是一个叫做p的函数。</span></span><br><span class=\"line\"><span class=\"comment\">//两种赋值方式等价</span></span><br><span class=\"line\">p=<span class=\"number\">0</span>; <span class=\"comment\">//0不指向任何函数</span></span><br><span class=\"line\">p=func;</span><br><span class=\"line\">p=&amp;func;</span><br><span class=\"line\"><span class=\"comment\">//两种调用方式等价</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> a=<span class=\"built_in\">p</span>(str1,str2);</span><br><span class=\"line\"><span class=\"keyword\">bool</span> b=(*p)(str1,str2);</span><br></pre></td></tr></table></figure>\r\n<p>拥有了指针，自然也能将函数指针作为 函数参数 和 函数返回值 使用。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//两种形参方式等价，自动将函数类型转为函数指针</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">bool</span> p(string,string))</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">bool</span> (*p)(string,string))</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//两种传参方式等价，自动将函数类型转为函数指针</span></span><br><span class=\"line\"><span class=\"built_in\">f</span>(func);</span><br><span class=\"line\"><span class=\"built_in\">f</span>(p);</span><br><span class=\"line\"><span class=\"comment\">//注意在作为返回值时，函数名不会自动转为函数指针</span></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">bool</span></span> (*<span class=\"built_in\">f</span>(<span class=\"keyword\">int</span> a)) (string,string); <span class=\"comment\">//f(int a)是一个函数，它返回一个指针，这个指针指向函数 bool func (string,string)。</span></span><br></pre></td></tr></table></figure>\r\n<p>显然上述的函数指针形式很繁琐，因此可以利用<code>typedef</code>和<code>decltype</code>等改名工具来简化：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//两种改名方式等价</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">bool</span> <span class=\"title\">f2</span><span class=\"params\">(string,string)</span></span>;<span class=\"comment\">//f2类型==func类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">decltype</span><span class=\"params\">(func)</span> f3</span>;     <span class=\"comment\">//f3类型==func类型</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> f4=<span class=\"built_in\"><span class=\"keyword\">bool</span></span> (string,string)  <span class=\"comment\">//f4类型==func类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\"><span class=\"keyword\">bool</span></span> (*p2)(string,string);  <span class=\"comment\">//p2类型==p类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">decltype</span><span class=\"params\">(func)</span> *p3</span>;         <span class=\"comment\">//p3类型==p类型</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> p4=<span class=\"built_in\"><span class=\"keyword\">bool</span></span> (*) (string,string)   <span class=\"comment\">//p4类型==p类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数指针作为参数。两种方式等价，因为函数类型自动转换为函数指针类型</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">f</span>(f3 afunc);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(p3 apoint)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//作为返回值时不等价。</span></span><br><span class=\"line\"><span class=\"function\">p3 <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>;<span class=\"comment\">//f(int a)是一个函数，返回p3类型，即指向func的函数指针类型。</span></span><br><span class=\"line\"><span class=\"function\">f3 <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>;<span class=\"comment\">//错误，不能将函数类型作为返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span> -&gt; <span class=\"title\">bool</span> <span class=\"params\">(*)</span> <span class=\"params\">(string,string)</span></span>;<span class=\"comment\">//后置返回语法</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p><strong>类型别名</strong> 不是\r\n<strong>变量名</strong>，上述代码没有创建一个f3变量或者一个p3变量，应当看作类型名去使用。</p>\r\n</blockquote>\r\n<h1 id=\"参考资料\">参考资料</h1>\r\n<p>C++ Primer 5 edition 中文版</p>\r\n","categories":["C++"],"tags":["C++"]},{"title":"C++派生类构造函数初始化顺序问题","url":"/2020/05/15/C++%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/","content":"<p>众所周知，派生类构造时先会初始化构造基类，然后构造自身。</p>\r\n<h2 id=\"派生类私有成员-和-基类-同时初始化\">派生类私有成员 和 基类\r\n同时初始化</h2>\r\n<p>假如派生类的构造函数，初始化时显式初始化基类，同时显式初始化派生类成员，那么先后顺序是怎样的呢？\r\n测试背景：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"built_in\">base</span>(<span class=\"keyword\">int</span> i) :<span class=\"built_in\">x</span>(i) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispb</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">  cout &lt;&lt; <span class=\"string\">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; <span class=\"string\">&quot;base</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">derived</span> :</span> <span class=\"keyword\">public</span> base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"keyword\">int</span> a=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"built_in\">derived</span>(<span class=\"keyword\">int</span> i) :<span class=\"built_in\">a</span>(i), <span class=\"built_in\">base</span>(a) &#123;  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispd</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">  cout &lt;&lt; <span class=\"string\">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; <span class=\"string\">&quot;derived</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> <span class=\"function\">derived <span class=\"title\">obj</span><span class=\"params\">(<span class=\"number\">8</span>)</span></span>;</span><br><span class=\"line\"> base*p =&amp;obj;</span><br><span class=\"line\"> p-&gt;<span class=\"built_in\">dispb</span>();</span><br><span class=\"line\"> <span class=\"built_in\">system</span>(<span class=\"string\">&quot;PAUSE&quot;</span>);</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>如上，派生类Derived构造时，基类初始化base(a)，用了派生类私有成员a，同时a也被参数i初始化。此时因为基类初始化在a初始化之前，传给base（）的a是随机值。输出结果是：</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/8kIskTc.png\" alt=\"x!=i\" />\r\n<figcaption aria-hidden=\"true\">x!=i</figcaption>\r\n</figure>\r\n<p>所以我们可以知道，即使是初始化列表里，即使a的初始化排在前面，也一定是先初始化基类base，再调用派生类私有成员的初始化。</p>\r\n<blockquote>\r\n<p>想要正常构造，把base（a)改成base（i）即可。</p>\r\n</blockquote>\r\n<h2\r\nid=\"派生类初始化私有成员基类在函数体内构造\">派生类初始化私有成员，基类在函数体内构造</h2>\r\n<p><strong>假如派生类的构造函数是这样的</strong>：初始化私有成员，体内构造基类</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">derived</span>(<span class=\"keyword\">int</span> i) :<span class=\"built_in\">a</span>(i) &#123; <span class=\"built_in\">base</span>(i); &#125;</span><br></pre></td></tr></table></figure>\r\n<p>会提示类base不存在默认构造函数。</p>\r\n<p>我们可以得知，在派生类构造函数中，假如初始化了自己的变量成员，则会自动先调用基类构造，再对派生类的成员进行初始化，上例因为base没有无参数的默认构造函数所以报错。</p>\r\n<p><strong>假如基类有无参数的构造函数呢？</strong>讲道理会是先调用基类默认构造，再初始化a，再调用base(i)，是这样吗？增加一个无参数的基类构造函数：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">base</span>() &#123; cout &lt;&lt;<span class=\"string\">&quot;This is base()&quot;</span>&lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class=\"line\">.....</span><br><span class=\"line\"><span class=\"built_in\">derived</span>(<span class=\"keyword\">int</span> i) :<span class=\"built_in\">a</span>(i) &#123; <span class=\"built_in\">base</span>(i); &#125;</span><br></pre></td></tr></table></figure>\r\n<p>报错：形参 i 重定义——明明只声明了一次 i\r\n，怎么就重定义了呢？把a(i)删去？还是报错重定义</p>\r\n<p>——<a\r\nhref=\"https://segmentfault.com/q/1010000014553913\">搜了一下类似问题，发现题解</a>，对base（i)在里面的时候：“此时编译器会把它解析成变量声明，由此局部变量i与函数参数重名。根据语法，它可以被解释成函数式显式类型转换或者声明，存在二义性。标准约定将其解释成声明。”</p>\r\n<p><strong>这里面存在 声明 语句 定义 等根本性语法的规则定义=\r\n=</strong>具体了解得看其他详细资料，不过我们知道了报错是因为在 base(i)\r\n中，i被当成了新的局部变量，和外面的函数参数重定义冲突。</p>\r\n<p>i 冲突那我不用 i\r\n了，我用base（a)可以吧？a是被初始化的变量拿去赋值没问题吧？</p>\r\n<p>派生类构造函数改成：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">base</span>(<span class=\"keyword\">int</span> i) :<span class=\"built_in\">x</span>(i) &#123; cout &lt;&lt;<span class=\"string\">&quot;base(int i): &quot;</span>&lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class=\"line\"><span class=\"built_in\">base</span>() &#123; cout &lt;&lt;<span class=\"string\">&quot;This is base()&quot;</span>&lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"built_in\">derived</span>(<span class=\"keyword\">int</span> i)：<span class=\"built_in\">a</span>(i)&#123; cout &lt;&lt; <span class=\"string\">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl; <span class=\"built_in\">base</span>(a); &#125;</span><br></pre></td></tr></table></figure>\r\n<p>derived(8)运行，猜猜运行结果是什么？</p>\r\n<p>我们知道初始化a时，先会调用base（），然后初始化a，然后进入函数体内输出a值，然后a传参给base（int\r\ni），Really？</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/ZfXu4sR.png\" alt=\"运行结果\" />\r\n<figcaption aria-hidden=\"true\">运行结果</figcaption>\r\n</figure>\r\n","categories":["C++"]},{"title":"DDGCN","url":"/2021/12/30/DDGCN/","content":"<p>DDGCN: A Dynamic Directed Graph Convolutional Network for Action\r\nRecognition</p>\r\n<ul>\r\n<li>Korban M, Li X. Ddgcn: A dynamic directed graph convolutional\r\nnetwork for action recognition[C]//European Conference on Computer\r\nVision. Springer, Cham, 2020: 761-776.</li>\r\n<li>University of Virginia</li>\r\n</ul>\r\n<h1 id=\"introduction\">Introduction</h1>\r\n<p>之前的时空图网络(ST\r\ngraph)有着以下两点局限性：第一，人体骨架确实有时空联系性，但是这种联系在不同的人体动作下是不一样的。因此怎么有效地提取这种联系是困难的。传统的GCN卷积方法是静态的，无法描述动态时空结构。第二，骨架的空间层级结构和动作的时间序列结构都包含了顺序信息，然而大多数ST\r\ngraph都是用了无向图结构，即无视了顺序信息。</p>\r\n<p>DDGCN提出用于自适应学习时空关系和动作的时空顺序信息。</p>\r\n<ul>\r\n<li>Dynamic Convolutional Sampling (DCS)</li>\r\n<li>Dynamic Convolutional Weights (DCW)</li>\r\n<li>Directed Spatial-Temporal Graph (DSTG) Features</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<h2 id=\"related-work\">Related Work</h2>\r\n<p>Action recognition algorithms can be classi\fed based on data\r\nmodalities they run on. The majority of action recognition methods model\r\nactions on image sequence directly. Accordingly, they have developed\r\nvarious strategies based on handcrafted features [31, 26, 15],\r\nConvolutional Neural Network (CNN) [2, 9, 27], or Generative Adversarial\r\nNetwork (GAN) [14, 25, 29] to perform action recog- nition. However,\r\nusing only appearance modality such as RGB images has its limitations\r\nincluding high inference of background, high dimensional inputs, sen-\r\nsitivity to image transformations, and low expressive capability.</p>\r\n<h2 id=\"overview\">Overview</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/i9ofGUn.png\" alt=\"Overview\" />\r\n<figcaption aria-hidden=\"true\">Overview</figcaption>\r\n</figure>\r\n<p>对于输入的动作序列X，先构造出时空图<span\r\nclass=\"math inline\">\\(G_{ST}\\)</span>来构建时间关系。然后通过多个Dynamic\r\nDirected Convolutional (DDC)来抽取特征。</p>\r\n<h2 id=\"dynamic-convolutional-sampling-dcs\">Dynamic Convolutional\r\nSampling (DCS)</h2>\r\n<p>首先对于帧<span\r\nclass=\"math inline\">\\(G_0\\)</span>，DCS会尝试对每个点找出其邻居<span\r\nclass=\"math inline\">\\(p_i(B(v_i))\\)</span>(包含邻接点和非邻接相关点)：</p>\r\n<ol type=\"1\">\r\n<li>先用<span\r\nclass=\"math inline\">\\(G_0\\)</span>中的邻接点对邻居列表进行初始化，然后通过DCS来逐渐包含那些非邻接的相关点</li>\r\n<li>初始化邻域：创建一个有序的邻域点集<span\r\nclass=\"math inline\">\\(O_i\\)</span>：将所有节点按到<span\r\nclass=\"math inline\">\\(v_i\\)</span>的图距离排序存放，然后从<span\r\nclass=\"math inline\">\\(O_i\\)</span>中拿出前<span\r\nclass=\"math inline\">\\(r\\)</span>个节点作为这个点的邻域<span\r\nclass=\"math inline\">\\(p_i(B(v_i))\\)</span>。</li>\r\n<li>更新邻域<span class=\"math inline\">\\(p_i\\)</span>：通过学习一个index\r\nshift <span class=\"math inline\">\\(\\Delta p_i\\)</span>\r\n，相当于对邻域进行一个动态的排序，重新找前几个相关节点。</li>\r\n</ol>\r\n<p>最终在邻域上通过图卷积聚合生成特征：</p>\r\n<p><span class=\"math display\">\\[\r\nf_{S T}\\left(v_{i}\\right)=\\sum_{v_{j} \\in B\\left(v_{i}\\right)}\r\nw\\left(v_{i}\\right) \\cdot\\left(p_{i}\\left(v_{j}\\right)+\\Delta\r\np_{i}\\left(v_{j}\\right)\\right),\r\n\\]</span></p>\r\n<h2 id=\"dynamic-convolutional-weights-dcw\">Dynamic Convolutional Weights\r\n(DCW)</h2>\r\n<p>图像的卷积都是空间有序的，卷积核的权重学习也是按照同样的固定顺序。然而图像上卷积是无序的，且邻域数量不确定，因此DCW用于将图卷积自适应的有序化。</p>\r\n<p>给定卷积权重<span class=\"math inline\">\\(W=\\{w_i \\in\r\nR^3,i=1,...,r\\}\\)</span>，目标是将<span\r\nclass=\"math inline\">\\(w_i\\)</span>动态分配给相应的节点<span\r\nclass=\"math inline\">\\(v_i\\)</span>：计算一个 rx2 的矩阵<span\r\nclass=\"math inline\">\\(P_v=DTW_{path}(W,B(v))\\)</span>，其最小化<span\r\nclass=\"math inline\">\\(B(v)\\)</span>和排序后的<span\r\nclass=\"math inline\">\\(W\\)</span>的DTW距离。</p>\r\n<blockquote>\r\n<p>Dynamic Time Warping (DTW) [1] 动态时间规整算法:\r\n衡量两个时间序列的相似度的方法。因为表达同一个意义的两个序列，时间长度可能不一致。</p>\r\n</blockquote>\r\n<h2 id=\"directed-spatial-temporal-graph-dstg\">Directed Spatial-Temporal\r\nGraph (DSTG)</h2>\r\n<p><strong>有向空间图</strong>：从root开始广度优先搜索，生成骨架的有向图。在运动时，父节点的动作往往会影响子节点的动作，即子节点是关联于父节点的。可以将节点之间的边定义为bone，那么bone\r\nfeatures即<span\r\nclass=\"math inline\">\\(f_i^B=\\overrightarrow{v_{i-1}v_i}=f_{i-1}-f_i\\)</span>,其中<span\r\nclass=\"math inline\">\\(f_i\\)</span>表示节点<span\r\nclass=\"math inline\">\\(v_i\\)</span>的特征向量。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/VzzvInI.png\" alt=\"骨架图\" />\r\n<figcaption aria-hidden=\"true\">骨架图</figcaption>\r\n</figure>\r\n<p><strong>有向时间图</strong>：即将节点与其在上一帧对应节点连接起来。temporal\r\nfeatures <span\r\nclass=\"math inline\">\\(f_i^T=f_{i}^t-f_{i-1}^{t-1}\\)</span></p>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[1] Berndt, D.J., Cli\u000bord, J.: Using dynamic time warping to \fnd\r\npatterns in time series. In: KDD workshop. vol. 10, pp. 359{370.\r\nSeattle, WA (1994)</p>\r\n","categories":["深度学习"],"tags":["深度学习","序列学习"]},{"title":"DeepFaceDrawing","url":"/2021/09/27/DeepFaceDrawing/","content":"<h1 id=\"deepfacedrawing-人脸合成到几何建模\">DeepFaceDrawing\r\n人脸合成到几何建模</h1>\r\n<p>草稿生成真实人脸图像</p>\r\n<h2 id=\"背景\">背景</h2>\r\n<p>人画线稿不规则，已有的深度学习适配质量非常差。</p>\r\n<p>做整个人脸的工作还是比较少的。</p>\r\n<p>人的草稿没有约束，因此给出阴影引导用户。</p>\r\n<p>人脸图片数据 CelebAMask-HQ</p>\r\n<h2 id=\"主要思想\">主要思想</h2>\r\n<p>可视媒体的结构化。对人脸进行分块，提高每一块的质量。人脸根据语义分成五块：左眼、右眼、鼻子、嘴巴、其余部分。</p>\r\n<p>得到每一块的特征向量，分别扩展成一个张量，然后拼起来，最终对全局计算一遍人脸生成的网络。</p>\r\n<p>也可以提供分块拼接功能。</p>\r\n<h3 id=\"分段训练\">分段训练</h3>\r\n<p>对分块数据做了一个embedding，把人的不规则输入通过embedding正则化，可以提高鲁棒性。</p>\r\n<h3 id=\"流形投影\">流形投影</h3>\r\n<p>embedding之后得到的向量和数据集向量有所差异，因此要让数据集已有的线稿去逼近，类似于LLE流形投影，既保留特征又去掉噪音。</p>\r\n<p>流形投影时选择两个点观察，发现是一个很好的连续分布。</p>\r\n<h3 id=\"阴影引导用户\">阴影引导用户</h3>\r\n<p>实时绘画时，提供检索出来的阴影引导用户，同时用户可以调整自己和数据库之间的置信权重比例。</p>\r\n<h1 id=\"基于变形表示的深度几何学习\">基于变形表示的深度几何学习</h1>\r\n<p>复杂的模型可以找很多结构化编码几何部件，通过变形刻画细节。</p>\r\n<h2 id=\"背景-1\">背景</h2>\r\n<p>片网&amp;多重参数化： - 不光滑或者不连接 - 非结构化</p>\r\n<p>结构化的盒子： - 缺失几何细节 - 物理上不可靠</p>\r\n<h2 id=\"变形几何表示\">变形几何表示</h2>\r\n<p>对几何进行分块，每一块得到一个包围盒进行非刚体注册，逼近部件。可以通过相同的拓扑盒子来逼近不同的几何细节，达到了相同的连接关系而不同几何细节，方便做卷积操作。（ACAP变形和ACAP网格图卷积）</p>\r\n<h2 id=\"支撑结构分析\">支撑结构分析</h2>\r\n<p>不只是邻接关系，还有支撑关系。有向支撑图的支撑关系分析，获得对部件结构的刻画。</p>\r\n<p>对模型进行编码：支撑信息、对称信息、变形信息。进行联合结构化的部件编码。结构化部件变分自编码器（SPVAE）</p>\r\n<p>优化方向：对称约束、支撑关系约束、稳定支撑约束、相同长度约束</p>\r\n<p>模型可以通过PointNet++分割语义，然后分析学习结构关系。</p>\r\n","categories":["深度学习"]},{"title":"ExternalAttention","url":"/2022/03/08/ExternalAttention/","content":"<ul>\r\n<li>Guo M H, Liu Z N, Mu T J, et al. Beyond self-attention: External\r\nattention using two linear layers for visual tasks[J]. arXiv preprint\r\narXiv:2105.02358, 2021.</li>\r\n<li>清华</li>\r\n</ul>\r\n<p>自注意力机制在同一个样本内,\r\n任意一个部位的特征都可以聚合所有位置的特征进行加权输出。但是自注意力拥有<strong>二次复杂度</strong>,\r\n并且<strong>不能计算多个样本之间的潜在联系</strong>。</p>\r\n<p>External-Attention(EAT) 希望在学习某个数据集时,\r\n能够找到多个样本之间的潜在联系。其通过保持一定的<strong>key\r\nmemory</strong>,\r\n以找到跨越所有样本的最具有辨识性的特征。这种思想类似于sparse coding 和\r\ndictionary learning。并且由于key memory设计的很小,\r\n因此EAT计算上具有O(n)的复杂度,\r\n比起自注意力<strong>高效</strong>很多。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/gVuVX87.png\" alt=\"external attention\" />\r\n<figcaption aria-hidden=\"true\">external attention</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h1 id=\"external-attention-eat\">External Attention (EAT)</h1>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nA&amp;=(\\alpha_{i,j})=Norm(FM_k^T)\\\\\r\nF_{out}&amp;=AM_v\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(F \\in \\mathbb{R}^{N \\times d}\\)</span>,\r\n其中<span class=\"math inline\">\\(M \\in \\mathbb{R}^{S \\times\r\nd}\\)</span>是一个独立于所有的输入特征进行学习的单元,即贯穿整个数据集的一个记忆模块,\r\n实践中使用了两个不同的单元 <span class=\"math inline\">\\(M_k\\)</span> 和\r\n<span class=\"math inline\">\\(M_v\\)</span> 来增强效果。<span\r\nclass=\"math inline\">\\(\\alpha_{i,j}\\)</span> 用于衡量第i个词元与<span\r\nclass=\"math inline\">\\(M\\)</span>中第j行记忆特征的关系。</p>\r\n<p><strong>Normalization</strong>: 在自注意力中attention\r\nmap是由余弦相似度的组成的一维向量,\r\n因此可以使用Softmax来进行权重归一化。EAT中假如把图像的每个像素看作一个词元,\r\n那么这个图像的attention map就是一个二维矩阵,\r\n因此使用了二维的softmax来进行归一化, 即double-normalization(2021,\r\nPCT):</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n(\\tilde{\\alpha})_{i, j} &amp;=F M_{k}^{T} \\\\\r\n\\hat{\\alpha}_{i, j} &amp;=\\exp \\left(\\tilde{\\alpha}_{i, j}\\right) /\r\n\\sum_{k} \\exp \\left(\\tilde{\\alpha}_{k, j}\\right) \\\\\r\n\\alpha_{i, j} &amp;=\\hat{\\alpha}_{i, j} / \\sum_{k} \\hat{\\alpha}_{i, k}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><strong>Multi-head</strong>:\r\n自注意力中常用多头机制来增强多视角的学习能力, 因此EAT中改造如下:</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nh_i&amp;=ExternalAttention(F_i,M_k,M_v) \\\\\r\nF_out&amp;=MultiHead(h,M_k,M_v) \\\\\r\n&amp;=Concat(h_1,...h_H)W_o\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(h_i\\)</span> 为每个头计算的注意力输出,\r\n<span class=\"math inline\">\\(W_o\\)</span>是用于使维度一致的线性层。<span\r\nclass=\"math inline\">\\(M\\)</span>为在多个头之间共享权重的memory单元。</p>\r\n<h1 id=\"效果\">效果</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/Uui5znz.png\" alt=\"Modelnet40\" />\r\n<figcaption aria-hidden=\"true\">Modelnet40</figcaption>\r\n</figure>\r\n","categories":["深度学习"],"tags":["深度学习","点云"]},{"title":"CaSPR","url":"/2022/03/06/CaSPR/","content":"<ul>\r\n<li>Rempe D, Birdal T, Zhao Y, et al. Caspr: Learning canonical\r\nspatiotemporal point cloud representations[J]. Advances in neural\r\ninformation processing systems, 2020, 33: 13688-13701.</li>\r\n<li>Stanford</li>\r\n</ul>\r\n<p>过去有一些工作做了动态点云的时间学习, 然而这些工作有一个致命限制:\r\n它们缺少时间连续性、鲁棒性、同类泛化性。有一些工作考虑了其中某一个方面,\r\n但没有对这三者整体进行统一的要求。</p>\r\n<p>Canonical Spatiotemporal Point Cloud Representations\r\n(CaSPR)致力于对3D形状的时空变化进行编码。</p>\r\n<ol type=\"1\">\r\n<li>将输入的点云序列规范化到一个共享的4D container空间:\r\n其先构建了坐标空间Normalized Object Coordinate Space (NOCS) [63],\r\n它能把同类中的一些外在属性引如位置、朝向和放缩程度给规范化。进一步的,\r\nCaSPR将NOCS扩展到4D <strong>Temporal-NOCS(T-NOCS)</strong>,\r\n额外将点云序列的持续时间归一化成一个单位时间。对于给定的点云序列,\r\n最终规范化后会给出在<strong>时间和空间</strong>上都规范化的点云。</li>\r\n<li>然后在规范化空间中学习连续的时空特征: 其使用了Neural Ordinary\r\nDifferential Equations (Neural ODEs) [9]。</li>\r\n</ol>\r\n<span id=\"more\"></span>\r\n<h1 id=\"规范化网络-tpointnet\">规范化网络 TPointNet++</h1>\r\n<p>在规范化的同时, 希望保留以下特性:</p>\r\n<ol type=\"1\">\r\n<li>避免时空邻域的搜索</li>\r\n<li>将时间视为和空间维度同等重要的一个维度</li>\r\n<li>将物体的时间特征加入到其局部结构的特征中</li>\r\n</ol>\r\n<figure>\r\n<img src=\"https://i.imgur.com/Kii5i5S.png\" alt=\"TPointNet\" />\r\n<figcaption aria-hidden=\"true\">TPointNet</figcaption>\r\n</figure>\r\n<p>其采用了双流的设计, 最终输出每个点的1600维embedding。</p>\r\n<ol type=\"1\">\r\n<li>PointNet: 将4D的点云序列(时间作为一个标签)视为一个整体,\r\n抽取出1024维的全局特征, 和64维的逐点特征。</li>\r\n<li>PointNet++: 对4D的每个点(不输入时间标签)计算局部结构特征,\r\n最终每个点输出512维特征。</li>\r\n</ol>\r\n<h1 id=\"后续求解使用-latent-ode-求解器-略\">后续求解使用 Latent ODE\r\n求解器 (略)</h1>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[9] Chen, T.Q., Rubanova, Y., Bettencourt, J., Duvenaud, D.K.: Neural\r\nordinary differential equations. In: Proceedings of the Advances in\r\nNeural Information Processing Systems (NeurIPS) (2018)</p>\r\n<p>[63] Sridhar, S., Rempe, D., Valentin, J., Bouaziz, S., Guibas, L.J.:\r\nMultiview aggregation for learning category-specific shape\r\nreconstruction. In: Proceedings of the Advances in Neural Information\r\nProcessing Systems (NeurIPS) (2019)</p>\r\n","categories":["深度学习"],"tags":["深度学习","点云"]},{"title":"Generative Adversarial Nets","url":"/2021/10/30/GAN/","content":"<p>一个生成模型G：学习到数据分布，使得D犯错概率最大<br />\r\n一个判别模型D：判别一个样本是来自真实数据还是G<br />\r\n存在一个特解，使得G可以涵盖住真实训练数据分布，D的判别概率始终是<span\r\nclass=\"math inline\">\\(\\frac{1}{2}\\)</span><br />\r\n对于MLP定义的G和D，可以使用反向传播训练整个系统，而不需要使用任何的马尔科夫链或者是展开的近似推理网络。</p>\r\n<h1 id=\"导论\">导论</h1>\r\n<p>迄今为止，大多数深度学习伟大的成功都是在判别模型上，将高维复杂的输入映射到一个类别标签。<br />\r\n而生成模型则有着很多的困难，如很难在极大似然估计和相关策略中进行概率计算，并且生成模型的上下文中难以利用分层线性单元的优势。</p>\r\n<p>本文提出了一个新的规避了这些困难的生成模型。</p>\r\n<p>GAN框架能够给很多模型和优化问题提供一种训练方法。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"对抗网络\">对抗网络</h1>\r\n<p>为了从数据 <span class=\"math inline\">\\(x\\)</span>\r\n上学习到生成器的分布 <span class=\"math inline\">\\(p_g\\)</span>\r\n，我们先给定一个先验输入噪声 <span\r\nclass=\"math inline\">\\(p_z(z)\\)</span><br />\r\n然后利用 <span class=\"math inline\">\\(G(z;\\theta_g)\\)</span>\r\n将z映射到数据空间，其中G是一个多层感知机。<br />\r\n再定义一个 <span class=\"math inline\">\\(D(x;\\theta_d)\\)</span>\r\n：计算x来自真实数据而不是生成器生成的分布<span\r\nclass=\"math inline\">\\(p_g\\)</span>的概率。</p>\r\n<p>训练D以最大化分类正确率，并且同时训练G以最小化<span\r\nclass=\"math inline\">\\(\\log(1-D(G(z)))\\)</span></p>\r\n<p>最终的评估函数：</p>\r\n<p><span class=\"math display\">\\[\r\n\\min _{G} \\max _{D} V(D, G)=\\mathbb{E}_{\\boldsymbol{x} \\sim p_{\\text\r\n{data }}(\\boldsymbol{x})}[\\log\r\nD(\\boldsymbol{x})]+\\mathbb{E}_{\\boldsymbol{z} \\sim\r\np_{\\boldsymbol{z}}(\\boldsymbol{z})}[\\log (1-D(G(\\boldsymbol{z})))]\r\n\\tag{1}\r\n\\]</span></p>\r\n<p>训练过程中，不会在一次训练循环里直接完成D的优化，那在有限数据集里会导致过拟合。因此，我们会在优化K次D和优化1次G中交替进行。只要G变化的足够缓慢，这将有助于保持D在它最优解的附近。</p>\r\n<p>这个策略类似于SML/PCD[2]中，为了避免样本在马尔科夫链中学习迭代时burning的方式。，</p>\r\n<p>实际上，公式(1)可能不能给G提供足够的梯度以供学习。在训练的初期，G效果很差，D可以轻易的分辨出数据的真假。此时\r\n<span class=\"math inline\">\\(\\log(1-D(G(z)))\\)</span>\r\n变得饱和：即接近极限了已经，变化很小。相比于训练G以最小化 <span\r\nclass=\"math inline\">\\(\\log(1-D(G(z)))\\)</span>\r\n，我们可以训练G以最大化<span\r\nclass=\"math inline\">\\(\\log(D(G(z)))\\)</span>\r\n，这个目标函数可以有相同的结果但是有更好的梯度。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/jxKCPer.png\"\r\nalt=\"GAN示意图：蓝线为判别器的认为的概率分布，黑点为真实数据的分布，绿线为生成器的分布。x线为真实数据域，z线为生成器采样数据域。箭头为z通过G映射到x。(b) 训练D后，D逼近真实数据分布。(c) 更新G，D的梯度引导G向真实分布靠近。(d) 足够训练的情况下，学习到的分布完全和训练分布一致，D(x)=0.5\" />\r\n<figcaption\r\naria-hidden=\"true\">GAN示意图：蓝线为判别器的认为的概率分布，黑点为真实数据的分布，绿线为生成器的分布。x线为真实数据域，z线为生成器采样数据域。箭头为z通过G映射到x。(b)\r\n训练D后，D逼近真实数据分布。(c) 更新G，D的梯度引导G向真实分布靠近。(d)\r\n足够训练的情况下，学习到的分布完全和训练分布一致，D(x)=0.5</figcaption>\r\n</figure>\r\n<h1 id=\"理论\">理论</h1>\r\n<p>生成器G隐式地定义了一个概率分布 <span class=\"math inline\">\\(p_g =\r\nG(z)\\)</span>——即从 <span class=\"math inline\">\\(z \\sim p_z\\)</span>\r\n中的采样结果。因此，我们希望训练算法在充分的环境下，可以最终收敛出一个不错的估计器来估计\r\n<span class=\"math inline\">\\(p_{data}\\)</span> 。</p>\r\n<p>接下来会证明这个minimax过程对于 $p_g = p_{data} $\r\n有一个全局最优解。然后会证明公式(1)可以通过训练算法来获得最优解。</p>\r\n<h2 id=\"训练算法\">训练算法</h2>\r\n<p>GAN的小批量随机梯度下降训练。<br />\r\nK：超参数，表明在判别器D上经过的step。</p>\r\n<p><strong>for</strong> number of training iterations\r\n<strong>do</strong></p>\r\n<ul>\r\n<li><p><strong>for</strong> <span class=\"math inline\">\\(k\\)</span> steps\r\n<strong>do</strong></p></li>\r\n<li><ol type=\"1\">\r\n<li>从先验噪声 <span class=\"math inline\">\\(p_{g}(z)\\)</span>\r\n中采样出m大小的小批量样本 <span class=\"math inline\">\\(\\left\\{z^{(1)},\r\n\\ldots, z^(m)\\right\\}\\)</span></li>\r\n</ol></li>\r\n<li><ol start=\"2\" type=\"1\">\r\n<li>从真实数据分布 <span class=\"math inline\">\\(p_{\\text {data\r\n}}(\\boldsymbol{x})\\)</span> 中采样出m大小的小批量样本 <span\r\nclass=\"math inline\">\\(\\left\\{\\boldsymbol{x}^{(1)}, \\ldots,\r\n\\boldsymbol{x}^{(m)}\\right\\}\\)</span></li>\r\n</ol></li>\r\n<li><ol start=\"3\" type=\"1\">\r\n<li>通过随机梯度下降更新判别器D：</li>\r\n</ol></li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\nabla_{\\theta_{d}} \\frac{1}{m} \\sum_{i=1}^{m}\\left[\\log\r\nD\\left(\\boldsymbol{x}^{(i)}\\right)+\\log\r\n\\left(1-D\\left(G\\left(z^{(i)}\\right)\\right)\\right)\\right]\r\n\\]</span></p>\r\n<ul>\r\n<li><p><strong>end <span class=\"math inline\">\\(k\\)</span>\r\nfor</strong></p></li>\r\n<li><p>从先验噪声 <span class=\"math inline\">\\(p_{g}(z)\\)</span>\r\n中采样出m大小的小批量样本 <span class=\"math inline\">\\(\\left\\{z^{(1)},\r\n\\ldots, z^(m)\\right\\}\\)</span></p></li>\r\n<li><p>通过随机梯度下降更新生成器G:</p></li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\nabla_{\\theta_{g}} \\frac{1}{m} \\sum_{i=1}^{m} \\log\r\n\\left(1-D\\left(G\\left(z^{(i)}\\right)\\right)\\right)\r\n\\]</span></p>\r\n<p><strong>end</strong> train iterations <strong>for</strong></p>\r\n<h2 id=\"证明-p_g-p_data-的全局最优解\">证明 <span\r\nclass=\"math inline\">\\(p_g = p_{data}\\)</span> 的全局最优解</h2>\r\n<h3 id=\"首先证明固定g时d的最优解为\">首先证明：固定G时，D的最优解为</h3>\r\n<p><span class=\"math display\">\\[\r\nD_{G}^{*}(x)=\\frac{p_{\\text {data }}(x)}{p_{\\text {data }}(x)+p_{g}(x)}\r\n\\]</span></p>\r\n<p>给定任何G，D，训练目标都是最大化 <span class=\"math inline\">\\(V(G,\r\nD)\\)</span> ：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nV(G, D) &amp;=\\mathbb{E}_{\\boldsymbol{x} \\sim p_{\\text {data\r\n}}(\\boldsymbol{x})}[\\log D(\\boldsymbol{x})]+\\mathbb{E}_{\\boldsymbol{z}\r\n\\sim p_{\\boldsymbol{z}}(\\boldsymbol{z})}[\\log (1-D(G(\\boldsymbol{z})))]\r\n\\\\\r\n期望展开&amp;=\\int_{\\boldsymbol{x}} p_{\\text {data }}(\\boldsymbol{x})\r\n\\log (D(\\boldsymbol{x})) d x+\\int_{\\boldsymbol{z}}\r\np_{\\boldsymbol{z}}(\\boldsymbol{z}) \\log (1-D(g(\\boldsymbol{z}))) d z \\\\\r\n换元z到x&amp;=\\int_{\\boldsymbol{x}} p_{\\text {data }}(\\boldsymbol{x})\r\n\\log (D(\\boldsymbol{x}))+p_{g}(\\boldsymbol{x}) \\log\r\n(1-D(\\boldsymbol{x})) d x\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>求积分最大值可以转化为求被积函数最大值：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nV(G,D)&amp;=\\int_{\\boldsymbol{x}} p_{\\text {data }}(\\boldsymbol{x}) \\log\r\n(D(\\boldsymbol{x}))+p_{g}(\\boldsymbol{x}) \\log (1-D(\\boldsymbol{x})) d x\r\n\\\\\r\n&amp;\\leq \\int_{\\boldsymbol{x}} \\max _{y} p_{\\text {data\r\n}}(\\boldsymbol{x}) \\log (y))+p_{g}(\\boldsymbol{x}) \\log (1-y) d x\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>并且因为固定G求D的最优，因此不涉及D的都可看作常数项即：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nf(D(x)) &amp;= p_{\\text {data }}(\\boldsymbol{x}) \\log\r\n(D(\\boldsymbol{x}))+p_{g}(\\boldsymbol{x}) \\log (1-D(\\boldsymbol{x})) \\\\\r\n&amp;= a \\log D + b \\log (1-D) \\\\\r\n即 f(y) &amp;= a \\log y + b \\log (1-y)\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>其中 $ a,b (0,1) $ 。为了求最优解，对该式计算 <span\r\nclass=\"math inline\">\\(y\\)</span> 的一阶导可得 <span\r\nclass=\"math inline\">\\(y=\\frac{a}{a+b}\\)</span>，继续求该位置的二阶导可得：</p>\r\n<p><span class=\"math display\">\\[\r\nf^{\\prime\r\n\\prime}\\left(\\frac{a}{a+b}\\right)=-\\frac{a}{\\left(\\frac{a}{a+b}\\right)^{2}}-\\frac{b}{1-\\left(\\frac{a}{a+b}\\right)^{2}}&lt;0\r\n\\]</span></p>\r\n<p>因此最优D为：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nD_{G}^{*}(x)&amp;=\\frac{p_{\\text {data }}(x)}{p_{\\text {data\r\n}}(x)+p_{g}(x)} \\\\\r\nP_G=P_{data}时，&amp;= \\frac{1}{2}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<h3 id=\"定理1cg-当且仅当-p_g-p_data-时取得全局最小值--log4\">定理1：<span\r\nclass=\"math inline\">\\(C(G)\\)</span> 当且仅当 <span\r\nclass=\"math inline\">\\(p_g = p_{data}\\)</span> 时取得全局最小值\r\n-log4</h3>\r\n<p>证明：</p>\r\n<p>结合公式(1)和$ D $的最优解，可知 $ C(G) $ 有如下表达式 ：</p>\r\n$$\r\n<span class=\"math display\">\\[\\begin{aligned}\r\nC(G)&amp;=\\int_{x} p_{\\text {data }}(x) \\log \\left(\\frac{p_{\\text {data\r\n}}(x)}{p_{G}(x)+p_{\\text {data }}(x)}\\right)+p_{G}(x) \\log\r\n\\left(\\frac{p_{G}(x)}{p_{G}(x)+p_{\\text {data }}(x)}\\right) \\mathrm{d} x\r\n\\\\\r\n\r\np_g = p_{data} 时 , C(G) &amp;=- log 4\r\n\\end{aligned}\\]</span>\r\n<p>$$</p>\r\n<p>为了检查这个 -log4 是不是最优值，构造方程：</p>\r\n$$\r\n<span class=\"math display\">\\[\\begin{aligned}\r\nC(G) &amp;=\\int_{x}(\\log 2-\\log 2) p_{\\text {data }}(x)+p_{\\text {data\r\n}}(x) \\log \\left(\\frac{p_{\\text {data }}(x)}{p_{G}(x)+p_{\\text {data\r\n}}(x)}\\right) \\\\\r\n&amp;+(\\log 2-\\log 2) p_{G}(x)+p_{G}(x) \\log\r\n\\left(\\frac{p_{G}(x)}{p_{G}(x)+p_{\\text {data }}(x)}\\right) \\mathrm{d} x\r\n\\\\\r\n\\\\\r\n&amp;=-\\log 2 \\int_{x} p_{G}(x)+p_{data}(x) \\mathrm{d} x +\\int_{x}\r\np_{data}(x)\\left(\\log 2+\\log \\left(\\frac{p_{data}(x)}{p_{G}(x)+p_{\\text\r\n{data }}(x)}\\right)\\right) \\\\\r\n&amp;+p_{G}(x)\\left(\\log 2+\\log\r\n\\left(\\frac{p_{G}(x)}{p_{G}(x)+p_{data}(x)}\\right)\\right) \\mathrm{d} x\r\n\\\\\r\n\\\\\r\n\r\nC(G)&amp;=-\\log 4+\\int_{x} p_{\\text {data }}(x) \\log\r\n\\left(\\frac{p_{\\text {data }}(x)}{\\left(p_{G}(x)+p_{\\text {data\r\n}}(x)\\right) / 2}\\right) \\mathrm{d} x \\\\\r\n&amp;+\\int_{x} p_{G}(x) \\log\r\n\\left(\\frac{p_{G}(x)}{\\left(p_{G}(x)+p_{\\text {data }}(x)\\right) /\r\n2}\\right) \\mathrm{d} x\r\n\r\n\\end{aligned}\\]</span>\r\n<p>$$</p>\r\n<p>后面两个积分式即是KL散度（一种衡量分布差异的方法）：</p>\r\n<blockquote>\r\n<p>KL散度为非负值，具有非对称性，且KL散度为0当且仅当两个离散分布处处相同。</p>\r\n<p><span class=\"math display\">\\[\r\nD_{\\mathrm{KL}}(P \\| Q)=\\mathbb{E}_{\\mathrm{x} \\sim P}\\left[\\log\r\n\\frac{P(x)}{Q(x)}\\right]=\\mathbb{E}_{\\mathrm{x} \\sim P}[\\log P(x)-\\log\r\nQ(x)]\r\n\\]</span></p>\r\n</blockquote>\r\n<p><span class=\"math display\">\\[\r\nC(G)=-\\log 4+K L\\left(p_{\\text {data }} \\mid \\frac{p_{\\text {data\r\n}}+p_{G}}{2}\\right)+K L\\left(p_{G} \\mid \\frac{p_{\\text {data\r\n}}+p_{G}}{2}\\right)\r\n\\]</span></p>\r\n<p>由于KL散度的非负性质，我们可以得到-log4即为<span\r\nclass=\"math inline\">\\(C(G)\\)</span>的全局最小值。进一步需要证明 <span\r\nclass=\"math inline\">\\(p_G=p_{data}\\)</span> 是取值的唯一点。</p>\r\n<p>因为KL散度是非对称的，因此构造两个相反的KL散度相加，它们的和就是对称项，即可以表示为JS散度：</p>\r\n<p><span class=\"math display\">\\[\r\nJSD(P \\| Q) = \\frac{1}{2}KL(P \\|(P+Q)/2) +\\frac{1}{2}KL(Q \\|(P+Q)/2)\r\n\\]</span></p>\r\n<p>因此 <span class=\"math inline\">\\(C(G)\\)</span> 可表示为：</p>\r\n<p><span class=\"math display\">\\[\r\nC(G)=-\\log 4 +2 JSD(p_{data}|p_G)\r\n\\]</span></p>\r\n<p>根据JS散度非负，且只有 $p_G=p_{data} 时 , JSD=0 $。\r\n综上所述，得证。</p>\r\n<h1 id=\"实验效果\">实验效果</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/JyLtCdO.png\" alt=\"MINIST\" />\r\n<figcaption aria-hidden=\"true\">MINIST</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/OOvavFd.png\" alt=\"TFD\" />\r\n<figcaption aria-hidden=\"true\">TFD</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/AA8kLIS.png\" alt=\"CIFAR-10 全连接\" />\r\n<figcaption aria-hidden=\"true\">CIFAR-10 全连接</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/IweITKm.png\"\r\nalt=\"CIFAR-10 卷积D和逆卷积G\" />\r\n<figcaption aria-hidden=\"true\">CIFAR-10 卷积D和逆卷积G</figcaption>\r\n</figure>\r\n<h1 id=\"优缺点\">优缺点</h1>\r\n<p>缺点：</p>\r\n<ol type=\"1\">\r\n<li>对 <span class=\"math inline\">\\(p_g (x)\\)</span>\r\n没有显式的表达。</li>\r\n<li>G不能在更新D之前训练过多，要不然会发生模型崩溃问题。</li>\r\n</ol>\r\n<blockquote>\r\n<p>模型崩溃Mode collapse 是指 GAN\r\n生成的样本单一。当G发现一种样本可以欺骗到D时，就只会生成那一种mode的样本。判别网络最后会判别来自该\r\nmode 的样本是假的。最后，生成网络 G 会简单地锁定到另一个\r\nmode。该循环会无限进行，就会限制生成样本的多样性</p>\r\n</blockquote>\r\n<p>优点：</p>\r\n<ol type=\"1\">\r\n<li>只需要反向传播，不需要马尔科夫链，不需要推理网络</li>\r\n<li>多种多样的模型可以结合在GAN的框架中。</li>\r\n<li>不会直接使用真实数据样本去更新G，而是只能通过判别器的梯度引导。换句话说，生成器不会直接copy原始输入。</li>\r\n</ol>\r\n<h1 id=\"other\">Other</h1>\r\n<p>为什么要distribution？<br />\r\n为了同样的输入能够产生不同的输出</p>\r\n<p>JS散度的问题?<br />\r\n如果两个分布完全不重叠，JS散度值始终是 log 2，改进有Wasserstein\r\ndistance...</p>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[1]Goodfellow I, Pouget-Abadie J, Mirza M, et al. Generative\r\nadversarial nets[J]. Advances in neural information processing systems,\r\n2014, 27.</p>\r\n<p>[2]Younes, L. (1999). On the convergence of Markovian stochastic\r\nalgorithms with rapidly decreasing ergodicity rates. Stochastics and\r\nStochastic Reports, 65(3), 177–228.</p>\r\n<p>[3]GAN完整理论推导与实现, 机器之心, <a\r\nhref=\"https://www.jiqizhixin.com/articles/2017-10-1-1\"\r\nclass=\"uri\">https://www.jiqizhixin.com/articles/2017-10-1-1</a></p>\r\n","categories":["深度学习"]},{"title":"GeometryMotion-Net","url":"/2022/02/24/GeometryMotion-Net/","content":"<ul>\r\n<li>Liu J, Xu D. GeometryMotion-Net: A strong two-stream baseline for 3D\r\naction recognition[J]. IEEE Transactions on Circuits and Systems for\r\nVideo Technology, 2021, 31(12): 4711-4721.</li>\r\n<li>北航计算机</li>\r\n<li>中科院二区</li>\r\n</ul>\r\n<h1 id=\"introduction\">Introduction</h1>\r\n<p>一个比较相似的工作是3DV,其使用了PoinNet++抽取几何信息,再通过体素化抽取运动信息。然而体素化之类的过程是计算消耗巨大的,导致3DV本身很慢。GeometryMotion-Net则是用于在点云序列中抽取几何和运动信息，并且不依赖于任何体素化操作。主要思想是利用<strong>一个几何流和运动流组成的two-stream框架</strong>来进行动作识别。</p>\r\n<ol type=\"1\">\r\n<li>采样：帧采样之后，对帧内使用PointNet++类似的<strong>set\r\nabstraction</strong>(FPS, grouping, PointNet)进行下采样。</li>\r\n<li>几何流：用整个点云序列构造成一个空间整体。其从所有的帧中将点全部合并在一起，然后在每个点的局部邻域中抽取出特征。</li>\r\n<li>运动流：在相邻两帧之间生成两个虚拟的帧。对于帧内的一个点，首先生成其相对于前后相邻帧的offset特征，然后在offset特征的空间中抽取其局部邻域信息。</li>\r\n</ol>\r\n<figure>\r\n<img src=\"https://i.imgur.com/oNRJnkD.png\" alt=\"整体结构图\" />\r\n<figcaption aria-hidden=\"true\">整体结构图</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h1 id=\"采样和初始特征\">采样和初始特征</h1>\r\n<p>将序列划分为T个等分区间，并且训练时从每个区间内随机取一个帧，测试时则每个区间取固定一帧。</p>\r\n<p><strong>Baseline</strong>：有了帧之后，一种简单的思路即使用现有的点云空间学习方法（如PointNet和PointNet++）来对帧内进行全局的学习。并且最终将T帧的全局特征连接起来，作为最终的序列级别的特征。</p>\r\n<p>回到这篇文章，对于每个帧内，使用了PointNet++中的set\r\nabstraction操作来进行下采样出N个点，并且为这N个点计算出了初始特征（xyz\r\n拼接 C）。</p>\r\n<blockquote>\r\n<p>set abstraction：采样层+聚类层+miniPointNet层。</p>\r\n</blockquote>\r\n<h1 id=\"几何流\">几何流</h1>\r\n<p>对于输入的T帧点云，几何流将其整合为一个大的点云<span\r\nclass=\"math inline\">\\(P^{T*N \\times\r\n3+C}\\)</span>个点。对于大点云中的每个点，聚合其邻域范围特征作为自己的特征。具体做法是，首先搜索其k近邻<span\r\nclass=\"math inline\">\\(N_k(i)\\)</span>,并且对每个邻居构造一个差分特征，如下所示:</p>\r\n<p><span class=\"math display\">\\[\r\n\\tilde{f}_{j}=h_{1}\\left(\\left[f_{j}-f_{i}, f_{i}\\right]\\right), \\quad\r\n\\forall j \\in N_{k_{1}}(i)\\\\\r\ng_{i}=\\underset{j \\in N_{k_{1}}(i)}{\\mathbf{M A X}} \\tilde{f}_{j}\r\n\\]</span></p>\r\n<p>其中<span class=\"math inline\">\\(h_1\\)</span>是一个MLP块,<span\r\nclass=\"math inline\">\\(\\tilde{f}_{j}\\)</span>则是每个邻居的差分特征。之后再对整个邻域进行max-pooling操作，以聚合整个邻域的特征<span\r\nclass=\"math inline\">\\(g_i\\)</span>，其作为中心点的特征。</p>\r\n<p>更新了整个大点云之后，则在其上使用一个mini\r\nPointNet来抽取整个点云的全局特征<span\r\nclass=\"math inline\">\\(\\mathbf{G}\\)</span>，类似于平均图像的概念。</p>\r\n<h1 id=\"运动流\">运动流</h1>\r\n<p>点云中无法得知不同帧之间点的一一对应关系，而做点的运动估计和轨迹跟踪本身也是个困难且计算量大的任务。因此，这篇文章选择了对每一帧生成前后两个虚拟帧来找到运动关系。对于每一帧点云<span\r\nclass=\"math inline\">\\(P\\)</span>，其中点特征为<span\r\nclass=\"math inline\">\\(f_i : R^{3+C}\\)</span>。定义其邻域点云为<span\r\nclass=\"math inline\">\\(P^r\\)</span>，其中点特征为<span\r\nclass=\"math inline\">\\(f_j : R^{3+C}\\)</span>。</p>\r\n<p>为了学习点的运动变化信息，即需要构造一个在运动上的差分特征。因此对于原始帧内的点<span\r\nclass=\"math inline\">\\(p_i\\)</span>，在<span\r\nclass=\"math inline\">\\(P^r\\)</span>中使用PointNet++的方法找到k近邻，并且用类似于运动流的方法构造差分特征，如下所示：</p>\r\n<p><span class=\"math display\">\\[\r\n\\bar{f}_{j}=h_{2}\\left(\\left[\\hat{f}_{j}^{r}-\\hat{f}_{i}^{c},\r\n\\check{f}_{i}^{c}, \\check{f}_{j}^{r}\\right]\\right), \\quad \\forall j \\in\r\nN_{k_{2}}(i)\\\\\r\nm_{i}=\\underset{j \\in N_{k_{2}}(i)}{\\operatorname{MAX}} \\bar{f}_{j}\r\n\\]</span></p>\r\n<p>最终可以得到一个时间聚合点为<span\r\nclass=\"math inline\">\\(m_i\\)</span>，其组成了一个时间聚合点云<span\r\nclass=\"math inline\">\\(M\\)</span>。之后在其上同样使用mini\r\nPointNet来抽取这个运动点云的全局特征<span\r\nclass=\"math inline\">\\(\\mathbf{M}\\)</span>。</p>\r\n<p>因此在运动流的管线中，输入T帧点云，前一帧和后一帧都可以作为邻域点云，最终产生2(T-1)个时间聚合点云<span\r\nclass=\"math inline\">\\(M\\)</span>，抽取特征之后即可得到2(T-1)个双向运动特征。</p>\r\n<h1 id=\"双流汇聚\">双流汇聚</h1>\r\n<p>汇聚前的输入为一个几何全局特征，和2(T-1)个运动特征，简单的汇聚方法即对这些特征进行拼接，然后使用MLP进行降维处理，最终输出分类得分。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/XOLjSBv.png\" alt=\"NTU RGB+D 120结果\" />\r\n<figcaption aria-hidden=\"true\">NTU RGB+D 120结果</figcaption>\r\n</figure>\r\n","categories":["深度学习"],"tags":["深度学习","序列学习","点云"]},{"title":"Github+Hexo 搭建博客","url":"/2020/07/15/Github-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","content":"<h1 id=\"github-pages-hexo-博客搭建\">github Pages + Hexo 博客搭建</h1>\r\n<p>前置知识：git 使用，github 建库</p>\r\n<blockquote>\r\n<p>注意GitHub仓库最好建的是username.github.io仓库，这样GitHub Pages\r\n才能获得一级域名。而二级域名在进行某些扩展时有问题。可以去搜一下关于github\r\npages两种域名的区别。</p>\r\n</blockquote>\r\n<h2 id=\"安装环境\">安装环境</h2>\r\n<h3 id=\"安装-node.js\">安装 node.JS</h3>\r\n<p><a\r\nhref=\"https://nodejs.org/en/download/\">官网下载安装程序，默认安装即可</a></p>\r\n<p>命令行运行<code>node -v</code> <code>npm -v</code>检查安装效果</p>\r\n<h3 id=\"安装-hexo\">安装 hexo</h3>\r\n<p>注意以下命令推荐使用字符支持良好的命令行，最好给管理员权限。我使用的是\r\ngit bash。</p>\r\n<blockquote>\r\n<p>可以使用 cmd，但我遇到了中文问题。</p>\r\n<p>powershell 运行会提示 “在此系统上禁止运行脚本”， 管理员权限下输入\r\n<code>set-executionpolicy remotesigned</code>\r\n更改安全策略，允许运行脚本。</p>\r\n</blockquote>\r\n<p>运行<code>npm install -g hexo-cli</code>进行安装,再运行<code>hexo -v</code>检查安装效果，有版本信息即安装成功</p>\r\n<h2 id=\"配置项目\">配置项目</h2>\r\n<h3 id=\"初始化\">初始化</h3>\r\n<p>安装成功后自己创建一个项目文件夹，命令行切换到文件夹路径进行以下初始化：</p>\r\n<p>运行<code>hexo init</code>初始化</p>\r\n<h3 id=\"本地测试\">本地测试</h3>\r\n<p>运行以下命令部署默认网页进行测试：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">hexo</span> <span class=\"string\">new</span> <span class=\"string\">test_my_site</span> <span class=\"comment\">#创建新 test_my_site 的 markdown 文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">hexo</span> <span class=\"string\">g</span>                <span class=\"comment\"># 从 md 文件生成 html 文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">hexo</span> <span class=\"string\">s</span>                <span class=\"comment\"># 部署本地服务器</span></span><br></pre></td></tr></table></figure>\r\n<p>观察到命令行在持续运行时，则可打开浏览器输入本地服务器地址（默认是<code>localhost:4000</code>）访问试试看。</p>\r\n<h3 id=\"部署到网络\">部署到网络</h3>\r\n<p>在文件夹根路径下面，找到_config.yml，打开修改</p>\r\n<p>最后一段为：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">repo:</span> <span class=\"string\">仓库的完整路径，推荐使用</span> <span class=\"string\">ssh</span> <span class=\"string\">路径，这样可以有</span> <span class=\"string\">ssh</span> <span class=\"string\">免密登录。例如我的</span> <span class=\"string\">git@github.com:Alobal/alobal.github.io.git</span></span><br><span class=\"line\"><span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\r\n<p>URL 小段为：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># URL</span></span><br><span class=\"line\"><span class=\"comment\">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"string\">访问网址，例如</span> <span class=\"string\">https://alobal.github.io/</span></span><br><span class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">仓库名，例如</span> <span class=\"string\">/</span></span><br></pre></td></tr></table></figure>\r\n<p>保存关闭该文件</p>\r\n<p>安装 hexo 的 git\r\n部署插件<code>npm install hexo-deployer-git --save</code></p>\r\n<p>运行以下命令进行发布到网络</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">hexo</span> <span class=\"string\">clean</span></span><br><span class=\"line\"><span class=\"string\">hexo</span> <span class=\"string\">g</span></span><br><span class=\"line\"><span class=\"string\">hexo</span> <span class=\"string\">d</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>在 hexo d 部署到 GitHub 时可能要求 GitHub 账号密码。</p>\r\n</blockquote>\r\n<p>出现<code>Branch 'master' set up to track remote branch 'master' from 'https:..</code>大概就恭喜你成功了。此时可以在\r\ngithub 仓库看到 hexo\r\n提交的文件。以及能通过访问网址查看你刚才发布的默认博客。</p>\r\n<h2 id=\"选一个你喜欢的主题\">选一个你喜欢的主题</h2>\r\n<h3 id=\"下载主题\">下载主题</h3>\r\n<p><a href=\"https://hexo.io/themes/\">hexo 主题库</a></p>\r\n<p>挑选一个合适的主题，比如很常见的 Next，复制 git\r\n地址，在本地博客项目根目录下，命令行输入进行 git clone</p>\r\n<p>例如<code>git clone https://github.com/next-theme/hexo-theme-next themes/next</code></p>\r\n<blockquote>\r\n<p>如果使用 next 主题请注意， next 主题在 2020 之前是 theme-next\r\n项目，2020 版本是 next-theme 项目，配置字段有点不同，根据需要选择。19\r\n版本网上教程比较健全了。</p>\r\n</blockquote>\r\n<h3 id=\"配置主题\">配置主题</h3>\r\n<p>打开 _config.yml，修改 theme 字段：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Extensions</span></span><br><span class=\"line\"><span class=\"comment\">## Plugins: https://hexo.io/plugins/</span></span><br><span class=\"line\"><span class=\"comment\">## Themes: https://hexo.io/themes/</span></span><br><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">主题名，例如</span> <span class=\"string\">next</span></span><br></pre></td></tr></table></figure>\r\n<p>其中主题也有自己的配置文件，项目名/themes/主题名/_config.yml，可以根据需要进行修改。比如\r\nnext\r\n主题配置文件中，可以在四种风格中选一种，选一个取消注释就好了。想预览效果可以去找\r\nnext 官方文档。</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Schemes</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Muse</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Mist</span></span><br><span class=\"line\"><span class=\"attr\">scheme:</span> <span class=\"string\">Pisces</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>\r\n<p>输入<code>hexo g;hexo d</code>\r\n重新生成网页并发布出去，可以自己偷偷欣赏欣赏。</p>\r\n<blockquote>\r\n<p>如果没看到生效，可能是因为浏览器缓存，关掉浏览器重新打开，或者\r\nCtrl+F5 强制刷新。</p>\r\n</blockquote>\r\n<h2 id=\"helloblog\">hello，blog</h2>\r\n<p>让我们试着发布第一篇博客。项目路径下，命令行输入<code>hexo n 博客名</code>\r\n, 可以在 项目名/source/_posts/ 下面找到新建的 markdown\r\n文件。打开文件可以发现有预置的文件头，暂时不用管，后续要添加<strong>分类</strong>和<strong>标签</strong>功能的时候可以写一写。在文件头之后，即<code>------</code>下面写入你的\r\nmarkdown 格式内容即可。</p>\r\n<p>关于 markdown 怎么书写，可以看我的 <a\r\nhref=\"https://alobal.github.io/Blog/2020/07/17/MarkDown%E7%AE%80%E6%B4%81%E6%89%8B%E5%86%8C/\">markdown\r\n简洁手册</a>。</p>\r\n<h2 id=\"参考\">参考</h2>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/26625249\">知乎经典贴</a></p>\r\n<h2 id=\"错误汇总\">错误汇总</h2>\r\n<h3 id=\"can-not-find-module-xxx\">can not find module xxx</h3>\r\n<p>命令行<code>npm install</code> 安装所有依赖包完事。</p>\r\n<h3 id=\"没有启用代码高亮\">没有启用代码高亮</h3>\r\n<p>根目录 config 里，修改配置如下：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">highlight:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">line_number:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">auto_detect:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">tab_replace:</span> <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">  <span class=\"attr\">wrap:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">hljs:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\r\n<p>next 主题配置里，选择自己要的高亮样式：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">codeblock:</span></span><br><span class=\"line\">  <span class=\"comment\"># Code Highlight theme</span></span><br><span class=\"line\">  <span class=\"comment\"># All available themes: https://theme-next.js.org/highlight/</span></span><br><span class=\"line\">  <span class=\"attr\">theme:</span></span><br><span class=\"line\">    <span class=\"attr\">light:</span>  <span class=\"string\">tomorrow-night-blue</span></span><br><span class=\"line\">    <span class=\"attr\">dark:</span>  <span class=\"string\">tomorrow-night-blue</span></span><br><span class=\"line\">  <span class=\"attr\">prism:</span></span><br><span class=\"line\">    <span class=\"attr\">light:</span> <span class=\"string\">tomorrow-night-blue</span></span><br><span class=\"line\">    <span class=\"attr\">dark:</span> <span class=\"string\">tomorrow-night-blue</span></span><br><span class=\"line\">  <span class=\"comment\"># Add copy button on codeblock</span></span><br><span class=\"line\">  <span class=\"attr\">copy_button:</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"comment\"># Available values: default | flat | mac</span></span><br><span class=\"line\">    <span class=\"attr\">style:</span></span><br></pre></td></tr></table></figure>\r\n","categories":["工具"],"tags":["博客"]},{"title":"How to Read a Paper","url":"/2021/09/26/How-to-Read-a-Paper/","content":"<h2 id=\"确定阅读目标\">确定阅读目标</h2>\r\n<ol type=\"1\">\r\n<li>能够重述给听众</li>\r\n<li>跟踪领域前沿技术</li>\r\n<li>调研一个新的领域</li>\r\n</ol>\r\n<p>根据自己的阅读目的调整自己的阅读深度。</p>\r\n<h2 id=\"三步走方法\">三步走方法</h2>\r\n<p>不要每一篇论文都从开始硬读到结尾，而是分段为三步走。每一步建立在上一步的基础之上，并且需要完成这一步应有的目标。</p>\r\n<p>第一步：了解论文总体的idea\r\n第二步：掌握论文的大致内容，但不需要在乎细节。 第三步：深度理解论文</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"第一步\">第一步</h3>\r\n<p>第一步用来快速浏览整篇论文，对论文有一个大体的认识，花费5~10分钟：</p>\r\n<ol type=\"1\">\r\n<li>仔细阅读<strong>标题，摘要，导论</strong>。</li>\r\n<li>阅读每一章节以及子节的<strong>引论</strong>，其他的不需要读。</li>\r\n<li>浏览一下<strong>数学</strong>性的内容，了解论文潜在的的理论基础。</li>\r\n<li>阅读<strong>结论</strong>。</li>\r\n<li>瞥一眼<strong>参考文献</strong>，在心里去掉那些你已经读过的。</li>\r\n</ol>\r\n<p>第一步做完之后，需要对一下五个问题有一个想法：</p>\r\n<ol type=\"1\">\r\n<li>分类：\r\n这篇论文是什么类型的？一项研究的原型？一个现有系统的分析？</li>\r\n<li>关联：和其他哪些论文有所联系？需要用到哪些理论基础来分析问题？</li>\r\n<li>正确性：论文的假设是否可以被证实？</li>\r\n<li>贡献点：论文的主要贡献点是什么？</li>\r\n<li>写作：这篇论文写作水平好吗？</li>\r\n</ol>\r\n<p>过了这些问题，已经足够让你判断论文是否值得继续阅读：不感兴趣、看不太懂、领域无关、正确性不够的论文，不用再看。</p>\r\n<p>同样，自己写作时也是如此。章节要连贯，内容概要要清晰明确，让人能够在浏览中掌握论文的要旨和亮点。用一个精心挑选的图表来总结全文是一种很棒的方法。</p>\r\n<h3 id=\"第二步\">第二步</h3>\r\n<p>第二步需要更用心地去看全文，但不需要在乎细节（例如证明过程什么的），花费大约一个小时。\r\n此时，可以在留白处写下注释笔记，记录要点，以及一些不懂的术语和问题。</p>\r\n<ol type=\"1\">\r\n<li>仔细看论文的<strong>图表插图</strong>。轴和标签是否标注正确？结论是否有误差范围？这些普遍的错误可以很好地区分优秀工作和粗制滥造。</li>\r\n<li>标记未读的相关<strong>参考文献</strong>，以便于进一步了解该论文的背景。</li>\r\n</ol>\r\n<p>第二步做完，需要能够掌握论文内容，并且能够带着支撑性的理论向别人概述文章主旨。这种深度的阅读适合于你感兴趣的，但不一定是你研究方向的论文。</p>\r\n<p>有可能这时候你还是没看懂这篇论文。这时候可以选择先把论文放一放，在过一会（例如读完相关材料）之后再回去读一读。或者先就这样，继续我们的第三步深度阅读。</p>\r\n<h3 id=\"第三步\">第三步</h3>\r\n<p>第三步是为了想要完整地理解一篇论文。在这一步里，努力尝试去复现/复推这篇论文：和作者基于同样的假设，重新去实现相关工作。然后比较自己实现的版本和论文版本，你会很容易地发现作者的创新点、设想、以及隐藏的错误。</p>\r\n<p>这一步需要特别注意每一个细节之处。我们需要理解论文中的每一个推导和假设，最终，我们可以把其中的知识和技术点加入到我们的知识库中。因此，我们也应该据此记下我们未来要做的工作。</p>\r\n<p>这一步可能要花上数个小时，最后我们应该有能力从记忆中完全把论文结构复现出来，并且对其优缺点了如指掌。</p>\r\n<h2 id=\"文献调研\">文献调研</h2>\r\n<p>踏入一个不熟悉的领域，怎么去选择要阅读的论文呢？</p>\r\n<ol type=\"1\">\r\n<li>利用学术搜索引擎（Google Scholar /\r\nCiteSeer）查找三到五篇近期的高引论文。对每篇论文过一次第一步，掌握对相关工作的一个感觉。然后看看它们的<strong>相关工作</strong>章节，以便找到近期进展的一些概述。直到找到<strong>survey综述论文</strong>。</li>\r\n<li>如果没找到，在参考文献里找一些多次引用的作者和论文。看看这些作者近期工作是在哪出版的，这样可以找到领域内的<strong>顶级会议</strong>。</li>\r\n<li>在这些会议上浏览他们近期的进展，配合上之前搜集的几篇论文，这就构成了调研的文集。可以在其中进行第二步的阅读。特别注意这些文章的<strong>共同引用论文</strong>。</li>\r\n</ol>\r\n<h2 id=\"参考文献\">参考文献</h2>\r\n<p>《How to Read a Paper》, S. Keshav David R. Cheriton School of\r\nComputer Science, University of Waterloo Waterloo, ON, Canada,August 2,\r\n2013,keshav@uwaterloo.ca</p>\r\n","categories":["工具"]},{"title":"LeetCode-No-1","url":"/2020/02/17/LeetCode-No-1/","content":"<h1 id=\"两数之和\"><a\r\nhref=\"https://leetcode-cn.com/problems/two-sum\">两数之和</a></h1>\r\n<p>给定一个整数数组 <code>nums</code> 和一个目标值\r\n<code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。\r\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>\r\n<p>示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] =\r\n2 + 7 = 9 所以返回 [0, 1]</p>\r\n<h3 id=\"解决思路\">1.解决思路</h3>\r\n<p><strong>暴力遍历</strong>，我们需要找出两个数满足一个数值和的需求，我首先想到的就是通过遍历尝试，简单暴力。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"keyword\">int</span> twoSum(vector&lt;<span class=\"keyword\">int</span>&amp; nums, <span class=\"keyword\">int</span> target) </span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=0;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j=0;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=0;i&lt;nums.size()-1;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j=i+1;j&lt;nums.size();j++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[i]+nums[j]==target)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    result.push_back(i);</span><br><span class=\"line\">                    result.push_back(j);</span><br><span class=\"line\">                    j=nums.size();</span><br><span class=\"line\">                    i=j-1;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>通过</li>\r\n<li>472 ms</li>\r\n<li>9.2 MB</li>\r\n<li>Cpp</li>\r\n</ul>\r\n<h3 id=\"优化思路\">2.优化思路</h3>\r\n<p>显然暴力解法最容易想但效率也大量浪费在了无谓的二层循环中，直接导致了O(n^2)的复杂度。\r\n<strong>细化需求</strong>，当我们找到一个数，本来是要在二层循环中尝试找到可以组合的数，我们已知数值寻找位置，因此可以考虑到使用<strong>map哈希表</strong>来构造数据结构,使用\r\n<strong>空间换时间</strong>。 哈希表查找复杂度为O(1)</p>\r\n<p><strong><em>两遍哈希表</em></strong>，我们把数组遍历存入map中，消耗O(n)，然后再对每一个数进行遍历，每次只要在map中寻找其对应的数值是否存在即可，总时间复杂度为2O(n)。\r\n<strong><em>一遍哈希表</em></strong>\r\n：在存入map时即对对应的匹配数进行查找，优化复杂度至O(n)。</p>\r\n<h3 id=\"最终实现代码\">3.最终实现代码</h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"keyword\">int</span> twoSum(vector&lt;<span class=\"keyword\">int</span>&amp; nums, <span class=\"keyword\">int</span> target) </span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        map&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span> store;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=0;i&lt;nums.size();i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(store.count(target-nums[i])0)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                result=vector&lt;<span class=\"keyword\">int</span>(&#123;store[target-nums[i]],i&#125;);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            store.insert(map&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>::value_type(nums[i],i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>通过</li>\r\n<li>20 ms</li>\r\n<li>10.1 MB</li>\r\n<li>Cpp</li>\r\n</ul>\r\n","categories":["LeetCode"]},{"title":"Hexo Github+Coding 双线部署(已废弃,Coding已不支持免费部署)","url":"/2020/08/27/Hexo-Github-Codin%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2/","content":"<h2 id=\"起因\">起因</h2>\r\n<p>本来在【关于】页挂了个终末之诗，觉得写得很好想分享出去看看。</p>\r\n<p>结果别说看了，别人打开 GitHub 部署的静态网页完全就是\r\n404！用久了传送门都忘掉了 GitHub 是带墙的 ... 只能保存了个没有样式的\r\nhtml 发过去。</p>\r\n<blockquote>\r\n<p>一开始还以为是个别连不上，因为我自己裸连虽然慢了点也能上。后来发现好像是因为上海的网墙矮一点？？之前在上海也是能裸连\r\nR6 服务器，回江西那是完全登不上的那种。</p>\r\n</blockquote>\r\n<p>所以想着再在国内代码托管平台部署一个了。毕竟虽然没有人看，但偶尔想分享的时候也太不方便了=\r\n=</p>\r\n<h2 id=\"配置\">配置</h2>\r\n<p>单独配置其中任何一个平台的话，在前面的博客里写的很详细了，默认已经配置好了\r\nGitHub 哈，介绍一些双线部署的小问题。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"hexo-_config.yml-配置\">hexo _config.yml 配置</h3>\r\n<p>这里主要注意 deploy 字段：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">仓库地址</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">仓库地址</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">master</span> </span><br></pre></td></tr></table></figure>\r\n<p>要同时往两个仓库部署，需要用<code>-</code>号语法。同时请注意严格遵守缩进规则。</p>\r\n<h3 id=\"coding-配置\">Coding 配置</h3>\r\n<p>注意 Coding 新建一个仓库后，默认是没有打开部署服务的。因此要去\r\n<code>项目设置-&gt;项目与成员-&gt;功能开关-&gt;持续部署</code>这里开启静态页面相关功能。</p>\r\n<p>之后可以在仓库的<strong>持续部署</strong>下找到静态网站功能了。去网站设置里保存一下相关设置即可，最好能打开强制\r\nHTTPS。</p>\r\n<blockquote>\r\n<p>至于其他博客说的什么仓库名项目名网站名要和用户名一样，我是没感觉到有必要性\r\n... 毕竟名字至少肯定不影响\r\npush，而静态网页的地址最后都是被分配\".com\"网址，也想不出和名字有啥关系。</p>\r\n</blockquote>\r\n<h3 id=\"github-和-coding-的路由区别\">GitHub 和 Coding 的路由区别</h3>\r\n<p>如果之前在 GitHub\r\n随便创个普通仓库部署的静态网页，这时候就会出现问题。我后来才知道，GitHub\r\nPages 分<strong>个人主页</strong>和<strong>项目主页</strong>：</p>\r\n<ul>\r\n<li>个人主页 user.github.io</li>\r\n<li>项目主页 user.github.io/xxxx</li>\r\n</ul>\r\n<p>普通仓库的 GitHub Pages 是项目主页，因此网址是次级网址，再加上之前在\r\nhexo 配置的<code>root</code>相关字段，hexo 加载资源什么的都是以 “/xxxx”\r\n为根目录去查找的。</p>\r\n<p>然而 Coding 给的是一级域名，此时部署到 Coding\r\n的页面也是会以“/xxxx”为根目录进行加载资源，显然就会出错了，直接体现就是\r\nmain.css 无法加载，F12 调试看可以发现是 main.css 的路径错误。</p>\r\n<p>然而在没有自定义域名的情况下，两边都不允许更换主次级域名，这时候发现GitHub有分<em>个人主页</em>这个东西\r\n...</p>\r\n<h3 id=\"github-个人主页-顶级网址\">GitHub 个人主页 顶级网址</h3>\r\n<p>普通的仓库名建出来的都是项目主页，是次级网址。GitHub有两个仓库名比较特殊：</p>\r\n<ul>\r\n<li>user 这个是彩蛋仓库，它的readme.md会显示在GitHub个人资料页</li>\r\n<li>user.github.io 这个是我们要的，顶级网址仓库。</li>\r\n</ul>\r\n<p>创建名为<code>user.github.io</code>的仓库，user\r\n是账户名，比如我需要的仓库名就是 alobal.github.io</p>\r\n<p>此时去开启GitHub Pages 可以发现域名就是 user.github.io\r\n了，重新调整hexo对GitHub的相关部署即可。</p>\r\n<blockquote>\r\n<p>记得hexo _config.yml 中设置 <code>root: /</code>。</p>\r\n</blockquote>\r\n<h3 id=\"成功部署\">成功部署</h3>\r\n<p>调整相关配置和仓库后，可以轻松验证两边都配置成功了。当然，如果你删了GitHub的旧仓库，假如以前有页间引用的绝对路径链接..此时都会失效。自己酌情考虑要不要清空吧。</p>\r\n<p>另外hexo _config.yml中有一个 url\r\n字段，设置的是网页访问网址，而且好像只能设置一个，但又没影响双线不同网址的部署，不知道有什么用=\r\n=可能是作为一种可选引用变量吧</p>\r\n","categories":["工具"],"tags":["博客"]},{"title":"KMP 字符串模式匹配","url":"/2020/09/11/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/","content":"<p>字符串模式匹配——给定两个字符串，主串 haystack，模式串 needle。在\r\nhaystack 中查找 needle 出现的首字符位置。</p>\r\n<blockquote>\r\n<p>示例：</p>\r\n<p>输入：haystack=\"hello\",needle=\"ll\" 输出：2</p>\r\n<p>\"ll\" 在“hello”中出现的首字符位置是第三个字符，下标是 2</p>\r\n</blockquote>\r\n<h3 id=\"暴力的简单匹配\">暴力的简单匹配</h3>\r\n<p>思想是，在 haystack 的每个位置，都检查一遍是不是 needle\r\n的首字符，即后续能不能和 needle 匹配上。</p>\r\n<p>使用两层循环很简单，时间复杂度是 O(len_h*len_n)，显然过于复杂。</p>\r\n<h2 id=\"简单匹配的优化方向\">简单匹配的优化方向</h2>\r\n<p>既然要优化，我们肯定要知道原来的算法到底在哪里浪费了性能。可以看下面的例子：</p>\r\n<blockquote>\r\n<p>haystack=\"abcabcabe\" needle=\"abcabe\"</p>\r\n</blockquote>\r\n<p>跟着简单匹配的思路，以 haystack[0]\r\n为起点，然后主串模式串同时向后移动并匹配每一位，我们可以发现最终匹配会停留在：</p>\r\n<ul>\r\n<li>abcab<code>c</code>abe</li>\r\n<li>abcab<code>e</code></li>\r\n</ul>\r\n<p>即 c 和 e 匹配失败，那么简单匹配会退出这轮子循环，再以 haystack[1]\r\n进行匹配。</p>\r\n<p>此时以人的思维去看，以 b 或 c 为起点肯定匹配不成功，相反\r\nabc<code>ab</code>cabe 和<code>ab</code>cabe 是显然可以匹配到的。</p>\r\n<p>而且从遍历的角度来看，主串已经走到了\r\nhaystack[5]，相当于我们已经获取了前 6 位字符的信息了，我们已经知道前 6\r\n位是什么字符了，再从 haystack[1]\r\n开始的话就相当于刚见过人家长啥样就忘了，没有利用到已知信息，这就是问题所在。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"失败返回的有效信息\">失败返回的有效信息</h3>\r\n<p>匹配在 e 处失败，整理一下这次匹配获得的信息： -\r\n主串从匹配起点到失败点，必然是\r\nabcab，要不然肯定在前面就失败了，不会在第六位失败。</p>\r\n<p>更普遍一点，在模式串 needle[i] 位失败，那么主串 haystack\r\n在失败点前面必然有 needle[0~i-1] 的所有字符。而因为 needle\r\n是固定不变的，所以不管 i=1，2，3，4，5 ...\r\n主串从匹配起始点到匹配失败点间的字符，都肯定是固定的。</p>\r\n<p>这就是匹配失败告诉我们的教训。</p>\r\n<h3 id=\"利用失败信息\">利用失败信息</h3>\r\n<p>例如匹配情况如下： - xxxxxx abcab<code>d</code> xxxxxx -\r\nabcab<code>e</code></p>\r\n<p>我们甚至不需要知道主串长什么样，只要模式串在 e\r\n处失败，我们就可以闭眼预测——主串失败点前面肯定是 abcab 。</p>\r\n<p>既然我们已经能预测到有 abcab\r\n了，那么我们能做点什么呢？当然能啊，对面都明牌了，我们事先安排好最优匹配策略不就完事。</p>\r\n<p>上例中已知 abcab<code>d</code> ，那人眼显然看出来了——a\r\n开始的匹配失败了，b、c 开头的显然不行，abc<code>ab</code>d 的 ab\r\n恰好直接对上模式串前两位 ab，那我们接下来干嘛呢？当然直接从 ab\r\n的位置接后着匹配 d 和 c： - xxxxxxxx abc<code>ab</code>d xxxxx -\r\n<code>ab</code>cabe</p>\r\n<blockquote>\r\n<p>此时可以发现，主串遍历指针在 d 处失败，直接再从 d 开始，不需要回退到\r\nb ，这是 KMP 的最大优点。</p>\r\n</blockquote>\r\n<p>通过我们事先的预测可以发现，不管主串长什么旮旯样，只要匹配在\r\nabcab<code>e</code>处失败，那么下一个匹配一定可以直接从<code>ab</code>cabe\r\n开始，不需要主串回退遍历。甚至不仅没回退，还在主串不同的情况下，模式串直接免掉了几位的匹配。</p>\r\n<p>假如失败在第 1 位、第 2 位、... 第 i\r\n位呢？显然前面说过，在哪一位匹配失败后，前面都有固定的字符串，我们都可以做好事先预测。</p>\r\n<blockquote>\r\n<p>例 1： - xxxxx abca<code>d</code> xxxx - abca<code>b</code>e\r\n此时我们知道前面是 abca，观察可知接下来的最优方案是直接以 needle[0]\r\n对上主串的第二个 a。</p>\r\n<p>例 2：</p>\r\n<ul>\r\n<li>xxxxx abac<code>d</code> xxxxx</li>\r\n<li>abac<code>e</code> 此时我们知道前面是 abac，但即使 needle[0]\r\n对上了主串失败区间的第二个 a，也必然会失败，因为后面是 c 和 b\r\n的必然不匹配，我们也没必要去尝试了。</li>\r\n</ul>\r\n</blockquote>\r\n<p>通过例 2 我们知道，匹配失败后我们拿 needle\r\n的头部去主串中找一个地方对上，但对上的时候必须有这样一个结构：<strong>模式串前缀\r\naxx 刚好对上主串失败区间的后缀 axx</strong>，这样的匹配才可能成功。</p>\r\n<h3 id=\"怎么事先预测\">怎么事先预测</h3>\r\n<p>现在我们的目标是怎么让程序去做事先预测，只要做好了事先预测，那么每次失败之后的下一步该怎么做就知道了。</p>\r\n<p>我们还知道，失败后可能成功的匹配只有\r\n<strong>模式串前缀=失败区间后缀</strong>，而失败区间又是模式串自己的子串，因此就是<strong>模式串\r\n0~i 的子串的前后缀相同</strong>，i 为模式串的任意位置。</p>\r\n<p>具体来说，在模式串 i 位失败，假如模式串前缀 [0~k-1] 和 0~i 的后缀\r\n[i-k~i-1] 有 k\r\n位相同，那么直接拿前缀去匹配后缀在主串中的位置就可以了。</p>\r\n<p>即：<strong>主串指针不动，前缀有 k-1 位匹配好了，模式串指针跳转到\r\nneedle[k] 继续匹配</strong>。</p>\r\n<blockquote>\r\n<p>在这个例子中： - xxxxxxxx abc<code>ab</code>d xxxxx -\r\n<code>ab</code>cabe</p>\r\n<p>模式串在 e 失败，则指针跳转到下标 2 的位置，以 needle[2] 去匹配 d</p>\r\n</blockquote>\r\n<h3 id=\"创建失效数组\">创建失效数组</h3>\r\n<p>所以我们可以创建一个<strong>失效数组</strong>，第 i 位存储模式串在第\r\ni 位失败后，模式串指针应当跳转到的位置。</p>\r\n<p>而且因为模式串固定，失败后的跳转位置也固定，做好了一个失效数组就可以在任意主串匹配中使用。</p>\r\n<p>所以我们的最终问题在于，检测每个失败区间 0~i 中是否有前后缀相同的 k\r\n位，并据此设定失败后的模式串指针跳转到 needle[k]。</p>\r\n<p>当然找到前后缀相同的 k 位，其实也就是前后缀的模式匹配问题。 &gt;...\r\n嗯，也是模式匹配。 &gt;KMP 让我惊叹地点在于，为了构造 KMP\r\n的失效数组，也用到了 KMP 自身的思想 ...</p>\r\n<p>前后缀计算的主要思想如下： - 前后缀的匹配有动态规划特性，0~i+1\r\n的前后缀，直接和 0~i 的前后缀相关联。例如对于 i 位以前的 0~i-1 有 k\r\n位成功匹配的前后缀：</p>\r\n<pre><code>- 假如 needle[k]==needle[i]，即前后缀可继续累加，0\\~i 则有了 k+1 位前后缀。\r\n\r\n- needle[k]!= needle[i]，相当于此时前后缀 i k 位匹配失败，相当于 0\\~k 的子串作为模式串 needle，去模式匹配后缀的子串，结果在 k 位失败了，按照我们之前失败跳转的思想，这里 k 自然进行跳转到对应位置 lost[k]。</code></pre>\r\n<blockquote>\r\n<p>注意 0~i 的有效前后缀 k 位，是为第 i+1 位的失败服务的，而不是为第 i\r\n位。换句话说，计算出了 0~i 位有 k 位有效的前后缀，那么进行 i++，然后把 k\r\n填入 lost[i]。</p>\r\n</blockquote>\r\n<p>构造失效数组代码，逐句详细注释： <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">GetLost</span><span class=\"params\">(string&amp; needle)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;   </span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">lost</span><span class=\"params\">(needle.size(),<span class=\"number\">0</span>)</span></span>;<span class=\"comment\">//构造等长失效数组，初始值 0</span></span><br><span class=\"line\">    <span class=\"comment\">//KMP</span></span><br><span class=\"line\"></span><br><span class=\"line\">    lost[<span class=\"number\">0</span>]=<span class=\"number\">-1</span>;<span class=\"comment\">//在 0 位失败肯定没法跳跃，-1 表示退出子循环。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k=<span class=\"number\">-1</span>;<span class=\"comment\">//跳跃位置，也即匹配前缀的下一位</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;<span class=\"comment\">//尾部</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;needle.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//前缀还空着或 i k 位相同，即目前为止前后缀仍相同，可以继续累加匹配的前后缀长度。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k==<span class=\"number\">-1</span> || needle[i]==needle[k])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//因为前后缀都是相对于 i 位之前的，在 0~i-1 的有效前后缀，其实是下一位，i 位跳转需要用到的，所以 i++，k++。</span></span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//设定在 i 位失败的跳转位置</span></span><br><span class=\"line\">            <span class=\"comment\">//i k 位不同，则就是跳转到 k。假如 i k 位相同，你说 i 失败了，k 必然也会失败，有啥意义呢，所以跳转到 k 跳转的位置。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(needle[i]!=needle[k])</span><br><span class=\"line\">                lost[i]=k;</span><br><span class=\"line\">            <span class=\"keyword\">else</span><span class=\"comment\">//</span></span><br><span class=\"line\">                lost[i]=lost[k];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//此时前后缀 i k 位匹配失败，相当于 0~k 的子串作为模式串 needle，去模式匹配后缀的子串，结果在 k 位失败了，按照我们之前失败跳转的思想，这里 k 自然进行跳转 ... KMP 内置 KMP 嗯</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>   </span><br><span class=\"line\">            k=lost[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lost;<span class=\"comment\">//完成失效数组</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\r\n<h3 id=\"利用失效数组进行模式匹配\">利用失效数组进行模式匹配</h3>\r\n<p>失效数组有了，每次失败后将模式串指针进行对应跳转即可，此时的模式匹配已经十分简单。</p>\r\n<p>匹配代码，这里只做了一次位置查找，简单修改可以查找出所有位置：\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(string&amp; haystack, string&amp; needle)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">int</span> x=<span class=\"number\">0</span>;<span class=\"comment\">//主串指针</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> y=<span class=\"number\">0</span>;<span class=\"comment\">//模式串指针</span></span><br><span class=\"line\">    vector&lt;<span class=\"keyword\">int</span>&gt; lost=<span class=\"built_in\">GetLost</span>(needle);<span class=\"comment\">//失效数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//模式串匹配</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x&lt;haystack.<span class=\"built_in\">size</span>() &amp;&amp; y&lt;<span class=\"built_in\"><span class=\"keyword\">int</span></span>(needle.<span class=\"built_in\">size</span>())) <span class=\"comment\">//注意这里 int 化！！！！！！很容易出意外的 bug，因为 size 返回值是 unsigned int</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(y==<span class=\"number\">-1</span> ||haystack[x]==needle[y])<span class=\"comment\">//匹配成功，或刚开始</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//当前位没问题，到下一位</span></span><br><span class=\"line\">            x++;</span><br><span class=\"line\">            y++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span><span class=\"comment\">//匹配在 y 失败，跳转到 lost[y]</span></span><br><span class=\"line\">        y=lost[y];</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(y==needle.<span class=\"built_in\">size</span>())<span class=\"comment\">//是模式串完全匹配成功退出循环的，x-y 即首字符位置</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x-y;</span><br><span class=\"line\">    <span class=\"keyword\">else</span><span class=\"comment\">//匹配失败退出循环的</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\r\n","categories":["算法"]},{"title":"LeetCode-No-10","url":"/2020/02/17/LeetCode-No-10/","content":"<h1 id=\"正则表达式匹配\"><a\r\nhref=\"https://leetcode-cn.com/problems/regular-expression-matching\">正则表达式匹配</a></h1>\r\n<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持\r\n'.' 和 '*' 的正则表达式匹配。</p>\r\n<p>'.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素\r\n所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>\r\n<p>说明:</p>\r\n<p>s 可能为空，且只包含从 a-z 的小写字母。\r\np 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例 1:</p>\r\n<p>输入: s = \"aa\" p = \"a\" 输出: false 解释: \"a\" 无法匹配 \"aa\"\r\n整个字符串。</p>\r\n<p>示例 2:</p>\r\n<p>输入: s = \"aa\" p = \"a<em>\" 输出: true 解释: 因为 '</em>'\r\n代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是\r\n'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。</p>\r\n<p>示例 3:</p>\r\n<p>输入: s = \"ab\" p = \".<em>\" 输出: true 解释: \".</em>\"\r\n表示可匹配零个或多个（'*'）任意字符（'.'）。</p>\r\n<p>示例 4:</p>\r\n<p>输入: s = \"aab\" p = \"c<em>a</em>b\" 输出: true 解释: 因为 '*'\r\n表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串\r\n\"aab\"。</p>\r\n<p>示例 5:</p>\r\n<p>输入: s = \"mississippi\" p = \"mis<em>is</em>p*.\" 输出: false</p>\r\n<h1 id=\"解题分析\">解题分析</h1>\r\n<h2 id=\"条件特性\">条件特性</h2>\r\n<ul>\r\n<li>首先可知\".\" 和对应字符的匹配都很容易处理,关键要处理好这个\" * \".</li>\r\n<li>\" * \"带来的变化有,\r\n使前一个字符匹配N次,<strong>N可为0</strong>,也就是说也可以忽略前一个字符.\r\n#### 错误思路\r\n~~由于我一开始没有注意到N可以为0,就采用了一个逐字符匹配的方法,假如遇到一个字符后面有\"<em>\",如果匹配错误则直接返回,匹配正确则维持pi不变,这样一步步推过去,在最后若两个字符串都到了结尾,则成功.后来提交错误后有针对性的修修补补浪费了很长时间,并且发现这种解法下再怎么改也不能AC,最终还是推盘重做T-T~~\r\n## 解题思路\r\n每一次带\"</em>\"的字符处,都会有两种可能的情况,要么匹配这个字符,要么不匹配这个字符.\r\n我们在测试一种情况发现不行之后,需要再退回测试另一种情况下的匹配.因此可以想到可以使用递归返回.</li>\r\n</ul>\r\n<h3 id=\"递归体设置\">递归体设置</h3>\r\n<p>1.若pi+1处为\" * \",则分情况处理 1.1.\r\n如果pi处可正确匹配,则分两个递归,一个是pi匹配1次,一个是pi匹配0次. 1.2.\r\n如果pi处不能匹配,则以pi匹配0次向后递归处理 1.3. 考虑特殊情况,s已经被带\"\r\n*\r\n\"字符匹配完,s为空,p还有至少两个字符存在,则p向后推进两个字符再和已经空的字符进行递归匹配.</p>\r\n<p>2.若pi处为\".\"或可匹配字符,则正常匹配成功,s和p都往后推进1个字符.</p>\r\n<p>3.若pi处为无法匹配字符,return false ### 递归出口\r\n因为我们的递归体若能成功匹配,则S在最底层的递归中,必定是一个空串 -\r\n此时<strong>若p为空串</strong>,则s和p恰好完全匹配成功,return true -\r\n<strong>若p不为空</strong>,则s肯定是被带\" *\r\n\"字符消化掉了,因此参考上面的递归体条件,进入下一次递归中p的带\"<em>\"字符被删掉,此时再进行出口判断.如果p仍不为空,即可return\r\nfalse. 注意p不为空时,有两种情况,并且后一种情况是前一种情况的递归结果\r\n因此<strong>不能简单的直接根据plength!=0直接返回false</strong>.\r\n要<strong>先判断p是否有字符</strong>,若有字符并且是带\" </em>\r\n\"字符,则是可匹配范围内的情况,需递归推两个字符进一步判断.\r\n若p有字符并且不是带\"*\"字符,则是无法正确匹配的情况,return false.</p>\r\n<h1 id=\"初版通过代码\">初版通过代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isMatch</span><span class=\"params\">(string s, string p)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> si = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> pi = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> slength = s.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> plength = p.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (slength != <span class=\"number\">0</span> &amp;&amp; plength == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (slength == <span class=\"number\">0</span> &amp;&amp; plength == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (p[pi + <span class=\"number\">1</span>] == <span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (slength == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">isMatch</span>(s.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>), p.<span class=\"built_in\">substr</span>(pi + <span class=\"number\">2</span>, plength - pi - <span class=\"number\">2</span>));</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(p[pi] == <span class=\"string\">&#x27;.&#x27;</span> || p[pi] == s[si])</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//pi匹配1次s前进p不变  pi匹配0次s不变p前进2</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">isMatch</span>(s.<span class=\"built_in\">substr</span>(si + <span class=\"number\">1</span>, slength - si - <span class=\"number\">1</span>), p.<span class=\"built_in\">substr</span>(pi, plength - pi)) || <span class=\"built_in\">isMatch</span>(s.<span class=\"built_in\">substr</span>(si, slength - si), p.<span class=\"built_in\">substr</span>(pi + <span class=\"number\">2</span>, plength - pi - <span class=\"number\">2</span>));</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">isMatch</span>(s.<span class=\"built_in\">substr</span>(si, slength - si), p.<span class=\"built_in\">substr</span>(pi + <span class=\"number\">2</span>, plength - pi - <span class=\"number\">2</span>));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (slength == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p[pi] == <span class=\"string\">&#x27;.&#x27;</span> || p[pi] == s[si])</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">isMatch</span>(s.<span class=\"built_in\">substr</span>(si + <span class=\"number\">1</span>, slength - si - <span class=\"number\">1</span>), p.<span class=\"built_in\">substr</span>(pi + <span class=\"number\">1</span>, plength - pi - <span class=\"number\">1</span>));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>624 ms</li>\r\n<li>16.4 MB</li>\r\n<li>Cpp 虽然已经AC了,时间空间上还是很笨拙的,日后找时间探索优化解法.\r\n-------------\r\n动态规划，以dp[i][j]为状态标志位，为1表示s的前i个字符和p的前j个字符可以匹配。\r\n注意dp[0][0]==1表示空字符串时可以匹配。 <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//两层for循环</span><br><span class=\"line\">for(i)</span><br><span class=\"line\">  for(j)</span><br></pre></td></tr></table></figure>\r\n通过判断当前字符匹配情况，加上前面的子串情况进行累积动态规划，最终达到dp[slength][plength]的值。</li>\r\n</ul>\r\n<h2\r\nid=\"理解了思路但实战这道题还是有细节方面思路不清继续挖坑\">理解了思路，但实战这道题还是有细节方面思路不清，继续挖坑。</h2>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-11","url":"/2020/02/17/LeetCode-No-11/","content":"<h1\r\nid=\"盛最多水的容器httpsleetcode-cn.comproblemscontainer-with-most-water\">(盛最多水的容器)[https://leetcode-cn.com/problems/container-with-most-water]</h1>\r\n<p>给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai)\r\n。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i,\r\n0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>\r\n<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>\r\n<p>图中垂直线代表输入数组\r\n[1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>\r\n<p> <img\r\nsrc=\"https://upload-images.jianshu.io/upload_images/19387483-4f82d6d77b0bc922.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"\r\nalt=\"image.png\" /></p>\r\n<p>示例:</p>\r\n<p>输入: [1,8,6,2,5,4,8,3,7] 输出: 49</p>\r\n<h1 id=\"解题分析\">解题分析</h1>\r\n<ul>\r\n<li>双循环暴力法是人类本能,就不侃了,直接放上辣眼睛的效率结果</li>\r\n</ul>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>通过情况</th>\r\n<th>时间</th>\r\n<th>内存</th>\r\n<th>语言</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>通过</td>\r\n<td>2436 ms</td>\r\n<td>9.8 MB</td>\r\n<td>Cpp</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<ul>\r\n<li><strong>正解</strong>: 双指针向内收缩法.即一指针在头部,一指针在尾部,\r\n而收缩时面积由两端之短决定,我们要找到更大的面积,则必定要改变两端之短,所以每次将短的那边往里收缩,遍历O(n).</li>\r\n<li><strong>正确性</strong>: S=min(ai,aj) *\r\n(j-i),假如大的那一边往里收缩则S=min(bi,bj) * (j-i-1).\r\n则min(bi,bj)要么是比收缩前最小值还小的值,要么是收缩前的最小值,所以S必定变小.\r\n因此双指针移动大的一端时,得到的S2&lt;=S1,肯定不是正确方向,所以可以省略掉这一系列的遍历,即只移动每对中小的那一端即可,省下O(n)的遍历不需要尝试,最终的遍历效率是O(n).</li>\r\n</ul>\r\n<h1 id=\"解题代码\">解题代码</h1>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int maxArea(vector&lt;int&amp; height) </span><br><span class=\"line\">    &#123;   //双指针 思考正确性</span><br><span class=\"line\">        int i=0;</span><br><span class=\"line\">        int j=height.size()-1;</span><br><span class=\"line\">        int Area;</span><br><span class=\"line\">        int MaxArea=0;</span><br><span class=\"line\">        </span><br><span class=\"line\">        while(i&lt;j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            int minvalue=min(height[i],height[j]);</span><br><span class=\"line\">            Area=minvalue*(j-i);</span><br><span class=\"line\">            if(AreaMaxArea)</span><br><span class=\"line\">                MaxArea=Area;</span><br><span class=\"line\">            </span><br><span class=\"line\">            if(height[i]==minvalue)</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            else</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        return MaxArea;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode No.136","url":"/2020/08/20/LeetCode-No-136/","content":"<h1 id=\"只出现一次的数字\"><a\r\nhref=\"https://leetcode-cn.com/problems/single-number\">只出现一次的数字</a></h1>\r\n<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>\r\n<p>说明：</p>\r\n<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>\r\n<p>示例 1:</p>\r\n<p>输入：[2,2,1] 输出：1</p>\r\n<p>示例 2:</p>\r\n<p>输入：[4,1,2,1,2] 输出：4</p>\r\n<h1 id=\"算法思想\">算法思想</h1>\r\n<p>老规矩找到问题给出的性质——目标元素只出现一次，剩余元素出现<strong>两次</strong>。</p>\r\n<p>不多不少，正好两次。显然这是一个主要的突破口。</p>\r\n<p>两次很容易让我们想到，假如非目标元素两两揍一顿互相抵消就好了。什么方式可以让相同的数抵消，不同的数保留呢？</p>\r\n<h3 id=\"数位的异或运算\">数位的异或运算</h3>\r\n<p>位的角度来看：1^1=0 0^0=0 1<sup>0=0</sup>1=1</p>\r\n<p>即相同的位会清空，不相同的位会保留。</p>\r\n<p>并且多位运算时：1<sup>1</sup>0=1<sup>(1</sup>0)=(1<sup>0)</sup>1=0</p>\r\n<p>易知位的异或运算具有结合律和交换律——即运算顺序不影响运算结果</p>\r\n<h3 id=\"数的异或\">数的异或</h3>\r\n<p>从数位异或中可以看出，偶数次的 1 或者 0 运算后都是\r\n0，在数的层面上也是一样，出现偶数次的数两两运算后也为 0。而 0\r\n和任何数异或等于数本身。</p>\r\n<p>因此对整个数组进行异或运算，相当于最后剩个 0\r\n和目标元素异或，结果就是目标值。</p>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//异或运算 相同的数异或归 0 且异或具有交换律</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> result=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> num :nums)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result^=num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-15-","url":"/2020/02/17/LeetCode-No-15-/","content":"<h1 id=\"三数之和\"><a\r\nhref=\"https://leetcode-cn.com/problems/3sum\">三数之和</a></h1>\r\n<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素\r\na，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>\r\n<p>注意：答案中不可以包含重复的三元组。</p>\r\n<p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>\r\n<p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2]]</p>\r\n<h1 id=\"思路分析\">思路分析</h1>\r\n<ul>\r\n<li><p>暴力O(n3) 这样做还不如不做kj</p></li>\r\n<li><p>联想<strong>两数之和</strong>那道题，可以采用map哈希来查找需要的值，但由于要先确定两个数之和，才能知道需要的值，所以有时间O(n2)+空间O(n)。</p></li>\r\n<li><p><strong>牺牲O(Nlog\r\nN)对数组sort，排序之后找数即可用双指针头尾同步进行</strong></p></li>\r\n<li><p>我的做法是，对于a&lt;=b&lt;=c，a+b+c=0，先确定b为<code>center</code>，然后对于center的每一次循环中，都让a,c分别从首尾开始，根据<code>sum=a+b+c</code>与0相比，判断是要a++还是c--。\r\n这里要注意人为考虑特殊情况，<strong>注意剪枝</strong>，否则像{0,0,0,0,0,0,0,0,0,0,0}会没意义的算很多遍。另外在每个center的内循环中，显然假如<strong>最小值大于0</strong>，或者<strong>最大值小于0</strong>，是不可能和为0，可以剪枝。</p></li>\r\n<li><p>另外，当数组中有重复数字时，会重复进行循环匹配，因此我额外使用了一个<code>set</code>。</p></li>\r\n<li><p><code>if(sum==0)</code>之后，额外加一个<code>if(set.count(vector)==0)</code>来判断是否已经有了相同的组合被存储了，如果没有，则<code>set</code>和<code>result</code>同时存储这个新组合，set中存储是为了对之后判重。</p></li>\r\n</ul>\r\n<h1 id=\"解题代码\">解题代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"keyword\">int</span> threeSum(vector&lt;<span class=\"keyword\">int</span>&amp; nums) </span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span> result;</span><br><span class=\"line\">        set&lt;vector&lt;<span class=\"keyword\">int</span> resultset;</span><br><span class=\"line\">        //剪枝</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.size() &lt;= 2)</span><br><span class=\"line\">   <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        </span><br><span class=\"line\">  sort(nums.begin(), nums.end());</span><br><span class=\"line\">        </span><br><span class=\"line\">        //不剪枝会被0吓死=.=</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nums[0]=0 ||nums[nums.size()-1]&lt;=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (nums[0] == 0 &amp;&amp;nums[nums.size()-1]==0)</span><br><span class=\"line\">    result.push_back(&#123; 0,0,0 &#125;);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> center;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(center=0;center&lt;nums.size();center++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            i=0;</span><br><span class=\"line\">            j=nums.size()-1;</span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i!=center &amp;&amp;j!=center)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[i]0 || nums[j]&lt;0)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">int</span> sum=nums[i]+nums[center]+nums[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(sum==0)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    vector&lt;<span class=\"keyword\">int</span> temp =&#123;nums[i],nums[center],nums[j]&#125;;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(resultset.count(temp)==0)</span><br><span class=\"line\">                    &#123;   </span><br><span class=\"line\">                        result.push_back(temp);</span><br><span class=\"line\">                        resultset.insert(temp);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                    j--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum&lt;0)</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum0)</span><br><span class=\"line\">                    j--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<table style=\"width:10%;\">\r\n<colgroup>\r\n<col style=\"width: 9%\" />\r\n</colgroup>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>执行用时 : 424 ms, 在所有 C++ 提交中击败了5.01%的用户 内存消耗 :24.3\r\nMB, 在所有 C++ 提交中击败了7.53%的用户</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>虽然好像剪枝也做了，但好像效率依然不够高，不知道是不是额外加了个set的问题\r\n看别人的题解，<strong>不以b以a为外循环可以避免重复</strong>，也就不需要set，但没懂是为什么。\r\n挖个坑，搞懂了再回来看看。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-16","url":"/2020/02/17/LeetCode-No-16/","content":"<h1 id=\"最接近的三数之和\"><a\r\nhref=\"https://leetcode-cn.com/problems/3sum-closest\">最接近的三数之和</a></h1>\r\n<p>给定一个包括 n 个整数的数组 nums 和\r\n一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>\r\n<p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</p>\r\n<p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p>\r\n<h1 id=\"解题思路\">解题思路</h1>\r\n<ul>\r\n<li>一开始我想分解问题，确定一个数，找最接近的两个数，其中找两个数的过程也是通过确定一个数，找最接近的最后一个数。解题不难，但复杂度很高。</li>\r\n<li>又是一个逼近问题，做了几道现在应该领悟到了<strong>双指针逼近</strong>的方法是一个很好的寻找逼近值的策略。</li>\r\n</ul>\r\n<h3 id=\"算法主体\">算法主体</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">while(i&lt;j)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if(sum&lt;target)</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">  else if(sumtarget)</span><br><span class=\"line\">    j--;</span><br><span class=\"line\">  else if(sum==target)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>算法简单，但实现细节需要考虑，并不是出口附近的sum就一定是最接近的sum。</li>\r\n</ul>\r\n<p>假如简单的取上面这个粗糙的循环，对于实例([-101,-100,0,2,3,4,5,6,7,8,9,10],-99)。当i从-100移到0之后，j一直减到i期间的sum都没有i=-100处的sum良好，但却会作为出口给人最优的错觉。</p>\r\n<p>错误经验：最优解也并不是取最后一次i变动的sum和最后一次j变动的sum，因为可能变i变j再变i反复变化，然而最优解其实一直停留在第一个变i之前。</p>\r\n<ul>\r\n<li>我自己的解决办法是把所有的sum都存储起来，最后统一遍历找出最优解，但显然这样需要花一点点时间。</li>\r\n</ul>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">threeSumClosest</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&amp; nums, <span class=\"keyword\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> result;</span><br><span class=\"line\">  <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">  vector&lt;<span class=\"keyword\">int</span> sums;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> sum;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> resultdistance = INT_MAX;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (a = 0; a &lt; nums.size() - 2; a++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   b = a + 1;</span><br><span class=\"line\">   c = nums.size() - 1;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">while</span> (b &lt; c)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">    sum = nums[a] + nums[b] + nums[c];</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    sums.push_back(sum);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sum &lt; target)</span><br><span class=\"line\">     b++;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum  target)</span><br><span class=\"line\">     c--;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=0;i&lt;sums.size();i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(abs(target - sums[i]) &lt; resultdistance)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     result = sums[i];</span><br><span class=\"line\">     resultdistance = abs(target - result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<hr />\r\n<p>不存储所有结果，直接在每个sum之后与result比较，效率比存储的高了4ms。</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>提交结果</th>\r\n<th>执行用时</th>\r\n<th>内存消耗</th>\r\n<th>语言</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>2019.9.15</td>\r\n<td>通过</td>\r\n<td>12 ms</td>\r\n<td>8.7 MB</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>2019.9.11</td>\r\n<td>通过</td>\r\n<td>16 ms</td>\r\n<td>12.9 MB</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>8ms可能是做不到了，量级上应该一样。</p>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-22","url":"/2020/02/17/LeetCode-No-22/","content":"<h1 id=\"括号生成\"><a\r\nhref=\"https://leetcode-cn.com/problems/generate-parentheses\">括号生成</a></h1>\r\n<p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>\r\n<p>例如，给出 n = 3，生成结果为：</p>\r\n<p>[ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]</p>\r\n<h1 id=\"题解分析\">题解分析</h1>\r\n<ul>\r\n<li><p>一开始我想创建一个2n的string数组\r\n因为string（包括子串）第一个空位一定会是' ( ' 因此我的算法思路是\r\n第一位肯定是' ( ' 不变，然后在剩下的length-1空位中遍历选一处插入')'\r\n然后递归进入子串插入，也是子串第一位 '( ' 不变，遍历剩下的空位一次次插入\r\n')' ，直到递归完成括号串。\r\n这种算法不能避免重复，而且我在创建动态长度的字符串这里就失败了=。=\r\n但没看到相似的思路，因此写下来说不定以后能够优化一下。</p></li>\r\n<li><h3 id=\"标准思路\">标准思路</h3></li>\r\n</ul>\r\n<p>递归对每一位进行检测，如果' ( '数量少，则这一位插入' (\r\n'进入递归，否则插入' ）'进行递归，直到填满。</p>\r\n<p>因为这种方法会遍历完所有'（'可能的位置，进而能够确定括号串，因此不会重复也不会遗漏。</p>\r\n<ul>\r\n<li><h3 id=\"递归法代码\">递归法代码</h3></li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;string generateParenthesis(<span class=\"keyword\">int</span> n)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vector&lt;string result;</span><br><span class=\"line\">       </span><br><span class=\"line\">        Recursion(n,&quot;&quot;,0,0,result);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">void</span>  Recursion(<span class=\"keyword\">int</span> n,string temp,<span class=\"keyword\">int</span> left ,<span class=\"keyword\">int</span> right,vector&lt;string&amp; result)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(temp.size()== 2*n)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result.push_back(temp);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left&lt;n)</span><br><span class=\"line\">            Recursion(n,temp+&#x27;(&#x27;,left+1,right,result);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(right&lt;left)</span><br><span class=\"line\">            Recursion(n,temp+&#x27;)&#x27;,left,right+1,result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>提交时间</th>\r\n<th>提交结果</th>\r\n<th>执行用时</th>\r\n<th>内存消耗</th>\r\n<th>语言</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>2 天前</td>\r\n<td>通过</td>\r\n<td>20 ms</td>\r\n<td>17 MB</td>\r\n<td>Cpp</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<ul>\r\n<li><h3 id=\"动态规划\">动态规划</h3></li>\r\n</ul>\r\n<p>因为递归法效率还没有极致，因此看了看题解大神的解法，发现了一位用动态规划的人才。\r\n给上链接 ：</p>\r\n<h3 id=\"闭合数的合理解释-jerry-peng\"><a\r\nhref=\"%5Bhttps://leetcode-cn.com/problems/generate-parentheses/solution/bi-he-shu-de-he-li-jie-shi-by-jerry-peng/%5D(https://leetcode-cn.com/problems/generate-parentheses/solution/bi-he-shu-de-he-li-jie-shi-by-jerry-peng/)\">闭合数的合理解释-Jerry\r\nPeng</a></h3>\r\n<ul>\r\n<li><p>算法分析 对于每个n对括号的括号串S[n] 都可以划分为两个部分\r\n<code>S[n] = '(' + S[c] + ')' + S[n-c-1];</code>\r\n第一对括号里面带着c长度的子问题， 右边剩下部分n-c-1长度的子问题\r\n<strong>自底向上，存储子问题结果，逐步合并到n长度的问题</strong>。\r\n因为要找到所有可能结果，因此c的取值需要遍历所有可能。</p></li>\r\n<li><h3 id=\"动态规划代码\">动态规划代码</h3></li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;string generateParenthesis(<span class=\"keyword\">int</span> n)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       map&lt;<span class=\"keyword\">int</span>,vector&lt;string resultmap;</span><br><span class=\"line\">        resultmap[0].push_back(&quot;&quot;);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=1;i&lt;=n;i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=0;j&lt;i;j++)</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(string left: resultmap[j])</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(string right: resultmap[i-j-1])</span><br><span class=\"line\">                    resultmap[i].push_back(&quot;(&quot;+left+&quot;)&quot;+right);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> resultmap[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>提交时间</th>\r\n<th>提交结果</th>\r\n<th>执行用时</th>\r\n<th>内存消耗</th>\r\n<th>语言</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>2 天前</td>\r\n<td>通过</td>\r\n<td>12 ms</td>\r\n<td>9.6 MB</td>\r\n<td>Cpp</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<hr />\r\n<p><strong>有想过为什么不直接分为left 和 right\r\n两个部分，一定要套个括号</strong> 　——假如只分两半left 和\r\nright，那在求解S[n]遍历的时候肯定要遍历到S[n]自身，因此需要先固定好一对括号，这样遍历会停止在S[n-1]的子问题，然后合并出待解的S[n]问题。</p>\r\n","categories":["LeetCode"]},{"title":"LeetCode No.221","url":"/2020/07/31/LeetCode-No-221/","content":"<h1 id=\"最大正方形\"><a\r\nhref=\"https://leetcode-cn.com/problems/maximal-square\">最大正方形</a></h1>\r\n<p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1\r\n的最大正方形，并返回其面积。</p>\r\n<p>示例:</p>\r\n<p>输入:</p>\r\n<p>1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0</p>\r\n<p>输出: 4</p>\r\n<h1 id=\"算法思想\">算法思想</h1>\r\n<p>大正方形必然是由小正方形迭代上来的。因此这题是个明显的动态规划题，但是我们怎么去确定状态转移方程呢？</p>\r\n<h3 id=\"状态转移方程的理解\">状态转移方程的理解</h3>\r\n<p>首先我们确定，正方形是从左上往右下进行延展(其他延展方向也行)。</p>\r\n<h5\r\nid=\"我们什么时候可以延展这个正方形呢\">我们什么时候可以延展这个正方形呢？</h5>\r\n<p>首先新找到的点肯定得是\r\n<code>1</code>，要不然不可能构成正方形。以matrix[i][j]位为1，我们可以得到示例如下：\r\na a a x a a a x a a a x x x x 1</p>\r\n<p>因为是正方形，所以假如 [i][j]位要构成新的正方形，那必然是从左上角的 a\r\n区域延展下来的。</p>\r\n<p>但是即使 a\r\n区域是正方形，[i][j]位是1，就一定形成新正方形吗？并没有</p>\r\n<p>当我们把正方形延展到[i][j]位时，其实[i]行和[j]列对应边也都扩展进去了，也就是上例的\r\nx 区域，也要是1才能延展构成新正方形。</p>\r\n<h5\r\nid=\"即我们现在知道延展正方形受限于哪些环境\">即我们现在知道延展正方形受限于哪些环境：</h5>\r\n<ul>\r\n<li><p>左上角的 a 区域的正方形有多大，新正方形则是边长++</p></li>\r\n<li><p>x 区域，从[i][j]分别往左和往上走，能提供的最大边长。</p>\r\n<p>如下，虽然 a\r\n区域是边长3的正方形，本来想要以[i][j]为新顶点扩展成边长4的正方形，但是由于新的两条边长度只有1，满足不了边长4的正方形的要求。</p>\r\n<p>因此[i][j]只能构成边长2的正方形。</p></li>\r\n</ul>\r\n<p>受限于 x 区域新边长的延展 1 1 1 0 1 1 1 0 1 1 1 1 0 0 1 1</p>\r\n<h5 id=\"得出状态转移方程\">得出状态转移方程</h5>\r\n<p>因此总结一下状态转移方程：</p>\r\n<p><code>[i][j]位的正方形边长=min( [i-1][j-1]的正方形边长，新的两边边长 ) + 1</code></p>\r\n<p>伪代码即\r\n<code>dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1</code></p>\r\n<p>其中dp[i][j]表示[i][j]位作为左下角时，形成正方形的边长。</p>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maximalSquare</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">char</span>&amp; matrix)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//动态规划，如何理解dp的递归式</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> width=matrix.<span class=\"built_in\">size</span>();<span class=\"keyword\">if</span>(width==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length=matrix[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();<span class=\"keyword\">if</span>(length==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span> dp(width+1,vector(length+1,0));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result=0;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=0;i&lt;width;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=0;j&lt;length;j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(matrix[i][j]==&#x27;1&#x27;)</span><br><span class=\"line\">                    dp[i+1][j+1]=min(min(dp[i][j],dp[i][j+1]),dp[i+1][j])+1;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    dp[i+1][j+1]=0;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(dp[i+1][j+1]result)</span><br><span class=\"line\">                    result=dp[i+1][j+1];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result*result;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"],"tags":["动态规划"]},{"title":"LeetCode-No-23","url":"/2020/02/17/LeetCode-No-23/","content":"<h1 id=\"合并k个链表\"><a\r\nhref=\"https://leetcode-cn.com/problems/merge-k-sorted-lists\">合并K个链表</a></h1>\r\n<p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>\r\n<p>示例:</p>\r\n<p>输入: [ 　1-4-5,   　1-3-4,   　2-6] 输出: 1-1-2-3-4-4-5-6</p>\r\n<h1 id=\"解题分析\">解题分析</h1>\r\n<ul>\r\n<li><p>因为之前做过2个排序链表的合并，所以这里主要想法是两两归并。\r\n两个链表合并：双指针判断对应节点大小，依次插入新链表，若一个链表用尽，则在result链表后接上另一个链表即可。</p></li>\r\n<li><p>归并其实也有讲究，我一开始直接用的是顺序归并<code>result=mergeTwoLists(result,temp)</code>，其实浪费了很多效率，把不必要的排序比较一遍又一遍的做。</p></li>\r\n<li><p>如下方题解代码，使用了折半归并（直观描述词）。每次合并<code>List i =mergeTwoLists(List i,List i+halflength)</code>.\r\n直到长度为1即完成。</p></li>\r\n</ul>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * struct ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode *next;</span><br><span class=\"line\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class=\"line\"> * &#125;;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    ListNode* mergeKLists(vector&lt;ListNode*&amp; lists) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ListNode* result=NULL;</span><br><span class=\"line\">        int length=lists.size();</span><br><span class=\"line\">        if(length==0)</span><br><span class=\"line\">            return NULL;</span><br><span class=\"line\">        while(length1)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            int temp=(length+1)/2;</span><br><span class=\"line\">            for(int i=0;i&lt;length/2;i++)</span><br><span class=\"line\">                lists[i]=mergeTwoLists(lists[i],lists[i+temp]);</span><br><span class=\"line\">            </span><br><span class=\"line\">            length=temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        return lists[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    ListNode result(0);</span><br><span class=\"line\">    ListNode* another = &amp;result;</span><br><span class=\"line\"></span><br><span class=\"line\">    while (l1 != NULL &amp;&amp; l2 != NULL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">     if (l1-val &lt;= l2-val)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">      another-next = l1;</span><br><span class=\"line\">      l1 = l1-next;  </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     else</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">      another-next = l2;</span><br><span class=\"line\">      l2 = l2-next;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">              </span><br><span class=\"line\">              another = another-next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">                   </span><br><span class=\"line\">          another-next=(l1==NULL)?l2:l1;</span><br><span class=\"line\">    return (&amp;result)-next;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode No.264","url":"/2021/03/03/LeetCode-No-264/","content":"<h1 id=\"丑数ii\"><a\r\nhref=\"https://leetcode-cn.com/problems/ugly-number-ii\">丑数II</a></h1>\r\n<p>编写一个程序，找出第 n 个丑数。</p>\r\n<p>丑数就是质因数只包含 2, 3, 5 的正整数。</p>\r\n<p>示例:</p>\r\n<p>输入: n = 10 输出: 12 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10\r\n个丑数。</p>\r\n<p>说明:  </p>\r\n<p>1 是丑数。 n 不超过1690。</p>\r\n<h1 id=\"算法思想\">算法思想</h1>\r\n<p>显而易见，我们要找分解式为 2 3 5\r\n构成的数。也容易想到，<strong>后面的丑数必然是由前面的丑数乘 2 3 5\r\n得到的</strong>。</p>\r\n<p>但是从前往后顺序计算乘积，并且顺序存放的话，例如<code>2*5  3*3</code>。可以看出先后顺序错位了，10先存放，而9后存放。</p>\r\n<p>因此要取计算的所有乘积的最小值,\r\n这个最小值必然是从小到大的下一个ugly，解决了存放的错位问题。</p>\r\n<h3 id=\"但是对哪些乘积取最小值呢\">但是对哪些乘积取最小值呢？</h3>\r\n<p>前面的数都计算一遍乘积的话计算量太大</p>\r\n<p>想一下，假如有 2*3， 那么对所有x2,x*3必然没有2*3小，因此对 3\r\n这个因子，只需要计算它和2的乘积即可。后面的肯定不是我们要找的最小乘积。</p>\r\n<p>因此，其实只要<strong>为每个因子找到当前最小的乘数即可</strong>。</p>\r\n<h3\r\nid=\"怎么确定每个因子的当前最小乘数呢\">怎么确定每个因子的当前最小乘数呢？</h3>\r\n<p>要找当前最小的，首先要确定这个因子的候选乘数有哪些，然后在里面找最小的。</p>\r\n<h4 id=\"哪些是候选乘数\">哪些是候选乘数？</h4>\r\n<p>我们找当前最小乘数是为了找出下一个最小的丑数。假如要生成所有丑数的话，每个因子都必然要遍历去乘每一个数。</p>\r\n<p>换句话说，对这个因子，所有数都是要乘的，跑不了的，即所有没乘过的数，都是它的候选乘数。</p>\r\n<h4 id=\"最小的候选乘数\">最小的候选乘数</h4>\r\n<p>既然所有数都要乘，而我们的数又是从小到大排列的，那么从前往后，第一个没有乘过的就是当前最小乘数。</p>\r\n<p>代码角度来看，即当前乘数为nums[i]，每乘一次，即i++,准备乘下一个数即可。</p>\r\n<h1 id=\"解题代码\">解题代码</h1>\r\n<p>注意我们有三个因子，因此需要用三个指针对三个因子维护他们的最小乘数。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">nthUglyNumber</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//动态规划，后面的数必然是前面的数乘 2 3 5得到</span></span><br><span class=\"line\">        <span class=\"comment\">//但是顺序进行的话 2*5  3*3 ，可以看出大小顺序不能保证，因此要取几个乘积的最小值,这个最小值必然是从小到大的下一个ugly</span></span><br><span class=\"line\">        <span class=\"comment\">//但是对哪些乘积取最小值呢？前面的数都计算一遍的话计算量太大。</span></span><br><span class=\"line\">        <span class=\"comment\">//想一下，假如有 2*3， 那么对所有x2,x*3必然没有2*3小，因此对 3 这个乘积，其实只要找到最小的乘数即可，其他乘积也是一样</span></span><br><span class=\"line\">        <span class=\"comment\">//怎么确定每个乘积的最小乘数呢？显然每个乘积都要乘每个数，那么从前往后找没乘过的 就是当前最小乘数</span></span><br><span class=\"line\"></span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span> nums(n,0);</span><br><span class=\"line\">        nums[0]=1;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p2=0,p3=0,p5=0;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=1;i&lt;n;i++)//除1外 生成n-1个丑数</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ugly_i=min(min(nums[p2]*2,nums[p3]*3),nums[p5]*5);//取当前乘积最小值</span><br><span class=\"line\">            nums[i]=ugly_i;</span><br><span class=\"line\">            //判断用的是哪个乘积，它的最小乘数要变了，注意重复的也算</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ugly_i==nums[p2]*2) p2++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ugly_i==nums[p3]*3) p3++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ugly_i==nums[p5]*5) p5++;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[n-1];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"],"tags":["动态规划"]},{"title":"LeetCode-No-28-(KMP)","url":"/2020/02/17/LeetCode-No-28-(KMP)/","content":"<h1 id=\"实现-strstr-函数\"><a\r\nhref=\"https://leetcode-cn.com/problems/implement-strstr\">实现 strStr() 函数</a></h1>\r\n<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack\r\n字符串中找出 needle 字符串出现的第一个位置\r\n(从0开始)。如果不存在，则返回  -1。</p>\r\n<p>示例 1:</p>\r\n<p>输入: haystack = \"hello\", needle = \"ll\" 输出: 2</p>\r\n<p>示例 2:</p>\r\n<p>输入: haystack = \"aaaaa\", needle = \"bba\" 输出: -1</p>\r\n<p>说明:\r\n当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\r\n对于本题而言，当 needle 是空字符串时我们应当返回 0\r\n。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>\r\n<blockquote>\r\n<p>显然这题主要目标是在主串中找到一个模式串，而我在数据结构课中有学到<strong>KMP</strong>算法，因此我首选题解就是<strong>实现KMP</strong>。</p>\r\n</blockquote>\r\n<h2 id=\"kmp-主要思想不回退的主串查找位有效利用失败信息\">KMP\r\n（主要思想：<strong>不回退的主串查找位，有效利用失败信息</strong>）</h2>\r\n<h3 id=\"暴力法存在的问题\">暴力法存在的问题</h3>\r\n<p>主串abcdabcdabce，模式串abcdabce. 标志位 i，j</p>\r\n<p>我们可以知道第一次匹配会在abcdabc<code>d</code>abce，abcdabc<code>e</code>处失败\r\n在暴力法中，失败后 i ++，j=0，从i=1，j=0 处再次开始一轮匹配。\r\n即主串明明匹配到了第8位，失败后却还要回退到第二位开始新的匹配，无疑浪费了很多时间。</p>\r\n<h3 id=\"失败返回的有效信息\">失败返回的有效信息</h3>\r\n<p>模式串在 e 处失败，可以带给我们什么有效信息：</p>\r\n<ol type=\"1\">\r\n<li>主串前面有<code>abcdabc</code></li>\r\n<li>主串这一位不为<code>e</code></li>\r\n</ol>\r\n<h3 id=\"利用返回的有效信息\">利用返回的有效信息</h3>\r\n<p>已经已知主串有了这七个字符，按人的思维去分析的话，可以知道主串前四位<code>abcd</code>都没必要去做新的匹配模式串的循环了，因为一定会失败，而5\r\n~ 7位<code>abc</code>虽然是在匹配模式串的5 ~\r\n7位匹配出来的，但是却也可以匹配模式串的前三位。因为这些都是已知信息，所以我们可以直接当失败处abcd<code>abc</code>d已经匹配了模式串的<code>abc</code>，只需要拿<code>d</code>去匹配<code>d</code>即可。</p>\r\n<p>相当于不仅没回退，还可以在当前位置上直接跳过模式串前三位进行后续匹配。</p>\r\n<p>而把上面的思路写成逻辑，我们就需要分析其产生的原因条件，以及导出的结果</p>\r\n<p><strong>为什么恰巧可以跳过呢</strong>？让我们来看一下跳过时的环境条件</p>\r\n<ol type=\"1\">\r\n<li>失败前的倒数几位，刚好可以拿去匹配正数前几位，因此相当于匹配好了前几位</li>\r\n<li>这种在某一位失败之后能否产生跳跃的信息，只和模式串本身有关，和主串无关，因为我们是用失败的倒数几位去匹配前几位，全是模式串自己。</li>\r\n</ol>\r\n<p>因此我们可以找到跳过的思路，对于匹配失败时：</p>\r\n<ol type=\"1\">\r\n<li>假如模式串在这个字符之前的倒数几位能和整数几位匹配，那就直接略过，i\r\n不变，j 跳到整数几位的后一位接着匹配</li>\r\n<li>假如不能形成这种前后缀的匹配，则直接让 i\r\n++，在下一位开始全新的匹配</li>\r\n</ol>\r\n<blockquote>\r\n<p>i 不用回到这次匹配的开头再i++，假如回到开头再 i++\r\n，我们的目标是当前匹配失败了，主串字符串匹配区间右移一位是不是能匹配成功。然而这种匹配成功的条件必须是<strong>区间右移后，和移动前的重叠区域字符相同。即在重叠区域内，pat[i+1]==pat[i]</strong>。用人话翻译就是，只有str=aaaaax\r\npat=aaaax这种前部分字符只有一个的情况才有移动区间匹配成功的可能。然而我们可以从实例中看到，这种字符串情况也包含在跳过的思路中，也恰好满足跳过的条件，甚至不用回移不用使j=0开始匹配，只需要接着从跳到的\r\nj 处匹配就解决了这个情况。</p>\r\n</blockquote>\r\n<h3 id=\"创造跳跃数组\">创造跳跃数组</h3>\r\n<p>我们知道，KMP主要算法就是在失败时，通过跳跃到恰当的位置接着匹配。\r\n而这个恰当的位置 k\r\n满足：k之前的所有k位，即前缀，和失败处的倒数k位，即后缀，恰好相同，此时失败即可跳到k处。</p>\r\n<p><strong>所以我们要解决的就是，在开始查找模式串之前，先对模式串每一位\r\nj 进行前后缀检测，存在满足的前后缀即可令 jump[j]=k\r\n存储在该处失败可跳跃到的位置。不存在则存入 -1 作为标志即可</strong></p>\r\n<p>因为跳跃位置只与模式串本身有关，因此事先处理好一次即可对任何主串复用。</p>\r\n<p>当然检测前后缀也不是一个简单的事，KMP中构造跳跃数组的过程中也是用了KMP自己.......作为学习者只能对创造者表示敬佩，这里用伪代码描述一下。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">因为在<span class=\"number\">0</span>位失败肯定没法跳跃，令jump[<span class=\"number\">0</span>]=<span class=\"number\">-1</span> </span><br><span class=\"line\">设置好跳跃定位标志 k=<span class=\"number\">-1</span></span><br><span class=\"line\">对模式串每一位 i</span><br><span class=\"line\">    假如 i  k 位相同，或者k==<span class=\"number\">-1</span></span><br><span class=\"line\">      即看作前后缀目前为止相同</span><br><span class=\"line\">      i, k 到下一位</span><br><span class=\"line\">      对于已经处理好前后缀之后的下一位，只需把跳跃信息给它即可</span><br><span class=\"line\">          假如下一位与跳跃位不同</span><br><span class=\"line\">              把已经处理好的k作为它的跳跃位即可，jump[i]=k</span><br><span class=\"line\">          假如下一位与跳跃位相同</span><br><span class=\"line\">              （比如在a失败，跳到的地方还是a，那就没有再比一次的必要了）</span><br><span class=\"line\">              把跳跃位的跳跃位作为它的跳跃位hhh jump[i]=jump[k]</span><br><span class=\"line\">   假如 i k 位不同 （他们的跳跃信息已经被处理好了）</span><br><span class=\"line\">      （内用KMP，即相当于后缀作为主串，前缀作为模式串，此时匹配失败了，前缀跳到跳跃位接着匹配）</span><br><span class=\"line\">      k=jump[k]</span><br><span class=\"line\">      </span><br></pre></td></tr></table></figure>\r\n<p>处理好跳跃数组（失效数组）之后，即可按数组的跳跃信息进行利用匹配.匹配过程看下方代码即可，并不难:</p>\r\n<h1 id=\"kmp解题代码\">KMP解题代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(string haystack, string needle)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;   </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(needle==<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//KMP</span></span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">int</span> jump[needle.<span class=\"built_in\">size</span>()];</span><br><span class=\"line\">        jump[<span class=\"number\">0</span>]=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> k=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//创建失效数组  abcabcd</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;needle.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(k==<span class=\"number\">-1</span> || needle[i]==needle[k])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                k++;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(needle[i]!=needle[k])</span><br><span class=\"line\">                    jump[i]=k;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    jump[i]=jump[k];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>    <span class=\"comment\">//内置kmp</span></span><br><span class=\"line\">                k=jump[k];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> x=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(x&lt;haystack.<span class=\"built_in\">size</span>() &amp;&amp; y&lt;<span class=\"built_in\"><span class=\"keyword\">int</span></span>(needle.<span class=\"built_in\">size</span>())) <span class=\"comment\">//注意这里int化！！！！！！看bug看了好久，size返回值是unsignedint</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(y==<span class=\"number\">-1</span> ||haystack[x]==needle[y])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                x++;</span><br><span class=\"line\">                y++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">               y=jump[y];</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(y==needle.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x-y;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-3","url":"/2020/02/17/LeetCode-No-3/","content":"<h1 id=\"无重复字符的最长子串\"><a\r\nhref=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters\">无重复字符的最长子串</a></h1>\r\n<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\r\n示例 1: 输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是\r\n\"abc\"，所以其长度为 3。</p>\r\n<p>示例 2: 输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是\r\n\"b\"，所以其长度为 1。</p>\r\n<p>示例 3: 输入: \"pwwkew\" 输出: 3 解释:\r\n因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\r\n请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。</p>\r\n<h2 id=\"解题思路\">解题思路</h2>\r\n<p>　这题也是思路比较直接的一题,分析以下几点需求:</p>\r\n<ol type=\"1\">\r\n<li><p>判断重复字符\r\n用int构造一个<strong><em>hash表</em></strong>进行判断即可,注意字符总数,数组空间可以开大一点\r\n(数组初始化的时候没有想到更好的优化效率方案).</p></li>\r\n<li><p>子串检测\r\n数据结构课上有学过kmp算法,因此容易联想到这里为了最佳效率,也应采用<strong><em>窗口移动</em></strong>的算法.</p></li>\r\n<li><p>后事处理\r\n移动窗口之后,由于窗口之外的字符的位置信息还保留在表内,因此需要进行处理\r\n直接思路是使用一个滞后的位置符<code>behind</code>进行遍历清除即可\r\n优化思路:\r\n可以通过判断滞留的位置是否处于现有检测窗口之前,如果是则无视,不需要遍历处理,<strong>空间换时间</strong></p></li>\r\n</ol>\r\n<h2 id=\"最终代码\">最终代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(string s)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;   </span><br><span class=\"line\">        <span class=\"keyword\">int</span> flag[<span class=\"number\">127</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">127</span>;i++)</span><br><span class=\"line\">            flag[i]=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result=<span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> max=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> start=<span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;s.<span class=\"built_in\">length</span>();i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            temp=<span class=\"built_in\">getNO</span>(s[i]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag[temp]&lt;start)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result++;</span><br><span class=\"line\">                flag[temp]=i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(result=max)</span><br><span class=\"line\">                    max=result;</span><br><span class=\"line\">                </span><br><span class=\"line\">                start=flag[temp]+<span class=\"number\">1</span>;</span><br><span class=\"line\">                result=i-flag[temp];</span><br><span class=\"line\">                flag[temp]=i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(result=max)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getNO</span><span class=\"params\">(<span class=\"keyword\">char</span> originchar)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> originchar-<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-31","url":"/2020/02/17/LeetCode-No-31/","content":"<h1 id=\"下一个排列\"><a\r\nhref=\"https://leetcode-cn.com/problems/next-permutation\">下一个排列</a></h1>\r\n<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>\r\n<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\r\n必须原地修改，只允许使用额外常数空间。</p>\r\n<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。 1,2,3 → 1,3,2\r\n3,2,1 → 1,2,3 1,1,5 → 1,5,1</p>\r\n<h1 id=\"思路分析\">思路分析</h1>\r\n<h3 id=\"是否存在更大的排列\">①是否存在更大的排列</h3>\r\n<h5 id=\"更大的排列\">更大的排列</h5>\r\n<p>考虑最大的字典序排列: 降序排列 <strong>[1,2,3]</strong> →\r\n<strong>[3,2,1]</strong> 对于 <strong>[3,2,1]</strong>\r\n序列,已经是最大字典序了</p>\r\n<p>假如序列存在一个更大的排列,那它必然不是降序排列\r\n因此判断是否存在下一个排列的条件就是\r\n<strong>顺序遍历数组,判断是否完全降序</strong></p>\r\n<h3 id=\"找到下一个排列\">②找到下一个排列</h3>\r\n<p>首先对于<strong>[1,2,3,4,5,6]</strong>,假如我们要人工找到下一个排列,我们知道要把倒数两位调换一下<strong>[1,2,3,4,6,5]</strong>,这样值的变动最小,字典序大小变动也最小.</p>\r\n<h5\r\nid=\"为什么最后两位调换之后字典序会变大呢\">为什么最后两位调换之后字典序会变大呢?</h5>\r\n<p>我们可以发现一个本质: <strong>它们是升序的,\r\n升序排列那么必然就存在可以调换成降序的操作空间</strong>,因此可以改动升序关系的任意两位来获取一个更大的字典序\r\n如 <strong>[1,2,5,4,3,6]</strong></p>\r\n<h5\r\nid=\"知道了获得更大序的方法接下来我们要确定什么操作能得到最小的更大序下一个更大的序列\">知道了获得更大序的方法,接下来我们要确定什么操作能得到最小的更大序(下一个更大的序列)</h5>\r\n<p>其实字典序类似于数的大小关系. 比如<strong>[1,2,3]</strong> →\r\n<strong>[2,1,3][1.3.2]</strong></p>\r\n<p>所以为了找到最小的更大序列,我们操作的<strong>升序数对</strong>要尽可能的小.所以目标就变成了:</p>\r\n<h5 id=\"找到最靠后的一对升序数对\">找到最靠后的一对升序数对</h5>\r\n<p><strong>[9,8,3,6,5,4]</strong>→<strong>[9,8,4,3,5,6]</strong>\r\n最靠后的/最小的 升序数对是\r\n[3,4],初步调换后是<strong>[9,8,4,6,5,3]</strong>\r\n显然这个结果还不太对.</p>\r\n<p>找到了最小的升序数对只是保证了在一步操作的范围内,我们增加的值是最小的.\r\n换句话说,其实再多加几步操作才能保证是下一个序列. 来看看我们还差些什么\r\n<strong>[9,8,4,6,5,3]</strong> →<strong>[9,8,4,3,5,6]</strong> ,\r\n4的后面原本是降序,被整理成了升序</p>\r\n<p>首先在我们的算法里,我们从后往前找一个升序的\"峰值\"\r\n换句话说,我们在找到\"\"峰值\"\"之前,也即从末尾到\"峰值\"\",必然是降序的,也就是局部最大的序列.\r\n因此我们调换了一对最小的升序对,整个序列在\"\"峰值\"\"之前已经是最小的了,\r\n但在调换位置之后的局部仍然是降序,即现在的序是<strong>前半段最小+后半段最大</strong>,\r\n因此<strong>将\"\"峰值\"\"往后调整成升序,即后半段最小</strong>即可构成\"最小+最小\"的下一个排列.</p>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">nextPermutation</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&amp; nums)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.<span class=\"built_in\">size</span>()&lt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextid=nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> currentid=nextid<span class=\"number\">-1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(currentid=<span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[nextid]nums[currentid])</span><br><span class=\"line\">            &#123;   </span><br><span class=\"line\">                <span class=\"comment\">//从后往前，找到第一组 升序对</span></span><br><span class=\"line\">               flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            nextid--;</span><br><span class=\"line\">            currentid--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag==<span class=\"number\">1</span>)<span class=\"comment\">//存在下一个更大排列</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                <span class=\"comment\">//交换生成新排列</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(nextid+<span class=\"number\">1</span>&lt;nums.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[nextid+<span class=\"number\">1</span>]nums[currentid] )</span><br><span class=\"line\">                    nextid++;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">tempswap</span>(nums[currentid],nums[nextid]);</span><br><span class=\"line\">            <span class=\"comment\">//currentid右边必然是降序</span></span><br><span class=\"line\">            <span class=\"comment\">//将currentid右边升序处理</span></span><br><span class=\"line\">            nextid=nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(currentid+<span class=\"number\">1</span>&lt;nextid)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">tempswap</span>(nums[nextid],nums[currentid+<span class=\"number\">1</span>]);</span><br><span class=\"line\">                nextid--;</span><br><span class=\"line\">                currentid++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;   <span class=\"comment\">//不存在，则倒序</span></span><br><span class=\"line\">            nextid=nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">            currentid=<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(currentid&lt;nextid)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">tempswap</span>(nums[nextid],nums[currentid]);</span><br><span class=\"line\">                nextid--;</span><br><span class=\"line\">                currentid++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tempswap</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp; a,<span class=\"keyword\">int</span>&amp; b)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp=b;</span><br><span class=\"line\">            b=a;</span><br><span class=\"line\">            a=temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-32","url":"/2020/02/17/LeetCode-No-32/","content":"<h1 id=\"最长有效括号\"><a\r\nhref=\"https://leetcode-cn.com/problems/longest-valid-parentheses\">最长有效括号</a></h1>\r\n<p>给定一个只包含 '(' 和\r\n')' 的字符串，找出最长的包含有效括号的子串的长度。</p>\r\n<p>示例 1:</p>\r\n<p>输入: \"(()\" 输出: 2 解释: 最长有效括号子串为 \"()\"</p>\r\n<p>示例 2:</p>\r\n<p>输入: \")()())\" 输出: 4 解释: 最长有效括号子串为 \"()()\"</p>\r\n<h1 id=\"思路分析\">思路分析</h1>\r\n<h5 id=\"错误思路规避\">错误思路规避</h5>\r\n<p>刚看到括号对, 第一反应就是栈操作的括号匹配,\r\n认为只要匹配到匹配失败的时候记录这条括号串的长度, 在遍历完整个串之后,\r\n通过最大值筛选就获得了最长有效括号长度.\r\n<strong>然而事实证明困难题没有那么憨憨</strong> 对于\"( ) ( (\r\n)\"显然简单的匹配栈会把这个长度定为4,实际上只有2 ##### 问题出在哪呢?\r\n<strong>( )</strong> ((((((((( <strong>( )</strong>\r\n在两个正常括号中间的压栈操作不会终止长度的累积\r\n当然也不能粗暴的终止,毕竟也有( ) ( ( ( ( ) ) ) ) ) 的情况</p>\r\n<h1 id=\"改良方法\">改良方法</h1>\r\n<p>参考了题解大神的思路之后, 明白了单纯压char型 ' (\r\n'入栈是一种很憨憨的行为...... 同样是压栈匹配,\r\n人家压的下标.....<strong>消耗一样,却额外带来了位置信息</strong></p>\r\n<p>匹配时括号对会产生一个位置差, 而对于这个差内部肯定是合法的括号串. (\r\n~~~~~~~) 假如是非法串, 要么是 ( 多了,那匹配时会匹配内部多的 (\r\n,而不是外部那个. 要么是 ) 多了, 那肯定已经把栈清空了,\r\n外围也不会有匹配括号.</p>\r\n<p>每次匹配成功会通过位置差得到一个当前长度信息<code>length=i-stack.top()</code>\r\n<strong>注意这里的top是已经匹配pop出一个(\r\n之后,再取的top,此时的top为目前合法字符串的开始位置的前一个</strong>\r\n假如top和pop为同一个,对于 ((())) 的嵌套形式是没问题的, 但对于连串形式如:\r\n例如 ( ( ) ( ) ( ) ( ) <strong>( )</strong> ) )\r\nstring[9]和string[10]匹配了,目前合法长度肯定不是10-9=1...实际上是10-0=10</p>\r\n<p><strong>也因为这个i-top的方法,我们需要在最开始的栈底压入一个-1,\r\n代表字符串开头</strong> 针对 ( ) ( ) ( ) 的情况, 最后一个右括号pop完,\r\n不压入一个-1你让人家减谁去算长度....</p>\r\n<p>顺带一提原方法错误的案例 再看( ) ( ( ), 原方法因为是只要不匹配失败,\r\n每过一位都会长度++,因此产生错误结果 4 而利用位置信息差算长度的方法,\r\n只会算出两个长度为2 的括号对 ,最大也就是2.</p>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<p>算法比较简单, 但分析细节还是比较令人舒适的~ <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(string s)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;   </span><br><span class=\"line\">        <span class=\"keyword\">int</span> result=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        stack&lt;<span class=\"keyword\">int</span> left;</span><br><span class=\"line\">        left.push(-1);//压入字符串头，以防（）（）（）（）情况</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;s.size())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i]==&#x27;(&#x27;)   //左括号 下标 入栈</span><br><span class=\"line\">                left.push(i);</span><br><span class=\"line\">            <span class=\"keyword\">else</span>    //右括号消除一个左括号，并用下标差计算长度</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                left.pop();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(left.empty()!=<span class=\"literal\">true</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(i-left.top()result)</span><br><span class=\"line\">                        result=i-left.top();  </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    left.push(i);</span><br><span class=\"line\">                  </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-4-","url":"/2020/02/17/LeetCode-No-4-/","content":"<h1 id=\"寻找两个有序数组的中位数\"><a\r\nhref=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays\">寻找两个有序数组的中位数</a></h1>\r\n<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。\r\n请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m +\r\nn))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3]\r\nnums2 = [2] 则中位数是 2.0</p>\r\n<p>示例 2: nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5</p>\r\n<h2 id=\"思路分析\">思路分析</h2>\r\n<p><strong>首先</strong>, 题目有 log\r\n时间复杂度限制，不能重组数组暴力解决</p>\r\n<p><strong>已知</strong>,\r\n两数组有序不为空，找到中位数的难点在于怎么把两个数组的数一起考虑</p>\r\n<p><strong>目标</strong>,\r\n中位数定义：将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。所以我们其实是找一个方法，把两个数组同时划分成两块，左边块的所有数都比右边块的所有数要小。\r\n若分割后左边有 k 个数，此时划分的边界有 LMax1,LMax2,RMin1,RMin2：</p>\r\n<ul>\r\n<li>Max(LMax1,LMax2) 必然是第 k 个数</li>\r\n<li>Min(RMin1,RMin2) 必然是第 k+1 个数</li>\r\n</ul>\r\n<p>即我们可以定位到第 k 个数，中位数的序号 k\r\n也可通过数组长度得到。因此，我们需要：</p>\r\n<p><strong>两个数组同时分割成有大小关系的两块，左块总共有 k 个数，k\r\n为中位数序号，此时中位数要么是第 k 个，要么是第 k 个和第 k+1\r\n个，都可以在边界找到</strong></p>\r\n<h2 id=\"题解分析-链接原高赞题解\"><a\r\nhref=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/\">题解分析</a>\r\n（链接原高赞题解）</h2>\r\n<h3 id=\"分割主体思路\">分割主体思路</h3>\r\n<p>要把两数组同时分割成两块，先看单一数组的内部。因为数组是有序的，所以假如在中间一割，同一数组的左边肯定小于右边。</p>\r\n<p>为了达到我们两个数组整体分割的目标，我们还需要满足对一个数组都有，分割的左边最大值小于另一个数组的右边最小值，这样左边的整体必然就会小于右边的整体。</p>\r\n<p>另外注意切割后要满足左大块总共有 k 个数。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://upload-images.jianshu.io/upload_images/19387483-5f138dbbe56bdd7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"\r\nalt=\"题解示意图，来自 LeetCode 扁扁熊\" />\r\n<figcaption aria-hidden=\"true\">题解示意图，来自 LeetCode\r\n扁扁熊</figcaption>\r\n</figure>\r\n<h3 id=\"边界数赋值\">边界数赋值</h3>\r\n<p>假如分割点恰巧在有数的位置 C, 为方便比较大小，LMax=RMin=L[C],\r\n即中位数同时分给两边。</p>\r\n<p>假如分割点在两数之间，即 LMax 和 RMin 即分属两边。</p>\r\n<h3 id=\"假想放大数组\">假想放大数组</h3>\r\n<p>因为无法用整数下标表示描述在两数之间的位置，但实际存在这种分割情况。\r\n所以我们不妨将每个数组<strong>放缩成 2m+1 的长度</strong>,\r\n即给两数之间也加入一个标识位置。 例如 [1,2,3] 假想放缩成 [#\r\n,1,#,2,#,3,#],</p>\r\n<p>此时：<strong>数的实际位置=假想位置/2</strong>，\r\n<strong>两数之间的假想位置=数的假想位置+-1</strong>。</p>\r\n<p>设放大后对一个数组切割的假想下标（虚位）为 C。 此时无论 C\r\n是<strong>数的虚位</strong>还是<strong>空的虚位</strong>, 都满足\r\nLMax=L[(C-1)/2] RMin=L[C/2],\r\n注意放缩产生的虚位是假想的，因此访问时要转换回实位</p>\r\n<p>例如对于 [# ,1,#,2,#,3,#] 2 的原下标是 1, 假想下标是 3, 3/2=1\r\n若此时以，C=3 为切割位置，即切在点上，则\r\nLMax=L[(C-1)/2]=L[1]=2,RMin=L[C/2]=L[1]=2 若以 C=4\r\n为分割处，即切在空上，LMax=L[1]=2,RMin=L[2]=3.</p>\r\n<p><strong>放大数组后，切点切空都可以用同一个式子正确给 LMax 和 RMin\r\n赋值</strong></p>\r\n<h3 id=\"左块确保有-k-个数\">左块确保有 k 个数</h3>\r\n<p>因为放大后数组总长度是 2m+2n+2，所以中位数在是 第 m+n+1 数和第 m+n+2\r\n数相加的平均值。</p>\r\n<p>因此有 <code>k=m+n+1</code>，且 <code>C2=m+n-C1</code>。</p>\r\n<p>真实数组序号从 0 开始，所以 C1+C2=k-1, 左块才有 k 个数，<strong>不是\r\nC1+C2=m+n+1</strong>。</p>\r\n<h3 id=\"切割终止条件\">切割终止条件</h3>\r\n<p>好，现在我们随便怎么切，都能确保左边是 k\r\n个数。但是注意为了维护左块所有数一定小于右块所有数，我们需要有<code>LMax&lt;=RMin</code></p>\r\n<h3 id=\"处理边界情况\">处理边界情况</h3>\r\n<p>切割时切割点可能在数组最左边或者最右边，此时直观上理解可知，切最左边的时候，LMax=无穷小，切最右边的时候\r\nRMin=无穷大</p>\r\n<h3 id=\"切割点遍历方式\">切割点遍历方式</h3>\r\n<p>切割点选择方式确定后，我们要逐步逼近正确的切割点\r\n类似于查找算法，此时可用二分法进行逼近，满足效率 O(log).</p>\r\n<h2 id=\"最终代码\">最终代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> &lt;vector        <span class=\"comment\">//注意头文件的加入，否则 INT_MIN 之类的可能无法使用</span></span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> &lt;stdio.h</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&amp; nums1, vector&lt;<span class=\"keyword\">int</span>&amp; nums2)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> length1=nums1.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length2=nums2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(length1length2)        <span class=\"comment\">//节省效率，以最短的数组为主切割 C1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">findMedianSortedArrays</span>(nums2,nums1);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> LMax1;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> LMax2;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> RMin1;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> RMin2;</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">int</span> k=length1+length2;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c1;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c2;<span class=\"comment\">//切割点</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> lo=<span class=\"number\">0</span>;<span class=\"comment\">//二分逼近变量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> hi=length1*<span class=\"number\">2</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//二分确定切割点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(lo&lt;=hi)  <span class=\"comment\">//写 LMax1RMin2 || LMax2RMin1 为什么不可以</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//计算切割点，保持了左边都是 k 个数</span></span><br><span class=\"line\">            c1=(lo+hi)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            c2=k-c1;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//计算四个边界值</span></span><br><span class=\"line\">           (c1==<span class=\"number\">0</span>) ? LMax1=INT_MIN : LMax1=nums1[(c1<span class=\"number\">-1</span>)/<span class=\"number\">2</span>];</span><br><span class=\"line\">            (c1==<span class=\"number\">2</span>*length1) ? RMin1=INT_MAX : RMin1=nums1[c1/<span class=\"number\">2</span>];</span><br><span class=\"line\">             (c2==<span class=\"number\">0</span>) ? LMax2=INT_MIN : LMax2=nums2[(c2<span class=\"number\">-1</span>)/<span class=\"number\">2</span>];</span><br><span class=\"line\">            (c2==<span class=\"number\">2</span>*length2) ? RMin2=INT_MAX : RMin2=nums2[c2/<span class=\"number\">2</span>];</span><br><span class=\"line\">            </span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(LMax1RMin2)<span class=\"comment\">//左上大于右下，左下显然小于右下，切多了，hi 降低</span></span><br><span class=\"line\">                hi=c1<span class=\"number\">-1</span>;          </span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(LMax2RMin1)<span class=\"comment\">//左下大于右上，左上显然小于右上，少了。lo 升高</span></span><br><span class=\"line\">                lo=c1+<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>       <span class=\"comment\">//左上小于右上右下，左下小于右上右下，目标条件。</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> LMax,RMin;</span><br><span class=\"line\">        LMax=(LMax1LMax2)?LMax1:LMax2;</span><br><span class=\"line\">        RMin=(RMin1&lt;RMin2)?RMin1:RMin2;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (LMax+RMin)/<span class=\"number\">2.0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<hr />\r\n<p>这个题目细节比较复杂，代码相对来说挺清晰简洁。</p>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-43","url":"/2020/02/17/LeetCode-No-43/","content":"<h1 id=\"字符串相乘\"><a\r\nhref=\"https://leetcode-cn.com/problems/multiply-strings\">字符串相乘</a></h1>\r\n<p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>\r\n<p>示例 1:</p>\r\n<p>输入: num1 = \"2\", num2 = \"3\" 输出: \"6\"</p>\r\n<p>示例 2:</p>\r\n<p>输入: num1 = \"123\", num2 = \"456\" 输出: \"56088\"</p>\r\n<p>说明：</p>\r\n<p>num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1\r\n和 num2 均不以零开头，除非是数字 0 本身。\r\n不能使用任何标准库的大数类型（比如\r\nBigInteger）或直接将输入转换为整数来处理。</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<p>//1 2 3 num1 //4 5 6 num2 //7 3 8+6 1 5 * 10+..... reverseresult</p>\r\n<h2 id=\"竖式暴力模拟\">1. 竖式暴力模拟</h2>\r\n<p>因为现实竖式乘法是从右到左落位,\r\n程序从左到右方便一些,所以运算过程中是反向存储的乘法结果,最后需要翻转.</p>\r\n<p>当然这个可以优化</p>\r\n<h4\r\nid=\"整数相乘直接思维是按竖式相乘-显而易见两次循环外层num2内层num1\">1.1\r\n整数相乘直接思维是按竖式相乘, 显而易见两次循环,外层num2,内层num1</h4>\r\n<h4 id=\"对num2的最后一位乘num1一遍currentresult保存这遍的结果\">1.2\r\n对num2的最后一位,乘num1一遍,currentresult保存这遍的结果</h4>\r\n<h4 id=\"result累加上currentresult-加法也有点麻烦-还得写个加法函数\">1.3\r\nresult累加上currentresult, (加法也有点麻烦, 还得写个加法函数</h4>\r\n<h4 id=\"因为最后一位乘过了就没用了num2.pop_back\">1.4\r\n因为最后一位乘过了就没用了,num2.pop_back()</h4>\r\n<h4\r\nid=\"注意乘完一个数-下一个currentresult要向左移一位即x10尾部添0-而我们又是反向存储所以需要在currentresult头部加i个0-ipop次数\">1.5\r\n注意乘完一个数, 下一个currentresult要向左移一位,即X10尾部添0,\r\n而我们又是反向存储,所以需要在currentresult头部加i个\"0\", i=pop次数</h4>\r\n<h4 id=\"num2所有数都用过了即num2结束循环\">1.6\r\nnum2所有数都用过了即num2=\"\",结束循环</h4>\r\n<h4 id=\"考虑一些收尾工作进位有没有多-要不要连续进位\">1.7\r\n考虑一些收尾工作,进位有没有多, 要不要连续进位</h4>\r\n<h4 id=\"将累加结果result反转-得到真实结果\">1.8 将累加结果result反转,\r\n得到真实结果</h4>\r\n<p>可以看到暴力法虽然思路直接,但是需要处理的东西也不少,而且时间空间效率都不理想,\r\n权当一个编码锻炼.</p>\r\n<h2 id=\"暴力代码\">暴力代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"function\">string <span class=\"title\">multiply</span><span class=\"params\">(string num1, string num2)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num1 == <span class=\"string\">&quot;0&quot;</span> || num2 == <span class=\"string\">&quot;0&quot;</span>)</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  string result;</span><br><span class=\"line\">  string tempresult;</span><br><span class=\"line\">  string zerostring;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> cflag = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (num2 != <span class=\"string\">&quot;&quot;</span>)<span class=\"comment\">//num1对num2每个数逐个相乘,每次result=result+currentresult*10</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (i = num1.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i = <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">    tempresult.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;0&#x27;</span> + ((num1[i] - <span class=\"string\">&#x27;0&#x27;</span>)*(num2.<span class=\"built_in\">back</span>() - <span class=\"string\">&#x27;0&#x27;</span>) + cflag) % <span class=\"number\">10</span>);</span><br><span class=\"line\">    cflag = ((num1[i] - <span class=\"string\">&#x27;0&#x27;</span>)*(num2.<span class=\"built_in\">back</span>() - <span class=\"string\">&#x27;0&#x27;</span>) + cflag) / <span class=\"number\">10</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">//乘到最后一个数还剩下cflag</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (cflag  <span class=\"number\">0</span>)</span><br><span class=\"line\">    tempresult.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;0&#x27;</span> + cflag);</span><br><span class=\"line\">   <span class=\"comment\">//用零串移位</span></span><br><span class=\"line\">   tempresult = zerostring + tempresult;</span><br><span class=\"line\">   <span class=\"comment\">//相加上下两个字符串</span></span><br><span class=\"line\">   <span class=\"built_in\">ADDstring</span>(result, tempresult);</span><br><span class=\"line\">   <span class=\"comment\">//乘完num2的一个数num2把用过的数pop</span></span><br><span class=\"line\">   num2.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">   <span class=\"comment\">//临时数据清空</span></span><br><span class=\"line\">   tempresult.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">   zerostring += <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\">   cflag = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//1 2 3</span></span><br><span class=\"line\">  <span class=\"comment\">//4 5 6</span></span><br><span class=\"line\">  <span class=\"comment\">//7 3 8+6 1 5 * 10</span></span><br><span class=\"line\">  string reverseresult;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = result.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; j = <span class=\"number\">0</span>; j--)</span><br><span class=\"line\">   reverseresult.<span class=\"built_in\">push_back</span>(result[j]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> reverseresult;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ADDstring</span><span class=\"params\">(string&amp; up, string&amp; down)</span><span class=\"comment\">//up和down字符串数值相加,结果存在up里,仅适用倒序存储</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> cflag = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">//result接在up上面</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (j &lt; down.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (j &lt; up.<span class=\"built_in\">size</span>())<span class=\"comment\">//up[j]存在</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">    temp = (up[j] - <span class=\"string\">&#x27;0&#x27;</span>) + (down[j] - <span class=\"string\">&#x27;0&#x27;</span>) + cflag;</span><br><span class=\"line\">    up[j] = (temp) % <span class=\"number\">10</span> + <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">    cflag = (temp) / <span class=\"number\">10</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span><span class=\"comment\">//up[j]不存在</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">    up.<span class=\"built_in\">push_back</span>(((down[j] - <span class=\"string\">&#x27;0&#x27;</span>) + cflag) % <span class=\"number\">10</span> + <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">    cflag = ((down[j] - <span class=\"string\">&#x27;0&#x27;</span>) + cflag) / <span class=\"number\">10</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   j++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (cflag != <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (j &lt; up.<span class=\"built_in\">size</span>())<span class=\"comment\">//up[j]存在</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">    temp = (up[j] - <span class=\"string\">&#x27;0&#x27;</span>) + cflag;</span><br><span class=\"line\">    up[j] = (temp) % <span class=\"number\">10</span> + <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">    cflag = (temp) / <span class=\"number\">10</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span><span class=\"comment\">//up[j]不存在</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">    up.<span class=\"built_in\">push_back</span>(cflag % <span class=\"number\">10</span> + <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">    cflag = cflag / <span class=\"number\">10</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"优化思路每一位数的乘法运算对result影响分析\">2.\r\n优化思路——每一位数的乘法运算对result影响分析</h2>\r\n<p>//1 2 3 num1[i] //为示范简单,这里序号从右往左编码,程序中需要转换 //4\r\n5 6 num2[j] //例如num1[0]和num2[0]相乘 : 3X6=18\r\n肯定影响到了result[0+0],有进位则会影响到result[0+0+1],\r\nresult其他的值则肯定不会改变</p>\r\n<h4\r\nid=\"优化分析-在竖式中从右向左编码-两个数num1i-num2j相乘-则只会影响到resultij-resultij1两位的结果\">2.1\r\n优化分析: 在竖式中,从右向左编码, 两个数num1[i], num2[j]相乘,\r\n则只会影响到result[i+j] , result[i+j+1]两位的结果</h4>\r\n<h4\r\nid=\"因此我们不需要临时存储的容器currentresult-只需要在-result中修改受影响的两位即可\">2.2\r\n因此我们不需要临时存储的容器currentresult, 只需要在\r\nresult中修改受影响的两位即可</h4>\r\n<h4\r\nid=\"另外num2.pop_back虽然符合直觉习惯但显然我们可以通过移动下标来代替反复的pop\">2.3\r\n另外num2.pop_back虽然符合直觉习惯,但显然我们可以通过移动下标来代替反复的pop</h4>\r\n<p>事实证明对于一些修改字符串的操作还是小心为慎,\r\n虽然pop这个操作看起来只需要剪掉尾巴就好, 应该耗时影响不大 ,\r\n<strong>但事实上我卡在80%就是因为它!!!!</strong>, 优化掉后直接97%=\r\n=.</p>\r\n<h4\r\nid=\"反转问题-同上可知-乘法最远也就影响到resultlength1length21.-即result长度已知-因此可以反向填充result即可避免最后还得反转\">2.4\r\n反转问题: 同上可知, 乘法最远也就影响到result[length1+length2+1].\r\n即result长度已知, 因此可以反向填充result即可避免最后还得反转</h4>\r\n<p>暴力法时因为不清楚result到底会有多长, 所以不能反向填充.</p>\r\n<h4 id=\"另外还有一些小细节思考\">2.5 另外还有一些小细节思考</h4>\r\n<h4 id=\"比如连续进位有没有问题\">比如连续进位有没有问题</h4>\r\n<h4 id=\"循环结束需不需要有收尾整理\">循环结束需不需要有收尾整理</h4>\r\n<h4\r\nid=\"我们现在result里填充了length1length21的-0-方便我们后续反向填充和累加-但是result0是最后一位进位的结果-假如最后没有进位呢\">我们现在result里填充了[length1+length2+1]的\r\n'0' 方便我们后续反向填充和累加, 但是result[0]是最后一位进位的结果,\r\n假如最后没有进位呢?</h4>\r\n<h1 id=\"优化代码-超越97时间86内存\">优化代码, 超越97%时间,86%内存</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"function\">string <span class=\"title\">multiply</span><span class=\"params\">(string num1, string num2)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num1 == <span class=\"string\">&quot;0&quot;</span> || num2 == <span class=\"string\">&quot;0&quot;</span>)</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">           </span><br><span class=\"line\">  string result;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> totallength=num1.<span class=\"built_in\">size</span>()+num2.<span class=\"built_in\">size</span>();<span class=\"comment\">//result最大可能长度</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> cflag =<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp=<span class=\"number\">0</span>;<span class=\"comment\">//i+j位和存储器</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;totallength;i++)<span class=\"comment\">//初始化填充</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//反向填充,可以不需要在最后reverse,....好像对效率影响不大</span></span><br><span class=\"line\">        <span class=\"comment\">//把num2.pop()删掉了,终于从8ms提到了4ms......</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (j&lt;num2.<span class=\"built_in\">size</span>())<span class=\"comment\">//num1[i]Xnum2[j] 只影响result的[i+j]和[i+j+1],因此相比暴力相加,可以优化中间步骤</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (i = num1.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i = <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">   &#123;   <span class=\"comment\">//因为要改变i+j位,所以先计算出i+j+1位,(程序用的i和注释i不是一个)</span></span><br><span class=\"line\">                temp=(result[totallength<span class=\"number\">-1</span>-((num1.<span class=\"built_in\">size</span>()-i<span class=\"number\">-1</span>)+j)]-<span class=\"string\">&#x27;0&#x27;</span>)+ (num1[i] - <span class=\"string\">&#x27;0&#x27;</span>)*(num2[num2.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>-j] - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">                <span class=\"comment\">//连续进位怎么办?临时存储?循环清理干净?</span></span><br><span class=\"line\">                <span class=\"comment\">//临时存储试试</span></span><br><span class=\"line\">                result[totallength<span class=\"number\">-1</span>-((num1.<span class=\"built_in\">size</span>()-i<span class=\"number\">-1</span>)+j+<span class=\"number\">1</span>)]+=temp/<span class=\"number\">10</span>;</span><br><span class=\"line\">    result[totallength<span class=\"number\">-1</span>-((num1.<span class=\"built_in\">size</span>()-i<span class=\"number\">-1</span>)+j)]=<span class=\"string\">&#x27;0&#x27;</span>+temp%<span class=\"number\">10</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            j++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">        <span class=\"comment\">//不需要检查最后一位要不要进位</span></span><br><span class=\"line\">       </span><br><span class=\"line\">  <span class=\"comment\">//1 2 3</span></span><br><span class=\"line\">  <span class=\"comment\">//4 5 6</span></span><br><span class=\"line\">  <span class=\"comment\">//7 3 8+6 1 5 * 10</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//跳过头部的0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(result[<span class=\"number\">0</span>]!=<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> result.<span class=\"built_in\">substr</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<hr />\r\n<p>string.pop_back()真的卡了我好久, 左优化右优化, 去头部0的方法换了又换,\r\n就是卡在80% .......谨慎考虑库函数的效率.</p>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-44","url":"/2020/02/17/LeetCode-No-44/","content":"<h1 id=\"通配符匹配\"><a\r\nhref=\"https://leetcode-cn.com/problems/wildcard-matching\">通配符匹配</a></h1>\r\n<p>------类似No.10的正则匹配</p>\r\n<p>给定一个字符串 (s) 和一个字符模式 (p)\r\n，实现一个支持 '?' 和 '*' 的通配符匹配。</p>\r\n<p>'?' 可以匹配任何单个字符。 '*' 可以匹配任意字符串（包括空字符串）。\r\n两个字符串完全匹配才算匹配成功。</p>\r\n<p>说明:</p>\r\n<p>s 可能为空，且只包含从 a-z 的小写字母。\r\np 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<p>和正则一样, 重点在于 * 的任意位匹配</p>\r\n<ol type=\"1\">\r\n<li><p>假如是一个没有 * 的串匹配,\r\n我们只要碰到一个匹配失败即可结束</p></li>\r\n<li><p>有了 <em>的情况,</em>\r\n可以用来干什么呢?-----帮你把匹配失败的地方干掉</p></li>\r\n<li><p>因此其实我们可以先正常逐个精确匹配, 遇到 * 可以记录下来,\r\n以便帮助后面</p></li>\r\n<li><p>当在某一位精确匹配失败时, 我们回去找 <em>的帮助,\r\n如果之前没有</em> , 帮不了, 匹配失败</p></li>\r\n<li><p>假如之前有 <em>,即需让</em>往后匹配来避免这个失败位, 但是因为*\r\n每向后扩展一位, 原本的精确匹配顺序全都挪动了一位,\r\n此时我们不知道是不是能匹配成功</p></li>\r\n<li><p>因此 <em>帮忙的时候,</em> 只向后扩展一位试试,\r\n此时是一个未知的匹配状态, 我们需要在 * 的边缘重新开始精确匹配,\r\n再失败了就重复 6 即可</p></li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isMatch</span><span class=\"params\">(string s, string p)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//i,j指示当前匹配位置,iflag,jflag指示*号匹配位置</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> slength=s.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> plength=p.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> iflag=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> jflag=<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//匹配到*之后的匹配中, 如果准确匹配,则进入了第一个if,失败则</span></span><br><span class=\"line\">        <span class=\"comment\">//  是* 则先保存现场, 在之后的匹配中如果失败则需要*来救场</span></span><br><span class=\"line\">        <span class=\"comment\">//  不是* ,则看之前有没有*,有可以用来救场,尝试增加*解决掉的位数,再继续试试</span></span><br><span class=\"line\">        <span class=\"comment\">// 没有*救场 , 那可以自闭了.over</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//循环内每次都确保当前匹配成功</span></span><br><span class=\"line\">        <span class=\"comment\">//注意j&lt;plength的处理,j==plength时,仍然要继续尝试用*解决的,不能无脑return false.</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;slength)</span><br><span class=\"line\">        &#123;   </span><br><span class=\"line\">            <span class=\"comment\">//准确匹配成功</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j&lt;plength &amp;&amp; (s[i]==p[j] || p[j]==<span class=\"string\">&#x27;?&#x27;</span>))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//匹配到*</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j&lt;plength &amp;&amp; p[j]==<span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                iflag=i;</span><br><span class=\"line\">                jflag=j;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//p中*用掉了,j去下一位. s[i]因为 *可能用于匹配空串,所以暂时不移动</span></span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//准确匹配失败,但是进入下面的elseif内则说明之前有*,这时候就需要增加*匹配的一位 来尝试解决掉不能准确匹配的东西.</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(jflag!=<span class=\"number\">-1</span>)</span><br><span class=\"line\">            &#123;   </span><br><span class=\"line\">                <span class=\"comment\">//*匹配到原iflag走不通,尝试匹配到iflag++位置,再次开始匹配</span></span><br><span class=\"line\">                i=++iflag;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//p因为是用*去匹配的,所以p下一个要匹配的位是*下一位,jflag+1</span></span><br><span class=\"line\">                j=jflag+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//连*都不能帮忙解决,s可以走了</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//注意考虑s匹配完了,p剩余*则还能成功</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&lt;plength)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p[j]==<span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> j==plength;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-45","url":"/2020/02/17/LeetCode-No-45/","content":"<h1 id=\"跳跃游戏\"><a\r\nhref=\"https://leetcode-cn.com/problems/jump-game-ii\">跳跃游戏</a></h1>\r\n<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>\r\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\r\n<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>\r\n<p>示例:</p>\r\n<p>输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。  \r\n从下标为 0 跳到下标为 1\r\n的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p>\r\n<p>说明:</p>\r\n<p>假设你总是可以到达数组的最后一个位置。</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<h3 id=\"假如不考虑最少次数-贪心法\">1. 假如不考虑最少次数, 贪心法</h3>\r\n<h4 id=\"逐位扩展可跳最大距离-只要够到了末尾就好.\">----\r\n逐位扩展可跳最大距离, 只要够到了末尾就好.</h4>\r\n<h4\r\nid=\"假如扩展的时候-最大距离到不了这个位-则不能从这个位扩展-即断路了.\">----\r\n假如扩展的时候, 最大距离到不了这个位, 则不能从这个位扩展, 即断路了.</h4>\r\n<h3 id=\"加上了最少次数要求\">2. 加上了最少次数要求</h3>\r\n<h4 id=\"什么情况会多次数-就是之前的一次能跳到的-跳了几次.\">----\r\n什么情况会多次数? 就是之前的一次能跳到的, 跳了几次.</h4>\r\n<h4\r\nid=\"那么怎么知道之前能不能跳到呢-记录能跳到的最大距离-只有到达最大距离-才算一次次数.-当然到末端也算一次.\">----\r\n那么怎么知道之前能不能跳到呢? 记录能跳到的最大距离, 只有到达最大距离,\r\n才算一次次数. 当然到末端也算一次.</h4>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jump</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//参考题解大神思路: i每到达前一个max,完成一次跳跃</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> end = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxend = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">\t    &#123;   <span class=\"comment\">//i每到达前一个max,完成一次跳跃</span></span><br><span class=\"line\">\t\t    maxend = <span class=\"built_in\">max</span>(nums[i] + i, maxend);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == end)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                end = maxend;</span><br><span class=\"line\">                sum++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-46-47","url":"/2020/02/17/LeetCode-No-46-47/","content":"<h1 id=\"全排列\"><a\r\nhref=\"https://leetcode-cn.com/problems/permutations\">全排列</a></h1>\r\n<p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p>\r\n<p>示例:</p>\r\n<p>输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2],\r\n[3,2,1]]</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<h3\r\nid=\"递归-顺着手工思路从后往前逐步交换.-固定前面的后面的全排列即可.\">1.\r\n递归, 顺着手工思路,从后往前逐步交换. 固定前面的+后面的全排列即可.</h3>\r\n<h3\r\nid=\"用一个for循环表示该位与后面每一位交换-包括交换自己-等于不交换的情况-然后用递归表达后面的全排列.\">2.\r\n用一个for循环表示该位与后面每一位交换, (包括交换自己, 等于不交换的情况),\r\n然后用递归表达后面的全排列.</h3>\r\n<p>注意递归出来后要把之前换的换回来, 要不然 [1 2 3 ] 换成 [2 1 3],\r\n递归到第二层 1 3 又会换成[2 3 1], 这已经不是全排列了, 是在顺序交换.\r\n容易出错</p>\r\n<h3 id=\"全排列ii-存在重复数字-要筛选掉重复的排列\">3. 全排列II\r\n存在重复数字, 要筛选掉重复的排列</h3>\r\n<h4\r\nid=\"为什么会有重复序列呢-因为-i-交换了-j-递归出来后-接下来i又碰到一个-j-.-两次交换递归下去的结果一模一样-所以会重复-.\">----为什么会有重复序列呢?\r\n因为 i 交换了 j, 递归出来后, 接下来i又碰到一个 j .\r\n两次交换递归下去的结果一模一样 , 所以会重复 .</h4>\r\n<h4\r\nid=\"因此对每个j-我们要查重它是不是在i-j之间-即已经交换过j值-查重通过了才能继续递归-否则跳过.\">----\r\n因此对每个j 我们要查重它是不是在i-j之间 (即已经交换过j值)\r\n,查重通过了才能继续递归, 否则跳过.</h4>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"keyword\">int</span> permuteUnique(vector&lt;<span class=\"keyword\">int</span>&amp; nums) </span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span> result;</span><br><span class=\"line\">        backtrace(nums,result,0);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">void</span> backtrace(vector&lt;<span class=\"keyword\">int</span>&amp;nums,vector&lt;vector&lt;<span class=\"keyword\">int</span>&amp;result,<span class=\"keyword\">int</span> i)</span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i==nums.size()-1)</span><br><span class=\"line\">            result.push_back(nums);</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i;j&lt;nums.size();j++)</span><br><span class=\"line\">        &#123;   </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i==j)//不需要交换的递归</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                backtrace(nums,result,i+1);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;     </span><br><span class=\"line\">            //检查要交换的这个,在已经交换过的里面,有没有相同的,有就不交换了</span><br><span class=\"line\">            <span class=\"keyword\">int</span> k;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(k=j-1;k=i;k--)</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[k]==nums[j])</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(k!=i-1)//查重没通过,跳过这个数</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            //正常交换递归</span><br><span class=\"line\">            swap(nums[i],nums[j]);</span><br><span class=\"line\">            backtrace(nums,result,i+1);</span><br><span class=\"line\">            swap(nums[i],nums[j]);  //换回来？</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\">void</span> swap(<span class=\"keyword\">int</span>&amp; a,<span class=\"keyword\">int</span>&amp;b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp=a;</span><br><span class=\"line\">        a=b;</span><br><span class=\"line\">        b=temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-46","url":"/2020/02/17/LeetCode-No-46/","content":"<h1 id=\"全排列\"><a\r\nhref=\"https://leetcode-cn.com/problems/permutations\">全排列</a></h1>\r\n<p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p>\r\n<p>示例:</p>\r\n<p>输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2],\r\n[3,2,1]]</p>\r\n<h1 id=\"思路分析\">思路分析</h1>\r\n<ul>\r\n<li><p>由排列特性我们的直觉思路是, 首先固定第一个数, 然后排列后面的数\r\n,同时后面的排列也是这种<strong>固定+排序</strong>的思路进行.\r\n因此很显然可以想到是一种递归回溯的算法.</p></li>\r\n<li><p>递归到字符串尾很简单,\r\n但需要注意的是怎么得到其他的组合情况.</p></li>\r\n</ul>\r\n<p><del>我首先设想的是进行一种遍历, 首先确定第一个数,\r\n然后选取未被排列过的剩下的数, 逐一形成n!个排列组合,\r\n但好像没想到简便的方法实现</del></p>\r\n<p>参考题解后得知, 想要不同的排列组合, 本质在于数的顺序不同,\r\n因此我们只要将数进行交换, 然后递归到底输出交换后的组合即可.</p>\r\n<h1 id=\"解答代码\">解答代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"keyword\">int</span> permute(vector&lt;<span class=\"keyword\">int</span>&amp; nums) </span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span> result;</span><br><span class=\"line\">        backtrace(nums,result,0);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">void</span> backtrace(vector&lt;<span class=\"keyword\">int</span>&amp;nums,vector&lt;vector&lt;<span class=\"keyword\">int</span>&amp;result,<span class=\"keyword\">int</span> i)</span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i==nums.size()-1)</span><br><span class=\"line\">            result.push_back(nums);</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i;j&lt;nums.size();j++)  //逐一尝试与后面的数的交换组合</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            swap(nums[i],nums[j]);//交换</span><br><span class=\"line\">            backtrace(nums,result,i+1);//然后输出交换后的串</span><br><span class=\"line\">            swap(nums[i],nums[j]);  //记得换回来保持原状, 否则换到最后会重复  比如ABC- CBA-ABC </span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\">void</span> swap(<span class=\"keyword\">int</span>&amp; a,<span class=\"keyword\">int</span>&amp;b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp=a;</span><br><span class=\"line\">        a=b;</span><br><span class=\"line\">        b=temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-49","url":"/2020/02/17/LeetCode-No-49/","content":"<h1 id=\"字母异位分词\"><a\r\nhref=\"https://leetcode-cn.com/problems/group-anagrams\">字母异位分词</a></h1>\r\n<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>\r\n<p>示例:</p>\r\n<p>输入: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], 输出: [\r\n[\"ate\",\"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"]] 说明：</p>\r\n<p>所有输入均为小写字母。 不考虑答案输出的顺序。</p>\r\n<h1 id=\"题解分析\">题解分析</h1>\r\n<h3 id=\"怎么判断是不是异位分词呢-想想异位分词具有什么特点\">1.\r\n怎么判断是不是异位分词呢? 想想异位分词具有什么特点?</h3>\r\n<h3 id=\"异位分词中-字母出现次数相同-字母顺序不同\">---- 异位分词中,\r\n字母出现次数相同, 字母顺序不同</h3>\r\n<h3 id=\"因此我们可以-排序后观察-26字母次数统计-进行比较.\">----\r\n因此我们可以 排序后观察 / 26字母次数统计 进行比较.</h3>\r\n<h3\r\nid=\"当然注意别做一类扫一遍-用个字典自动分类就可以了.\">当然注意别做一类扫一遍,\r\n用个字典自动分类就可以了.</h3>\r\n<h1 id=\"题解代码----排序字典\">题解代码----排序+字典</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;string groupAnagrams(vector&lt;string&amp; strs) </span><br><span class=\"line\">    &#123;   //加字典的排序</span><br><span class=\"line\">        vector&lt;vector&lt;string result;</span><br><span class=\"line\">        unordered_map&lt;string, vector&lt;string hashmap;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(string s : strs)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            string temp = s;</span><br><span class=\"line\">            sort(temp.begin(), temp.end());</span><br><span class=\"line\">            hashmap[temp].push_back(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i : hashmap)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result.push_back(i.second);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-48-矩阵圈圈类型","url":"/2020/02/17/LeetCode-No-48-%E7%9F%A9%E9%98%B5%E5%9C%88%E5%9C%88%E7%B1%BB%E5%9E%8B/","content":"<h1 id=\"旋转矩阵\"><a\r\nhref=\"https://leetcode-cn.com/problems/rotate-image\">旋转矩阵</a></h1>\r\n<p>给定一个 n × n 的二维矩阵表示一个图像。</p>\r\n<p>将图像顺时针旋转 90 度。</p>\r\n<p>说明：</p>\r\n<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>\r\n<p>示例 1:</p>\r\n<p>给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],</p>\r\n<p>原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3]]</p>\r\n<p>示例 2:</p>\r\n<p>给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7],\r\n[15,14,12,16]],</p>\r\n<p>原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6,\r\n8, 9], [16, 7,10,11]]</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>矩阵圈圈式问题主要在于怎么确定问题需要的 圈。例如旋转矩阵这个问题,\r\n看似旋转, 实际上是一圈圈的边界互换, 上边界换到右边界, 以此类推。</p>\r\n<p>那么其实只要我们找到四个边界, 然后以边界去for遍历就好了。遍历完一圈\r\n,收缩上下左右边界, 继续遍历, 直到边界重合。</p>\r\n<table>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>之后的顺时针遍历问题也是一样, 以边界为中心去做遍历.不断收缩边界,\r\n注意单行单列的圈 需要做避免重复处理, 旋转问题这里不需要, 因为是n x\r\nn.</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 id=\"题解代码\">题解代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">int</span>&amp; matrix)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;       </span><br><span class=\"line\">            <span class=\"comment\">//确定四个边界,因为是nxn其实可以两个数就够了,但是为了可读性用四个数</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> left=<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> top=<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> right=matrix[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> bottom=matrix.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(left&lt;right)<span class=\"comment\">//每次旋转外围四边,旋转完缩小外围定义</span></span><br><span class=\"line\">            &#123;   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;right-left;i++)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//上到右</span></span><br><span class=\"line\">                    temp=matrix[top+i][right];</span><br><span class=\"line\">                    matrix[top+i][right]=matrix[top][left+i];</span><br><span class=\"line\">                    <span class=\"comment\">//左到上</span></span><br><span class=\"line\">                    matrix[top][left+i]=matrix[bottom-i][left];</span><br><span class=\"line\">                    <span class=\"comment\">//下到左</span></span><br><span class=\"line\">                    matrix[bottom-i][left]=matrix[bottom][right-i];</span><br><span class=\"line\">                    <span class=\"comment\">//右到下</span></span><br><span class=\"line\">                    matrix[bottom][right-i]=temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                left++;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">                top++;</span><br><span class=\"line\">                bottom--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-5","url":"/2020/02/17/LeetCode-No-5/","content":"<h1 id=\"最长回文子串\"><a\r\nhref=\"https://leetcode-cn.com/problems/longest-palindromic-substring\">最长回文子串</a></h1>\r\n<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为\r\n1000。 示例 1： 输入: \"babad\" 输出: \"bab\" 注意: \"aba\"\r\n也是一个有效答案。</p>\r\n<p>示例 2： 输入: \"cbbd\" 输出: \"bb\"</p>\r\n<h2 id=\"仿no.4切入\">仿No.4切入</h2>\r\n<ul>\r\n<li>回文序列本质上还是一个切割问题</li>\r\n<li>以切割点为起始,逐步比较两边是否相等即可判断回文.</li>\r\n<li>注意切割处可以是数, 也可以是两数之间</li>\r\n</ul>\r\n<h2 id=\"求解代码\">求解代码</h2>\r\n<p>题目思路较为简单,直接放出一遍撸过的代码. <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\">string <span class=\"title\">longestPalindrome</span><span class=\"params\">(string s)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tstring result;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> center;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> left;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> right;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s.<span class=\"built_in\">length</span>() == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//参考题4扩展</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//[1,2,3] [1,# ,2,#,3]</span></span><br><span class=\"line\">\t\t <span class=\"comment\">//[2,1,1,2] [2,# ,1,#,1,#,2]</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (center = <span class=\"number\">0</span>; center &lt; <span class=\"number\">2</span>*s.<span class=\"built_in\">length</span>()<span class=\"number\">-1</span>; center++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tleft = center / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\tright = (center + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (left &lt; <span class=\"number\">0</span> || right = s.<span class=\"built_in\">length</span>() || s[left] != s[right])</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tleft++;</span><br><span class=\"line\">\t\t\t\t\tright--;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tleft--;</span><br><span class=\"line\">\t\t\t\tright++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (right - left + <span class=\"number\">1</span>  result.<span class=\"built_in\">length</span>())</span><br><span class=\"line\">\t\t\t\tresult.<span class=\"built_in\">assign</span>(s, left, right - left + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n----------------- ## 错误思路反省 #### 1.<strong>条件定义错误</strong>\r\n简单的将回文定义为 一个数在中间,两边相等 的序列,\r\n实际上回文序列最中间可能是<strong>空</strong>而不是<strong>数</strong>.\r\n#### 2.<strong>边界特殊情况考虑不周</strong>\r\n比如空字符串,比如没想到\"aaaaa\"这种字符串,\r\n当然使用扩展分割的算法时这些情况都可以求解,\r\n只不过如果自己能早点注意到这些特殊情况,就不需要绕弯子 ,\r\n可以直接上来就撸分割了. #### 3. <strong>自行测试</strong>\r\n自己在提交给OJ之前,应该自己尽量想出各种各样的测试样例,\r\n不能写出什么就随便丢上去跑,\r\n只有自己用心测试了之后才会发现自己的初始算法有那么多的错误.</p>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-50","url":"/2020/02/17/LeetCode-No-50/","content":"<h1 id=\"powxn\"><a\r\nhref=\"https://leetcode-cn.com/problems/powx-n\">pow(x,n)</a></h1>\r\n<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>\r\n<p>示例 1:</p>\r\n<p>输入: 2.00000, 10 输出: 1024.00000</p>\r\n<p>示例 2:</p>\r\n<p>输入: 2.10000, 3 输出: 9.26100</p>\r\n<p>示例 3:</p>\r\n<p>输入: 2.00000, -2 输出: 0.25000 解释: 2-2 = 1/22 = 1/4 = 0.25\r\n说明:</p>\r\n<p>-100.0 &lt; x &lt; 100.0 n 是 32\r\n位有符号整数，其数值范围是 [−231, 231 − 1] 。</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<h3 id=\"数学思路-快速幂算法\">数学思路, 快速幂算法</h3>\r\n<h4\r\nid=\"因为xn可以分解成xn2-xn2-所以可以把n二分下去-变成logn的快速幂算法\">----因为x<sup>n</sup>可以分解成x<sup>n/2</sup>\r\n* x<sup>n/2</sup>, 所以可以把n二分下去 变成logN的快速幂算法</h4>\r\n<h4 id=\"另外注意-数值越界-奇偶的二分的区别\">另外注意: 数值越界,\r\n奇偶的二分的区别</h4>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">myPow</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">int</span> n)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;   <span class=\"comment\">//????通不过45,90啊</span></span><br><span class=\"line\">        <span class=\"comment\">//只有奇偶递归的话,数值变大了就有问题</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==INT_MIN)<span class=\"comment\">//注意-n 和 n 的越界范围不一样</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>/(<span class=\"built_in\">myPow</span>(x,INT_MAX)*x);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>/<span class=\"built_in\">myPow</span>(x,-n);</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1.0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n==<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">double</span> half=<span class=\"built_in\">myPow</span>(x,n/<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n%<span class=\"number\">2</span>==<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> half*half;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"comment\">//(n%2!=0)</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> half*half*x;            </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-51&No-52","url":"/2020/02/17/LeetCode-No-51-52/","content":"<h1 id=\"n皇后\"><a\r\nhref=\"https://leetcode-cn.com/problems/n-queens\">N皇后</a></h1>\r\n<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n\r\n的棋盘上，并且使皇后彼此之间不能相互攻击。 <img\r\nsrc=\"https://upload-images.jianshu.io/upload_images/19387483-fd574c97962d8a50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"\r\nalt=\"N皇后示例-LeetCode\" /> 上图为 8 皇后问题的一种解法。 给定一个整数\r\nn，返回所有不同的 n 皇后问题的解决方案。</p>\r\n<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和\r\n'.' 分别代表了皇后和空位。</p>\r\n<p>示例:</p>\r\n<p>输入: 4 输出: [ [\".Q..\", // 解法 1 \"...Q\", \"Q...\", \"..Q.\"],] 解释: 4\r\n皇后问题存在两个不同的解法。</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<ul>\r\n<li><h4\r\nid=\"主要思路和数独类一样回溯遍历\">主要思路和数独类一样，回溯遍历</h4></li>\r\n<li><h4\r\nid=\"放置特性行列对角线不同\">放置特性：行、列、对角线不同</h4></li>\r\n<li><h4\r\nid=\"需要注意怎么判断皇后在当前位置是否可放置呢使用状态表判断三个数组构成\">需要注意怎么判断皇后在当前位置是否可放置呢？——使用状态表判断，三个数组构成</h4></li>\r\n</ul>\r\n<ol type=\"1\">\r\n<li>行列不同很简单，以行遍历为例，因为一行放了一个就到下一行，所以行不可能重复。</li>\r\n<li>列检查，遍历每行的时候，检查<strong>列状态表</strong>，这列未被使用才可。<code>bool colFlag[n]</code></li>\r\n<li>检查主对角线，主对角线特征是<strong>行列差</strong>相同即是同一个主对角线，行列差范围在[-n+1,n-1]，因为索引有负，进行一个+n的偏移处理。<code>diagonal[2*n]</code></li>\r\n<li>检查次对角线，特征是<strong>行列和</strong>相同，范围在[0,2n-2]。<code>SubDiagonal[2*n]</code></li>\r\n<li>检查通过才可放置，同时后续假如要撤销记得收拾好记录表。</li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;string solveNQueens(<span class=\"keyword\">int</span> n) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;string result;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> First=0;//第一行的Q位置</span><br><span class=\"line\">       </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(First&lt;n)//第一个Q的位置代表尝试轮次,第一行超过最后一格则所有遍历结束</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //初始化棋盘</span><br><span class=\"line\">            vector&lt;string tempReuslt;</span><br><span class=\"line\">            string tempString(n,&#x27;.&#x27;);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=0;i&lt;n;i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                tempReuslt.push_back(tempString);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //列使用情况,<span class=\"literal\">false</span>代表没用过</span><br><span class=\"line\">            <span class=\"keyword\">bool</span> colFlag[n];</span><br><span class=\"line\">            <span class=\"keyword\">bool</span> diagonal[2*n];//对角线使用情况</span><br><span class=\"line\">            <span class=\"keyword\">bool</span> SubDiagonal[2*n];//次对角线使用情况</span><br><span class=\"line\">            memset(colFlag,0,<span class=\"keyword\">sizeof</span>(colFlag));</span><br><span class=\"line\">            memset(diagonal,0,<span class=\"keyword\">sizeof</span>(diagonal));</span><br><span class=\"line\">            memset(SubDiagonal,0,<span class=\"keyword\">sizeof</span>(SubDiagonal));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            //第一个Q在First位置</span><br><span class=\"line\">            tempReuslt[0][First]=&#x27;Q&#x27;;</span><br><span class=\"line\">            colFlag[First]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">            diagonal[0-First+n]=<span class=\"literal\">true</span>;//偏移n,因为行减列可能是负数</span><br><span class=\"line\">            SubDiagonal[First]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> count=1;</span><br><span class=\"line\">            backTrace(result,tempReuslt,count,colFlag,n,diagonal,SubDiagonal);</span><br><span class=\"line\"></span><br><span class=\"line\">            First++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> backTrace(vector&lt;vector&lt;string&amp; result,vector&lt;string&amp;tempReuslt,<span class=\"keyword\">int</span>&amp; count,<span class=\"keyword\">bool</span>* colFlag,<span class=\"keyword\">int</span>&amp; n,<span class=\"keyword\">bool</span>* diagonal,<span class=\"keyword\">bool</span>* SubDiagonal)</span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        //找齐了</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(count==n)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result.push_back(tempReuslt);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;//填入第count个数</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=0;i&lt;n;i++)</span><br><span class=\"line\">        &#123;   </span><br><span class=\"line\">            //检查列,对角线,次对角线</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((colFlag[i]==<span class=\"literal\">true</span> || (diagonal[count-i+n]==<span class=\"literal\">true</span>) || SubDiagonal[count+i]==<span class=\"literal\">true</span>)==<span class=\"literal\">false</span>)</span><br><span class=\"line\">            &#123;  </span><br><span class=\"line\">                //填入一个数</span><br><span class=\"line\">                tempReuslt[count][i]=&#x27;Q&#x27;;</span><br><span class=\"line\">                colFlag[i]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                diagonal[count-i+n]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                SubDiagonal[count+i]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\"></span><br><span class=\"line\">                //找下一个数</span><br><span class=\"line\">                backTrace(result,tempReuslt,count,colFlag,n,diagonal,SubDiagonal);</span><br><span class=\"line\"></span><br><span class=\"line\">                //重置当前数</span><br><span class=\"line\">                count--;</span><br><span class=\"line\">                tempReuslt[count][i]=&#x27;.&#x27;;</span><br><span class=\"line\">                colFlag[i]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">                diagonal[count-i+n]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">                SubDiagonal[count+i]=<span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-53","url":"/2020/02/17/LeetCode-No-53/","content":"<h1 id=\"最大子序和\"><a\r\nhref=\"https://leetcode-cn.com/problems/maximum-subarray\">最大子序和</a></h1>\r\n<p>给定一个整数数组\r\nnums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\r\n<p>示例:</p>\r\n<p>输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1]\r\n的和最大，为 6。 进阶:</p>\r\n<p>如果你已经实现复杂度为 O(n)\r\n的解法，尝试使用更为精妙的分治法求解。</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<h5\r\nid=\"一开始我是想着尝试双指针往中间收缩只要收缩能增加和那就保留当前状态但不知道怎么描述收缩停止条件\">1.\r\n一开始我是想着，尝试双指针往中间收缩，只要收缩能增加和，那就保留当前状态，但不知道怎么描述收缩停止条件。</h5>\r\n<h5 id=\"动态规划当累积到第i个数时有两种情况\">2.\r\n动态规划，当累积到第i个数时,有两种情况:</h5>\r\n<p>2.1 吃掉之前的sum,变得更大 2.2 之前的sum为负,要它干嘛,不吃,自立门户\r\n#####\r\n所以很简单，只需要判断前面的sum是否有价值就行了，因为是不能跳跃的，没价值你只能丢弃这个包袱，不能挑几项走。</p>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&amp; nums)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;   </span><br><span class=\"line\">        <span class=\"comment\">//想着两边双指针逼近收缩,不过不知道怎么确定收缩停止条件,暂时搁置</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//动态规划</span></span><br><span class=\"line\">        <span class=\"comment\">//当累积到第i个数时,有两种情况:</span></span><br><span class=\"line\">        <span class=\"comment\">//1.吃掉之前的sum,变得更大</span></span><br><span class=\"line\">        <span class=\"comment\">//2.之前的sum为负,要它干嘛,不吃,自立门户</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum=nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxResult=nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> L=nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;L;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum0)</span><br><span class=\"line\">                sum+=nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                sum=nums[i];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(summaxResult)</span><br><span class=\"line\">                maxResult=sum;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxResult;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-56-&-No-57","url":"/2020/02/17/LeetCode-No-56-No-57/","content":"<h1\r\nid=\"合并区间-插入区间httpsleetcode-cn.comproblemsmerge-intervals\">(合并区间\r\n|| 插入区间)[https://leetcode-cn.com/problems/merge-intervals]</h1>\r\n<p>给出一个区间的集合，请合并所有重叠的区间。</p>\r\n<p>示例 1:</p>\r\n<p>输入: [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释:\r\n区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p>\r\n<p>示例 2:</p>\r\n<p>输入: [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5]\r\n可被视为重叠区间。</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<h3 id=\"合并区间\">合并区间</h3>\r\n<ol type=\"1\">\r\n<li>[a,b] [c,d]合并条件：b=c &amp;&amp; a&lt;=d\r\n此时区间存在重复区段，可以合并</li>\r\n<li>由于原区间序列是乱序，你合并了前两个，产生合并结果temp，但你不知道temp还可以和后续的什么合并，所以又需要遍历一遍，不现实。</li>\r\n<li>因此我们先按区间左边界进行排序，这样temp只需要考虑是否还要合并紧挨着的下一个即可。\r\n### 插入区间</li>\r\n<li>首先需要找到插入位置，即左边界 介于 前一个和后一个的左边界\r\n中间。</li>\r\n<li>插入之后的收尾工作 插入时会不会和前一个发生和合并？\r\n因为是按左边界顺序，因此<strong>往前只可能合并一个</strong>\r\n但是不知道新区间的右边界延伸到了哪里，因此对<strong>后续区间都要检查一遍是否需要合并</strong></li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<h3 id=\"合并区间-1\">合并区间</h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"keyword\">int</span> merge(vector&lt;vector&lt;<span class=\"keyword\">int</span>&amp; intervals) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> Len=intervals.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Len==0)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        </span><br><span class=\"line\">        sort(intervals.begin(),intervals.end(),cmp);</span><br><span class=\"line\">        result.push_back(intervals[0]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=1;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;Len)</span><br><span class=\"line\">        &#123;    //可连接 [1,3] [2,4]</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(intervals[i][0]&lt;=result.back()[1])</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(intervals[i][1]result.back()[1])</span><br><span class=\"line\">                    result.back()[1]=intervals[i][1];</span><br><span class=\"line\">                <span class=\"keyword\">else</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>//不可连接 </span><br><span class=\"line\">                result.push_back(intervals[i]);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> cmp(vector&lt;<span class=\"keyword\">int</span>&amp; a,vector&lt;<span class=\"keyword\">int</span>&amp; b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a[0]&lt;b[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"插入区间\">插入区间</h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"keyword\">int</span> insert(vector&lt;vector&lt;<span class=\"keyword\">int</span>&amp; intervals, vector&lt;<span class=\"keyword\">int</span>&amp; newInterval) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=0;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> Len=intervals.size();</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> IsInsert=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;Len)</span><br><span class=\"line\">        &#123;   //找到插入的位置</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(intervals[i][1]&lt;newInterval[0])</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i==Len)//插在末尾之后</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            intervals.push_back(newInterval);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> intervals;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=0;j&lt;i;j++)//无需检查的项直接插入</span><br><span class=\"line\">            result.push_back(intervals[j]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(intervals[i][0]&lt;=newInterval[1])//可以合并</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            intervals[i][0]=min(intervals[i][0],newInterval[0]);</span><br><span class=\"line\">            intervals[i][1]=max(intervals[i][1],newInterval[1]);</span><br><span class=\"line\">            result.push_back(intervals[i]);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>//插入 而不是合并</span><br><span class=\"line\">            result.push_back(newInterval);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;Len)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //插入项往后 每一项都要检查是否要往前合并,直到不用合并</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(intervals[i][0]&lt;=result.back()[1])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(result.back()[1]&lt;intervals[i][1])</span><br><span class=\"line\">                    result.back()[1]=intervals[i][1];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //出来的i往后是无法合并的项</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;Len)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result.push_back(intervals[i]);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-61","url":"/2020/02/17/LeetCode-No-61/","content":"<h1 id=\"旋转链表\"><a\r\nhref=\"https://leetcode-cn.com/problems/rotate-list\">旋转链表</a></h1>\r\n<p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p>\r\n<p>示例 1:</p>\r\n<p>输入: 1-2-3-4-5-NULL, k = 2 输出: 4-5-1-2-3-NULL 解释: 向右旋转 1 步:\r\n5-1-2-3-4-NULL 向右旋转 2 步: 4-5-1-2-3-NULL</p>\r\n<p>示例 2:</p>\r\n<p>输入: 0-1-2-NULL, k = 4 输出: 2-0-1-NULL 解释: 向右旋转 1 步:\r\n2-0-1-NULL 向右旋转 2 步: 1-2-0-NULL 向右旋转 3 步: 0-1-2-NULL 向右旋转\r\n4 步: 2-0-1-NULL</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<h5 id=\"直观移位每个节点向右移动k位\">1.\r\n直观移位——每个节点向右移动K位</h5>\r\n<p>遍历每个节点，都后向计算出该位置的新节点，即向左找K位，然后赋值过来。思路很简单。\r\n（前向计算也是可以的，甚至更利于想出优化的第二步） #####\r\n注意细节：一个是移动出了链头，要转到链尾继续移动。 #####\r\n然而链表头并没有指向链尾的指针，因此怎么从链头转到链尾呢？\r\n一个很傻的方法是把链表数值做成vector...然后在vector中找相应的数值，然后赋给当前位置...\r\n很傻，浪费空间时间= = ##### 2.\r\n我们的目标是从链头转到链尾，然而链头唯一的跳转指针next又必须连着链表，所以不太好修改头指针。但是链尾的next是空的，我们是不是可以利于一下呢？\r\n再看前向计算，每个节点向右移动K位，找到正确位置然后赋值，问题也在于怎么从链尾转移到链头。\r\n##### 3.\r\n因此我们可以把链尾连向链头，即tail-next=head，此时找位置的问题就不存在了，可以开开心心对每个节点遍历。\r\n##### 4.\r\n遍历移动完想想，移完虽然AC了，但好像憨憨的？链表顺序还是原来的样子，对链尾连着链头的循环链表来讲，移完看起来只不过是head从原节点，往前走了几步，然后停了下来选了一个新位置当head。\r\n例如 1-2-3-4-5，k=2\r\n遍历移动==》4-5-1-2-3，即head往前走了K步，停在了4的位置，然后以4为链头往后即是新链表。\r\n##### 5.\r\n因此我们不需要遍历移动每个节点，首先我们找到链尾，然后知道链尾往前K个（包括链尾本身）即是新head，找到新head时，把head前一个的next置为NULL，断开循环链表即是所需链表。\r\n当然，我们在链尾的时候同样不能往前走，因此往前找K个即相当于往后找L-K+1个（不包括链尾）。\r\n你可能会想既然是从链尾向后找L-K+1个，那不是相当于从最初的head过去找L-K个吗？</p>\r\n<p>但是没有先遍历到链尾，把链尾链头连接起来的话，我们是没有循环链表的，即使一开始从head找出新head，我们还是得再遍历到链尾，连上链头，再把新链头和新链尾断开=\r\n=\r\n当然直接从head开始找，可以沿途把新链尾和原链头都存储下来，然后遍历到链尾的时候，该连的连该断的断即可=\r\n=。</p>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * struct ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode *next;</span><br><span class=\"line\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class=\"line\"> * &#125;;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    ListNode* rotateRight(ListNode* head, int k) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ListNode* i=head;</span><br><span class=\"line\">        int L=0;</span><br><span class=\"line\">        if(head==NULL)</span><br><span class=\"line\">            return head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        while(i-next!=NULL)//找链尾</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            i=i-next;</span><br><span class=\"line\">            L++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        L++;</span><br><span class=\"line\"></span><br><span class=\"line\">        i-next=head;//首尾相连</span><br><span class=\"line\">        //缩小k</span><br><span class=\"line\">        k%=L;</span><br><span class=\"line\">        int j=0;</span><br><span class=\"line\">        //从末尾起移动L-k到达 i , i-next是新头</span><br><span class=\"line\">        k=L-k;</span><br><span class=\"line\"></span><br><span class=\"line\">        while(j&lt;k)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            i=i-next;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        head=i-next;</span><br><span class=\"line\">        i-next=NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">       </span><br><span class=\"line\"></span><br><span class=\"line\">       return head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-60","url":"/2020/02/17/LeetCode-No-60/","content":"<h1 id=\"第k个排列\"><a\r\nhref=\"https://leetcode-cn.com/problems/permutation-sequence\">第K个排列</a></h1>\r\n<p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p>\r\n<p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时,\r\n所有排列如下：</p>\r\n<p>\"123\" \"132\" \"213\" \"231\" \"312\" \"321\" 给定 n\r\n和 k，返回第 k 个排列。</p>\r\n<p>说明：</p>\r\n<p>给定 n 的范围是 [1, 9]。 给定 k 的范围是[1,  n!]。</p>\r\n<p>示例 1:</p>\r\n<p>输入: n = 3, k = 3 输出: \"213\"</p>\r\n<p>示例 2:</p>\r\n<p>输入: n = 4, k = 9 输出: \"2314\"</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<ol type=\"1\">\r\n<li><p>我一开始想到的是全排列的函数的复用，我能找到全排列难道我找不到第k个排列？但我发现全排列那里并没有按序排列，因此不可复用..</p></li>\r\n<li><p>可以复用 下一个排列\r\n的函数，毕竟一直找找到第K个就好，效率较低，没尝试。</p></li>\r\n<li><p>数学计算。全排列每个位置的每个数其实是有数学特征的。比如对 1 2\r\n3</p>\r\n<p>3.1 <strong>首位情况</strong>：\r\n肯定先是1在首位两次，然后是2首位2次，然后是3首位两次。</p>\r\n<p>3.2\r\n<strong>次位情况</strong>：除掉首位数字，剩下的数字在nums[]中，同样也是先nums[0]作为次位，出现\r\n<strong>尾部排列次数</strong> 次，然后是nums[1]...依次类推。</p>\r\n<p>综上：即我们知道每位的次数情况，比如 1 2\r\n3中，我们要找第5个排列，因为首位1在前两个， 首位2 在3 4 个，因此\r\n第5个排列必然是首位3。 再看次位，第5个排列，除去 1 2\r\n首位的四个，我们要找的是3首位的第一个，依次类推即可。\r\n即我们可以直接计算出每一位应该是什么数字。然后组成result即可。</p></li>\r\n<li><p>细节</p>\r\n<p>4.1 当前位\r\n每个数字出现次数，由尾部的全排列次数决定，而全排列是n！，因此最好能预置个阶乘结果数组。</p>\r\n<p>4.2 k/fac[n-1] 向上取整得i，此时该位应该是\r\nnums里的第i个数（下标i-1），同时对nums删除这个数。</p>\r\n<p>4.3 n==1 时，nums只剩一个数，直接连上并返回。</p></li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">getPermutation</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;   </span><br><span class=\"line\">        <span class=\"comment\">//题解数组</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> vector&lt;<span class=\"keyword\">int</span> fac = &#123;0,1,2,6,24,120,720,5040,40320,362880,3628800&#125;;</span><br><span class=\"line\">        string result(n,&#x27;0&#x27;);</span><br><span class=\"line\">        string nums(n,&#x27;0&#x27;);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=0;i&lt;n;i++)</span><br><span class=\"line\">            nums[i]=&#x27;1&#x27;+i;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=0;n0;i++)</span><br><span class=\"line\">        &#123;   </span><br><span class=\"line\">            <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> left=0;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n=2) //计算每个首位有多少个排列,跳过这些排列</span><br><span class=\"line\">            &#123;   </span><br><span class=\"line\">                left=fac[n-1];</span><br><span class=\"line\">                a=k/left;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(k%left!=0)</span><br><span class=\"line\">                    a++;</span><br><span class=\"line\">                result[i]=nums[a-1];</span><br><span class=\"line\">                k-=(a-1)*left;</span><br><span class=\"line\">                nums.erase(a-1,1);</span><br><span class=\"line\">                n--;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> //只剩一个数,直接修改返回</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result[i]=nums[0];</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;   </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-62-&-No-63-&-No-64","url":"/2020/02/17/LeetCode-No-62-64/","content":"<h1 id=\"不同路径-i-ii\"><a\r\nhref=\"https://leetcode-cn.com/problems/unique-paths-ii\">不同路径 I &amp;\r\nII</a></h1>\r\n<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start”\r\n）。</p>\r\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>\r\n<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\r\n<img\r\nsrc=\"https://upload-images.jianshu.io/upload_images/19387483-b32c8851464ff850.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"\r\nalt=\"示例\" /></p>\r\n<p>网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n\r\n的值均不超过 100。</p>\r\n<p>示例 1:</p>\r\n<p>输入: [   [0,0,0],   [0,1,0],   [0,0,0]] 输出: 2 解释: 3x3\r\n网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1.\r\n向右 - 向右 - 向下 - 向下 2. 向下 - 向下 - 向右 - 向右</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<h3 id=\"对没有障碍物的情况\">对没有障碍物的情况</h3>\r\n<ol type=\"1\">\r\n<li>小学数学思想：走到终点总共需要的操作是 m-1个向下 和\r\nn-1个向右，那么即是一个组合数问题，在总共m-1+n-1的操作步中，选取m-1个操作步放置向下操作，剩下的放向右操作。<span\r\nclass=\"math display\">\\[C_{m+n-2}^{m-1}\\]</span></li>\r\n</ol>\r\n<p>2.当然，组合数是一个阶乘运算，不太理想。再用编程思想去想，直观上是一个深度遍历，或者说回溯遍历的问题。即尝试每种可能的走路方案，走到终点则计数+1。\r\n3.说到回溯，大概率我们可以想想能不能换成动态规划？ ### 动态规划 1.\r\n首先这显然是一个依赖子问题解决的问题。考虑位置[i][j]，有两种方式可以到达这，一种是从[i-1][j]向下，一种是[i][j-1]向右。即[i][j]位置解，即依赖于上\r\n和 左 两个位置的解。</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>考虑dp[i][j]为到达[i][j]位置的总方法数，那么假如[i-1][j]能往下，则dp[i][j]+=dp[i-1][j]，同理对dp[i][j-1]。</li>\r\n<li>动态规划主体已经清晰了，再可以进一步优化空间细节。\r\n我们是按行遍历列，而每行开头的dp[i][0]仅依赖于dp[i-1][0]，即每行开头的dp可由列方向上的第一个生成。\r\n而每行的除开头外任意一个，在行方向上又仅依赖于前一个dp[i][j-1]。换句话说，我们至始至终在行方向上只需要一个O（1）的存储空间，保留行前一个的dp结果即可。\r\n<strong>即我们只需要一个O（n）的一行大小的列dp组，一个常数大小的行dp存储数即可。</strong></li>\r\n<li>注意细节，dp数组要用long类型= =int会炸</li>\r\n</ol>\r\n<h3\r\nid=\"no.64给每个位置加了权值要求走到右下角的权值累计和最小\">No.64给每个位置加了权值，要求走到右下角的权值累计和最小</h3>\r\n<ol type=\"1\">\r\n<li>同样也是动态规划，到任意一位置的最小权值，必然是由[i-1][j] 和\r\n[i][j-1]的最小值发展而来，以此类推。</li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uniquePathsWithObstacles</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">int</span>&amp; obstacleGrid)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//动态规划</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> m=obstacleGrid.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n=obstacleGrid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">long</span> temp[n];<span class=\"comment\">//注意要用long 有样例爆int....</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(obstacleGrid[<span class=\"number\">0</span>][<span class=\"number\">0</span>]!=<span class=\"number\">1</span>)</span><br><span class=\"line\">            temp[<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;n;i++)<span class=\"comment\">//首行处理</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(obstacleGrid[<span class=\"number\">0</span>][i]!=<span class=\"number\">1</span>)</span><br><span class=\"line\">                temp[i]=temp[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                temp[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> row=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(;row&lt;m;row++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(obstacleGrid[row][<span class=\"number\">0</span>]==<span class=\"number\">1</span>)<span class=\"comment\">//首列障碍物处理</span></span><br><span class=\"line\">                temp[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;n;i++)</span><br><span class=\"line\">            &#123;   </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(obstacleGrid[row][i]==<span class=\"number\">1</span>)</span><br><span class=\"line\">                    temp[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    temp[i]+=temp[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> temp[n<span class=\"number\">-1</span>];    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-65","url":"/2020/02/17/LeetCode-No-65/","content":"<h1 id=\"有效数字\"><a\r\nhref=\"https://leetcode-cn.com/problems/valid-number\">有效数字</a></h1>\r\n<p>验证给定的字符串是否可以解释为十进制数字。</p>\r\n<p>例如:</p>\r\n<p>\"0\" = true \" 0.1 \" = true \"abc\" = false \"1 a\" = false \"2e10\" = true \"\r\n-90e3   \" = true \" 1e\" = false \"e3\" = false \" 6e-1\" = true \"\r\n99e2.5 \" = false \"53.5e93\" = true \" --6 \" = false \"-+3\" = false\r\n\"95a54e53\" = false</p>\r\n<p>说明: 我们有意将问题陈述地比较模糊。在实现代码之前，你应当事先思考所有可能的情况。这里给出一份可能存在于有效十进制数字中的字符列表：</p>\r\n<p>数字 0-9 指数 - \"e\" 正/负号 - \"+\"/\"-\" 小数点 - \".\"\r\n当然，在输入中，这些字符的上下文也很重要。</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<ol type=\"1\">\r\n<li><p>这题我感觉是一种代码实现问题，考查考虑问题是否全面？\r\n没有什么特别的算法思想，想清楚判定数字的流程，然后一路判断下来即可。但是要实现你原计划的流程，还是要好好打理一下自己的代码。</p></li>\r\n<li><p><strong>字符特征</strong> ： 2.1\r\n可能包含”0~9“，”e“，”.“，“+”，“-”，” “。 2.2 ”e”\r\n允许出现的次数？还要考虑“e”后是否允许出现”.\" ，\r\n”+“，”-“？是否允许作为开头结尾？前面是否一定要有数字？ 2.3 “.\"\r\n允许出现的次数？ ”.\" 后是否允许出现 “e\" , \"+ \" ,\"-\r\n\"？是否允许作为开头结尾 ？前面是否一定要有数字？ 2.4 ”+“\r\n，”-“，最多出现两次，一次在幂，一次在指数，且一定位于其他符号之前，且不能作为结尾\r\n2.5 ”0~9“ ，”0“是否允许在幂 或者 指数 或者 小数部分\r\n的首部，是否允许”0“结尾的小数部分。 2.6 ” “，只能作为开头结尾。 2.7\r\n整个数，必须要有数字出现。</p></li>\r\n<li><p><strong>判断流程</strong> 3.1 数前空格清除 3.2 首位判断+ -\r\n号，然后进入幂部分/整数部分 3.3 正常判断数字，遇到 ”.\" 进入小数部分，“e”\r\n进入指数部分，其余false。 3.4.1\r\n小数部分，标记小数点已经用过，不能再出现，其余照常。 3.4.2\r\n指数部分，检查e前是否有数字，”+“\r\n”-“可以再用，重置”+-“的标志位，小数点不能用了，小数点标志位置false，当然e也不能再用了。继续照常检查数字。\r\n3.5 检查到” “，”\r\n“只能作为末尾出现，因此直接跳出主体循环，进入尾部判断环节。 3.6\r\n数的结尾检查，不能是”e\", \"+ \" \"-\" ，但可以是“ . ”。\r\n3.7尾部清洗，一路检查是否是“ ”，遇到个不是的则false。 3.8\r\n检查全部通过，但它也要有数字才可能是数！return HasNum；</p></li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isNumber</span><span class=\"params\">(string s)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;   <span class=\"comment\">//0开头结尾 true</span></span><br><span class=\"line\">        <span class=\"comment\">//多个e  false</span></span><br><span class=\"line\">        <span class=\"comment\">//e左右两边要有数 </span></span><br><span class=\"line\">        <span class=\"comment\">//指数不能为小数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> UsedSign=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> UsedCom=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> UsedExp=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> HasNum=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//首部空格清除</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;s.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i]!=<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//首位判断符号位</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&lt;s.<span class=\"built_in\">size</span>() &amp;&amp; (s[i]==<span class=\"string\">&#x27;+&#x27;</span> || s[i]==<span class=\"string\">&#x27;-&#x27;</span>) )<span class=\"comment\">//符号</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            UsedSign=<span class=\"literal\">true</span>;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//主体判断</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(;i&lt;s.<span class=\"built_in\">size</span>();i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i]=<span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; s[i]&lt;=<span class=\"string\">&#x27;9&#x27;</span>)</span><br><span class=\"line\">            &#123;   </span><br><span class=\"line\">                HasNum=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;+&#x27;</span> || s[i]==<span class=\"string\">&#x27;-&#x27;</span>)<span class=\"comment\">//主要用来判断指数的符号</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(UsedSign==<span class=\"literal\">false</span> &amp;&amp; s[i<span class=\"number\">-1</span>]==<span class=\"string\">&#x27;e&#x27;</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    UsedSign=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;.&#x27;</span>)<span class=\"comment\">//小数点</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(UsedCom==<span class=\"literal\">false</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    UsedCom=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;e&#x27;</span>)<span class=\"comment\">//指数符号</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(UsedExp==<span class=\"literal\">false</span> &amp;&amp; HasNum==<span class=\"literal\">true</span>) <span class=\"comment\">//e前需有数字</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    UsedExp=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                    UsedSign=<span class=\"literal\">false</span>;<span class=\"comment\">//重置符号状态位,指数也可以带符号</span></span><br><span class=\"line\">                    UsedCom=<span class=\"literal\">true</span>;<span class=\"comment\">//指数不能是小数</span></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27; &#x27;</span>) <span class=\"comment\">//尾部空格</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i<span class=\"number\">-1</span>]==<span class=\"string\">&#x27;e&#x27;</span> ||s[i<span class=\"number\">-1</span>]==<span class=\"string\">&#x27;+&#x27;</span> || s[i<span class=\"number\">-1</span>]==<span class=\"string\">&#x27;-&#x27;</span>)<span class=\"comment\">//e + -结尾 不行</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;s.<span class=\"built_in\">size</span>())<span class=\"comment\">//尾部空格清除</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i]!=<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> HasNum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-68","url":"/2020/02/17/LeetCode-No-68/","content":"<h1 id=\"文本左右对齐\"><a\r\nhref=\"https://leetcode-cn.com/problems/text-justification\">文本左右对齐</a></h1>\r\n<p>给定一个单词数组和一个长度 maxWidth，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。</p>\r\n<p>你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 '\r\n' 填充，使得每行恰好有 maxWidth 个字符。</p>\r\n<p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p>\r\n<p>文本的最后一行应为左对齐，且单词之间不插入额外的空格。</p>\r\n<p>说明:</p>\r\n<p>单词是指由非空格字符组成的字符序列。 每个单词的长度大于\r\n0，小于等于 maxWidth。 输入单词数组 words 至少包含一个单词。 示例:</p>\r\n<p>输入: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\",\r\n\"justification.\"] maxWidth = 16 输出: [    \"This    is    an\",  \r\n \"example  of text\",    \"justification.  \"] 示例 2:</p>\r\n<p>输入: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\r\nmaxWidth = 16 输出: [   \"What   must   be\",   \"acknowledgment  \",  \r\n\"shall be        \"] 解释: 注意最后一行的格式应为 \"shall be \" 而不是\r\n\"shall be\",   因为最后一行应为左对齐，而不是左右两端对齐。<br />\r\n第二行同样为左对齐，这是因为这行只包含一个单词。 示例 3:</p>\r\n<p>输入: words =\r\n[\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\r\n  \"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]\r\nmaxWidth = 20 输出: [   \"Science  is  what we\", \"understand      well\",\r\n  \"enough to explain to\",   \"a  computer.  Art is\",   \"everything  else\r\n we\",   \"do                  \"]</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<ol type=\"1\">\r\n<li>也是没有突出思路的困难题....考验代码实现细节的功底。 ####\r\n进入每行一轮的循环：</li>\r\n<li>计算每行能最多放多少个单词，贪心尝试，能放多少放多少= = <strong>2.1\r\n注意每个单词后面要留个位置给空格</strong> <strong>2.2\r\n同时记得保存个末行标志位，以便后续末行特殊处理</strong> <strong>2.3\r\n这里用到了两个指针，一个指向起始单词，一个探索结束单词</strong></li>\r\n<li>计算每行的所需空格数，用vector存储每空应该有多少个空格，注意空格多了先在左边填，因此可以实现类似个抽屉原理，先把能平均分的部分分了，然后多的从前往后填。\r\n<strong>3.1\r\n注意最后一个单词后面没有空格，计算每空空格数时可以先排除它，前面的空格全分完了，在vector后面push_back(0)即可</strong>\r\n<strong>3.2\r\n注意该行一个单词的时候需要特殊处理，把所有空格都填在vector[0]即可。</strong></li>\r\n<li>末行特殊处理，末行单词间空格数固定为1，最后一个单词之后的空格数为所有剩余空格。</li>\r\n<li>循环填入单词，填一个单词+vector[i]数量的空格。</li>\r\n<li>填入该行结果</li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;string fullJustify(vector&lt;string&amp; words, <span class=\"keyword\">int</span> maxWidth) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vector&lt;string  result;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> wordsFlag=0;//处理到的最远的单词</span><br><span class=\"line\">        <span class=\"keyword\">int</span> StartFlag=0;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> SpaceNum=0;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> wordsNum=0;//每行单词数</span><br><span class=\"line\">        <span class=\"keyword\">int</span> CurrentLength=0;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> isLast=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span> spaces;//存储每行每处的空格数</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(wordsFlag&lt;words.size())//行循环</span><br><span class=\"line\">        &#123;   </span><br><span class=\"line\">            StartFlag=wordsFlag;</span><br><span class=\"line\">            wordsNum=0;</span><br><span class=\"line\">            CurrentLength=0;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(CurrentLength&lt;maxWidth)//判断一行最多能放几个单词</span><br><span class=\"line\">            &#123;   </span><br><span class=\"line\">                CurrentLength+=words[wordsFlag].size();</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(CurrentLength+wordsNummaxWidth)//超过了 退掉最后一次</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    CurrentLength-=words[wordsFlag].size();</span><br><span class=\"line\">                    // wordsFlag--; wordsFlag 停在下一行第一个</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                wordsNum++;</span><br><span class=\"line\">                wordsFlag++;</span><br><span class=\"line\"></span><br><span class=\"line\">                //末行判定</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(wordsFlag=words.size())</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    isLast=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            //计算所需空格数</span><br><span class=\"line\">            SpaceNum=maxWidth-CurrentLength;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(wordsNum1)//1判断，wordsNum-1=0时不能当除数</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                 spaces= vector&lt;<span class=\"keyword\">int</span>(wordsNum-1,SpaceNum/(wordsNum-1));//space有wordsNum-1处，每处平均有SpaceNum/(wordsNum-1)个</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = 0; j &lt; SpaceNum%(wordsNum-1); ++j)//多的从前往后填，填多少是多少，保证左边的空格大于等于右边的</span><br><span class=\"line\">                        spaces[j] += 1;</span><br><span class=\"line\">                spaces.push_back(0);//最后一个数不要空格</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                spaces= vector&lt;<span class=\"keyword\">int</span>(1,SpaceNum);</span><br><span class=\"line\"></span><br><span class=\"line\">            //末行处理</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isLast==<span class=\"literal\">true</span> &amp;&amp; wordsNum1)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> j= 0;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (; j &lt;wordsNum-1; j++)</span><br><span class=\"line\">                    spaces[j]=1;//末行每处空都只有一个空格，最后是剩余空格，也是服了= =</span><br><span class=\"line\">                spaces[j]=SpaceNum-(wordsNum-1);//剩余空格</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">            string temp;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j=0;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(StartFlag&lt;wordsFlag)</span><br><span class=\"line\">            &#123;   </span><br><span class=\"line\">                //填充单词</span><br><span class=\"line\">                temp+=words[StartFlag];//填词</span><br><span class=\"line\">                //填充空格</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=0;i&lt;spaces[j];i++)//填空格</span><br><span class=\"line\">                    temp.push_back(&#x27; &#x27;);</span><br><span class=\"line\">                StartFlag++;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            result.push_back(temp);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-69-（牛顿迭代法）","url":"/2020/02/17/LeetCode-No-69-%EF%BC%88%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89/","content":"<h1 id=\"x的平方根\"><a\r\nhref=\"https://leetcode-cn.com/problems/sqrtx\">x的平方根</a></h1>\r\n<p>实现 int sqrt(int x) 函数。</p>\r\n<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>\r\n<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>\r\n<p>示例 1:</p>\r\n<p>输入: 4 输出: 2</p>\r\n<p>示例 2:</p>\r\n<p>输入: 8 输出: 2 说明: 8 的平方根是 2.82842...,  \r\n由于返回类型是整数，小数部分将被舍去。</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<ol type=\"1\">\r\n<li>首先直接计算平方根不太现实，所以这是一个在有序的1~x中查找出平方根的问题。</li>\r\n<li>查找有序整数中的特定值，正常思路即<strong>二分查找</strong>，实现也简单。</li>\r\n<li><strong>递归缩小求解：</strong> <span\r\nclass=\"math display\">\\[\\sqrt{x}=2*\\sqrt{\frac{x}{4}}\\]</span>\r\n因此可以递归找到易解的小x，然后再回溯整合到原x。\r\n注意为什么选择2作为系数进行递归呢？\r\n——x缩小和放大2的倍数，可以通过位操作实现，效率极高。</li>\r\n</ol>\r\n<p>递归式为：<code>mySqrt(x)=mySqrt(x2)&lt;&lt;1</code> 4.\r\n针对这个计算平方根的特定问题，有 <strong>牛顿迭代法</strong>：\r\n<strong>牛顿法</strong>（英语：Newton's\r\nmethod）又称为<strong>牛顿-拉弗森方法</strong>（英语：Newton-Raphson\r\nmethod），它是一种在实数域和复数域上近似求解方程的方法。方法使用函数<span\r\nclass=\"math inline\">\\(f(x)\\)</span>\r\n的泰勒级数的前面几项来寻找方程的根。</p>\r\n<p><span\r\nclass=\"math display\">\\[x_{k+1}=\frac{1}{2}[x_k+\frac{x}{x_k}]\\]</span>\r\n根据精度要求，<span class=\"math inline\">\\(x_k\\)</span>和<span\r\nclass=\"math inline\">\\(x_{k+1}\\)</span>收敛后差距小于1即可返回结果。</p>\r\n<p><strong>迭代求解示意</strong>：<img\r\nsrc=\"https://upload-images.jianshu.io/upload_images/19387483-cf905b78f3551337.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"\r\nalt=\"迭代示意图，图源 (https://leetcode-cn.com/problems/sqrtx/solution/niu-dun-die-dai-fa-by-loafer/)\" /></p>\r\n<p>如上图所示，想求<span\r\nclass=\"math inline\">\\(\\sqrt{a}\\)</span>，图示a=2\r\n先随便取xi=4，然后找到过(xi,yi)的切线，且<span\r\nclass=\"math inline\">\\(f(x)=x^2-a\\)</span>的导数是<span\r\nclass=\"math inline\">\\(2x\\)</span> 即切线方程<span\r\nclass=\"math inline\">\\(f(x)-(x_i^2-a)=2x_i(x-xi)\\)</span>\r\n显而易见这个切线与x轴的交点得$x_{i+1}=\frac\r\n{2x_i<sup>2-(x_i</sup>2-a)}{2x_i}= \frac{1}{2} (x_i+\frac{a}{x_i}) $\r\n即得<span class=\"math inline\">\\(x_{i+1}\\)</span>比<span\r\nclass=\"math inline\">\\(x_{i}\\)</span>更接近解<span\r\nclass=\"math inline\">\\(\\sqrt{a}\\)</span>。</p>\r\n<h1 id=\"牛顿迭代题解代码\">牛顿迭代题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mySqrt</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//牛顿迭代</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x&lt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">        <span class=\"comment\">//注意long类型</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> last=x/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> cur =(last+x/last)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"built_in\">abs</span>(last-cur)=<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;   </span><br><span class=\"line\">            last=cur;</span><br><span class=\"line\">            cur=(cur +x/ cur) / <span class=\"number\">2.0</span> ;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur&lt;=x/cur)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-75","url":"/2020/02/17/LeetCode-No-75/","content":"<h1 id=\"颜色分类\"><a\r\nhref=\"https://leetcode-cn.com/problems/sort-colors/\">颜色分类</a></h1>\r\n<p>给定一个包含红色、白色和蓝色，一共 <em>n </em>个元素的数组，<strong><a\r\nhref=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\">原地</a></strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>\r\n<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>\r\n<p><strong>示例:</strong></p>\r\n输入:** [2,0,2,1,1,0] <strong>输出:</strong> [0,0,1,1,2,2]\r\n</pre\r\n\r\n**进阶：**\r\n\r\n*   一个直观的解决方案是使用计数排序的两趟扫描算法。\r\n    首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。\r\n*   你能想出一个仅使用常数空间的一趟扫描算法吗？\r\n\r\n# 题目分析\r\n1. 相同元素相邻，换句话说即分区存放，一个颜色一个区域，但因为这里颜色使用0 ，1，2表示，即对一个012的无序序列进行排序，变成000...111....2222的顺序。\r\n正常排序算法都适用，只不过这里注意仅有三种可能的顺序值，可以有特殊做法。\r\n2. 对于一个元素，我们将他分区时，肯定是插在区域的末尾，换句话说，我们只要保留每个区域的末尾下标，插入的时候交换过去就可以了。\r\n三个区域，其实我们只要确定了两个区域即可确定第三个区域，因为0区域在最左边，2区域在最右边，方便程序定位，因此取0 2 的末尾指针保留下来。\r\n3. 确定了双指针确定区域，那么怎么进行遍历处理呢？确定了分类移动的位置，即cur遍历每一位的数值，分类处理遇到0放左边，遇到2放右边，02放好了，则1的区域也放好了。\r\n\r\n#####     针对cur的分类处理：\r\n1. 是0，则和0的flag ，left交换值，同时left++。此时cur获取的是之前的left交换过来的值。我们知道我们换过去的处理好了，那么这个换过来的还需要处理吗？目前还不知道，先看2的情况的处理。\r\n\r\n2.  是2，则和2的flag，right交换，同时right--。同样，此时cur获取了交换过来的值，由于这个值必然是在cur右边（因为它是原right，即cur的右边界），则cur肯定没有遍历过这个值。\r\n同时因为它在cur右边，它也不可能是交换过去的，因为交换过去的值肯定都在0 2 区域里了。\r\n因此这个值是野生的，所以cur在此停留，继续处理这个交换过来的值。\r\n\r\n3. 是1，因为我们把0 2 排序好，1的区域自然就出来了，因此1直接不处理，过就好了\r\n\r\n4. 那么看看0的情况交换过来的值？首先这个值的位置关系，即原left是在cur左边还是右边呢？\r\n\r\n    **只有当left会在cur右边时**，left指向的才可能是cur没处理过的，但此时cur在left内部？那cur就是把一个0换到了外边，把一个乱序的换进了0的内部，内鬼毫无意义。\r\n\r\n      **当left在cur左边时，即left指向的必定经过了cur的洗礼**，而且它必不是原来在后面被换到前面的，因为交换的肯定在left内部去了。所以它原值就是在那，且经过处理不用动，因此从left换到现在的cur之后，也是同样的处理，也不用动它，cur++拜拜嘞。\r\n\r\n5. 当cur遇到right，即到达2的边界，则说明不需要处理了，结束。\r\n\r\n# 题解代码\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sortColors</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&amp; nums)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right=nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cur=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur&lt;=right)</span><br><span class=\"line\">        &#123;   </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[cur]==<span class=\"number\">0</span>)<span class=\"comment\">//这个数字是0，移动0区域内，</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(nums[cur],nums[left]);</span><br><span class=\"line\">                <span class=\"comment\">//假如curleft，left交换过来的值肯定已经被处理过了，但是处理时产生交换，原left指向的，一定是不用处理的吗？</span></span><br><span class=\"line\">                <span class=\"comment\">//jeromememory：准确的说 cur 如果 与 p0 不是指向同一个索引，那 cur 指向的索引值如果发生交换，那交换过来的一定是 1（原因是只有当遍历过的节点有1，p0 和 cur 才不会同步），而 如果索引是 1 刚好也就不用有任何操作，所以可以直接++。</span></span><br><span class=\"line\">                <span class=\"comment\">//假如cur==left==0，没啥好说的，下一个</span></span><br><span class=\"line\">                <span class=\"comment\">//假如cur&lt;left, 可能吗？cur++的机会 = left++的机会</span></span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[cur]==<span class=\"number\">2</span>)<span class=\"comment\">//这个数字是2，移到2区域内</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(nums[cur],nums[right]);</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">                <span class=\"comment\">//交换过来的值，是右边过来的，cur没处理过，因此还需要对这个位置处理，--抵消++，位置不变</span></span><br><span class=\"line\">                cur--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-84","url":"/2020/02/17/LeetCode-No-84/","content":"<h1 id=\"最大矩形\"><a\r\nhref=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram\">最大矩形</a></h1>\r\n<p>给定 n\r\n个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1\r\n。</p>\r\n<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。 <img\r\nsrc=\"https://upload-images.jianshu.io/upload_images/19387483-c76a635ea91ad61e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"\r\nalt=\"LeetCode图\" /></p>\r\n<p>以上是柱状图的示例，其中每个柱子的宽度为\r\n1，给定的高度为 [2,1,5,6,2,3]。 <img\r\nsrc=\"https://upload-images.jianshu.io/upload_images/19387483-4198f8b5095d233b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"\r\nalt=\"LeetCode图\" /></p>\r\n<p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p>\r\n<p> </p>\r\n<p>示例: 输入: [2,1,5,6,2,3] 输出: 10</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<ol type=\"1\">\r\n<li><p>想要知道最大矩形，肯定先要知道每根柱子怎么形成矩形的</p></li>\r\n<li><p>对柱子 i，高度为 hi，以i为中心往两边扩展，只要碰到的柱子高度\r\nHj=hi，那么形成的矩形必然是以 hi 为高构造。</p></li>\r\n<li><p>假如 Hj&lt;hi，那么这个矩形的高就是新的 Hj，而这个 Hj\r\n构造的矩形必然会出现在以柱子 j\r\n为中心扩展的时候，所以不必考虑降低现在的高度。</p></li>\r\n<li><p>所以对柱子 i\r\n的扩展，往左右两边找，碰到矮的停下来，确定两边边界，边界高度\r\nHj=hi，这个即是这个 i 自己能做出来的最大矩形。\r\n可以双重循环扫描，但不是重点，这里学习题解大神的栈思路。 #\r\n题解分析：栈保留边界</p></li>\r\n<li><p>首先有一层主循环遍历所有柱子，从左到右，当前柱子为 i。</p></li>\r\n<li><p>我们目的是要找i的两个边界，因为是从左到右扫描，即我们可以顺手找到\r\ni 的右边界。只要扫描时碰到比 i 矮的就知道这个是右边界了。</p></li>\r\n<li><p>但是碰到比 i 高或者相等的柱子 j 怎么办呢？j 不会是 i 的边界\r\n，但我们也要找 j 的边界。因此我们要把未处理的 i 和 j 都留下来。</p></li>\r\n<li><p>而继续往后找的时候， i 的右边界x 必然是 j 的右边界或者之外\r\n（hi&lt;=hj) 。 <strong>因此对于下一个柱子 x：</strong> 4.1\r\n假如我们先判断 x 是不是 i 的边界，假如它是，它也不一定就是 j 的右边界\r\n，我们还得用 x 和 j 比较一次。假如它不是，它也不一定就不是 j\r\n的右边界，还是得 x j 比较一次，<strong>所以先判定 i\r\n的边界很鸡肋</strong>。 4.2 假如先判断 x 是不是更高的 j\r\n的右边界，假如它不是，那么肯定也不是 i\r\n的边界，假如它是，那么可以继续判定是不是更矮的 i 的右边界。</p></li>\r\n<li><p>因此，我们的扫描过程是这样的，<strong>从左到右</strong>，且保留的柱子<strong>高度递增</strong>（因为只要更高的才会保留，否则是作为右边界判定）。\r\n且判定的顺序是高的在前，低的在后，即<strong>新的在前，旧的在后</strong>，因此<strong>保留柱子的数据结构是：栈</strong>。\r\n因此遇到一个新柱子，与栈顶比较，更高则继续压栈。更低则是栈顶的右边界，然后栈顶出栈，判定是不是下一个栈顶的右边界。</p></li>\r\n<li><p>右边界解决了，我们还需要确定每个柱子 i 的左边界，左边界肯定在左边\r\n， 并且左边界也要比 i 矮，而我们的栈又是高度递增的=\r\n=+显然，我们可以利用出栈过程。 在栈顶确定了右边界，然后出栈的时候： 6.1\r\n下面的那个柱子高度大于【栈顶右边界高度Hr】，那么这个柱子不是左边界，而可以组成这个矩形（因为有右边界后，矩形最低高度是Hr，只要高于Hr，都是）我们继续出栈寻找即可。\r\n6.2 即一直出栈，直到出了个高度小于等于【栈顶右边界高度Hr】的柱子 x\r\n，那么 x 就是上面这个矩形的左边界。\r\n出栈到边界了怎么办？在数组开头预备一个0作为栈底标志位结束出栈。\r\n同样压栈到边界了怎么办？在数组结尾预备一个0作为启动出栈的标志位。</p></li>\r\n<li><p>此时 i 的左右边界都能找到，高度为 i ，计算面积。</p></li>\r\n</ol>\r\n<h4\r\nid=\"总之精髓在于出栈过程从栈顶的右边界一直出栈到满足的左边界中间这些柱子形成当前最大矩形\">总之精髓在于出栈过程，从栈顶的右边界，一直出栈到满足的左边界，中间这些柱子形成当前最大矩形。</h4>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">largestRectangleArea</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&amp; heights)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//题解学习</span></span><br><span class=\"line\">        std::stack&lt;<span class=\"keyword\">int</span> Lefts;</span><br><span class=\"line\">        heights.insert(heights.begin(),0);//补0作为边界判断</span><br><span class=\"line\">        heights.insert(heights.end(),0);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result=0;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=0;i&lt;heights.size();i++)</span><br><span class=\"line\">        &#123;   </span><br><span class=\"line\">            //栈单调递增，当碰到一个i 比栈顶矮，则它必是栈顶的右边界</span><br><span class=\"line\">            //再逐渐出栈，每次出栈循环，都是栈顶作为中心，而栈单调递增，栈顶下面一个更矮的必是栈顶的左边界，左右边界确定，则栈顶位置能形成的矩阵面积可计算完毕。</span><br><span class=\"line\">            //直到栈顶比 i 还矮，那 i 就不能作为右边界了 ，栈顶此时的右边界也找不到，则 i 入栈待命当左边界，然后<span class=\"keyword\">for</span>下一轮</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(Lefts.empty()!=<span class=\"literal\">true</span> &amp;&amp; heights[Lefts.top()]heights[i])//找到比栈顶矮的柱子，即栈顶柱子的右边界</span><br><span class=\"line\">            &#123;     </span><br><span class=\"line\">                temp=Lefts.top();</span><br><span class=\"line\">                Lefts.pop();</span><br><span class=\"line\">                result = max(result, (i - Lefts.top()-1)*heights[temp]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Lefts.push(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-72","url":"/2020/02/17/LeetCode-No-72/","content":"<h1 id=\"编辑距离\"><a\r\nhref=\"https://leetcode-cn.com/problems/edit-distance\">编辑距离</a></h1>\r\n<p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2\r\n所使用的最少操作数 。</p>\r\n<p>你可以对一个单词进行如下三种操作：</p>\r\n<p>插入一个字符 删除一个字符 替换一个字符 示例 1:</p>\r\n<p>输入: word1 = \"horse\", word2 = \"ros\" 输出: 3 解释: horse - rorse (将\r\n'h' 替换为 'r') rorse - rose (删除 'r') rose - ros (删除 'e')</p>\r\n<p>示例 2:</p>\r\n<p>输入: word1 = \"intention\", word2 = \"execution\" 输出: 5 解释:\r\nintention - inention (删除 't') inention - enention (将 'i' 替换为 'e')\r\nenention - exention (将 'n' 替换为 'x') exention - exection (将 'n'\r\n替换为 'c') exection - execution (插入 'u')</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<ol type=\"1\">\r\n<li>和字符串匹配之类的差不多，都是\r\n<strong>动态规划</strong>，观察子问题状态，考虑转移状态</li>\r\n<li>动态规划 dp[i][j]状态</li>\r\n<li><strong>对比dp[i-1][j]状态时</strong>，只需要把i代表的字母删除即可回到dp[i-1][j]</li>\r\n<li><strong>对比dp[i][j-1]状态</strong>，因为[i][j-1]代表word1 i位 和\r\nword2 j-1 位匹配，因此word2还多个j位没有匹配到，对word1增加操作即可</li>\r\n<li><strong>对比dp[i-1][j-1]状态</strong>，双方都多出个第i位和第j位，如果这两个相等，则和dp[i-1][j-1]一样，不相等，则需要一次替换操作。</li>\r\n</ol>\r\n<h1 id=\"dp题解代码\">dp题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minDistance</span><span class=\"params\">(string word1, string word2)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//动态规划  dp[i][j]状态</span></span><br><span class=\"line\">        <span class=\"comment\">//对比dp[i-1][j]状态时，只需要把i代表的字母删除即可回到dp[i-1][j]</span></span><br><span class=\"line\">        <span class=\"comment\">//对比dp[i][j-1]状态，因为[i][j-1]代表word1 i位 和 word2 j-1 位匹配，因此word2还多个j位没有匹配到，对word1增加操作即可</span></span><br><span class=\"line\">        <span class=\"comment\">//对比dp[i-1][j-1]状态，双方都多出个第i位和第j位，如果这两个相等，则和dp[i-1][j-1]一样，不相等，则需要一次替换操作。</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> dp[word1.<span class=\"built_in\">size</span>()+<span class=\"number\">1</span>][word2.<span class=\"built_in\">size</span>()+<span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=word1.<span class=\"built_in\">size</span>();i++)</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>]=i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=word2.<span class=\"built_in\">size</span>();i++)</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i]=i;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=word1.<span class=\"built_in\">size</span>();i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j=<span class=\"number\">1</span>;j&lt;=word2.<span class=\"built_in\">size</span>();j++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(word1[i<span class=\"number\">-1</span>]==word2[j<span class=\"number\">-1</span>])</span><br><span class=\"line\">                    dp[i][j]=<span class=\"number\">1</span>+<span class=\"built_in\">min</span>( <span class=\"built_in\">min</span>(dp[i<span class=\"number\">-1</span>][j],dp[i][j<span class=\"number\">-1</span>]),dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]<span class=\"number\">-1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    dp[i][j]=<span class=\"number\">1</span>+<span class=\"built_in\">min</span>( <span class=\"built_in\">min</span>(dp[i<span class=\"number\">-1</span>][j],dp[i][j<span class=\"number\">-1</span>]),dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[word1.<span class=\"built_in\">size</span>()][word2.<span class=\"built_in\">size</span>()];                    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-86","url":"/2020/02/17/LeetCode-No-86/","content":"<h1 id=\"分隔链表\"><a\r\nhref=\"https://leetcode-cn.com/problems/partition-list/\">分隔链表</a></h1>\r\n<p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x\r\n的节点都在大于或等于 x 的节点之前。</p>\r\n<p>你应当保留两个分区中每个节点的初始相对位置。</p>\r\n<p>示例:</p>\r\n<p>输入: head = 1-4-3-2-5-2, x = 3 输出: 1-2-2-4-3-5</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<ol type=\"1\">\r\n<li>直接思路是第一次遍历找到中间节点，并且划分为左右两边，然后再重新遍历链表元素，按大小分类到两边去。</li>\r\n<li>但这样要来回遍历链表，还要不停的交换节点很麻烦，换个<strong>逆向思路：既然是一个链表分成两个区域，不就相当于两个链表合成一个区域</strong></li>\r\n<li>因此，即构造两个链表，遍历原链表元素，分类接在两个链表上。</li>\r\n<li>遍历结束合成两个链表。</li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * struct ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode *next;</span><br><span class=\"line\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class=\"line\"> * &#125;;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    ListNode* partition(ListNode* head, int x) </span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        //逆向想问题，既然分成了两段，那也可以是两段连成了一段</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode lefthead(0);</span><br><span class=\"line\">        ListNode* left=&amp;lefthead;</span><br><span class=\"line\">        ListNode righthead(0);</span><br><span class=\"line\">        ListNode* right=&amp;righthead;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        while(head!=NULL)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">           if(head-val&lt;x)</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">               left-next=head;</span><br><span class=\"line\">               left=left-next;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           else</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">               right-next=head;</span><br><span class=\"line\">               right=right-next;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           head=head-next;</span><br><span class=\"line\"></span><br><span class=\"line\">          </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        right-next=NULL;//注意赋值null，否则下面的链表连接会无限循环超时</span><br><span class=\"line\">        left-next=righthead.next;</span><br><span class=\"line\">        return lefthead.next;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"LeetCode-No-92","url":"/2020/02/17/LeetCode-No-92/","content":"<h1 id=\"反转链表\"><a\r\nhref=\"https://leetcode-cn.com/problems/reverse-linked-list-ii\">反转链表</a></h1>\r\n<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>\r\n<p>说明: 1 ≤ m ≤ n ≤ 链表长度。</p>\r\n<p>示例:</p>\r\n<p>输入: 1-2-3-4-5-NULL, m = 2, n = 4 输出: 1-4-3-2-5-NULL</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<ol type=\"1\">\r\n<li>反转一段区域，首先肯定想到是一个一个反转 比如2-3-4 先3插前面去 3-2-4\r\n，然后4插前面去 4-3-2</li>\r\n<li>怎么移过去呢？观察这个局部链表，可以知道我们每次把要处理的插入到链表头即可。</li>\r\n<li>因此保留一个pre指向反转区域头部，例如示例中是1</li>\r\n<li>遍历反转区域元素current，令temp=current-next保存下位，处理好current的前后指向关系，然后把temp插入到链表头，即pre-next即可。</li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * struct ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode *next;</span><br><span class=\"line\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class=\"line\"> * &#125;;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    ListNode* reverseBetween(ListNode* head, int m, int n) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int count=1;</span><br><span class=\"line\">        ListNode* temp;</span><br><span class=\"line\">        ListNode* current;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode First(0);</span><br><span class=\"line\">        First.next=head;</span><br><span class=\"line\">        ListNode* pre=&amp;First;</span><br><span class=\"line\">        while(count&lt;m)//pre停在原第m-1个数</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            pre=pre-next;</span><br><span class=\"line\">            count++;   </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current=pre-next;//current指向当前处理数</span><br><span class=\"line\">        </span><br><span class=\"line\">        while(count&lt;n)//count计数位，每次将current-next插入到pre-next，相当于利用pre做了个栈，[1,2,3,4,5]为例 current=2 pre=1</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            temp=current-next;//保留current后节点，temp=3</span><br><span class=\"line\">            current-next=temp-next;//2-next=4</span><br><span class=\"line\">            temp-next=pre-next;//逆转temp和current的前后关系。3-next=2</span><br><span class=\"line\">            pre-next=temp;//更新pre的后节点，1-next=3</span><br><span class=\"line\">            //current</span><br><span class=\"line\">            count++;//完成[1,3,2,4,5]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return First.next;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"MarkDown简洁手册","url":"/2020/07/17/MarkDown%E7%AE%80%E6%B4%81%E6%89%8B%E5%86%8C/","content":"<h1 id=\"first-title-一级标题-markdown示例\">First title 一级标题\r\nMarkDown示例</h1>\r\n<p><code># First title 一级标题  MarkDown示例</code></p>\r\n<h2 id=\"second-title-二级标题\">Second title 二级标题</h2>\r\n<p><code>## Second title 二级标题</code></p>\r\n<h3 id=\"third-title-三级标题\">Third title 三级标题</h3>\r\n<p><code>### Third title 三级标题</code></p>\r\n<h4 id=\"fourth-四级标题\">Fourth 四级标题</h4>\r\n<p><code>#### Fourth 四级标题</code></p>\r\n<h5 id=\"fifth-五级标题-下面是分割线\">Fifth 五级标题 下面是分割线</h5>\r\n<p><code>##### Fifth 五级标题 下面是分割线</code></p>\r\n<hr />\r\n<p><code>---</code></p>\r\n<h2 id=\"正文书写\">1. 正文书写</h2>\r\n<p><code>## 1. 正文书写</code></p>\r\n<p>标准正文示例.</p>\r\n<p><code>标准正文示例.</code></p>\r\n<p><strong>粗体示例</strong></p>\r\n<p><code>**粗体示例**</code></p>\r\n<p><em>斜体示例</em></p>\r\n<p><code>*斜体示例*</code></p>\r\n<p><strong><em>粗斜体示例</em></strong></p>\r\n<p><code>***粗斜体示例***</code></p>\r\n<blockquote>\r\n<p>引用示例</p>\r\n<blockquote>\r\n<p>嵌套引用示例</p>\r\n</blockquote>\r\n<p>引用示例</p>\r\n</blockquote>\r\n<figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;引用示例</span><br><span class=\"line\"><span class=\"quote\">&gt;</span></span><br><span class=\"line\"><span class=\"quote\">&gt;&gt;嵌套引用示例</span></span><br><span class=\"line\"><span class=\"quote\">&gt;</span></span><br><span class=\"line\"><span class=\"quote\">&gt;引用示例</span></span><br></pre></td></tr></table></figure>\r\n<ol type=\"1\">\r\n<li><p>有序列表示例1</p>\r\n<p>1.1. 嵌套多级列表1.1</p>\r\n<p>1.2. 嵌套多级列表1.2</p>\r\n<ul>\r\n<li>有序列表嵌套无序列表</li>\r\n</ul></li>\r\n<li><p>有序列表示例2</p>\r\n<p>2.1. 嵌套多级列表2.1</p>\r\n<p>2.2. 嵌套多级列表2.2</p></li>\r\n</ol>\r\n<figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">1.</span> 有序列表示例1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"code\">    1.1. 嵌套多级列表1.1</span></span><br><span class=\"line\"><span class=\"code\"></span></span><br><span class=\"line\"><span class=\"code\">    1.2. 嵌套多级列表1.2</span></span><br><span class=\"line\"><span class=\"code\">    </span></span><br><span class=\"line\"><span class=\"code\">    - 有序列表嵌套无序列表</span></span><br><span class=\"line\"><span class=\"code\"></span></span><br><span class=\"line\"><span class=\"bullet\">2.</span> 有序列表示例2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"code\">    2.1. 嵌套多级列表2.1</span></span><br><span class=\"line\"><span class=\"code\"></span></span><br><span class=\"line\"><span class=\"code\">    2.2. 嵌套多级列表2.2</span></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li><p>无序列表示例1</p></li>\r\n<li><p>无序列表示例2</p></li>\r\n<li><ul>\r\n<li>嵌套无序列表2.1</li>\r\n</ul></li>\r\n<li><ol type=\"1\">\r\n<li>无序嵌套有序</li>\r\n</ol></li>\r\n<li><ol start=\"2\" type=\"1\">\r\n<li>无序嵌套有序</li>\r\n</ol></li>\r\n</ul>\r\n<figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> 无序列表示例1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">-</span> 无序列表示例2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">-</span> - 嵌套无序列表2.1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">-</span> 1. 无序嵌套有序</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">-</span> 2. 无序嵌套有序</span><br></pre></td></tr></table></figure>\r\n<hr />\r\n<h2 id=\"资源插入\">2. 资源插入</h2>\r\n<ol type=\"1\">\r\n<li>代码段插入示例<code>for day in time</code></li>\r\n</ol>\r\n<p><code>1. 代码段插入示例 ``for day in time``</code></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>代码块插入示例:</li>\r\n</ol>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码块示例 第一个```后加代码名即可进行语法识别</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;std;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"code\">```C++</span></span><br><span class=\"line\"><span class=\"code\">//代码块示例 第一个```</span>后加代码名即可进行语法识别</span><br><span class=\"line\"><span class=\"section\">#include <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">iostream</span>&gt;</span></span></span></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"code\">    cout&lt;&lt;std;</span></span><br><span class=\"line\"><span class=\"code\">&#125;</span></span><br><span class=\"line\"><span class=\"code\">```</span></span><br></pre></td></tr></table></figure>\r\n<ol start=\"3\" type=\"1\">\r\n<li><a href=\"www.lianjie.com\">链接插入示例</a></li>\r\n</ol>\r\n<p><code>3. [链接插入示例](www.lianjie.com)</code></p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>图片插入示例:</li>\r\n</ol>\r\n<figure>\r\n<img src=\"https://i.imgur.com/sVc8zeN.png\" alt=\"这里是图片注释\" />\r\n<figcaption aria-hidden=\"true\">这里是图片注释</figcaption>\r\n</figure>\r\n<figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\">![<span class=\"string\">这里是图片注释</span>](<span class=\"link\">https://i.imgur.com/sVc8zeN.png</span>)</span><br></pre></td></tr></table></figure>\r\n","categories":["工具"],"tags":["MarkDown","写作"]},{"title":"LeetCode-No-94-二叉树中序遍历","url":"/2020/02/17/LeetCode-No-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","content":"<h1 id=\"二叉树中序遍历\"><a\r\nhref=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal\">二叉树中序遍历</a></h1>\r\n<p>给定一个二叉树，返回它的中序 遍历。</p>\r\n<p>示例:</p>\r\n<p>输入: [1,null,2,3] 1  <br />\r\n2 / 3</p>\r\n<p>输出: [1,3,2]</p>\r\n<h1 id=\"题解分析\">题解分析</h1>\r\n<p>1.<strong>递归法</strong>很简单，跳过进入<strong>迭代法</strong>。 2.\r\n分析中序遍历顺序：左子树 父节点 右子树， 3. 且对左子树还要以\r\n左子树的左子树 左子树 左子树的右子树的顺序递归下去 4.\r\n因此表现出来就是，<strong>一直左到底</strong>，然后输出左\r\n返回父节点并输出，然后输出右子节点\r\n然后再返回到父节点的父节点，以此类推。\r\n父节点同时也是父父节点的左子树，因此回溯上去的时候顺序是<strong>”父（左）-右“、”父（左）-右“</strong>。\r\n5. 先进后出，存储结构使用<strong>栈</strong> 6.\r\n对root先往左压栈到底，然后出栈输出，并输出右节点，然后继续出栈。</p>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * struct TreeNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     TreeNode *left;</span><br><span class=\"line\"> *     TreeNode *right;</span><br><span class=\"line\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class=\"line\"> * &#125;;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    vector&lt;int inorderTraversal(TreeNode* root) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vector&lt;int result;</span><br><span class=\"line\">        if(root==NULL)</span><br><span class=\"line\">            return result;</span><br><span class=\"line\">        stack&lt;TreeNode* mem;</span><br><span class=\"line\">        TreeNode* current=root;</span><br><span class=\"line\">        while(!mem.empty() || current)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //循环先把左树压栈</span><br><span class=\"line\">            while(current)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                mem.push(current);</span><br><span class=\"line\">                current=current-left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            current=mem.top();//父节点（同时是父父节点左节点） 出栈</span><br><span class=\"line\">            result.push_back(current-val);//输出父节点（同时是父父节点左节点）</span><br><span class=\"line\">            current=current-right;//输出右节点</span><br><span class=\"line\">            mem.pop();//上去一层</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"]},{"title":"MeteorNet","url":"/2022/01/03/MeteorNet/","content":"<ul>\r\n<li>Liu X, Yan M, Bohg J. Meteornet: Deep learning on dynamic 3d point\r\ncloud sequences[C]//Proceedings of the IEEE/CVF International Conference\r\non Computer Vision. 2019: 9246-9255.</li>\r\n<li>Carnegie Mellon University</li>\r\n</ul>\r\n<h2 id=\"meteor-module\">Meteor Module</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/RgsZUHy.png\"\r\nalt=\"MeteorNet应用架构：左：Meteor模块将不同帧的点先混合起来，然后统一输出特征。右：先分别抽取特征，再通过Meteor模块进行时间特征抽取。\" />\r\n<figcaption\r\naria-hidden=\"true\">MeteorNet应用架构：左：Meteor模块将不同帧的点先混合起来，然后统一输出特征。右：先分别抽取特征，再通过Meteor模块进行时间特征抽取。</figcaption>\r\n</figure>\r\n<h3 id=\"聚类方法\">聚类方法</h3>\r\n<figure>\r\n<img src=\"https://i.imgur.com/iPVSfJv.png\"\r\nalt=\"(a)dircet grouping (b) Chained-flow grouping\" />\r\n<figcaption aria-hidden=\"true\">(a)dircet grouping (b) Chained-flow\r\ngrouping</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<p><strong>Direct grouping</strong>：主要灵感源于\r\n<strong>时间过得越久，物体能移动的最大距离就越远。</strong>\r\n因此对于邻域半径，也可以随着时间增加而增加。</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathcal{N}_{d}\\left(p_{i}^{(t)} ;\r\nr\\right)=\\left\\{p_{j}^{\\left(t^{\\prime}\\right)}\r\n\\mid\\left\\|\\mathbf{x}_{j}^{\\left(t^{\\prime}\\right)}-\\mathbf{x}_{i}^{(t)}\\right\\|&lt;r\\left(\\left|t^{\\prime}-t\\right|\\right)\\right\\}\r\n\\]</span></p>\r\n<p><strong>Chained-flow\r\ngrouping</strong>：物体的运动通常沿着一定的轨迹方向。因此运动可以通过<strong>场景流</strong>[28]来进行描述。首先对于所有的时间<span\r\nclass=\"math inline\">\\(t\\)</span>，利用已知的两个相邻帧的点云<span\r\nclass=\"math inline\">\\(p_i^{t},p_j^{t-1}\\)</span>，通过场景流估计算子<span\r\nclass=\"math inline\">\\(\\mathcal{F}_{0}\\)</span>(如FlowNet3D[14])来找到<span\r\nclass=\"math inline\">\\(p_i^{t}\\)</span>在<span\r\nclass=\"math inline\">\\(t-1\\)</span>帧的对应虚拟点云<span\r\nclass=\"math inline\">\\(p_i^{\\prime(t-1)}\\)</span>，</p>\r\n<p><span class=\"math display\">\\[\r\n\\left\\{\\mathfrak{f}_{i}^{(t,\r\nt-1)}\\right\\}_{i}=\\mathcal{F}_{0}\\left(\\left\\{p_{i}^{(t)}\\right\\},\\left\\{p_{j}^{(t-1)}\\right\\}\\right)\r\n\\]</span></p>\r\n<p>估计得到的点云即 <span\r\nclass=\"math inline\">\\(\\mathbf{x}_{i}^{\\prime(t-1)}=\\mathbf{x}_{i}^{(t)}+\\mathfrak{f}_{i}^{(t,\r\nt-1)}\\)</span></p>\r\n<p>为了找到<span class=\"math inline\">\\(p_i^{t}\\)</span>在<span\r\nclass=\"math inline\">\\(t-2\\)</span>帧的对应虚拟点云，首先用上述同样的方式计算<span\r\nclass=\"math inline\">\\(p_j^{t-1}\\)</span>在<span\r\nclass=\"math inline\">\\(t-2\\)</span>帧的反向流<span\r\nclass=\"math inline\">\\(\\mathfrak{f}_{j}^{(t-1,\r\nt-2)}\\)</span>，然后通过<span\r\nclass=\"math inline\">\\(p_i^{\\prime(t-1)}\\)</span>和<span\r\nclass=\"math inline\">\\(p_j^{t-1}\\)</span>的距离来对<span\r\nclass=\"math inline\">\\(\\mathfrak{f}_{j}^{(t-1,\r\nt-2)}\\)</span>进行一个加权插值得到<span\r\nclass=\"math inline\">\\(\\mathfrak{f}_{i}^{(t-1, t-2)}\\)</span>：</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathfrak{f}_{i}^{\\prime(t-1, t-2)}=\\frac{\\sum_{j=1}^{k}\r\nw\\left(\\mathbf{x}_{j}^{(t-1)}, \\mathbf{x}_{i}^{(t-1)}\\right)\r\n\\mathfrak{f}_{j}^{(t-1, t-2)}}{\\sum_{j=1}^{k}\r\nw\\left(\\mathbf{x}_{j}^{(t-1)}, \\mathbf{x}_{i}^{\\prime(t-1)}\\right)}\r\n\\]</span></p>\r\n<p>其中<span class=\"math inline\">\\(w\\left(\\mathbf{x}_{1},\r\n\\mathbf{x}_{2}\\right)=\\frac{1}{d\\left(\\mathbf{x}_{1},\r\n\\mathbf{x}_{2}\\right)^{p}}\\)</span>为反距离函数，这样即可以得到<span\r\nclass=\"math inline\">\\(t-2\\)</span>时刻的估计点云：<span\r\nclass=\"math inline\">\\(\\mathbf{x}_{i}^{\\prime(t-2)}=\\mathbf{x}_{i}^{(t)}+\\mathfrak{f}_{i}^{(t,\r\nt-1)}+{\\mathfrak{f}}_{i}^{(t-1, t-2)}\\)</span>。</p>\r\n<p>对于<span class=\"math inline\">\\(t-2\\)</span>往前的帧都可以重复上述\r\nchained 插值方式进行处理得到。最终可以根据虚拟点云来确定邻域范围为：</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathcal{N}_{c}\\left(p_{i}^{(t)} ;\r\nr\\right)=\\left\\{p_{j}^{\\left(t^{\\prime}\\right)}\r\n\\mid\\left\\|\\mathbf{x}_{j}^{\\left(t^{\\prime}\\right)}-\\mathbf{x}_{i}^{\\prime\\left(t^{\\prime}\\right)}\\right\\|&lt;r\\right\\}\r\n\\]</span></p>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[28] Sundar Vedula, Simon Baker, Peter Rander, Robert Collins, and\r\nTakeo Kanade. Three-dimensional scene flow. In ICCV,1999</p>\r\n<p>[14] Xingyu Liu, Charles. R. Qi, and Leonidas J. Guibas. Flownet3d:\r\nLearning scene flow in 3d point clouds. In CVPR, 2019.</p>\r\n","categories":["深度学习"],"tags":["深度学习","序列学习","点云"]},{"title":"Hexo+Next7.8 美化性配置","url":"/2020/07/24/Next7-8-%E7%BE%8E%E5%8C%96%E6%80%A7%E9%85%8D%E7%BD%AE/","content":"<h1 id=\"前情提要\">前情提要</h1>\r\n<ul>\r\n<li>Next 7.8.0</li>\r\n<li>hexo 4.2.1</li>\r\n<li>npm 6.14.5</li>\r\n<li>Next 配置文件指 项目根目录/themes/next/_config.yml</li>\r\n<li>项目配置文件指 项目根目录/_config.yml</li>\r\n<li>注意在配置文件中配置字段时，请严格控制缩进</li>\r\n<li>安装命令没特别说明都在 项目根目录 下进行</li>\r\n</ul>\r\n<p><strong>以下所有配置都建立在 7.8\r\n版本的基础之上实现的，保新保质，绝对不是复制偷搬那些祖传博客。</strong></p>\r\n<blockquote>\r\n<p>^_^ 友情建议：进行较大更改之前，先通过如 <code>git</code>\r\n等方式进行保存。并且更改后为了避免样式不刷新，尽量先<code>hexo clean</code>清除样式。生成后最好先在本地<code>hexo s</code>部署。确认没有千疮百孔再推到线上吧。</p>\r\n</blockquote>\r\n<h1 id=\"美化性配置\">美化性配置</h1>\r\n<p>虽然功能有了，但没人想要自己的博客完全单调扁平，虽然 next\r\n的设计已经清新的挺舒服了，但人总有自定义的需求嘛。</p>\r\n<p>修改途径有两种：</p>\r\n<ul>\r\n<li><p>custom style\r\n文件，覆盖单点样式，一般用于进行几个小地方的自定义等</p></li>\r\n<li><p>custom variable\r\n文件，修改变量，变量会被其他样式引用到，因此一般修改都是整体性的，一般用于修改文章宽度，文章颜色等整体性的样式。\r\n&gt;注意我在 variable\r\n配置时发现，这里颜色字段只支持十六进制表示法，不支持 rgb 表示。</p></li>\r\n</ul>\r\n<p>以下样式修改大多是在 styles 和 variables 两个文件中进行。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"next-样式结构\">Next 样式结构</h2>\r\n<p>以<strong>主题</strong>目录为根目录，主要关注\r\n<code>./source/css</code> 目录，偶尔需要 <code>./layout</code>\r\n目录，结构如下：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">NEXT</span><br><span class=\"line\">├─layout  布局相关，swig 文件，html 标记语言及嵌套语言，对新手比较难改。</span><br><span class=\"line\">│  ├─_macro</span><br><span class=\"line\">│  ├─_partials</span><br><span class=\"line\">│  ├─_scripts</span><br><span class=\"line\">│  └─_third-party</span><br><span class=\"line\">│    </span><br><span class=\"line\">│─source  资源相关</span><br><span class=\"line\">    ├─css css 样式相关</span><br><span class=\"line\">    │  ├─_common 公共部分，一般是些公共小组件的样式，什么 back 2 top 按钮</span><br><span class=\"line\">    │  │  ├─components 组件部分</span><br><span class=\"line\">    │  │  |    </span><br><span class=\"line\">    │  │  ├─outline  框架部分</span><br><span class=\"line\">    │  │  │  ├─footer  脚注</span><br><span class=\"line\">    │  │  │  ├─header  头部，菜单栏，github 彩带，书签等</span><br><span class=\"line\">    │  │  │  └─sidebar 侧栏，导航栏相关，站点概况区域相关</span><br><span class=\"line\">    │  │  |    </span><br><span class=\"line\">    │  │  └─scaffolding</span><br><span class=\"line\">    │  │      ├─highlight</span><br><span class=\"line\">    │  │      └─tags</span><br><span class=\"line\">    │  │      </span><br><span class=\"line\">    │  ├─_schemes 主题样式方案，四大主题的样式，内部调用了 variables 的值</span><br><span class=\"line\">    │  │  ├─Gemini 因此一般修改下面的_variables 的变量值就可以。</span><br><span class=\"line\">    │  │  ├─Mist</span><br><span class=\"line\">    │  │  ├─Muse</span><br><span class=\"line\">    │  │  └─Pisces</span><br><span class=\"line\">    │  │     </span><br><span class=\"line\">    │  └─_variables 以变量形式存储的 css 属性值，宽度，颜色，等全局性属性都在这里</span><br><span class=\"line\">    │  │  ├─base.styl 全局配置，下面四个为各样式对全局配置的覆盖字段</span><br><span class=\"line\">    │  │  ├─Gemini.styl</span><br><span class=\"line\">    │  │  ├─Mist.styl</span><br><span class=\"line\">    │  │  ├─Muse.styl</span><br><span class=\"line\">    │  │  └─Pisces.styl</span><br></pre></td></tr></table></figure>\r\n<p>variables\r\n里配置字段非常多，基本假如修改的只是属性值的话，都可以在这里找到 ...\r\n什么文章显示宽度、文章背景颜色，链接色 ...\r\n详细有什么字段建议自己去摸一摸\r\n<code>base.styl</code>文件，变量名都很有可读性，实在看不懂自己可以修改看看变化。</p>\r\n<p>variables\r\n取值优先级：<code>custom variables 文件 &gt; 主题 .styl 文件 &gt; base.styl 全局配置</code>。</p>\r\n<p>一般我们需要修改覆盖什么变量，即针对性的将赋值写在 custom variables\r\n文件中即可。</p>\r\n<blockquote>\r\n<p>Windows 输出树形目录技巧：命令行输入 <code>tree /?</code> ，即可查阅\r\ntree 命令的相关用法，照着用即可，生成的树形结构即可复制出来。</p>\r\n</blockquote>\r\n<h2 id=\"创建-custom-文件\">创建 custom 文件</h2>\r\n<p>在 next\r\n配置文件中，找到下面这段，然后把需要的自定义字段取消注释，这里我们想要自定义\r\nstyle 和\r\nvariable，因此取消注释这两个字段，之后可以在路径文件中写入你想要<strong>覆盖</strong>的样式。</p>\r\n<p>**注意默认路径是 hexo 项目根目录下的\r\nsource/_data/styles.styl**，取消注释后按路径自己创建那个文件。</p>\r\n<p><strong>再次强调，不是 next 主题目录为根的路径。</strong></p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Define custom file paths.</span></span><br><span class=\"line\"><span class=\"comment\"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span></span><br><span class=\"line\"><span class=\"attr\">custom_file_path:</span></span><br><span class=\"line\">  <span class=\"comment\">#head: source/_data/head.swig</span></span><br><span class=\"line\">  <span class=\"comment\">#header: source/_data/header.swig</span></span><br><span class=\"line\">  <span class=\"comment\">#sidebar: source/_data/sidebar.swig</span></span><br><span class=\"line\">  <span class=\"comment\">#postMeta: source/_data/post-meta.swig</span></span><br><span class=\"line\">  <span class=\"comment\">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class=\"line\">  <span class=\"comment\">#footer: source/_data/footer.swig</span></span><br><span class=\"line\">  <span class=\"comment\">#bodyEnd: source/_data/body-end.swig</span></span><br><span class=\"line\">  <span class=\"attr\">variable:</span> <span class=\"string\">source/_data/variables.styl</span></span><br><span class=\"line\">  <span class=\"comment\">#mixin: source/_data/mixins.styl</span></span><br><span class=\"line\">  <span class=\"attr\">style:</span> <span class=\"string\">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"调试样式方法\">调试样式方法</h2>\r\n<p>虽然能够自定义覆盖样式，但是 css\r\n配色总是要试试的嘛，怎么调试出自己喜欢的配色再添加到文件里呢？</p>\r\n<p>chrome\r\n打开博客网站，右键你想要更改的元素，例如正文背景，在右键菜单中点【检查】，可以看到如图的调试台，右边则是相应的元素样式。如图：\r\n<img\r\nsrc=\"https://wx1.sinaimg.cn/mw1024/b8e57787gy1ggtuquyezgj20wn0di0v3.jpg\"\r\nalt=\"主要找右边的样式表\" />\r\n比如这里我就把正文背景从原来的纯白，修改为了带点暖黄的护眼色。\r\n然后把更改的这段复制到 styles.styl 即可，如下：</p>\r\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">//正文背景护眼色</span><br><span class=\"line\"><span class=\"selector-pseudo\">:root</span> &#123;</span><br><span class=\"line\">    --<span class=\"selector-tag\">body</span>-bg-<span class=\"attribute\">color</span>: <span class=\"number\">#f9dbb6</span>47;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>重新生成文章即可，其他浏览器调试应该也是同理。</p>\r\n<p>样式修改花样就太多了 ...\r\n整个页面每个地方每个角落都能修改，具体每个想法怎么修改我肯定是覆盖不了的，一般通过浏览器调试找到相应的属性值修改就行。</p>\r\n<p>因此下面通过几个简单的修改作为示例好了。</p>\r\n<h2 id=\"字体配置\">字体配置</h2>\r\n<p>在 next/_config.yml 里，找到 font 字段，一般配置 global\r\n全局字体就行。</p>\r\n<p>字体 CDN 默认是 google 的，可以去里面挑自己喜欢的字体，在 family\r\n字段配置即可。</p>\r\n<p>个人是比较喜欢思源宋体的。</p>\r\n<p>示例如下：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">font:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Uri of fonts host, e.g. https://fonts.googleapis.com (Default).</span></span><br><span class=\"line\">  <span class=\"attr\">host:</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Font options:</span></span><br><span class=\"line\">  <span class=\"comment\"># `external: true` will load this font family from `host` above.</span></span><br><span class=\"line\">  <span class=\"comment\"># `family: Times New Roman`. Without any quotes.</span></span><br><span class=\"line\">  <span class=\"comment\"># `size: x.x`. Use `em` as unit. Default: 1 (16px)</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Global font settings used for all elements inside &lt;body&gt;.</span></span><br><span class=\"line\">  <span class=\"attr\">global:</span></span><br><span class=\"line\">    <span class=\"attr\">external:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">family:</span> <span class=\"string\">Noto</span> <span class=\"string\">Serif</span> <span class=\"string\">SC</span></span><br><span class=\"line\">    <span class=\"attr\">size:</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"标题阴影美化\">标题阴影美化</h2>\r\n<p>标题虽然可以通过字体大小区分，但是光秃秃的几个字在全文里还是有比较混杂的感觉，即不方便分割上下文，也不凸显标题本身。</p>\r\n<p>因此考虑添加阴影来增强标题感。</p>\r\n<p>在 styles 中添加字段如下，具体颜色和大小参数自己配吧。</p>\r\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.post-body</span> <span class=\"selector-tag\">h1</span>, <span class=\"selector-class\">.post-body</span> <span class=\"selector-tag\">h2</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">box-shadow</span>: inset <span class=\"number\">0</span> -<span class=\"number\">0.6em</span> <span class=\"number\">0</span> <span class=\"number\">#ffeb88</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"单句代码悬浮突出美化\">单句代码悬浮突出美化</h2>\r\n<p>单句代码无论用什么颜色修改感觉都差点意思，要么是太过鲜艳，在频繁的地方看的挺烦，要么是太过暗淡，又不够突出明显。</p>\r\n<p>因此搬运了悬浮贴的 css 样式。</p>\r\n<p>单句代码和代码块都在<code>code</code>类下面，因此最好加个<code>p</code>类限制为仅单句代码。</p>\r\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span> <span class=\"selector-tag\">code</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">1em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>: <span class=\"number\">1.5rem</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#333</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-weight</span>: bold;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ebc65a</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0.2em</span> <span class=\"number\">0.2em</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">#ebc65a</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0.1em</span> <span class=\"number\">0.4em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> <span class=\"number\">0.4em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>: bottom;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"修改文章页面宽度\">修改文章页面宽度</h2>\r\n<p>在<code>next\\source\\css\\_variables</code>中找到对应子主题文件的如下字段：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$content-desktop              = &#x27;calc(100% - %s)&#x27; % unit($content-desktop-padding / 2, &#x27;px&#x27;);</span><br><span class=\"line\">$content-desktop-large        = 900px;</span><br><span class=\"line\">$content-desktop-largest      = 61%;</span><br></pre></td></tr></table></figure>\r\n<p>如果子主题文件没有，可以去<code>base.styl</code>里找。</p>\r\n<p>或者自己在子主题文件里添加这个字段。</p>\r\n<p>至于相应的值就自己调试成自己舒服的了。</p>\r\n<blockquote>\r\n<p>小提示：<code>hexo s</code>部署在本地后，可以直接修改这些 styl\r\n文件，刷新页面即生效，不需要中断本地服务器。</p>\r\n</blockquote>\r\n<h2 id=\"修改文章背景色及透明度\">修改文章背景色及透明度</h2>\r\n<p>在<code>next\\source\\css\\_variables</code>中找到对应子主题文件的如下字段：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$content-bg-color             =#ffffffc2;</span><br></pre></td></tr></table></figure>\r\n<p>如果子主题文件没有，可以去<code>base.styl</code>里找。</p>\r\n<p>或者自己在子主题文件里添加这个字段。</p>\r\n<p>值也自己调咯，推荐透明度在 0.9 左右。</p>\r\n<h2 id=\"hightlight代码配色\">hightlight代码配色</h2>\r\n<p>觉得 next 的几款 highlight\r\n都不太搭白底网站，于是摸了一遍发现<code>themes\\next\\source\\css\\_common\\scaffolding\\highlight\\</code>路径下的文件存储着几套主题的配色，可以自己改一套喜欢的了。</p>\r\n<h1 id=\"参考美化\">参考美化</h1>\r\n<p><a\r\nhref=\"https://www.randomyang.top/2019/01/27/pixels%E5%B9%B6%E4%B8%8D%E7%AE%80%E5%8D%95/\">randomyang\r\n的 paper 设计</a></p>\r\n<p><a href=\"https://co5.me/\">co5=Shioko 个人博客</a></p>\r\n<p><a href=\"https://qianling.pw/\">千灵</a></p>\r\n","categories":["工具"],"tags":["博客"]},{"title":"LeetCode_剑指Offer No.39","url":"/2020/07/20/LeetCode-%E5%89%91%E6%8C%87Offer-No-39/","content":"<h1 id=\"求数组中的众数\"><a\r\nhref=\"https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof\">求数组中的众数</a></h1>\r\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\r\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\r\n<p>示例 1:</p>\r\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2] 输出: 2</p>\r\n<p>限制：</p>\r\n<p>1 &lt;= 数组长度 &lt;= 50000</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<p>题目关键词：<strong>出现次数</strong>，即我们很容易想到对次数进行统计然后查找的暴力方式，当然，没有介绍的必要。</p>\r\n<p>另一个关键词：<strong>超过一半</strong>，超过一半的性质能带给我们什么优势？暴力法没有顾及到，下面介绍的<strong>抵消法</strong>/<strong>摩尔投票法</strong>则利用了这一性质进行提速。</p>\r\n<p>再仔细思考题目性质：</p>\r\n<p><strong>核心性质</strong>————寻找众数，众数次数超过一半————众数次数 -\r\n所有其他数字加起来出现的次数 0</p>\r\n<ol type=\"1\">\r\n<li><p>我们可以拿出一个 众数，和 一个非众数\r\n匹配抵消。<strong>两两抵消</strong>后，最终剩下的肯定是众数。</p></li>\r\n<li><p>假设当前数是a，碰到下一个不同的数b，a和b抵消后，不管a b\r\n和众数是什么关系。之后的数组中依然有性质————众数次数 -\r\n所有其他数字加起来出现的次数 0\r\n，即a和b的抵消不影响我们在后续数组中找众数。</p></li>\r\n<li><p>即我们可以按序把两两不相同的数抵消，相同的数累计起来去抵消后续不同的数。并且后续的数组中依然可以继续抵消。</p></li>\r\n<li><p>这样即可递归下去，最终遍历完整个数组，把所有数抵消了一遍，我们得到剩下的数<code>remain=众数</code>。</p></li>\r\n</ol>\r\n<h1 id=\"算法流程\">算法流程</h1>\r\n<ol type=\"1\">\r\n<li><p>取第一个数作为当前<code>remain</code></p></li>\r\n<li><p>遍历到下一个数</p>\r\n<ul>\r\n<li>假如不同，则两两抵消，由上面分析可知，不影响后面数组中最后留下的是众数。</li>\r\n<li>假如相同，则在<code>count</code>中累计起来，后面可以抵消更多的不同的数。</li>\r\n</ul></li>\r\n<li><p>遍历完一整遍数组，全部抵消完毕，则最后<code>remain</code>保持为抵消后多余出来的众数</p></li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<p>抵消法做法很简单，值得注意的是理解算法的正确性，为什么这样做是对的。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&amp; nums)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//抵消思路，因为次数超过一半————众数次数 - 所有其他数字加起来出现的次数 0 ,</span></span><br><span class=\"line\">        <span class=\"comment\">//即取 众数一次 抵消 非众数一次 最终剩下来的就是众数</span></span><br><span class=\"line\">        <span class=\"comment\">//即 假设a是众数，碰到下个数不是a， 那么这两个数抵消，剩下的数组里依然有 众数次数 - 所有其他数字加起来出现的次数 0</span></span><br><span class=\"line\">        <span class=\"comment\">//最终全部抵消后，多余的是众数。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> remain;<span class=\"comment\">//最后剩下的肯定是全数组的众数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count=<span class=\"number\">0</span>;<span class=\"comment\">//记录当前假设的众数的次数 用于抵消</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> length=nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;length;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count==<span class=\"number\">0</span>)<span class=\"comment\">//更新假设对象</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                remain=nums[i];</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[i]!=remain)<span class=\"comment\">//两两抵消</span></span><br><span class=\"line\">                count--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span><span class=\"comment\">//相同数，count++</span></span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> remain;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["LeetCode"],"tags":["分治"]},{"title":"PSTNet","url":"/2022/01/06/PSTNet/","content":"<ul>\r\n<li>Fan H, Yu X, Ding Y, et al. PSTNet: Point spatio-temporal\r\nconvolution on point cloud sequences[C]//International Conference on\r\nLearning Representations. 2020.</li>\r\n<li>National University of Singapore</li>\r\n</ul>\r\n<h1 id=\"introduction\">Introduction</h1>\r\n<p>点云可以准确捕捉场景的集合信息，同时对不同的光照条件有较强的鲁棒性。另外，可以通过附带RGB图像来作为3D点的附加特征，以增强点云的能力。</p>\r\n<p>动态点云是不规则和无序的，为了建模点云的动力学，一种解决方案是将点云转换为3D体素序列，然后对体素序列应用4D卷积(Choy等人，2019)。然而，直接对体素序列执行卷积需要大量的计算。此外，在<strong>体素化过程中，量化误差是不可避免的</strong>，这可能会限制需要精确测量场景几何的应用。另一个解决方案MeteorNet\r\n(Liu et al.， 2019e)是扩展静态点云方法PointNet++ (Qi et al.，\r\n2017b)来处理原始点云序列。</p>\r\n<p>这篇文章的point spatio-temporal (PST)\r\nconvolution用于直接处理点云序列。由于点云在空间上无序但在时间上有序，因此可以解耦空间和时间信息，来对点云序列进行建模。</p>\r\n<p>点云序列在帧之间没有对应关系，因此PSTNet提出了一个 point tube\r\n结构来保持时空上的局部结构。</p>\r\n<p>主要工作：</p>\r\n<ul>\r\n<li>首次尝试解耦点云序列的空间和时间信息，提出PST卷积来编码点云序列。</li>\r\n<li>PST transposed\r\nconvolution，用于解码序列，完成point-level的预测任务</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<h1 id=\"point-spatio-temporal-convolutional-net\">Point Spatio-Temporal\r\nConvolutional Net</h1>\r\n<h2\r\nid=\"decomposing-space-and-time-in-point-cloud-sequence-modeling\">DECOMPOSING\r\nSPACE AND TIME IN POINT CLOUD SEQUENCE MODELING</h2>\r\n<p>点云空间上无序，时间上有序，因此可以解耦这两个维度来减少空间的不规则对时间模型的影响。另外空间和时间的变化尺度一般不一样，不能在网络中将两者同等对待。通过解耦两者，不仅时空模型更好做了，捕获时间信息的能力上也有显著改善。PST\r\n卷积为：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\boldsymbol{F}_{t}^{\\prime(x, y, z)}&amp;=\\sum_{k=-\\lfloor l /\r\n2\\rfloor}^{\\lfloor l / 2\\rfloor} \\sum_{\\left\\|\\left(\\delta_{x},\r\n\\delta_{y}, \\delta_{z}\\right)\\right\\| \\leq r}\r\n\\mathbf{W}^{\\left(\\delta_{x}, \\delta_{y}, \\delta_{z}\\right)}_k \\cdot\r\n\\boldsymbol{F}_{t+k}^{\\left(x+\\delta_{x}, y+\\delta_{y},\r\nz+\\delta_{z}\\right)}，\\\\\r\n&amp;=\\sum_{k=-\\lfloor l / 2\\rfloor}^{\\lfloor l / 2\\rfloor}\r\n\\sum_{\\left\\|\\left(\\delta_{x}, \\delta_{y}, \\delta_{z}\\right)\\right\\|\r\n\\leq r} \\mathbf{T}_{k}^{\\left(\\delta_{x}, \\delta_{y}, \\delta_{z}\\right)}\r\n\\cdot\\left(\\mathbf{S}_{k}^{\\left(\\delta_{x}, \\delta_{y},\r\n\\delta_{z}\\right)} \\cdot \\boldsymbol{F}_{t+k}^{\\left(x+\\delta_{x},\r\ny+\\delta_{y}, z+\\delta_{z}\\right)}\\right),\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(\\mathbf{W} \\in \\mathbb{R}^{C^{\\prime}\r\n\\times C \\times l}\\)</span>为卷积算子，可分解为时间卷积<span\r\nclass=\"math inline\">\\(\\mathbf{T} \\in \\mathbb{R}^{C^{\\prime} \\times C_m\r\n\\times l}\\)</span>和空间卷积<span class=\"math inline\">\\(\\mathbf{S} \\in\r\n\\mathbb{R}^{C_m \\times C\r\n}\\)</span>，另外由于时间卷积核空间卷积的互相独立，公式可以进一步化为：</p>\r\n<p><span class=\"math display\">\\[\r\n\\boldsymbol{F}_{t}^{\\prime(x, y, z)}=\\sum_{k=-\\lfloor l /\r\n2\\rfloor}^{\\lfloor l / 2\\rfloor} \\mathbf{T}_{k} \\cdot\r\n\\sum_{\\left\\|\\left(\\delta_{x}, \\delta_{y}, \\delta_{z}\\right)\\right\\|\r\n\\leq r} \\mathbf{S}^{\\left(\\delta_{x}, \\delta_{y}, \\delta_{z}\\right)}\r\n\\cdot \\boldsymbol{F}_{t+k}^{\\left(x+\\delta_{x}, y+\\delta_{y},\r\nz+\\delta_{z}\\right)},\r\n\\]</span></p>\r\n<p>首先空间卷积就存在一个问题，怎么去定义卷积。因为不同的点的邻居的位置偏移完全不一样，我们不可能做一个巨大的卷积核，把所有的位置偏移量<span\r\nclass=\"math inline\">\\(\\theta_{x,y,z}\\)</span>都囊括在核里，因此可以把这个空间卷积转换为一个关于偏移的固定大小的函数<span\r\nclass=\"math inline\">\\(f((\\delta_{x}, \\delta_{y}, \\delta_{z};\\theta)\r\n:\\mathbb{R}^{1x3} \\rightarrow \\mathbb{R}^{C_m \\times\r\nC}\\)</span>，具体实现如下：</p>\r\n<p><span class=\"math display\">\\[\r\nf\\left(\\left(\\delta_{x}, \\delta_{y}, \\delta_{z}\\right) ;\r\n\\boldsymbol{\\theta}\\right)=\\boldsymbol{\\theta}_{d}\r\n\\cdot\\left(\\delta_{x}, \\delta_{y}, \\delta_{z}\\right)^{T} \\cdot 1 \\odot\r\n\\boldsymbol{\\theta}_{s}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(\\boldsymbol{\\theta}_{d} \\in\r\n\\mathbb{R}^{C_m \\times 3}\\)</span>是displacement transform\r\n核，用于捕捉位移的空间局部结构。 <span\r\nclass=\"math inline\">\\(\\boldsymbol{\\theta}_{s} \\in \\mathbb{R}^{C_m \\times\r\nC}\\)</span> 是sharing核，用于增加特征维度，增强特征表示能力。最终<span\r\nclass=\"math inline\">\\(f\\)</span>即使用固定大小的子核，针对任意一个偏移<span\r\nclass=\"math inline\">\\(\\theta_{x,y,z}\\)</span>计算产生一个变换特征的矩阵。来替代原大小不定的卷积操作的权重变换。</p>\r\n<h2 id=\"point-tube\">Point Tube</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/BUVS67Q.png\" alt=\"Point tube\" />\r\n<figcaption aria-hidden=\"true\">Point tube</figcaption>\r\n</figure>\r\n<p>Point\r\ntube结构用于维护点云的时空局部结构，和体素不一样的是，体素是规则划分的，point\r\ntube\r\n是基于输入序列动态生成的，即稠密区域有更多的tube。构造方式如下：</p>\r\n<p><strong>时间关键帧的选择</strong>：对于点云序列，需要采样出关键帧来作为tube的中心。这里和卷积窗口一样的思路，基于temporal\r\nkernel size (l), temporal stride (st) and temporal padding\r\n(p)来采样关键帧，左右两边即是tube两端。</p>\r\n<p><strong>空间关键点的选择</strong>：在关键帧中进行FPS采样</p>\r\n<p><strong>传播空间关键点</strong>：将关键帧中关键点的位置直接传播到邻域帧，也视为这些帧的关键点。</p>\r\n<p><strong>寻找空间邻居</strong>：搜寻r半径的邻域作为邻居</p>\r\n<p>有了Point\r\ntube的邻域关系，就可以使用PST卷积进行时空局部邻域的卷积。</p>\r\n<h2 id=\"pst-transposed-convolution\">PST Transposed Convolution</h2>\r\n<p>得到了点云整体的特征，有时候对于point-wise的任务还需要将特征传播给所有点。因此PST转置卷积即输入编码信息，输出每个点的特征<span\r\nclass=\"math inline\">\\([P_i;F_i]=F_i^{\\prime\\prime} \\in\r\n\\mathbb{R}^{C^{\\prime\\prime} \\times N}\\)</span>，具体操作如下：</p>\r\n<p>首先<strong>解码时间</strong>：通过一个时间上的转置卷积，将特征恢复到原来的时间长度：</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathbf{T}^{\\prime} \\cdot \\boldsymbol{F}_{t}^{\\prime(x, y,\r\nz)}=\\left[M_{t-\\lfloor l / 2\\rfloor}^{\\prime(x, y, z)}, \\cdots,\r\nM_{t+\\lfloor l / 2\\rfloor}^{\\prime(x, y, z)}\\right],\r\n\\]</span></p>\r\n<p><span\r\nclass=\"math inline\">\\(F_t\\)</span>为输入的tube特征，通过PST转置卷积<span\r\nclass=\"math inline\">\\(\\mathbf{T^\\prime} \\in \\mathbb{R}^{l \\times\r\nC_m^\\prime \\times C^\\prime}\\)</span>，得到<span\r\nclass=\"math inline\">\\(M_t\\)</span>：即解码时间后，每个帧的空间卷积结果。</p>\r\n<p>然后<strong>解码空间</strong>：受PointNet++里的启发，在关键点和其余点之间根据距离权重进行插值传播特征：</p>\r\n<p><span class=\"math display\">\\[\r\nF_{t}^{\\prime \\prime(x, y, z)}=S^{\\prime} \\cdot\r\n\\frac{\\sum_{\\left\\|\\left(\\delta_{x}, \\delta_{y},\r\n\\delta_{z}\\right)\\right\\| \\leq r} w\\left(\\delta_{x}, \\delta_{y},\r\n\\delta_{z}\\right) M_{t}^{\\prime\\left(x+\\delta_{x}, y+\\delta_{y},\r\nz+\\delta_{z}\\right)}}{\\sum_{\\left\\|\\left(\\delta_{x}, \\delta_{y},\r\n\\delta_{z}\\right)\\right\\| \\leq r} w\\left(\\delta_{x}, \\delta_{y},\r\n\\delta_{z}\\right)}, w\\left(\\delta_{x}, \\delta_{y},\r\n\\delta_{z}\\right)=\\frac{1}{\\left\\|\\left(\\delta_{x}, \\delta_{y},\r\n\\delta_{z}\\right)\\right\\|^{2}}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(S^{\\prime} \\in \\mathbb{R}^{C^{\\prime\r\n\\prime} \\times C_{m}^{\\prime}}\\)</span>\r\n是一个共享核，用于增强特征的插值，并且将特征维度从<span\r\nclass=\"math inline\">\\(C_m^\\prime\\)</span>变换成<span\r\nclass=\"math inline\">\\(C^{\\prime\\prime}\\)</span>。</p>\r\n<h1 id=\"experiment\">Experiment</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/eLaiMX0.png\"\r\nalt=\"MSR-Action3D 动作识别准确率\" />\r\n<figcaption aria-hidden=\"true\">MSR-Action3D 动作识别准确率</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/bCnQo4g.png\" alt=\"NTU 动作识别准确率\" />\r\n<figcaption aria-hidden=\"true\">NTU 动作识别准确率</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/4mFXeJz.png\"\r\nalt=\"上为输入点云，颜色表示深度。下为PST卷积的输出。PST卷积最终得到了运动的主要部位\" />\r\n<figcaption\r\naria-hidden=\"true\">上为输入点云，颜色表示深度。下为PST卷积的输出。PST卷积最终得到了运动的主要部位</figcaption>\r\n</figure>\r\n","categories":["深度学习"],"tags":["深度学习","序列学习","点云"]},{"title":"PCT","url":"/2021/12/18/PCT/","content":"<p><strong>PCT: Point cloud transformer</strong></p>\r\n<ul>\r\n<li>Guo M H, Cai J X, Liu Z N, et al. PCT: Point cloud transformer[J].\r\nComputational Visual Media, 2021, 7(2): 187-199.</li>\r\n<li>清华</li>\r\n<li>CVMJ</li>\r\n</ul>\r\n<p>提出了基于Transformer的PCT网络。Transformer在NLP和图像处理取得了巨大成功，其内在的置换不变性也十分适合点云学习。为了更好的捕捉点云局部信息，使用了最远点采样和最近邻搜索来加强输入的embedding处理。实验证明PCT达到了分类分割和法向估计的SOTA。</p>\r\n<p>由于点云和自然语言是完全不同的数据类型，因此PCT对Transformer作出了几项调整：</p>\r\n<ul>\r\n<li><strong>Coordinate-based input\r\nembedding</strong>：Transformer里的positional encoding\r\n是为了区分不同位置的同一个词。然而点云没有位置顺序关系，因此PCT中将\r\npositional encoding 和 input embedding\r\n结合了起来，基于坐标进行编码。</li>\r\n<li><strong>Optimized offset-attention module</strong>：是原始\r\nself-attention 的升级模块。它把原来的attention\r\nfeature换成了self-attention的输入和attention\r\nfeature之间的offset。同一个物体在不同的变换下的绝对坐标完全不一样，因此相对坐标更鲁棒。</li>\r\n<li><strong>Neighbor embedding module</strong>：\r\n注意力机制有效捕捉全局特征，但可能忽视局部几何信息，而这在点云中很重要。句子中的每个单独的词都有基本的语义信息，但是点云中孤立的点不存在语义信息。因此使用了一个neighbor\r\nembedding\r\n策略来进行改良，让注意力机制着重于分析点局部邻域的信息，而不是孤立的点的信息。</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<h1 id=\"transformer基础\">Transformer基础</h1>\r\n<p>Transformer是一个解码编码结构，包含了三个主要模块：<strong>input\r\nembedding、positional\r\nencoding、self-attention</strong>。Self-attention是核心模块，其通过基于全局上下文产生细粒度的注意力特征信息。Transformer所有的操作都是并行的并且顺序无关的。</p>\r\n<ol type=\"1\">\r\n<li>Self-attention 将input embedding 和 positional\r\nencoding之和作为输入，使用线性层对每个词计算\r\n<strong>query，key，value</strong>。</li>\r\n<li>通过任意两个词的query 和 key\r\n向量的点积，计算两者之间的<strong>注意力权重</strong>。</li>\r\n<li>定义<strong>注意力特征</strong>：所有value向量以注意力权重的加权和。因此输出的每个词的注意力特征与所有的输入有关，因此能够学习全局上下文信息。</li>\r\n</ol>\r\n<h1 id=\"pct-point-cloud-transformer\">PCT: Point Cloud Transformer</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/sVc8zeN.png\"\r\nalt=\"PCT架构：由input coordinates的embedding开始，通过attention学习特征表示，再通过线性层进行特征输出。LBRD为Linear，Batch Normalization，ReLU，Dropout\" />\r\n<figcaption aria-hidden=\"true\">PCT架构：由input\r\ncoordinates的embedding开始，通过attention学习特征表示，再通过线性层进行特征输出。LBRD为Linear，Batch\r\nNormalization，ReLU，Dropout</figcaption>\r\n</figure>\r\n<p>PCT目标是将输入的点编码到一个高维特征空间，以便于体现点之间的语义关系。编码上的原则基本与原始Transformer保持一致，除了忽略掉了positional\r\nembedding，因为input coordinates已经包含了这一部分。</p>\r\n<h2 id=\"朴素pct\">朴素PCT</h2>\r\n<p>修改原生Transformer最简单的办法就是把点云看做句子，把点看做单词。</p>\r\n<ol type=\"1\">\r\n<li>使用一种忽视了点间作用的朴素的point\r\nembedding，即致力于在嵌入空间中将语义接近的点放得更近。</li>\r\n<li>使用原生的Self-attention机制计算词元的语义相关性。由于Query，Key，Value都是由共享的线性变换层计算得到，因此它们都是<strong>顺序无关</strong>。Softmax和加权求和同样也是<strong>顺序无关</strong>。因此，整个self-attention处理是<strong>顺序无关</strong>，以至于很适合处理无序的点云数据。最终Self-attention层计算如下：\r\n<span class=\"math display\">\\[\r\nF_{out}=SA(F_{in})=LBR(F_{sa})+F_{in}\r\n\\]</span></li>\r\n</ol>\r\n<figure>\r\n<img src=\"https://i.imgur.com/YgYNRPq.png\"\r\nalt=\"Offset-Attention结构：通过一个转换开关可以选择Self-Attention或是Offset-Attention的normalization方式。虚线代表的是Self-Attention。\" />\r\n<figcaption\r\naria-hidden=\"true\">Offset-Attention结构：通过一个转换开关可以选择Self-Attention或是Offset-Attention的normalization方式。虚线代表的是Self-Attention。</figcaption>\r\n</figure>\r\n<h2 id=\"offset-attention\">Offset-Attention</h2>\r\n<p>图卷积网络中体现了使用拉普拉斯矩阵 <span\r\nclass=\"math inline\">\\(L=D-E\\)</span>\r\n来代替原有邻接矩阵E的优势。类似的，在PCT中使用offset-attention(OA)来代替原始的self-attention(SA)来获得更好的效果：</p>\r\n<p><span class=\"math display\">\\[\r\nF_{out}=OA(F_{in})=LBR(F_{in}-F_{sa})+F_{in}\r\n\\]</span></p>\r\n<p>normalization方式也有所不同。如上图开关处所示，PCT中对第一维使用了softmax，对第二维使用了1范数来规范化attention\r\nmap。相比于传统的Transformer更强化了注意力权重，并且减少了噪声影响。</p>\r\n<p>带有上述Offset-Attention和input embedding的网络被称为 <strong>simple\r\nPCT(SPCT)</strong>。</p>\r\n<h2 id=\"增强局部特征-neighbor-embedding\">增强局部特征 Neighbor\r\nembedding</h2>\r\n<p>PCT通过point embedding\r\n可以有效的抽取全局特征，但是却忽略了同样重要的局部信息。借鉴PointNet++和DGCNN，PCT设计了一个<strong>neighbor\r\nembedding</strong>来增强局部学习能力。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/9qRySPy.png\"\r\nalt=\"左：Neighbor embedding。中：Sampling and grouping。右上：采样示例。右下：KNN聚类示例\" />\r\n<figcaption aria-hidden=\"true\">左：Neighbor embedding。中：Sampling and\r\ngrouping。右上：采样示例。右下：KNN聚类示例</figcaption>\r\n</figure>\r\n<p>如图所示，neighbor embedding包含两个LBR和Sampling and\r\ngrouping(SG)。LBR层用于基础的point\r\nembedding，SG层用于采样点云，并且聚合采样点kNN的邻域特征。思路来源于<strong>EdgeConv</strong>[26]。</p>\r\n<ol type=\"1\">\r\n<li>先通过FPS进行下采样，然后对于每一个采样点，找到其在<strong>原始点云</strong>中的kNN邻域，</li>\r\n<li>计算每个采样点的邻域特征：即计算邻域相对于中心点的差分特征，然后拼接输出：\r\n<span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\Delta \\boldsymbol{F}(p) &amp;=\\text { concat }_{q \\in\r\n\\operatorname{knn}(p, \\mathcal{P})}(\\boldsymbol{F}(q)-\\boldsymbol{F}(p))\r\n\\\\\r\n\\left.\\widetilde{\\boldsymbol{F}}_{(} p\\right)\r\n&amp;=\\operatorname{concat}(\\Delta \\boldsymbol{F}(p),\r\n\\operatorname{RP}(\\boldsymbol{F}(p), k)) \\\\\r\n\\boldsymbol{F}_{s}(p)\r\n&amp;=\\operatorname{MP}(\\operatorname{LBR}(\\operatorname{LBR}(\\widetilde{\\boldsymbol{F}}(p))))\r\n\\end{aligned}\r\n\\]</span> MP为Max Pooling，RP为repeating vector <span\r\nclass=\"math inline\">\\(x\\)</span> <span class=\"math inline\">\\(k\\)</span>\r\ntimes。</li>\r\n</ol>\r\n<h2 id=\"分类和分割任务的区别\">分类和分割任务的区别</h2>\r\n<p>分类只需要对所有点给出一个全局的类别，所以处理时SG层将点云进行采样压缩了。</p>\r\n<p>分割和法向估计任务中，由于要给每一个点一个输出信息(部件标签或者法向信息)，因此SG层只用来抽取局部特征，而不对原始点云进行压缩。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/n7OolGg.jpg\" alt=\"分割效果图\" />\r\n<figcaption aria-hidden=\"true\">分割效果图</figcaption>\r\n</figure>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[6] Vaswani, A.; Shazeer, N.; Parmar, N.; Uszkoreit, J.; Jones, L.;\r\nGomez, A. N.; Kaiser, L.; Polosukhin, I. Attention is all you need. In:\r\nProceedings of the 31st International Conference on Neural Information\r\nProcessing, 6000–6010, 2017.</p>\r\n<p>[26] Wang, Y.; Sun, Y.; Liu, Z.; Sarma, S. E.; Bronstein, M. M.;\r\nSolomon, J. M. Dynamic graph CNN for learning on point clouds. ACM\r\nTransactions on Graphics Vol. 38, No. 5, Article No. 146, 2019.</p>\r\n","categories":["深度学习"],"tags":["深度学习","序列学习","点云"]},{"title":"PSTT","url":"/2022/03/21/PSTT/","content":"<ul>\r\n<li>Wei Y, Liu H, Xie T, et al. Spatial-Temporal Transformer for 3D\r\nPoint Cloud Sequences[C]//Proceedings of the IEEE/CVF Winter Conference\r\non Applications of Computer Vision. 2022: 1171-1180.</li>\r\n<li>中山大学</li>\r\n<li>不在CCF h5指数62 排计算机视觉第12</li>\r\n</ul>\r\n<p>提出了<strong>Spatio-Temporal\r\nSelf-Attention(STSA)</strong>模块和<strong>Resolution\r\nEmbedding(RE)</strong>模块。STSA用于时空联系，RE用于聚合邻域特征，增强特征图的分辨率。</p>\r\n<p>现有的基于point的时空方法要么是使用注意力机制，要么是使用RNN模型。然而，这些方法依赖于长期联系，导致信息冗余。STSA使用了自注意力来提取帧间联系。这样会使冗余程度下降，鲁棒性提高(残差+layer\r\nnormalization)，训练速度提升。</p>\r\n<p>另外，在语义分割上面的编码器-解码器结构，在编码器降维时会造成信息丢失。RE模块使用了注意力权重来加强分辨率。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"resolution-embedding-re\">Resolution Embedding (RE)</h1>\r\n<p>先是时空邻域构造：即多帧的ball query，并且使用两个pointnet++的set\r\nabstraction layers进行特征抽取。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/IKzp3Gd.png\"\r\nalt=\"RE结构：维度b，s，d分别代表batch，num_points，feature。\" />\r\n<figcaption\r\naria-hidden=\"true\">RE结构：维度b，s，d分别代表batch，num_points，feature。</figcaption>\r\n</figure>\r\n<ul>\r\n<li>Feature Block：使用set abstraction层提取特征 <span\r\nclass=\"math inline\">\\(n_i^t\\)</span>。</li>\r\n<li>Resolution\r\nBlock：将空间分为两部分，然后把特征再叠加在一起。最后通过一个MLP进行降维处理。通过这样的处理最终抽取出邻域间的信息\r\n<span class=\"math inline\">\\(k_i^t\\)</span>。</li>\r\n</ul>\r\n<p>最终使用两个scalar attention来进行两种特征的融合：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\na_{1},a_{2}&amp;=Softmax(MLP(k_i^t,n_i^t)) \\\\\r\nI_i^t&amp;=a_1 \\cdot k_i^t + a_2 \\cdot n_i^t\r\n\\end{aligned}\r\n\\]</span></p>\r\n<h1 id=\"spatio-temporal-self-attentionstsa\">Spatio-Temporal\r\nSelf-Attention(STSA)</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/ZcaaX9j.png\" alt=\"STSA\" />\r\n<figcaption aria-hidden=\"true\">STSA</figcaption>\r\n</figure>\r\n<p>在一组空间特征<span\r\nclass=\"math inline\">\\(I\\)</span>输入到SA之前，先将每个空间特征<span\r\nclass=\"math inline\">\\(I_i^t\\)</span>划分为多个patches，并且按时间维度上拼接不同时间的patches，最后得到<span\r\nclass=\"math inline\">\\(F_{input} \\in \\mathbb{R}^{N \\times\r\nd}\\)</span>。</p>\r\n<p>由于自注意力会引入初始权重的随机性，导致输出特征可能和输入特征相去甚远。因此将自注意力的计算结果和输入特征构造一个<strong>残差连接</strong>，形成最后的输出特征。另外，Layer\r\nNormalization是常用的加速注意力模型收敛的工具：</p>\r\n<p><span class=\"math display\">\\[\r\nF_{output}=LayerNorm[FeedForward(F_{sa_out}+F_{input})]\r\n\\]</span></p>\r\n<h1 id=\"效果\">效果</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/WtxOupd.png\" alt=\"MSRAction3D效果\" />\r\n<figcaption aria-hidden=\"true\">MSRAction3D效果</figcaption>\r\n</figure>\r\n","categories":["深度学习"],"tags":["深度学习","点云"]},{"title":"Point4DTransformer","url":"/2022/02/17/Point4DTransformer/","content":"<ul>\r\n<li>Fan H, Yang Y, Kankanhalli M. Point 4D transformer networks for\r\nspatio-temporal modeling in point cloud videos[C]//Proceedings of the\r\nIEEE/CVF Conference on Computer Vision and Pattern Recognition. 2021:\r\n14204-14213.</li>\r\n<li>CVPR</li>\r\n<li>新加坡国立大学/悉尼科技大学</li>\r\n</ul>\r\n<h1 id=\"introduction\">Introduction</h1>\r\n<p>想把点云转为规则数据再进行卷积，一方面由于其稀疏性，通常需要定义稀疏卷积[6]。另外体素化本身也需要额外的计算[59]，而这限制了实时处理的能力。</p>\r\n<p>另一种方案是直接处理点云序列。由于点云序列具有不规则性和无序性，其使得点云在不同帧之间不具有连续性。因此通常会使用point\r\ntracking来捕获动态点云[36]，但这是一个很难的任务。而且tracking通常都是依赖于点的颜色，这也不容易扩展到无色点云。Point\r\n4D Transformer 用于对原始点云序列进行建模，并在3D 动作识别和4D\r\n语义分割任务上证明了优越性。P4DTransformer主要包含：</p>\r\n<ol type=\"1\">\r\n<li>4D\r\nconvolution，对点云序列的时空局部结构进行embedding处理。并且通过这种时空聚合，减少了后续transformer需要处理的点数。</li>\r\n<li>transformer，通过自注意力学习序列全局的appearance和motion信息。相关的局部结构会通过注意力权重联系起来，而不需要显示的进行tracking。</li>\r\n</ol>\r\n<figure>\r\n<img src=\"https://i.imgur.com/6UPkPKK.png\" alt=\"结构图\" />\r\n<figcaption aria-hidden=\"true\">结构图</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h1 id=\"point-4d-convolution仿pstnet\">Point 4D\r\nConvolution(仿PSTNet)</h1>\r\n<p>基于网格的卷积已经被证明了在学习局部结构时很有用[23,18,51,4,17]。卷积的关键在于如何学习一个权重核，其给出了从中心点到周围偏移点的权重关系。由于传统卷积中，数据是离散的，因此可以方便地对偏移量进行卷积。然而点云坐标是连续且不规则的，其偏移量有无穷多个。因此在4D卷积中使用一个函数<span\r\nclass=\"math inline\">\\(\\zeta\\)</span>来间接生成卷积核，而不是直接给出一个核让它去学习。4D卷积定义如下：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n&amp;\\boldsymbol{F}_{t}^{\\prime(x, y, z)}=\\sum_{\\left(\\delta_{x},\r\n\\delta_{y}, \\delta_{z}, \\delta_{t}\\right) \\in G} \\zeta\\left(\\delta_{x},\r\n\\delta_{y}, \\delta_{z}, \\delta_{t}\\right) \\cdot\r\n\\boldsymbol{F}_{t+\\delta_{t}}^{\\left(x+\\delta_{x}, y+\\delta_{y},\r\nz+\\delta_{z}\\right)} \\\\\r\n&amp;=\\sum_{\\delta_{t}=-r_{t}}^{r_{t}} \\sum_{\\left\\|\\left(\\delta_{x},\r\n\\delta_{y}, \\delta_{z}\\right)\\right\\| \\leq r_{s}} \\zeta\\left(\\delta_{x},\r\n\\delta_{y}, \\delta_{z}, \\delta_{t}\\right) \\cdot\r\n\\boldsymbol{F}_{t+\\delta_{t}}^{\\left(x+\\delta_{x}, y+\\delta_{y},\r\nz+\\delta_{z}\\right)}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(F_t: \\mathbb{R}^{C \\times\r\n1}\\)</span>为点在帧t时的特征(C个特征)，<span\r\nclass=\"math inline\">\\(\\delta_x,\\delta_y,\\delta_z,\\delta_t\\)</span>为时空上的偏移量。<span\r\nclass=\"math inline\">\\(\\cdot\\)</span>为矩阵乘法。<span\r\nclass=\"math inline\">\\(\\sum\\)</span>可以使用不同的pooling方法实现，如sum-pooling，max-pooling，average-pooling。<span\r\nclass=\"math inline\">\\(G\\)</span>为时空邻域，其通过空间半径<span\r\nclass=\"math inline\">\\(r_s\\)</span>和时间半径<span\r\nclass=\"math inline\">\\(r_t\\)</span>来确定。$:^{1 } <sup>{C</sup>C}\r\n$用于对给定偏移量生成一个权重核：</p>\r\n<p><span class=\"math display\">\\[\r\n\\zeta\\left(\\delta_{x}, \\delta_{y}, \\delta_{z}, \\delta_{t}\\right) \\cdot\r\n\\boldsymbol{f}=\\left(\\boldsymbol{W}_{d} \\cdot\\left(\\delta_{x},\r\n\\delta_{y}, \\delta_{z}, \\delta_{t}\\right)^{T}\\right)\r\n\\odot\\left(\\boldsymbol{W}_{f} \\cdot \\boldsymbol{f}\\right)\r\n\\]</span></p>\r\n<p><span\r\nclass=\"math inline\">\\(\\boldsymbol{f}=\\boldsymbol{F}_{t+\\delta_{t}}^{\\left(x+\\delta_{x},\r\ny+\\delta_{y}, z+\\delta_{z}\\right)}\\)</span> 为偏移点的特征。 <span\r\nclass=\"math inline\">\\(\\boldsymbol{W}_{d} \\in\\)</span> <span\r\nclass=\"math inline\">\\(\\mathbb{R}^{C^{\\prime} \\times 4}\\)</span> 和 <span\r\nclass=\"math inline\">\\(\\boldsymbol{W}_{f} \\in \\mathbb{R}^{C^{\\prime}\r\n\\times C}\\)</span>用于提升特征维度，分别将坐标和额外特征统一变换到<span\r\nclass=\"math inline\">\\(C^\\prime\\)</span>维度，然后再通过 <span\r\nclass=\"math inline\">\\(\\odot\\)</span> 逐元素算子(如加法和乘法)\r\n将坐标信息和特征信息结合。 换句话说，<span\r\nclass=\"math inline\">\\(\\zeta\\left(\\delta_{x}, \\delta_{y}, \\delta_{z},\r\n\\delta_{t}\\right)\\)</span>\r\n即实现了对任意偏移量进行加权处理(模拟卷积)。</p>\r\n<p>如果不存在除坐标特征外的额外特征 <span\r\nclass=\"math inline\">\\(\\boldsymbol{F}_{t}\\)</span>，则形式变为 <span\r\nclass=\"math inline\">\\(\\zeta\\left(\\delta_{x}, \\delta_{y}, \\delta_{z},\r\n\\delta_{t}\\right)=\\boldsymbol{W}_{d} \\cdot\\left(\\delta_{x}, \\delta_{y},\r\n\\delta_{z},\r\n\\delta_{t}\\right)^{T}\\)</span>，即也单纯进行了一个MLP的坐标信息加强。</p>\r\n<h1 id=\"transformer\">Transformer</h1>\r\n<p>通过4D卷积的可以得到一个局部结构的embedding：<span\r\nclass=\"math inline\">\\(F_t^{\\prime(x,y,z)}\\)</span>。由于点的坐标反应了局部结构的关系，因此对embedding再次强化坐标信息：</p>\r\n<p><span class=\"math display\">\\[\r\n\\boldsymbol{I}^{(x,y,z,t)}=\\boldsymbol{W}_i \\dot\r\n(x,y,z,t)^T+\\boldsymbol{F}_t^{\\prime(x,y,z)}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(\\boldsymbol{W}_i : \\mathbb{R}^{C^\\prime\r\n\\times 4}\\)</span>。最终自注意力的输入特征为<span\r\nclass=\"math inline\">\\(\\boldsymbol{I}: \\mathbb{R}^{C^\\prime \\times\r\nL^\\prime N^\\prime}\\)</span></p>\r\n<p>有几点值得注意的：</p>\r\n<ul>\r\n<li>自注意力的softmax是序列范围的，而不是帧范围的。所谓帧范围，即一个帧内所有的权重累加为1。而序列范围即整个序列所有帧的所有<span\r\nclass=\"math inline\">\\(I_i\\)</span>权重累加为1。</li>\r\n<li>使用多头注意力机制。</li>\r\n<li>参考[10,53]在Transformer中使用LayerNorms[1]，MLP，ReLU，残差连接[18]</li>\r\n</ul>\r\n<h1 id=\"效果\">效果</h1>\r\n<p>准确率上SOTA：</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/oskcS3W.png\"\r\nalt=\"在NTU RGB+D上的准确率比较\" />\r\n<figcaption aria-hidden=\"true\">在NTU RGB+D上的准确率比较</figcaption>\r\n</figure>\r\n<p>计算上有一定的优越性：</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/QBcUYLp.png\"\r\nalt=\"处理每个视频的运行时间比较\" />\r\n<figcaption aria-hidden=\"true\">处理每个视频的运行时间比较</figcaption>\r\n</figure>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[1] Lei Jimmy Ba, Jamie Ryan Kiros, and Geoffrey E. Hinton. Layer\r\nnormalization. arXiv, 1607.06450, 2016</p>\r\n<p>[6] Christopher B. Choy, JunYoung Gwak, and Silvio Savarese. 4d\r\nspatio-temporal convnets: Minkowski convolutional neu- ral networks. In\r\nCVPR, 2019.</p>\r\n<p>[10] Alexey Dosovitskiy, Lucas Beyer, Alexander Kolesnikov, Dirk\r\nWeissenborn, Xiaohua Zhai, Thomas Unterthiner, Mostafa Dehghani,\r\nMatthias Minderer, Georg Heigold, Sylvain Gelly, Jakob Uszkoreit, and\r\nNeil Houlsby. An image is worth 16x16 words: Transformers for image\r\nrecognition at scale. In ICLR, 2021.</p>\r\n<p>[12] Hehe Fan, Xiaojun Chang, De Cheng, Yi Yang, Dong Xu, and\r\nAlexander G. Hauptmann. Complex event detection by identifying reliable\r\nshots from untrimmed videos. In ICCV, 2017.</p>\r\n<p>[18] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep\r\nresidual learning for image recognition. In CVPR, 2016.</p>\r\n<p>[36] Xingyu Liu, Mengyuan Yan, and Jeannette Bohg. Meteornet: Deep\r\nlearning on dynamic 3d point cloud sequences. In ICCV, 2019.</p>\r\n<p>[53] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit,\r\nLlion Jones, Aidan N. Gomez, Lukasz Kaiser, and Illia Polosukhin.\r\nAttention is all you need. In NeurIPS, 2017.</p>\r\n","categories":["深度学习"],"tags":["深度学习","点云"]},{"title":"PointNet++","url":"/2021/11/29/PointNet++/","content":"<p><strong>PointNet++: Deep Hierarchical Feature Learning on Point Sets\r\nin a Metric Space</strong></p>\r\n<p>Qi C R, Yi L, Su H, et al. Pointnet++: Deep hierarchical feature\r\nlearning on point sets in a metric space[J]. Advances in neural\r\ninformation processing systems, 2017, 30.</p>\r\n<p>最初的PointNet[2]没有捕捉到点的局部结构特征，限制了细粒度和复杂场景的识别、泛化能力。PointNet++则引出了一个分层结构神经网络，它在多级结构的点云中递归地应用PointNet。</p>\r\n<p>由于在均匀点云密度上训练的网络在非均匀密度点云上性能极大的削弱，PointNet++提出了一个新颖的学习网络层，可以自适应整合多种尺度的特征。</p>\r\n<p>实验表明PointNet++能够高效且鲁棒的学习到点云的深度特征，并且效果达到目前最优。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"introduction\">Introduction</h1>\r\n<p>PointNet基本思想是学习到每个点的空间编码，并且整合所有独立的点的特征成一个全局点云特征。PointNet没有捕捉局部结构特征，而局部结构特征是卷积网络成功的的关键之一。CNN可以通过规则网格的输入，沿着多分辨率的层级结构，以逐渐增大的尺度来捕捉特征。<strong>这种能够沿着多级结构捕捉局部特征的能力带来了更好的泛化能力。</strong></p>\r\n<p>PointNet++则是通过空间上的多级结构去处理点云。PointNet++通过潜在空间的距离度量，将点云划分为一系列堆叠的局部区域。和CNNs类似，PointNet++从小的局部邻域中捕捉到几何结构的局部特征，然后再整合到更大的尺度之中进行处理，形成更高级的特征，直到获得全局特征。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/5BC3Bo8.png\"\r\nalt=\"原图 2：PointNet++网络结构图\" />\r\n<figcaption aria-hidden=\"true\">原图 2：PointNet++网络结构图</figcaption>\r\n</figure>\r\n<p><strong>Problem Statement</strong>：对于<span\r\nclass=\"math inline\">\\(\\mathcal{X}=(M,\r\nd)\\)</span>，M是点集（不一定均匀分布），d为距离度量。希望学习到一个函数<span\r\nclass=\"math inline\">\\(\\mathcal{f}\\)</span>来抽取<span\r\nclass=\"math inline\">\\(\\mathcal{X}\\)</span>中的语义特征。</p>\r\n<p><strong>关键问题</strong>：</p>\r\n<ol type=\"1\">\r\n<li>怎么去划分局部区域</li>\r\n<li>怎么去捕捉局部特征</li>\r\n</ol>\r\n<p>这两个问题实际上相关，划分的同一个局部结构中使用的特征学习器（PointNet）可以进行权重共享，即形同于卷积的形式来学习局部结构特征。</p>\r\n<p><strong>如何去划分局部区域？</strong>局部区域即一个空间中的球形邻域，参数包括中心点和大小。</p>\r\n<ul>\r\n<li>中心点：为了覆盖到完整的点集，应该使用最远点采样算法（FPS）选出代表邻域的中心点。</li>\r\n<li>大小：不同于CNNs小尺寸卷积核往往有更好的效果。小的邻域可能不足以让PointNets捕捉特征。</li>\r\n</ul>\r\n<h1 id=\"method\">Method</h1>\r\n<h2 id=\"hierarchical-point-set-feature-learning\">Hierarchical Point Set\r\nFeature Learning</h2>\r\n<p>和PointNet直接max\r\npooling整个点集不同，PointNet++对点集进行了分级管理，随着层级逐步抽取越来越大的区域特征。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/ha5H68M.png\"\r\nalt=\"原图 2 ：分级结构网络示意图\" />\r\n<figcaption aria-hidden=\"true\">原图 2 ：分级结构网络示意图</figcaption>\r\n</figure>\r\n<p>分层结构由<strong>set abstraction\r\n层</strong>构成。每个层中会处理其包含的点集，并且抽取出一个更少元素的新点集。set\r\nabstraction详细结构为：</p>\r\n<h3 id=\"sampling-层\">Sampling 层</h3>\r\n<p>从输入点集中使用FPS采样一个子集。这些点即作为每个局部邻域的中心点。</p>\r\n<h3 id=\"grouping-层\">Grouping 层</h3>\r\n<p>在中心点附近使用ball\r\nQuery查找相邻点，以便构建出局部邻域。输入包括原点集<span\r\nclass=\"math inline\">\\(N \\times (d+C)\\)</span>以及采样点集<span\r\nclass=\"math inline\">\\(N^` \\times\r\nd\\)</span>。输出包含K个元素的邻域点集<span class=\"math inline\">\\(N^`\r\n\\times K \\times\r\n(d+c)\\)</span>。每个邻域的K不一定相同，PointNet层最终会将其统一到一个相同长度的特征向量。</p>\r\n<h3 id=\"pointnet-层\">PointNet 层</h3>\r\n<p>使用了一个mini-PointNet来编码抽取每个邻域的特征。输出<span\r\nclass=\"math inline\">\\(N^` \\times\r\n(d+C^`)\\)</span>。处理时每个邻域中点集坐标转换成了相对中心点的偏移坐标：<span\r\nclass=\"math inline\">\\(x_i=x_i-\\hat{x}\\)</span>，以便于捕捉点间联系关系。</p>\r\n<h2\r\nid=\"robust-feature-learning-under-non-uniform-sampling-denisty\">Robust\r\nFeature Learning under Non-Uniform Sampling Denisty</h2>\r\n<p>从Grouping层可知，每个邻域的密度是不一样的。而非均匀分布会给点集特征提取带来一个较大的困难。稠密区域的特征可能不能泛化到稀疏区域。理想中，我们希望从尽可能小的邻域中提取特征。然而对于稀疏邻域来说，同样小的区域存在着采样不足的问题而不能提取特征。因此PointNet++通过一个密度自适应的PointNet层来结合不同尺度下的邻域特征。</p>\r\n<p>在PointNet++中，每个set abstraction\r\n层都会提取多尺度下的局部特征，并且根据邻域密度来智能地组合起来。其有两种类型的密度自适应层来实现以上目的：</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/uvgtlsr.png\"\r\nalt=\"原图 3：自适应密度示意图。(a)为MSG层。(b)为MRG层\" />\r\n<figcaption aria-hidden=\"true\">原图\r\n3：自适应密度示意图。(a)为MSG层。(b)为MRG层</figcaption>\r\n</figure>\r\n<h3 id=\"multi-scale-groupingmsg\">Multi-scale grouping（MSG）</h3>\r\n<p>一种简单而有效的多尺度提取方法：使用多种尺度的grouping层，并且利用PointNet层去提取每个尺度下的特征，最终concat组合成一个统一多尺度的特征。</p>\r\n<p>训练时通过随机dropout，使得网络能够接触到不同密度不同分布的点集，使得训练后网络能够找到更优的策略来组合多维度特征。在测试时则不进行dropout。</p>\r\n<h3 id=\"multi-resolution-groupingmrg\">Multi-resolution\r\ngrouping（MRG）</h3>\r\n<p>上面的MSG方法显然是计算昂贵的。比起MSG，MRG避免了很多最低层次的计算，更加高效。在<span\r\nclass=\"math inline\">\\(L_i\\)</span>尺度下，一个邻域的特征由两个向量连接而成。一个向量是通过set\r\nabstraction层抽取低级尺度<span\r\nclass=\"math inline\">\\(L_{i-1}\\)</span>下的子邻域的特征来获得。另一个向量是使用一个单独的PointNet直接处理邻域所有的点来得到。</p>\r\n<p>当邻域的密度较低时，低尺度特征很容易受到采样稀疏性影响，因此逐尺度总结的特征会变得没有直接提取的特征可靠，从而更依赖直接特征。另一方面，当密度过高时，逐尺度特征能够提供更精细的细节。</p>\r\n<h2 id=\"point-feature-propagation-for-set-segmentation\">Point Feature\r\nPropagation for Set Segmentation</h2>\r\n<p>set\r\nabstraction层会对原始点云进行二次采样，然而对于分割任务需要获得所有原始点的特征。一个办法是在所有尺度的set\r\nabstraction中将所有的点都作为中心点进行计算一次，而这计算很昂贵。<strong>另一个方法是将二次采样的点的特征传播到原始的点。</strong></p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/9j4usHP.png\" alt=\"原图 2：分割网络图\" />\r\n<figcaption aria-hidden=\"true\">原图 2：分割网络图</figcaption>\r\n</figure>\r\n<p>PointNet++采用了一个分层传播策略，包括<strong>基于距离插值</strong>和<strong>层级跳跃链接</strong>。</p>\r\n<ul>\r\n<li>设<span class=\"math inline\">\\(N_{l-1},N_l\\)</span>为<span\r\nclass=\"math inline\">\\(l\\)</span>层set\r\nabstraction的输入和输出的点集大小(<span class=\"math inline\">\\(N_l \\leq\r\nN_{l-1}\\)</span>)，feature propagation层会将<span\r\nclass=\"math inline\">\\(N_l \\times (d+C)\\)</span>的输入数据传播给<span\r\nclass=\"math inline\">\\(N_{l-1}\\)</span>个点，<strong>即在<span\r\nclass=\"math inline\">\\(N_{l-1}\\)</span>点的坐标上进行特征的插值。</strong>插值方法选择了在K近邻之上的反距离加权平权（实验采用p=2，k=3）：\r\n<span class=\"math display\">\\[\r\n  f^{(j)}(x)=\\frac{\\sum_{i=1}^{k} w_{i}(x) f_{i}^{(j)}}{\\sum_{i=1}^{k}\r\nw_{i}(x)} \\quad \\text { where } \\quad w_{i}(x)=\\frac{1}{d\\left(x,\r\nx_{i}\\right)^{p}}, j=1, \\ldots, C\r\n  \\]</span></li>\r\n<li>然后将<span\r\nclass=\"math inline\">\\(N_{l-1}\\)</span>点上的插值特征与从set\r\nabstraction层跳跃链接过来的特征进行连接。</li>\r\n<li>连接后的特征传递给unit\r\npointnet层（类1x1卷积层）。其中使用了一些共享权重的全连接层和ReLU层，以便更新每个点的特征向量。</li>\r\n<li>重复以上处理过程，直到特征传播给了原始的所有点</li>\r\n</ul>\r\n<h1 id=\"experiments\">Experiments</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/2ORoLoL.png\"\r\nalt=\"原图 4：Table2中with normal指点特征中加了face normals特征。左下图是随机dropout结果。右下图显示了在非均匀密度下的效果。DP表示random dropout。SSG表示single scale grouping。\" />\r\n<figcaption aria-hidden=\"true\">原图 4：Table2中with\r\nnormal指点特征中加了face\r\nnormals特征。左下图是随机dropout结果。右下图显示了在非均匀密度下的效果。DP表示random\r\ndropout。SSG表示single scale grouping。</figcaption>\r\n</figure>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[2] C. R. Qi, H. Su, K. Mo, and L. J. Guibas. Pointnet: Deep learning\r\non point sets for 3d classification and segmentation. arXiv preprint\r\narXiv:1612.00593, 2016.</p>\r\n","categories":["深度学习"],"tags":["点云"]},{"title":"PointLSTM","url":"/2021/12/09/PointLSTM/","content":"<p><strong>An Efficient PointLSTM for Point Clouds Based Gesture\r\nRecognition</strong></p>\r\n<p>Min Y, Zhang Y, Chai X, et al. An efficient pointlstm for point\r\nclouds based gesture recognition[C]//Proceedings of the IEEE/CVF\r\nConference on Computer Vision and Pattern Recognition. 2020:\r\n5761-5770.</p>\r\n<p>把手势识别看作一个不规则序列的识别任务，致力于在点云序列中找到长期空间关联性。PointLSTM用于在保持空间结构的前提下，将信息从过去传播到未来。PointLSTM将过去的邻域点状态信息与现在的特征结合，以通过一个权重共享的LSTM层更新现在状态信息。这个方法可以集成在很多序列学习方法中。</p>\r\n<p>在手势识别上，（NVGesture、SHREC'17）达到SOTA，超越了之前基于骨架的方法。</p>\r\n<p>主要贡献工作：</p>\r\n<ul>\r\n<li>提出PointLSTM\r\n，在不规则序列数据上，保持空间结构的同时抽取长期时空联系。</li>\r\n<li>简化版本PointLSTM-PSS可以减少计算，并且易于探索改善性能的方法。</li>\r\n<li>在3D手势识别和动作识别上展现出了实时应用的巨大潜力。</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<h1 id=\"introduction\">Introduction</h1>\r\n<p>相比于RGB数据，点云更精准的描述了物体表面的几何结构和距离信息，从而为手势识别提供辅助。如何从点云中抽取丰富的特征则是一个主要任务。Qi\r\net\r\nal.[30]的PointNet可以从原始点云直接抽取信息。PointNet++[31]则扩展了层级聚合和采样操作，以捕捉局部联系特征。一些近期工作[19,\r\n20,\r\n23]对聚类操作做出了调整，以便于从时空领域中抽取运动特征和结构特征。然而这些工作仅局限于短期模型，缺乏捕捉长期联系的能力。</p>\r\n<p>近期RNN和LSTM在序列模型上的成功[3,7]提供了解决上述问题的灵感。然而点云数据是无序的，因此直接在没有对齐的点云序列上应用一个权重共享的LSTM层会有更新困难的问题。因此，<strong>如何在保持空间结构的前提下利用时间信息就是主要的挑战。</strong></p>\r\n<p>为了解决这个问题，提出了点云定制版的LSTM，即<strong>PointLSTM</strong>。理想情况下，当前帧的每个点都希望找到一个过去的点与之对应，并且进行相关处理。然而这是一个条件很强的假设，实际基本不可能满足，因此放松一点条件：寻找并聚合过去帧中相关的一些点的状态。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/X9tjztV.png\"\r\nalt=\"原图 1：s为state，f为feature。(a)理想状态下，每个点都能找到其在上一个时间步中对应的点。(b)在没有那么强的假设条件下，PointLSTM也能从过去的空间邻域中聚合相关信息\" />\r\n<figcaption aria-hidden=\"true\">原图\r\n1：s为state，f为feature。(a)理想状态下，每个点都能找到其在上一个时间步中对应的点。(b)在没有那么强的假设条件下，PointLSTM也能从过去的空间邻域中聚合相关信息</figcaption>\r\n</figure>\r\n<p>另外，为减少计算提出了一个<strong>带有Point-shared\r\nstates的PointLSTM简化版本：PointLSTM-PSS</strong>。</p>\r\n<h1 id=\"related-work\">Related Work</h1>\r\n<p><strong>基于视觉手势识别</strong></p>\r\n<p>[2,26,27]使用了图神经网络和LSTM来学习手部关节的时空序列。然而基于骨架的方法对遮挡状态，运动速度，图像分辨率等都十分敏感。相比于骨架数据，点云数据更能反映几何特征。</p>\r\n<p><strong>序列模型的LSTM</strong></p>\r\n<p>[3,7]等工作都证实了在序列模型中，RNN的一个特例LSTM拥有出色的长期模型能力。PointRNN[8]和CloudLSTM[43]都在动态点云上应用了RNN，以进行pointwise的预测。</p>\r\n<p>PointLSTM不同于它们使用pooling操作来汇总局部信息来进行逐点的预测，而是保持了空间结构，并且使用pooling操作来找到全局特征的相关信息。</p>\r\n<h1 id=\"method\">Method</h1>\r\n<h2 id=\"pointlstm\">PointLSTM</h2>\r\n<p>为解决之前的 当前帧无法匹配过去帧\r\n的问题，根据同一帧中的点是否共享状态信息，提出了两个解决办法来包容没有对齐的点云。</p>\r\n<p>定义：</p>\r\n<ul>\r\n<li>点云时间序列为 <span\r\nclass=\"math inline\">\\(\\mathbb{P}\\)</span>。每帧包含任意数量的点 <span\r\nclass=\"math inline\">\\(\\mathbb{P}^{(t)}=\\{p_{i}^{(t)} \\mid i=\\)</span>\r\n<span class=\"math inline\">\\(1,2, \\cdots, n_{t}\\}\\)</span>。每个点<span\r\nclass=\"math inline\">\\(p_{i}^{(t)}\\)</span> 可以表示为两部分：一个 <span\r\nclass=\"math inline\">\\(d\\)</span> 维坐标 <span\r\nclass=\"math inline\">\\(\\boldsymbol{x}_{i}^{(t)}\\)</span> 和一个 <span\r\nclass=\"math inline\">\\(m\\)</span> 维 特征向量 <span\r\nclass=\"math inline\">\\(\\boldsymbol{f}_{i}^{(t)}\\)</span></li>\r\n<li>点 <span class=\"math inline\">\\(p_{i}^{(t)}\\)</span>在 <span\r\nclass=\"math inline\">\\(\\mathbb{P}^{(t+\\Delta t)}\\)</span>\r\n帧的邻域点集：<span class=\"math inline\">\\(\\mathcal{N}_{\\Delta\r\nt}\\left(\\boldsymbol{x}_{i}^{(t)}\\right)\\)</span></li>\r\n<li>一般的LSTM层: <span class=\"math inline\">\\(h^{(t)},\r\nc^{(t)}=LSTM(\\boldsymbol{y}^{(t)}, h^{(t-1)}，c^{(t-1)})\\)</span></li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://i.imgur.com/RhUqy7a.png\"\r\nalt=\"原图 2：(a)在PointLSTM中每个点有独立的state，基于当前输入和过去邻域的states进行更新。(b)PointLSTM-PSS同一帧中的点共享一个state，基于对输出的一系列states取平均进行更新。\" />\r\n<figcaption aria-hidden=\"true\">原图\r\n2：(a)在PointLSTM中每个点有独立的state，基于当前输入和过去邻域的states进行更新。(b)PointLSTM-PSS同一帧中的点共享一个state，基于对输出的一系列states取平均进行更新。</figcaption>\r\n</figure>\r\n<h3 id=\"point-independent-states\">Point-independent states</h3>\r\n<p>假设每个点有独立的state <span\r\nclass=\"math inline\">\\(h^{(t)}_i\\)</span> 和cell state <span\r\nclass=\"math inline\">\\(c^{(t)}_i\\)</span>。对每个点，在过去的邻域中找到相关点形成点对\r\n<span class=\"math inline\">\\(\\left(p_{i}^{(t)}, p_{j}^{(t-1)}\\right),\r\np_{j}^{(t-1)} \\in\r\n\\mathcal{N}_{-1}\\left(x_{i}^{(t)}\\right)\\)</span>。通过点对计算输出：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\boldsymbol{y}_{i, j}^{(t)}\r\n&amp;=\\left[\\boldsymbol{x}_{i}^{(t)}-\\boldsymbol{x}_{j}^{(t-1)} ;\r\n\\boldsymbol{f}_{i}^{(t)}\\right] \\\\\r\n\\tilde{h}_{i, j}^{(t)}, \\tilde{\\boldsymbol{c}}_{i, j}^{(t)}\r\n&amp;=\\operatorname{LSTM}\\left(\\boldsymbol{y}_{i, j}^{(t)},\r\nh_{j}^{(t-1)}, c_{j}^{(t-1)}\\right)\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>得到每一对点 <span class=\"math inline\">\\(\\left(p_{i}^{(t)},\r\np_{j}^{(t-1)}\\right)\\)</span> 的临时state和cell state <span\r\nclass=\"math inline\">\\(\\tilde{h}_{i, j}^{(t)}, \\tilde{c}_{i,\r\nj}^{(t)}\\)</span>。再利用这些临时变量更新点云每个点 <span\r\nclass=\"math inline\">\\(p_{i}^{(t)}\\)</span> 的states和cell states <span\r\nclass=\"math inline\">\\(h_{i}^{(t)},\r\nc_{i}^{(t)}\\)</span>实现全部更新：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{gathered}\r\nh_{i}^{(t)}=g\\left(\\tilde{h}_{i, 1}^{(t)}, \\tilde{h}_{i, 2}^{(t)},\r\n\\cdots, \\tilde{h}_{i, n_{t-1}}^{(t)}\\right) \\\\\r\nc_{i}^{(t)}=g\\left(\\tilde{c}_{i, 1}^{(t)}, \\tilde{c}_{i, 2}^{(t)},\r\n\\cdots, \\tilde{c}_{i, n_{t-1}}^{(t)}\\right)\r\n\\end{gathered}\r\n\\]</span></p>\r\n<p>其中<span\r\nclass=\"math inline\">\\(g\\)</span>是一个对称函数，实现中采取一个max\r\npooling层</p>\r\n<h3 id=\"point-shared-states\">Point-shared states</h3>\r\n<p>如上每个点都要计算点对则消耗巨大。简化版本中同一帧的所有点拥有同一个states和cell\r\nstates。计算公式即把上面公式中<span\r\nclass=\"math inline\">\\(h_i，c_i\\)</span>表示每个点的<span\r\nclass=\"math inline\">\\(i\\)</span>去掉即可。即每一个时间步只需计算一轮。</p>\r\n<h2 id=\"neighborhood-grouping\">Neighborhood Grouping</h2>\r\n<p>为体现出是否对齐的影响，采用了两种grouping方式</p>\r\n<p><strong>Direct grouping</strong></p>\r\n<p>直接寻找中心点<span\r\nclass=\"math inline\">\\(p_{t,i}\\)</span>的k近邻。在物体静止的时候可以聚合相邻帧的空间信息。如果不设距离限制，同样也可以捕捉到一些运动信息。</p>\r\n<p><strong>Aligned grouping</strong></p>\r\n<p>假设当前点 <span class=\"math inline\">\\(p^{(t)}_i\\)</span>\r\n在前一帧中有一个虚拟的对应点 <span\r\nclass=\"math inline\">\\(\\tilde{p}^{(t-1)}_i\\)</span>\r\n，通过估计它们之间的反向流 $ ^{(t)}_i= ^{(t)}_i-x^{(t)}_i$ 来定位 <span\r\nclass=\"math inline\">\\(\\tilde{p}^{(t-1)}_i\\)</span>\r\n，并借此找到上一帧中的k邻域点集 <span\r\nclass=\"math inline\">\\(\\mathcal{N}_{-1}\\left(\\boldsymbol{x}_{i}^{(t)};k\\right)\\)</span>\r\n。</p>\r\n<p>然而，这种非刚性场景流估计依然是一个难题。</p>\r\n<h2 id=\"实现细节\">实现细节</h2>\r\n<h3 id=\"density-based-sampling-layer\">Density-based sampling layer</h3>\r\n<p>从深度视频中得到的大多数点都是多余的。工作[23]说明了对于手势识别，每帧100-200的小数目点云是一个合理的选择。因此为了减少计算冗余，采用了一个基于密度的采样方法[21]，点\r\n<span class=\"math inline\">\\({x}^{(t)}_i\\)</span> 密度估计如下：</p>\r\n<p><span class=\"math display\">\\[\r\n\\rho\\left(\\boldsymbol{x}_{i}^{(t)}\\right)=\\frac{1}{n_{t} r^{d}}\r\n\\sum_{j=1}^{n_{t}}\r\nw\\left(\\frac{\\boldsymbol{x}_{i}^{(t)}-\\boldsymbol{x}_{j}^{(t)}}{r}\\right)\r\n\\]</span></p>\r\n<p>其中 <span class=\"math inline\">\\(r\\)</span> 是 <span\r\nclass=\"math inline\">\\({x}^{(t)}_i\\)</span> 与其第k近邻的欧拉距离。<span\r\nclass=\"math inline\">\\(w\\)</span>\r\n是一个有界可积权重函数。通过密度估计，在每一个采样层中，都采样密度较小的点，即对应点云的边界信息。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/hShx5Nx.png\"\r\nalt=\"原图 4：第一行是从深度信息中分割出手部区域的点云序列，且经过预处理。第一行每帧有128个点。第二行通过采样后每帧有64个点。第三行显示了对应的骨架序列。\" />\r\n<figcaption aria-hidden=\"true\">原图\r\n4：第一行是从深度信息中分割出手部区域的点云序列，且经过预处理。第一行每帧有128个点。第二行通过采样后每帧有64个点。第三行显示了对应的骨架序列。</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>动作识别和手势识别的区别：Gesture手势识别是设计用于非口语交流，携带有语言特性。Action动作是完成一个目的的行为形式，拥有更大的类内变化。</p>\r\n</blockquote>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[1] Roy P, Bhattacharya S, Roy P P, et al. Position and Rotation\r\nInvariant Sign Language Recognition from 3D Point Cloud Data with\r\nRecurrent Neural Networks[J]. arXiv preprint arXiv:2010.12669, 2020.</p>\r\n<p>[2] Yuxiao Chen, Long Zhao, Xi Peng, Jianbo Yuan, and Dimitris N\r\nMetaxas. Construct dynamic graphs for hand gesture recognition via\r\nspatial-temporal attention. In British Machine Vision Conference,\r\n2019</p>\r\n<p>[3] Kyunghyun Cho, Bart Van Merrienboer, Caglar Gulcehre, ¨Dzmitry\r\nBahdanau, Fethi Bougares, Holger Schwenk, and Yoshua Bengio. Learning\r\nphrase representations using rnn encoder-decoder for statistical machine\r\ntranslation. In Proceedings of the Conference on Empirical Methods in\r\nNatural Language Processing, pages 1724–1734, 2014</p>\r\n<p>[7] Jeffrey Donahue, Lisa Anne Hendricks, Sergio Guadarrama,Marcus\r\nRohrbach, Subhashini Venugopalan, Kate Saenko,and Trevor Darrell.\r\nLong-term recurrent convolutional networks for visual recognition and\r\ndescription. In Proceedings of the IEEE Conference on Computer Vision\r\nand Pattern Recognition, pages 2625–2634, 2015.</p>\r\n<p>[8] Hehe Fan and Yi Yang. Pointrnn: Point recurrent neural network\r\nfor moving point cloud processing. arXiv preprint arXiv:1910.08287,\r\n2019.</p>\r\n<p>[19] Xingyu Liu, Charles R Qi, and Leonidas J Guibas.Flownet3d:\r\nLearning scene flow in 3d point clouds. In Proceedings of the IEEE\r\nConference on Computer Vision and Pattern Recognition, pages 529–537,\r\n2019.</p>\r\n<p>[20] Xingyu Liu, Mengyuan Yan, and Jeannette Bohg. Meteornet: Deep\r\nlearning on dynamic 3d point cloud sequences. In Proceedings of the IEEE\r\nInternational Conference on Computer Vision, pages 9246–9255, 2019</p>\r\n<p>[21] YP Mack and Murray Rosenblatt. Multivariate k-nearest neighbor\r\ndensity estimates. Journal of Multivariate Analysis, 9(1):1–15,\r\n1979.</p>\r\n<p>[23] Yuecong Min, Xiujuan Chai, Lei Zhao, and Xilin Chen. Flickernet:\r\nAdaptive 3d gesture recognition from sparse point clouds. In British\r\nMachine Vision Conference, 2019.</p>\r\n<p>[26] Xuan Son Nguyen, Luc Brun, Olivier Lezoray, and S ´ ebastien ´\r\nBougleux. A neural network based on spd manifold learning for\r\nskeleton-based hand gesture recognition. In Proceedings of the IEEE\r\nConference on Computer Vision and Pattern Recognition, pages\r\n12036–12045, 2019.</p>\r\n<p>[27] Juan C Nunez, Raul Cabido, Juan J Pantrigo, Antonio S\r\nMontemayor, and Jose F Velez. Convolutional neural networks and long\r\nshort-term memory for skeleton-based human activity and hand gesture\r\nrecognition. Pattern Recognition, 76:80–94, 2018.</p>\r\n<p>[30] Charles R Qi, Hao Su, Kaichun Mo, and Leonidas J Guibas.\r\nPointnet: Deep learning on point sets for 3d classification and\r\nsegmentation. In Proceedings of the IEEE Conference on Computer Vision\r\nand Pattern Recognition, pages 652–660,</p>\r\n<p>[31] Qi C R, Yi L, Su H, et al. Pointnet++: Deep hierarchical feature\r\nlearning on point sets in a metric space[J]. arXiv preprint\r\narXiv:1706.02413, 2017.</p>\r\n<p>[43] Chaoyun Zhang, Marco Fiore, Iain Murray, and Paul Patras.\r\nCloudlstm: A recurrent neural model for spatiotemporal point-cloud\r\nstream forecasting. arXiv preprint arXiv:1907.12410, 2019.</p>\r\n","categories":["深度学习"],"tags":["深度学习","序列学习","点云"]},{"title":"PointNet-Based-Hand-Gesture-Recognition","url":"/2021/12/11/PointNet-Based-Hand-Gesture-Recognition/","content":"<p><strong>A PointNet-Based Solution for 3D Hand Gesture\r\nRecognition</strong></p>\r\n<p>Mirsu R, Simion G, Caleanu C D, et al. A pointnet-based solution for\r\n3d hand gesture recognition[J]. Sensors, 2020, 20(11): 3226.</p>\r\n<ol type=\"1\">\r\n<li>在Kaggle上公开了<a\r\nhref=\"https://www.kaggle.com/cdcaleanu/upt-tof-3d-hand-gesture-database?select=01_amp.bin\">手势数据集</a></li>\r\n<li>使用PCA进行手前臂分割</li>\r\n<li>使用基于直方图的邻域策略规范化点云大小</li>\r\n<li>使用PointNet架构完成3D DRGB图的手势识别</li>\r\n</ol>\r\n<h2 id=\"多级手部分割\">多级手部分割</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/6MCc6kE.png\" alt=\"多级分割流程图\" />\r\n<figcaption aria-hidden=\"true\">多级分割流程图</figcaption>\r\n</figure>\r\n<h3 id=\"预处理\">预处理</h3>\r\n<p>由于分类时直接对3D点云使用了深度学习，因此预处理好点云数据也很重要。详细工作可参考之前的paper[28]。</p>\r\n<p><strong>过滤平滑</strong>：使用中值滤波来去除斑点噪声。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/LzqDVdk.png\"\r\nalt=\"(a)未平滑原始深度图 (b)平滑过滤后\" />\r\n<figcaption aria-hidden=\"true\">(a)未平滑原始深度图\r\n(b)平滑过滤后</figcaption>\r\n</figure>\r\n<p><strong>筛选出手部区域</strong>：默认手部是屏幕最近的物体。因此从最近点开始，选取一个深度区间7cm左右的所有点。同时进行计数。若这个区间的点总数小于阈值，则说明最近的点是一个离群点，不可靠。因此将区间往后移动重新划分。</p>\r\n<p><strong>区域内聚类</strong>：\r\n通过区域，中心，等方式进行计算聚类。如果有多个类，则选择左上方的作为手部区域。</p>\r\n<p><strong>手前臂分割</strong>：通过PCA找到数据的对称轴。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/7baQ8zl.png\"\r\nalt=\"(a)(b)PCA找到的手前臂轴和手部区域轴，(c)PCA无效的状态\" />\r\n<figcaption\r\naria-hidden=\"true\">(a)(b)PCA找到的手前臂轴和手部区域轴，(c)PCA无效的状态</figcaption>\r\n</figure>\r\n<p>并且利用一个手部检测窗口，一个手腕检测窗口来找到手腕分界线：计算两个窗口内点数的比例，找到一个比例极值处作为手腕分界线。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/i2G6tHJ.png\"\r\nalt=\"红框为手部检测窗口，每一轮增大一点。绿框为手腕检测窗口，大小固定。\" />\r\n<figcaption\r\naria-hidden=\"true\">红框为手部检测窗口，每一轮增大一点。绿框为手腕检测窗口，大小固定。</figcaption>\r\n</figure>\r\n<p><strong>采样压缩点云</strong>：移除邻居最多的点，或者保留邻域最小的点</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/p9uOoIM.png\" alt=\"点云采样示意图\" />\r\n<figcaption aria-hidden=\"true\">点云采样示意图</figcaption>\r\n</figure>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[28] Simion, G.; Caleanu, C. Multi-stage 3D segmentation for ToF\r\nbased gesture recognition system. In Proceedings of the 2014 11th\r\nInternational Symposium on Electronics and Telecommunications (ISETC),\r\nTimisoara, Romania, 15–16 November 2014; pp. 1–4.</p>\r\n","categories":["深度学习"],"tags":["深度学习","序列学习","点云"]},{"title":"PointNet","url":"/2021/11/14/PointNet/","content":"<p><strong>PointNet: Deep Learning on Point Sets for 3D Classification\r\nand Segmentation</strong></p>\r\n<p>Qi C R, Su H, Mo K, et al. Pointnet: Deep learning on point sets for\r\n3d classification and segmentation[C]//Proceedings of the IEEE\r\nconference on computer vision and pattern recognition. 2017:\r\n652-660.</p>\r\n<p>点云是重要的几何数据结构。由于点云的不规则形式，大部分人都将其转化为规则的3D体素网格，或者图像集合。这篇文章定义了一个全新的神经网络类型，其可以直接使用点云格式，并且很好的保持了点云输入中的置换不变性，即PointNet。</p>\r\n<p>PointNet为点云的各种应用如目标识别、部件分割、语义分割等，提供了统一的架构。</p>\r\n<p>PointNet虽然简单，但是十分高效。实验上，它和最先进的模型效果旗鼓相当，甚至更好。理论上，文章分析了网络在学习什么，并且分析了为什么网络对输入的置换和缺失具有很好的鲁棒性。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"introduction\">Introduction</h1>\r\n<p>传统的卷积结构为实现权值共享和其他核优化方法，需要高度规则的输入数据格式，因此经常会把点云和网格转化为规则的去做。但是这样会造成数据不必要的冗余，并且引入了人为量化误差而掩盖了数据本身的不变性。</p>\r\n<p>点云十分简单，并且避免了网格的复杂性，因此网络容易从中学习。但是点云仅仅是点集，因此需要在网络计算中进行一些对称化，来保证其排列不变性。更进一步，还应该考虑到刚体运动的不变性。</p>\r\n<p><strong>single symmetric function: max pooling.</strong>\r\n网络可以学习到一系列用于筛选出兴趣点的优化方法，并且将其筛选条件进行编码。最后的全连接层收集了学习到的最优特征，整合进整个形状的全局描述子。</p>\r\n<p><strong>空间变换网络</strong>：输入数据容易进行刚体变换或仿射变换：因为每一个点的变换是独立的。因此可以在PointNet处理数据之前添加一个数据依赖的空间变换网络，来对数据进行规范化处理，有利于改善结果。</p>\r\n<p><strong>点云数据特征</strong>：</p>\r\n<ol type=\"1\">\r\n<li>无序性：点云数据是一个无序的集合，因此网络如果要处理N个3D点的点云集合，需要对N!种不同的排列组合的输入保持不变性。</li>\r\n<li>点间联系：点云中的点并不是孤立存在的，一群邻近点可以形成一个有语义的子集。因此，网络必须要能够捕捉到这种邻近点群形成的局部结构特征，以及局部结构特征之间的联系。</li>\r\n<li>变换不变性：例如旋转和平移不应该影响点云的分类和分割。</li>\r\n</ol>\r\n<h1 id=\"亮点\">亮点</h1>\r\n<p>三个关键点：</p>\r\n<ol type=\"1\">\r\n<li>max pooling 层作为对称函数来聚合所有点云信息。</li>\r\n<li>一个局部和全局信息的组合结构。</li>\r\n<li>两个节点对齐T-net网络。用于对齐输入点和点特征。</li>\r\n</ol>\r\n<h2 id=\"针对无序输入的对称函数\">针对无序输入的对称函数</h2>\r\n<p><strong>两个现有策略</strong>：</p>\r\n<ol type=\"1\">\r\n<li>将输入进行规范化排序</li>\r\n</ol>\r\n<p>虽然排序听起来简单，但实际上无法找到一个在有扰动的情况下，依然稳定的排序顺序。因为这实际上是在把高维数据降维至一维直线，同时还要保证空间上的相似性（spatial\r\nproximity），而这是一件无法实现的事。因此排序依然无法解决无序性问题，如图5所示，对排序后的点集使用MLP进行训练效果依然很差，虽然比起不排序的好一点点。</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>将输入看作类似RNN那样的sequence，另外还通过各种排列组合来增强训练数据。</li>\r\n</ol>\r\n<p>考虑到点集可以看作是一种序列信号，因此引入了RNN的使用。并且期望通过随机排列序列来对RNN进行训练，这样RNN可以对输入顺序保有一定的不变性。然而《OrderMatters》[2]告诉我们RNN的输入顺序会影响网络的学习效果。尽管RNN对小批量序列有一定的顺序鲁棒性，但这很难在点云成千上万的数据批量上成立。从实验上，RNN为基础的模型依然表现的不够好。</p>\r\n<p><strong>PointNet策略</strong>：\r\n使用一个简单的对称函数来聚合每一个点的信息。</p>\r\n<blockquote>\r\n<p>对称函数：函数接收一系列的向量作为输入，输出一个新的向量。并且该输出不受输入向量间顺序的影响。例如+、*都是对称函数。</p>\r\n</blockquote>\r\n<p>本质上是对点集中变换过的每个元素使用一个对称函数，来近似等于一个通用函数(general\r\nfunction):</p>\r\n<p><span class=\"math display\">\\[\r\nf\\left(\\left\\{x_{1}, \\ldots, x_{n}\\right\\}\\right) \\approx\r\ng\\left(h\\left(x_{1}\\right), \\ldots, h\\left(x_{n}\\right)\\right)\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(f: 2^{\\mathbb{R}^{N}} \\rightarrow\r\n\\mathbb{R}, h: \\mathbb{R}^{N} \\rightarrow \\mathbb{R}^{K}\\)</span> 且\r\n<span class=\"math inline\">\\(g:\\)</span> <span\r\nclass=\"math inline\">\\(\\underbrace{\\mathbb{R}^{K} \\times \\cdots \\times\r\n\\mathbb{R}^{K}}_{n} \\rightarrow \\mathbb{R}\\)</span> 为对称函数。</p>\r\n<p>主观上看，这种模型十分简单：h看作MLP，g看作一个一元函数和max\r\npooling的结合体，实验证明这种模型十分有效。通过一系列的h，网络可以学习得到多种多样的f，来描述点云特性。</p>\r\n<h2 id=\"局部信息和全局信息整合\">局部信息和全局信息整合</h2>\r\n<p>通过对无序输入的处理，可以得到一个<span\r\nclass=\"math inline\">\\(f\\)</span>的向量<span\r\nclass=\"math inline\">\\([f_1,...,f_k]\\)</span>，即算是一种全局特征描述子。为了进行点云分割，不仅需要全局信息，还需要和局部信息进行结合。</p>\r\n<p>PointNet将先得到的全局特征重新与每个点的特征连接起来，然后计算出新的每个点的特征，即产生局部特征和全局特征的整合。</p>\r\n<p>通过这种整合，PointNet能够给出有关于局部几何信息和全局语义信息的点的数量。例如，PointNet可以精准预测每个点的法线（即证明网络可以整合点的局部信息）。</p>\r\n<h2 id=\"节点对齐网络\">节点对齐网络</h2>\r\n<p>为了让点云经过几何变换后依然有相同的语义标签，一个自然的做法是在特征抽取前将点云对齐到一个规范化空间。PointNet中通过一个小型网络T-net来预测一个仿射变换矩阵，并且直接将这个仿射变换应用在输入点云的坐标数据上，来实现对齐。</p>\r\n<p>在特征空间上也可以这样做，通过一个网络来预测特征的变换矩阵，来实现对不同输入点云的特征的对齐。不过由于特征空间的高纬度，这样的操作极大增加了网络更新的困难。因此PointNet在损失函数中添加了一个正则项，来迫使特征变换矩阵更像一个正交矩阵（正交变换不会损失数据信息）：</p>\r\n<p><span class=\"math display\">\\[\r\nL_{r e g}=\\left\\|I-A A^{T}\\right\\|_{F}^{2}\r\n\\]</span></p>\r\n<p><span\r\nclass=\"math inline\">\\(A\\)</span>是特征变换矩阵。实验证明，这个正则化可以使网络变得更加稳定，且整体效果更好。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/nnVKzLc.png\"\r\nalt=\"表 5 在ModelNet40上的对齐变换测试\" />\r\n<figcaption aria-hidden=\"true\">表 5\r\n在ModelNet40上的对齐变换测试</figcaption>\r\n</figure>\r\n<h1 id=\"网络详细结构\">网络详细结构</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/KiBbOvL.png\"\r\nalt=\"图1 PointNet结构图：Classification输出全局label。Segmentation网络最后输出每个点的分数。\" />\r\n<figcaption aria-hidden=\"true\">图1\r\nPointNet结构图：Classification输出全局label。Segmentation网络最后输出每个点的分数。</figcaption>\r\n</figure>\r\n<ul>\r\n<li>主体每一层都使用了ReLU和Batchnorm，最后一个输出为256的全连接层之后使用了dropout=0.7。</li>\r\n<li>一维卷积层（权值共享MLP）：\r\n使用多个大小为1，步长为1的卷积核，对每一个点进行卷积，不涉及到其他点。</li>\r\n<li>第一个T-Net：三层共享权值的MLP（64，128，1024）+ max pooling+\r\n两层全连接（512，256\r\n），最终输出3X3矩阵。除了最后一层都使用了ReLU和batch\r\nnormalization。</li>\r\n<li>第二个T-Net：结构相同，最后输出64X64矩阵。</li>\r\n<li>softmax分类损失携带一个一个权重0.001的正则损失，以便于让矩阵接近正交。</li>\r\n</ul>\r\n<h1 id=\"理论支撑\">理论支撑</h1>\r\n<p>证明过程有时间再看，目前先看对网络的理论性支撑。</p>\r\n<h2 id=\"集合函数万能近似定理\">集合函数万能近似定理</h2>\r\n<p>证明了PointNet理论上拟合函数的正确性。</p>\r\n<p>对于 Hausdorff 距离 <span class=\"math inline\">\\(d_{H}(\\cdot, \\cdot)\r\n.\\)</span> 假设<span class=\"math inline\">\\(f: \\mathcal{X} \\rightarrow\r\n\\mathbb{R}\\)</span> 是一个Hausdorff度量的连续集合函数。<span\r\nclass=\"math inline\">\\(\\quad \\forall \\epsilon&gt;\\)</span> <span\r\nclass=\"math inline\">\\(0, \\exists\\)</span> 一个连续函数<span\r\nclass=\"math inline\">\\(h\\)</span>和一个对称函数 <span\r\nclass=\"math inline\">\\(g\\left(x_{1}, \\ldots, x_{n}\\right)=\\gamma \\circ M\r\nA X\\)</span>, 对于任意 <span class=\"math inline\">\\(S \\in\r\n\\mathcal{X}\\)</span>有：</p>\r\n<p><span class=\"math display\">\\[\r\n\\left|f(S)-\\gamma\\left(\\underset{x_{i} \\in\r\nS}{\\operatorname{MAX}}\\left\\{h\\left(x_{i}\\right)\\right\\}\\right)\\right|&lt;\\epsilon\r\n\\]</span></p>\r\n<p>其中 <span class=\"math inline\">\\(x_{1}, \\ldots, x_{n}\\)</span> 是\r\n<span class=\"math inline\">\\(S\\)</span>的无序子集元素 , <span\r\nclass=\"math inline\">\\(\\gamma\\)</span> 是连续函数， <span\r\nclass=\"math inline\">\\(M A X\\)</span> 是 vector max operator：输入<span\r\nclass=\"math inline\">\\(n\\)</span>个向量并且输出一个每个元素位置都是最大值的向量.</p>\r\n<h2 id=\"维度瓶颈和稳定性\">维度瓶颈和稳定性</h2>\r\n<p>证明了PointNet受max pooling层维度影响很大，且其鲁棒性也与max\r\npooling层有关。表现结果是PointNet会学习到一个形状的<strong>关键点轮廓</strong>来表示这个形状。</p>\r\n<p>定义<span\r\nclass=\"math inline\">\\(\\bold{u}={\\operatorname{MAX}}\\left\\{h\\left(x_{i}\\right)\\right\\}\\)</span>为最后一层是输出K维的max\r\npooling层的网络。假设有如上定义的<span class=\"math inline\">\\(\\mathrm{u}:\r\n\\mathcal{X} \\rightarrow \\mathbb{R}^{K}\\)</span> 且 <span\r\nclass=\"math inline\">\\(f=\\gamma \\circ\\)</span> u。那么有：</p>\r\n<ol type=\"a\">\r\n<li><p>输入数据是关键点集的超集，则运算不会产生损失：<span\r\nclass=\"math inline\">\\(\\forall S, \\exists \\mathcal{C}_{S},\r\n\\mathcal{N}_{S} \\subseteq \\mathcal{X}, f(T)=f(S) if \\mathcal{C}_{S}\r\n\\subseteq T \\subseteq \\mathcal{N}_{S}\\)</span></p></li>\r\n<li><p>关键点集元素数不超过K：<span\r\nclass=\"math inline\">\\(\\left|\\mathcal{C}_{S}\\right| \\leq\r\nK\\)</span></p></li>\r\n</ol>\r\n<h1 id=\"优缺点\">优缺点</h1>\r\n<p>PointNet具有很强的鲁棒性，通过其对关键点集的提取，可以在有较多的点云损失的情况下依然保持分类能力。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/GxXDDfN.png\"\r\nalt=\"图 6 PointNet鲁棒性测试。中间的图是均匀分布异常点的结果。右边的图是给每个点数据添加不相关的高斯噪声的结果。\" />\r\n<figcaption aria-hidden=\"true\">图 6\r\nPointNet鲁棒性测试。中间的图是均匀分布异常点的结果。右边的图是给每个点数据添加不相关的高斯噪声的结果。</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/NNo3Lpu.png\"\r\nalt=\"图 7 PointNet学习到点云的关键点集：关键点集为那些对maxpooling特征有贡献的点。upper-bound点集为给定同样的全局特征信息，最多能包含的点。\" />\r\n<figcaption aria-hidden=\"true\">图 7\r\nPointNet学习到点云的关键点集：关键点集为那些对maxpooling特征有贡献的点。upper-bound点集为给定同样的全局特征信息，最多能包含的点。</figcaption>\r\n</figure>\r\n<p>PointNet只有全局特征和每个点的特征，丢失了局部点间特征。如网络结构所示，卷积层不涉及到任何点间联系。后续PointNet++[3]有关注点间联系的问题。</p>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[2] O. Vinyals, S. Bengio, and M. Kudlur. Order matters: Sequence to\r\nsequence for sets. arXiv preprint arXiv:1511.06391, 2015.</p>\r\n<p>[3] Hao C R Q L Y, Guibas S L J. PointNet++: Deep Hierarchical\r\nFeature Learning on Point Sets in a Metric Space[J]. arXiv preprint\r\narXiv:1706.02413, 2017.</p>\r\n<p><a\r\nhref=\"https://blog.csdn.net/qq_27136953/article/details/109960161?utm_medium=distribute.wap_relevant.none-task-blog-2~default~baidujs_title~default-4.wap_blog_relevant_default&amp;spm=1001.2101.3001.4242.3\">理论证明详解博客</a></p>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/86331508\">网络结构介绍博客</a></p>\r\n","categories":["深度学习"],"tags":["点云"]},{"title":"PointTransformer","url":"/2021/12/18/PointTransformer/","content":"<p><strong>Point Transformer</strong></p>\r\n<ul>\r\n<li>Zhao H, Jiang L, Jia J, et al. Point transformer[C]//Proceedings of\r\nthe IEEE/CVF International Conference on Computer Vision. 2021:\r\n16259-16268.</li>\r\n<li>港中文</li>\r\n</ul>\r\n<p>self-attention是天然的一个集合操作：将位置信息作为元素属性，并且视作集合处理。而另一方面点云天然就是位置属性的集合，因此self-attention直觉上很适合点云数据。之前已经有一些工作[48,21,50,17]在点云分析上使用了attention。他们在整个点云上使用全局的注意力机制，而这会带来昂贵的计算。并且他们使用了标量点积的注意力，即不同通道之间共享相同的聚合权重。</p>\r\n<p>相反，Point Transformer有以下优势：</p>\r\n<ul>\r\n<li><strong>局部应用注意力机制</strong>，使得拥有处理百万点数的大场景的能力。</li>\r\n<li>使用了<strong>vector\r\nattention</strong>，而这是实现高准确率的重要因素。</li>\r\n<li>阐述了<strong>position\r\nencoding</strong>的重要性，而不是像之前的工作一样忽略的位置信息。</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<h1 id=\"point-transformer\">Point Transformer</h1>\r\n<h2 id=\"原始transoformer操作\">原始Transoformer操作</h2>\r\n<p>Self-attention操作可以分为两类：<span\r\nclass=\"math inline\">\\(y_i\\)</span>为输出特征，<span\r\nclass=\"math inline\">\\(\\varphi,\\psi,\\alpha\\)</span>为逐点的线性变换操作。<span\r\nclass=\"math inline\">\\(\\delta\\)</span>为position encoding，<span\r\nclass=\"math inline\">\\(\\rho\\)</span>为标准化操作，如softmax。</p>\r\n<ul>\r\n<li>scalar\r\nattention：计算线性变换后的特征的标量积，并且将这个标量积结果当做聚合<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>变换特征的注意力权重。 <span\r\nclass=\"math display\">\\[\r\n\\mathbf{y}_{i}=\\sum_{\\mathbf{x}_{j} \\in \\mathcal{X}}\r\n\\rho(\\varphi\\left(\\mathbf{x}_{i}\\right)^T\r\n\\psi\\left(\\mathbf{x}_{j})+\\delta\\right)\r\n\\alpha\\left(\\mathbf{x}_{j}\\right)\r\n\\]</span></li>\r\n<li>vector attention：<span\r\nclass=\"math inline\">\\(\\beta\\)</span>作为一个relation函数(如减法)，<span\r\nclass=\"math inline\">\\(\\gamma\\)</span>作为一个映射函数(如MLP)，产生vector\r\nattention。这样产生的vector形式的attention能够调节独立的特征通道。 <span\r\nclass=\"math display\">\\[\r\n\\mathbf{y}_{i}=\\sum_{\\mathbf{x}_{j} \\in \\mathcal{X}}\r\n\\rho\\left(\\gamma\\left(\\beta\\left(\\varphi\\left(\\mathbf{x}_{i}\\right),\r\n\\psi\\left(\\mathbf{x}_{j}\\right)\\right)+\\delta\\right)\\right) \\odot\r\n\\alpha\\left(\\mathbf{x}_{j}\\right)\r\n\\]</span></li>\r\n</ul>\r\n<h2 id=\"point-transformer层\">Point Transformer层</h2>\r\n<p>基于vector self-attention，relation\r\nfunction使用了减法，并且在attention vector <span\r\nclass=\"math inline\">\\(\\gamma\\)</span> 和线性特征 <span\r\nclass=\"math inline\">\\(\\alpha\\)</span> 两边都加上了position encoding\r\n<span class=\"math inline\">\\(\\delta\\)</span>。</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathbf{y}_{i}=\\sum_{\\mathbf{x}_{j} \\in \\mathcal{X}(i)}\r\n\\rho\\left(\\gamma\\left(\\varphi\\left(\\mathbf{x}_{i}\\right)-\\psi\\left(\\mathbf{x}_{j}\\right)+\\delta\\right)\\right)\r\n\\odot\\left(\\alpha\\left(\\mathbf{x}_{j}\\right)+\\delta\\right)\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/AMxRPzg.png\"\r\nalt=\"Point transformer layer\" />\r\n<figcaption aria-hidden=\"true\">Point transformer layer</figcaption>\r\n</figure>\r\n<h2 id=\"position-encoding\">Position Encoding</h2>\r\n<p>位置编码对于self-attention十分重要，它可以学习局部结构。因此设计了一个可训练的参数化位置编码模型：</p>\r\n<p><span class=\"math display\">\\[\r\n\\delta=\\theta(p_i-p_j)\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(p\\)</span>为坐标，<span\r\nclass=\"math inline\">\\(\\theta\\)</span>为两个线性层和一个ReLU的MLP，并且位置编码模型和其他层一起进行端到端的训练。</p>\r\n<h2 id=\"point-transformer-block\">Point Transformer Block</h2>\r\n<p>本文构造了一个残差Point Transformer Block，其中Point Transformer\r\nLayer是其核心。如下图所示，Block集成了self-attention层，降维和加速的线性层，一个残差连接。这个Block接受所有点的坐标，并且输出每个点的特征向量。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/2rU3ABC.png\" alt=\"关键结构图\" />\r\n<figcaption aria-hidden=\"true\">关键结构图</figcaption>\r\n</figure>\r\n<h2 id=\"基于block的完整网络结构\">基于Block的完整网络结构</h2>\r\n<p>整个网络完全由point transformer，线性变换，pooling\r\n层构建，而没有使用卷积辅助。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/IR9kdzM.png\"\r\nalt=\"完整的语义分割和分类网络\" />\r\n<figcaption aria-hidden=\"true\">完整的语义分割和分类网络</figcaption>\r\n</figure>\r\n<p><strong>主体结构</strong>：首先对点云进行五次的下采样。下采样的比例可以根据应用场景调整，例如想要轻量化加速模型什么的。这些阶段主要连续使用了两个变换模块：特征编码transition\r\ndown和特征解码transition up。</p>\r\n<p><strong>Transition\r\ndown</strong>：主要功能是压缩点云。通过FPS算法进行采样点云<span\r\nclass=\"math inline\">\\(P_1\\)</span>生成子集<span\r\nclass=\"math inline\">\\(P_2\\)</span>，同时在采样前点云上<span\r\nclass=\"math inline\">\\(P_1\\)</span>使用kNN聚合特征向量。总之，<span\r\nclass=\"math inline\">\\(P_1\\)</span>的输入特征会以下一下处理：</p>\r\n<ol type=\"1\">\r\n<li>线性变换</li>\r\n<li>batch normalization</li>\r\n<li>ReLU</li>\r\n<li>FPS采样产生<span class=\"math inline\">\\(P_2\\)</span>，对<span\r\nclass=\"math inline\">\\(P_2\\)</span>的每个点，寻找其在<span\r\nclass=\"math inline\">\\(P_1\\)</span>的kNN，进行max pooling提取特征。</li>\r\n</ol>\r\n<p><strong>Transition\r\nup</strong>：对于预测密集型任务(语义分割)，使用了一种<strong>U-net的结构</strong>：使用对称的解码器与上面的编码器相配对。解码器的主要功能是将<span\r\nclass=\"math inline\">\\(P_2\\)</span>的特征映射到它的超集<span\r\nclass=\"math inline\">\\(P_1\\)</span>。<span\r\nclass=\"math inline\">\\(P_2\\)</span>的输入经过以下处理：</p>\r\n<ol type=\"1\">\r\n<li>线性变换</li>\r\n<li>batch normalization</li>\r\n<li>ReLU</li>\r\n<li>通过三维插值映射特征到超集<span\r\nclass=\"math inline\">\\(P_1\\)</span>。其中插值特征的生成不仅依赖于前一个解码器的输出特征，还依赖于匹配的编码器特征。</li>\r\n</ol>\r\n<p><strong>Output\r\nhead</strong>：对于语义分割，最终生成了每个点的特征向量。使用一个MLP层来将特征最终映射到logits。对于分类，使用全局平均池化来获得整个点集的特征，最终在通过一个MLP来映射到logits。</p>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[17] Juho Lee, Yoonho Lee, Jungtaek Kim, Adam Kosiorek, Seungjin\r\nChoi, and Yee Whye Teh. Set transformer: A framework for attention-based\r\npermutation-invariant neural networks. In ICML, 2019.</p>\r\n<p>[21] Xinhai Liu, Zhizhong Han, Yu-Shen Liu, and Matthias Zwicker.\r\nPoint2sequence: Learning the shape representation of 3d point clouds\r\nwith an attention-based sequence to sequence network. In AAAI, 2019.</p>\r\n<p>[48] Saining Xie, Sainan Liu, Zeyu Chen, and Zhuowen Tu. Attentional\r\nshapecontextnet for point cloud recognition. In CVPR, 2018.</p>\r\n<p>[50] Jiancheng Yang, Qiang Zhang, Bingbing Ni, Linguo Li, Jinxian\r\nLiu, Mengdie Zhou, and Qi Tian. Modeling point clouds with\r\nself-attention and gumbel subset sampling. In CVPR, 2019.</p>\r\n","categories":["深度学习"],"tags":["深度学习","序列学习","点云","Transformer"]},{"title":"SIGGRAPH2021翻阅","url":"/2021/10/09/SIGGRAPH2021%E7%BF%BB%E9%98%85/","content":"<h3\r\nid=\"unsupervised-learning-for-cuboid-shape-abstraction-via-joint-segmentation-from-point-clouds\">Unsupervised\r\nLearning for Cuboid Shape Abstraction via Joint Segmentation from Point\r\nClouds</h3>\r\n<p>KAIZHI YANG,XUEJIN CHEN, University of Science and Technology of\r\nChina, China</p>\r\n<p>将复杂的3D物体表达成简单的几何图元，即<strong>形状提取</strong>（shape\r\nabstract），对于几何建模、结构分析、形状合成来说十分重要。这篇文章中提出了一个无监督的形状提取方法，可以把点云映射到紧凑的立方体表示。利用部件分割和立方体形态来联合预测立方体的分布，并且在自监督学习中加强形状提取和部件分割的一致性。</p>\r\n<p><strong>立方体提取</strong>，利用一种变分自动编码网络，将点云输入转换成一系列的参数化立方体。</p>\r\n<p><strong>分割网络</strong>，\r\n根据点和立方体的联系，将每一个点分配到一个立方体中。在没有人工标注点云部件的情况下，设计了四个新的损失函数，以联合监督有关\r\n<strong>立方体压缩和几何相似度</strong> 的两条线路。</p>\r\n<p><strong>评估</strong>，在大量的形状数据集上进行评估，并且证明了比起现有方法的优越性。另外，在网络架构和学习到的特征的基础上，此方法可以支持诸如结构化形状生成，形状插值，结构化形状聚类。</p>\r\n<p>3D形状提取，3D结构表达，点云，结构分割</p>\r\n<span id=\"more\"></span>\r\n<h3\r\nid=\"sp-gan-sphere-guided-3d-shape-generation-and-manipulation\">SP-GAN:\r\nSphere-Guided 3D Shape Generation and Manipulation</h3>\r\n<p>RUIHUI LI, XIANZHI LI, KA-HEI HUI, and CHI-WING FU, The Chinese\r\nUniversity of Hong Kong, China</p>\r\n<p><strong>SP-GAN</strong>,一种新的用于指导点云生成3D形状的，无监督球体引导生成模型。</p>\r\n<p><strong>设计亮点</strong>,将复杂的3D形状生成工作分解成<strong>全局形状模型</strong>和<strong>局部结构调整</strong>，以便于简化学习过程并且加强形状生成质量。并且，此模型形成了球上的点和生成形状的点之间的隐式的稠密对应关系，以便于各种形状的结构可知的形状的操作，例如部件编辑，形状插值，复合形状部件组合等等。</p>\r\n<p><strong>比起现有模型</strong>，SP-GAN能够合成，各种各样的，高质量的，细节丰富的形状，并且提高了部件可知（part-aware）的形状的生成和操控的可控性，并且可以在<strong>没有任何部件标注</strong>的基础上训练。</p>\r\n<p>通过一个<strong>全局监督</strong>（prior）（球体上均匀分布的点），在空间上引导生成过程，并且在其上附加一个<strong>局部监督</strong>（a\r\nrandom latent code）来给每一个球上的点提供局部细节。</p>\r\n<p><strong>评估</strong>，在可视化和量化的评估下，比起现有最好的模型，该模型能够生成多样的、高细节低噪声的点云结构。</p>\r\n<p>形状分析和合成，生成模型，3D形状生成，3D形状操控，点云</p>\r\n<h3\r\nid=\"single-depth-view-based-real-time-reconstruction-of-hand-object-interactions\">Single\r\nDepth View Based Real-Time Reconstruction of Hand-Object\r\nInteractions</h3>\r\n<p>HAO ZHANG, YUXIAO ZHOU, YIFEI TIAN, JUN-HAI YONG, and FENG XU,\r\nTsinghua University</p>\r\n<p>重构手持物的交互，因其强遮挡性和复杂的运动性，是一件有挑战的工作。</p>\r\n<p><strong>实时重建</strong>，通过单深度信息来即时重建手部动作，物品形状，以及刚体/非刚体的运动。</p>\r\n<p><strong>关节学习网络</strong>，在深度图中分割手和手持物，并且预测手部的3D关键点。通过两个任务共享大多数网络层次，可以为实时性能节省计算消耗。</p>\r\n<p><strong>数据集</strong>，构造了一个混合数据集以便于利用真实数据（真实世界的分布）和合成数据（改变物体、运动、视点）训练网络。</p>\r\n<p>接着在一个统一优化（uniform\r\noptimization）中利用两个目标的深度和关键点，来重构交互动作。受益于一个新的切向接触约束，该系统不仅解决了留存的模糊性，还保持了实时的性能。</p>\r\n<p><strong>评估</strong>，对于不同的手和不同形状的手持物，不同的交互动作，运动的相机视角，该系统都能有效。</p>\r\n<p>单深度摄像头，手部追踪，目标重建，手持物交互</p>\r\n<h3\r\nid=\"learning-skeletal-articulations-with-neural-blend-shapes\">Learning\r\nSkeletal Articulations with Neural Blend Shapes</h3>\r\n<p>PEIZHUO LI, CFCS, Peking University &amp; AICFVE, Beijing Film\r\nAcademy KFIR ABERMAN, Google Research RANA HANOCKA, Tel-Aviv University\r\nLIBIN LIU, CFCS, Peking University OLGA SORKINE-HORNUNG, ETH Zurich\r\n&amp; AICFVE, Beijing Film Academy BAOQUAN CHEN∗, CFCS, Peking\r\nUniversity &amp; AICFVE, Beijing Film Academy</p>\r\n<p>利用动作捕捉数据进行角色动画设计是一个长久的计算机动画问题。</p>\r\n<p><strong>关键方向</strong>，骨骼数据转换为可用的动捕数据，关节区域的形变，而这通常需要高度定制和针对特定姿势的改进。<br />\r\n<strong>神经技术</strong>，利用预定义的骨骼结构包裹表达3D角色，而这可以产生高质量的姿势相关变形。</p>\r\n","categories":["深度学习"]},{"title":"SPCMNet：LearningSceneDynamics","url":"/2022/03/19/SPCMNet-LearningSceneDynamics/","content":"<ul>\r\n<li>He P, Emami P, Ranka S, et al. Learning Scene Dynamics from Point\r\nCloud Sequences[J]. International Journal of Computer Vision, 2022:\r\n1-27.</li>\r\n<li>Q1 CCF-A</li>\r\n<li>University of Florida ，CS</li>\r\n</ul>\r\n<p>主要是做序列点云的场景流估计以及预测任务。之前的场景流估计一般都是t-1帧预测t帧，两帧之间的联系。本文定义了序列多帧联系的场景流估计问题。并且基于这个问题，提出了一些序列学习的方法。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/FQFKpVw.png\" alt=\"整体结构图\" />\r\n<figcaption aria-hidden=\"true\">整体结构图</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<ul>\r\n<li>Intra-Frame Feature Pyramid\r\n(IFFP)：依照了PointPWC-Net的结构，由于不能直接对点云进行传统卷积，使用了PointConv层进行卷积处理。<strong>并且通过多次FPS采样卷积中心，构建了多个金字塔式特征</strong>。</li>\r\n<li>Inter-Frame Spatiotemporal Correlation (IFSC):\r\n为了能找到时空联系，很自然我们希望使时间维度上的receptive\r\nfield能够尽可能覆盖到整个序列。因此借鉴了传统序列模型的<strong>LSTM结构</strong>,使用了一个\r\n<strong>recurrent cost volume</strong> 结构来保存一定的时间信息。</li>\r\n<li>Multi-scale Coarse-to-Fine Prediction: 两个帧的特征+cost\r\nvolume的特征生成最低级(粗粒度)的预测点，然后通过Pointnet++的特征上采样传播逐渐生成细粒度特征。</li>\r\n</ul>\r\n<h1 id=\"recurrent-cost-volume\">Recurrent Cost Volume</h1>\r\n<p>PointPWC-Net(2020)提出的<strong>可学习的相继两个点云的matching\r\ncost</strong>：找到<span\r\nclass=\"math inline\">\\(p_t^j\\)</span>在上一帧中的邻域，并且计算邻域所有点与其的特征差和坐标差。</p>\r\n<p><span class=\"math display\">\\[\r\n\\operatorname{Cost}\\left(p_{t}^{j},\r\np_{t-1}^{i}\\right)=\\phi_{\\mathrm{MLP}}\\left(c_{t-1}^{i}-c_{t}^{j},\r\nx_{t-1}^{i}, x_{t}^{j}\\right)\r\n\\]</span></p>\r\n<p>然而这种<strong>点对点</strong>的matching cost对异常点特别敏感。</p>\r\n<p>FlowNet3D(2019)的flow\r\nembedding层则是<strong>点对集合</strong>的matching\r\ncost，其通过聚合邻域的特征一定程度上解决了这个问题。其先通过<strong>ball\r\nquery</strong>找到邻域，然后计算邻域每个点对中心点的matching\r\ncost，并且使用max\r\npooling进行邻域聚合。然而这种聚合的坏处就是会丢失一些运动信息。</p>\r\n<p>本文提出了一种 <strong>集合对集合</strong>的matching\r\ncost。这种从点对点到集合对集合的变化，有点像2003年Chui and\r\nRangarajan在传统点云匹配问题上的softmax到softassign\r\ncost的改变。具体对点<span class=\"math inline\">\\(p_t^j\\)</span>的matching\r\ncost定义如下：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\operatorname{CV}\\left(p_{t}^{j}\\right) &amp;=\\sum_{p_{t}^{k} \\in\r\nM\\left(p_{t}^{j}\\right)} \\omega_{M}\\left(p_{t}^{k}, p_{t}^{j}\\right) \\\\\r\n&amp; \\times \\sum_{p_{t-1}^{i} \\in N\\left(p_{t}^{k}\\right)}\r\n\\omega_{N}\\left(p_{t-1}^{i}, p_{t}^{k}\\right)\r\n\\operatorname{Cost}\\left(p_{t-1}^{i}, p_{t}^{k}\\right)\\\\\r\n\\omega_{M}\\left(p_{t}^{k},\r\np_{t}^{j}\\right)&amp;=\\operatorname{MLP}\\left(c_{t}^{k}-c_{t}^{j}\\right)\r\n\\\\\r\n\\omega_{N}\\left(p_{t-1}^{i},\r\np_{t}^{k}\\right)&amp;=\\operatorname{MLP}\\left(c_{t-1}^{i}-c_{t}^{k}\\right)\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>其中 <span class=\"math inline\">\\(M\\)</span> 为空间邻域，<span\r\nclass=\"math inline\">\\(N\\)</span>\r\n为时空邻域(即在t-1帧的空间邻域),可以通过ball-query和KNN得到。上式即对于点<span\r\nclass=\"math inline\">\\(p_t^j\\)</span>，先计算其空间邻域的特征差，然后对于空间邻域的每一个点，计算其时空邻域的特征差。两者累积相乘得到最终的cost\r\nvolume。</p>\r\n<p>下面来看cost volume怎么利用在Recurrent记忆元上。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/Ae1A1cz.png\" alt=\"RCV\" />\r\n<figcaption aria-hidden=\"true\">RCV</figcaption>\r\n</figure>\r\n<p>在RCV中，输入是当前帧的点坐标<span\r\nclass=\"math inline\">\\(C_t\\)</span>和特征<span\r\nclass=\"math inline\">\\(X_t\\)</span>。内部保留了<span\r\nclass=\"math inline\">\\(C_{t-1}\\)</span>来记录最近的点信息，同时利用两个隐状态<span\r\nclass=\"math inline\">\\(H_{t-1}\\)</span>和<span\r\nclass=\"math inline\">\\(M_{t-1}\\)</span>来作为记忆元存储。记忆元的更新方法如下：</p>\r\n<p><span class=\"math display\">\\[\r\n\\operatorname{CV}\\left(\\boldsymbol{P}_{t} ;\r\n\\boldsymbol{P}_{t-1}\\right)=\\operatorname{CV}\\left(\\boldsymbol{C}_{t},\r\n\\boldsymbol{X}_{t} ;\\boldsymbol{C}_{t-1},\\left\\{\\boldsymbol{H}_{t-1},\r\n\\boldsymbol{M}_{t-1}\\right\\}\\right)\r\n\\]</span></p>\r\n<p>即计算t帧点云内所有点关于t-1帧的cost\r\nvolume。其中t-1帧的特征用隐状态表示。</p>\r\n<p>定义了算子之后，接下来隐状态的更新和LSTM类似。<span\r\nclass=\"math inline\">\\(I\\)</span>，<span\r\nclass=\"math inline\">\\(F\\)</span>，<span\r\nclass=\"math inline\">\\(O\\)</span>分别为输入门，遗忘门，输出门。</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nI_{t} &amp;=\\sigma_{I}\\left(C V_{I}\\left(\\boldsymbol{C}_{t},\r\n\\boldsymbol{X}_{t} ; \\boldsymbol{C}_{t-1},\r\n\\boldsymbol{H}_{t-1}\\right),\\right.\\\\\r\nF_{t} &amp;=\\sigma_{F}\\left(C V_{F}\\left(\\boldsymbol{C}_{t},\r\n\\boldsymbol{X}_{t} ; \\boldsymbol{C}_{t-1},\r\n\\boldsymbol{H}_{t-1}\\right),\\right.\\\\\r\nO_{t} &amp;=\\sigma_{O}\\left(C V_{O}\\left(\\boldsymbol{C}_{t},\r\n\\boldsymbol{X}_{t} ; \\boldsymbol{C}_{t-1},\r\n\\boldsymbol{H}_{t-1}\\right)\\right.\\\\\r\n\\hat{\\boldsymbol{M}}_{t-1} &amp;=C V_{M}\\left(\\boldsymbol{C}_{t}, \\text\r\n{ None } ; \\boldsymbol{C}_{t-1}, \\boldsymbol{M}_{t-1}\\right), \\\\\r\n\\hat{\\boldsymbol{H}}_{t} &amp;=\\tanh \\left(C\r\nV_{H}\\left(\\boldsymbol{C}_{t}, \\boldsymbol{X}_{t} ;\r\n\\boldsymbol{C}_{t-1}, \\boldsymbol{H}_{t-1}\\right)\\right), \\\\\r\n\\boldsymbol{M}_{t} &amp;=F_{t} \\odot \\hat{\\boldsymbol{M}}_{t-1}+I_{t}\r\n\\odot \\hat{\\boldsymbol{H}}_{t}, \\\\\r\n\\boldsymbol{H}_{t} &amp;=O_{t} \\odot \\boldsymbol{M}_{t},\r\n\\end{aligned}\r\n\\]</span></p>\r\n","categories":["深度学习"],"tags":["深度学习","点云"]},{"title":"SequentialPointNet","url":"/2021/12/26/SequentialPointNet/","content":"<p><strong>SequentialPointNet: A strong parallelized point cloud\r\nsequence network for 3D action recognition</strong></p>\r\n<ul>\r\n<li>Li X, Huang Q, Wang Z, et al. SequentialPointNet: A strong\r\nparallelized point cloud sequence network for 3D action recognition[J].\r\narXiv preprint arXiv:2111.08492, 2021.</li>\r\n<li>河海大学 CS</li>\r\n<li><a\r\nhref=\"https://github.com/XingLi1012/SequentialPointNet.git\">源码仓库</a></li>\r\n</ul>\r\n<p>针对人类动作在空间上复杂，在时间上简单的特性，不平等的对待空间信息和时间信息。提出了一个强并行能力的点云序列网络SequentialPointNet：一个帧内appearance编码模块，一个帧间动作编码模块。</p>\r\n<ul>\r\n<li>为了对人体动作丰富的空间信息建模，每帧先在帧内的appearance\r\nencoding中并行处理，并且输出一个特征向量序列，描述静态的appearance在时间维度上的改变。</li>\r\n<li>为了建模简单的时间维度上的变化，在帧间的动作编码模块中，在特征向量序列中应用了\r\n时间上的位置编码和分层的池化策略。</li>\r\n<li>为了更好的挖掘时空内容，聚合人体动作的多级特征。</li>\r\n</ul>\r\n<h1 id=\"帧间编码\">帧间编码</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/AfhgtrM.png\" alt=\"帧间编码\" />\r\n<figcaption aria-hidden=\"true\">帧间编码</figcaption>\r\n</figure>\r\n<p><strong>Temporal position\r\nembedding</strong>：和Transformer的positional\r\nencoding差不多。将时间上的位置进行encoding：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{gathered}\r\nP E_{t, 2 h}=\\sin \\left(t / 10000^{2 h / d_{\\text {sout }}}\\right) \\\\\r\nP E_{t, 2 h+1}=\\cos \\left(t / 10000^{2 h / d_{\\text {sout }}}\\right)\\\\\r\n\\widehat{f}_{t, h}=f_{t, h}+P E_{t, h}\r\n\\end{gathered}\r\n\\]</span></p>\r\n<p><strong>共享MLP</strong>：在时间位置编码之后，再进行特征抽取，加强信息。</p>\r\n<p><strong>Hierarchical pyramid max\r\npooling</strong>：类似于多卷积核操作。将时间序列化为不同的几个部分，并且使用max\r\npooling分别抽取特征。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/unueYdQ.png\" alt=\"层级式max pooling\" />\r\n<figcaption aria-hidden=\"true\">层级式max pooling</figcaption>\r\n</figure>\r\n<p><strong>多级特征抽取</strong>：序列层级学习是帧间的分级策略，还有帧内的多级特征抽取：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{gathered}\r\nP=\\underset{t=1, \\ldots,\r\nT}{\\operatorname{MAX}}\\left\\{\\operatorname{MAX}_{j=1, \\ldots,\r\nn_{2}}\\left\\{r_{j}^{t}\\right\\}\\right\\} \\\\\r\nR=\\operatorname{MAX}_{t=1, \\ldots, T}\\left\\{f_{t}\\right\\}\r\n\\end{gathered}\r\n\\]</span></p>\r\n","categories":["深度学习"],"tags":["序列学习","点云"]},{"title":"《SexEducation 2》观后感","url":"/2021/05/07/SexEducation%E8%A7%82%E5%90%8E%E6%84%9F/","content":"<h2 id=\"爱恨分明的各路人色剧透吐槽\">爱恨分明的各路人色（剧透吐槽）</h2>\r\n<h3\r\nid=\"亚当可能是感觉转变最细腻的一个角色了\">亚当，可能是感觉转变最细腻的一个角色了</h3>\r\n<p>从一个整天面无表情的四肢发达头脑简单的霸凌大块头，逐渐展露出内心对自己取向的拒绝，被冷漠的父亲养成的外壳式自我坚强，高大的身体里好像一个弱小委屈的小男孩在迷茫地用最原始的粗暴探寻自己的道路。最后到面对自己面对外界，当着全校学生和家长的面，牵起埃里克的手，甚至开始温温柔柔地像邻家大男孩。</p>\r\n<p>最后在埃里克家长面前收获真爱并且被家长夸赞，嘴角第一次弧度上扬，可爱。当然埃里克说的其实也很有道理，欺凌了那么久，给埃里克造成了那么久的打击，别人不原谅他不和他做朋友是理所应当的，不过和梅芙一开始不原谅母亲不同，他勇敢地面对了自己的一切，努力地转变着自己的行为，最后大家都可以选择原谅和不原谅，都是合情合理的。</p>\r\n<p>相反梅芙妈那边就不一样了，明明没啥改变还指责别人不原谅自己？不原谅是人家的合情合理。更何况不值得原谅。</p>\r\n<span id=\"more\"></span>\r\n<h3\r\nid=\"虽然大块头小男孩亚当很讨喜但是rahim出场的还是很可悲以及值得惋惜\">虽然大块头小男孩亚当很讨喜，但是Rahim出场的还是很可悲以及值得惋惜。</h3>\r\n<p>和亚当的拒绝后反转不同，Rahim从第二季开头上线开始，就是很直爽潇洒地承认自己对Eric的感情，勇敢的和他在一起，帮助他突破在公众环境下gay的身份认知，愿意陪他干所有事，可惜和Eric脑波对不上，不喜欢他的音乐剧爱好，get不到他的笑点，虽然这里亚当能get到就很剧情刻意。最后还要被Eric无情抛弃。虽然主角视角里Eric是终于面对了真爱，但Rahim这里他只是勇敢恋爱了然后爱人还有旧情未断甚至抛弃了他罢了。一个可怜的酷酷角色。</p>\r\n<h3\r\nid=\"说实话第二季梅芙的周围人都让人讨厌\">说实话，第二季梅芙的周围人都让人讨厌。</h3>\r\n<h3 id=\"首先是不请自来的母亲\">首先是不请自来的母亲</h3>\r\n<p><strong>十几年抛弃女儿毫无音讯，结果最后无路可去想回就回？回就算了，还好像对方不原谅你还是对方的错一样？</strong></p>\r\n<p>明明是自己抛弃了女儿多少年，把自己的错误一笔带过，还轻飘飘不可思议地质疑梅芙为什么不能原谅？请你先尊重认识一下自己的罪孽。一句轻飘飘的对不起不过是给自己原谅自己的借口，然后还可以谴责对方，“不过是一次错误为什么要这么对我”。？凭什么被伤害的人还要被你指点原谅。真想道歉请真心地用尽一切办法挽回对方。别人不原谅别人当然有权利不原谅，这时候你就恼羞成怒指责对方？这是来道歉的？这是倚老卖老来仗势说教的。</p>\r\n<p>另外被举报的时候，她哪来的道德高点和底气说“Never”。？你抛弃女儿十几年的时候你不觉得对方更应该“Never”？</p>\r\n<p>婴儿要被社区照顾的时候很心痛很憎恨的样子？还央求不带走你的孩子？孩子在家你照顾过她？盆栽枯死，婴儿衣服从来不洗，把婴儿丢给邻居女儿照顾，自己假装出门然后跑回家轻轻松松看电视？婴儿用来满足占有欲罢了。</p>\r\n<p>当然被举报也有一线机会洗白，那就是以撒的那个证据是错的，或者干脆就是陷害的。这样最后恼羞成怒，被误解的不甘“Never”是可以理解的。</p>\r\n<h3\r\nid=\"另外我很讨厌以撒这种人设以及他被对待的方式\">另外我很讨厌以撒这种人设，以及他被对待的方式</h3>\r\n<p>破坏梅芙旧爱是出自其私心无可厚非了，单从和梅芙相识开始就是欺人做坏事小人得意，圆滑捣乱的形象。这样居然还不会被讨厌，坏男孩真的是讨人喜欢吗。从我看来这种找茬的就很欠揍。</p>\r\n<p>故意丢书环节，第一次梅芙出于好意帮忙可以理解，当着面第二次丢书再要你捡，这真的不算是找茬骚扰吗？然后还得寸进尺，还要帮你推进去，还要帮你跳舞。正常人不早该踹一脚上去了。</p>\r\n<p>还非要跟着别人去没被邀请的Party，啊这，你撩妹可以好好撩，别搞得那么讨人厌不好吗。</p>\r\n<p>更绝的是梅芙一个酷酷的人还会不断妥协最后成为朋友，虽然梅芙的形象很明朗的是假装scary实际温柔。</p>\r\n<p><strong>与其说讨厌以撒的伪找茬式搭讪交友，不如说讨厌梅芙向这些无理取闹妥协温柔地过分。</strong></p>\r\n<p>之后也是一些手段阻止梅芙收获真正的幸福，用其他短评的话来说就是：以便和他一起待在深渊。</p>\r\n","categories":["生活"]},{"title":"SkeletonTransformer","url":"/2022/01/08/SkeletonTransformer/","content":"<ul>\r\n<li>Plizzari C, Cannici M, Matteucci M. Skeleton-based action\r\nrecognition via spatial and temporal transformer networks[J]. Computer\r\nVision and Image Understanding, 2021, 208: 103219.</li>\r\n<li>Politecnico di Torino 意大利都灵理工大学</li>\r\n<li>Q3</li>\r\n</ul>\r\n<h1 id=\"introduction\">Introduction</h1>\r\n<p>尽管ST-GCN的结构已经在骨架动作识别中广泛应用，但是仍然有一些结构上的缺陷。</p>\r\n<p>本文设计了Spatial Self-Attention (SSA)\r\n模块，用于在骨架之间动态的建立联系，而独立于人体真实骨架结构。另外在时间维度上设计了Temporal\r\nSelf-Attention (TSA)模块用于学习关节在时间上的变化。</p>\r\n<h1 id=\"spatialtemporal-transformer-st-tr\">Spatial–Temporal Transformer\r\n(ST-TR)</h1>\r\n<p>Self-Attention最初的灵感是希望对句子中单词进行跨越距离的相关性编码。因此本文希望同样的方式也可以应用到骨架节点上。</p>\r\n<p><strong>空间上</strong>：节点之间的相关性是很重要的，<strong>因此抛弃了任何预定义的骨架结构</strong>，让self-attention自动查找关节关系，类似于动态边的图卷积。</p>\r\n<p><strong>时间上</strong>：也希望通过self-attention查找出不同帧的关系。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/MYJ50cH.png\"\r\nalt=\"时空两个Self-Attention，两者都使用了多头注意力机制\" />\r\n<figcaption\r\naria-hidden=\"true\">时空两个Self-Attention，两者都使用了多头注意力机制</figcaption>\r\n</figure>\r\n<h2 id=\"spatial-self-attention-ssa\">Spatial Self-Attention (SSA)</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/7XzfJ4V.png\" alt=\"SSA\" />\r\n<figcaption aria-hidden=\"true\">SSA</figcaption>\r\n</figure>\r\n<p>类似于文本的self-Attention，抛开图结构，对关节点进行注意力计算。，最终输出这个关节点经过注意力编码的特征：</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathbf{z}_{i}^{t}=\\sum_{j}\r\n\\operatorname{softmax}_{j}\\left(\\frac{\\alpha_{i\r\nj}^{t}}{\\sqrt{d_{\\mathrm{k}}}}\\right) \\mathbf{v}_{j}^{t}\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/4eAkiFl.png\" alt=\"详细结构\" />\r\n<figcaption aria-hidden=\"true\">详细结构</figcaption>\r\n</figure>\r\n<h2 id=\"temporal-self-attention-tsa\">Temporal Self-Attention (TSA)</h2>\r\n<p>在时间计算中，每个关节点被视为独立的存在，去计算帧之间的注意力关联性：</p>\r\n<p><span class=\"math display\">\\[\r\n\\alpha_{t u}^{v}=\\mathbf{q}_{t}^{v} \\cdot \\mathbf{k}_{u}^{v} \\quad\r\n\\forall v \\in V, \\quad \\mathbf{z}_{t}^{v}=\\sum_{j}\r\n\\operatorname{softmax}_{u}\\left(\\frac{\\alpha_{t\r\nu}^{v}}{\\sqrt{d_{\\mathrm{k}}}}\\right) \\mathbf{v}_{u}^{v},\r\n\\]</span></p>\r\n<h2 id=\"two-stream-spatialtemporal-transformer-st-tr-network\">Two-Stream\r\nSpatial–Temporal Transformer (ST-TR) Network</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/MqxcnCa.png\" alt=\"ST-TR\" />\r\n<figcaption aria-hidden=\"true\">ST-TR</figcaption>\r\n</figure>\r\n<p>为了结合SSA和TSA模块，构造了一个 two-stream\r\narchitecture(ST-TR)。SSA和TSA分别独立在S-TR stream和 T-TR\r\nstream进行应用，然后再融合。(Shi et al. 2019)</p>\r\n<p>两个streams中都先应用了三层的残差网络对特征进行提取。S-TR中在空间上使用了GCN进行提取特征，T-TR中使用了标准的2D卷积(TCN,Yan\r\net al. 2018)。</p>\r\n<p>然后在后续的S-TR模块，T-TR模块(结构如上图)处理中分别用SSA和TSA来替换GCN和TCN。</p>\r\n<p>最后在经历一系列S-TR ,\r\nT-TR模块的处理后，通过累加起两个stream的softmax输出来获得最终的score。</p>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[1] Shi, L., Zhang, Y., Cheng, J., Lu, H., 2019b. Two-stream adaptive\r\ngraph convolutional networks for skeleton-based action recognition. In:\r\nProceedings of the IEEE Conference on Computer Vision and Pattern\r\nRecognition. pp. 12026–12035.</p>\r\n<p>[2] Shi, L., Zhang, Y., Cheng, J., Lu, H., 2019a. Skeleton-based\r\naction recognition with directed graph neural networks. In: Proceedings\r\nof the IEEE Conference on Computer Vision and Pattern Recognition. pp.\r\n7912–7921.</p>\r\n","categories":["深度学习"],"tags":["深度学习","序列学习","点云"]},{"title":"网络编程框架基础(Unity+C#)","url":"/2021/10/20/Socket%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/","content":"<h2 id=\"基础流程\">基础流程</h2>\r\n<h3 id=\"客户端流程\">客户端流程</h3>\r\n<ol type=\"1\">\r\n<li>socket.Connect（远程IP地址，远程端口）</li>\r\n<li>socket.Send/BenginSend发送数据</li>\r\n<li>socket.Receive/BeginReceive接收服务端数据</li>\r\n<li>socket.Close关闭连接</li>\r\n</ol>\r\n<h3 id=\"服务器流程\">服务器流程</h3>\r\n<ol type=\"1\">\r\n<li>listenfd.Bind（ipEp）将给listenfd套接字绑定IP和端口。</li>\r\n<li>listenfd.Listen（backlog）开启监听</li>\r\n<li>listenfd.Accept/BeginAccept接收客户端连接。Accept/EndAccept返回连接的Socket对象，对于服务器来说，它有一个监听Socket（listenfd）用来监听（Listen）和应答（Accept），对每个客户端的连接产生一个专门的Socket（connfd）用来处理该客户端的数据。</li>\r\n<li>connfd.Receive/BeginReceive 接受数据</li>\r\n</ol>\r\n<span id=\"more\"></span>\r\n<h3 id=\"异步操作性能最优\">异步操作（性能最优）</h3>\r\n<p>由BeginXXX开始，产生调用时转接到对应的回调函数。EndXXX放在回调函数里：EndXXX返回对应数据，处理完成后再在回调函数里BeginXXX开启新一轮的异步操作。</p>\r\n<h3 id=\"poll状态监测\">Poll状态监测</h3>\r\n<p>比起异步程序，同步程序更简单明了，而且不会引发线程问题。因此先高频检测socket状态，后同步阻塞操作。但是CPU占用率会过高。</p>\r\n<p>public bool Poll（int microSeconds，SelectMode mode）</p>\r\n<p>Poll方法将会检查Socket的状态。<br />\r\n如果指定mode参数为SelectMode.SelectRead，则可确定Socket是否为可读；<br />\r\n指定参数为SelectMode.SelectWrite，可确定Socket是否为可写；<br />\r\n指定参数为SelectMode.SelectError，可以检测错误条件。<br />\r\nmicroSeconds设置阻塞时间，-1一直阻塞，0非阻塞。</p>\r\n<p><strong>使用框架</strong>：</p>\r\n<figure class=\"highlight cs\"><table><tr><td class=\"code\"><pre><span class=\"line\">初始化listenfd</span><br><span class=\"line\">初始化clients列表</span><br><span class=\"line\"><span class=\"keyword\">while</span>（<span class=\"literal\">true</span>）&#123;</span><br><span class=\"line\">　　<span class=\"keyword\">if</span>（listenfd可读）　Accept获得连接socket;</span><br><span class=\"line\">　　<span class=\"keyword\">for</span>（遍历clients列表）&#123;</span><br><span class=\"line\">　　　　<span class=\"keyword\">if</span>（这个连接socket可读）　Receive消息处理;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>即服务端使用主循环结构while（true）{……}，不断重复做两件事情：</p>\r\n<ol type=\"1\">\r\n<li>判断监听Socket是否可读，如果监听Socket可读，意味着有客户端连接上来，调用Accept回应客户端，以及把客户端Socket加入客户端信息列表。</li>\r\n<li>如果某一个客户端Socket可读，处理它的消息（在聊天室中，服务端把消息广播给各个客户端）。</li>\r\n</ol>\r\n<h3 id=\"多路复用select\">多路复用Select</h3>\r\n<p>同时Poll检测多个Socket（可以同时包含listen socket和connect\r\nsocket），没有一个可用则根据参数进行阻塞。避免了CPU使用率过高。</p>\r\n<p>public static void Select(IList checkRead，IList check Write，IList\r\ncheckError，int microSeconds)</p>\r\n<p>参数分别为三个待检测状态的Socket列表IList，以及阻塞时间。检测完成后IList只剩下满足状态的Socket。若阻塞超时则是返回空列表。</p>\r\n<p>使用框架：</p>\r\n<figure class=\"highlight cs\"><table><tr><td class=\"code\"><pre><span class=\"line\">初始化listenfd</span><br><span class=\"line\">初始化clients列表</span><br><span class=\"line\"><span class=\"keyword\">while</span>（<span class=\"literal\">true</span>）</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">　　checkList = 待检测Socket列表</span><br><span class=\"line\">　　Select（checkList ……）</span><br><span class=\"line\">　　<span class=\"keyword\">for</span>（遍历可读checkList列表）<span class=\"comment\">//可能同时包含listen socket和connect socket</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    　　如果是listenfd -&gt; Accept获得连接socket;</span><br><span class=\"line\">　　　　如果是连接socket -&gt; 消息处理;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"黏包问题\">黏包问题</h2>\r\n<p>可选三种方法：</p>\r\n<ol type=\"1\">\r\n<li>附带长度信息</li>\r\n<li>附带结束符号</li>\r\n<li>固定长度</li>\r\n</ol>\r\n<p>通常使用长度信息法</p>\r\n<h3 id=\"发送消息\">发送消息</h3>\r\n<p>在头部利用2字节作为长度信息。</p>\r\n<figure class=\"highlight cs\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">byte</span>[] bodyBytes = System.Text.Encoding.Default.GetBytes(sendStr);</span><br><span class=\"line\">Int16 len =(Int16)bodyBytes.Length;</span><br><span class=\"line\"><span class=\"built_in\">byte</span>[] lenBytes = BitConverter.GetBytes(len);<span class=\"comment\">//隐藏了大端小端问题</span></span><br><span class=\"line\"><span class=\"built_in\">byte</span>[] sendBytes = lenBytes.Concat(bodyBytes).ToArray();</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"接收和处理消息\">接收和处理消息</h3>\r\n<p>需提供接收缓冲区和缓冲区实际长度。</p>\r\n<figure class=\"highlight cs\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">byte</span>[] readBuff = <span class=\"keyword\">new</span> <span class=\"built_in\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\"><span class=\"built_in\">int</span> buffCount = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\r\n<ol type=\"1\">\r\n<li>Receive需要偏移到已存储消息尾部进行追加存储</li>\r\n<li>更新buffCount</li>\r\n</ol>\r\n<p>根据缓冲区长度处理数据：</p>\r\n<ol type=\"1\">\r\n<li>小于等于2字节，长度信息不完整，不处理。</li>\r\n<li>大于2字节，读取长度，大于消息实际长度，等待后续消息，不处理。</li>\r\n<li>大于2字节，读取长度，小于等于消息实际长度：即存在一条完整消息。按长度读取。</li>\r\n</ol>\r\n<p>读取结束需要更新缓冲区，例如把缓冲区向前移位：</p>\r\n<figure class=\"highlight cs\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.Copy(readBuff，msgStart，readBuff，<span class=\"number\">0</span>，count);</span><br></pre></td></tr></table></figure>\r\n<p>但是数组移位是一个低效的办法，因此可以把缓冲数组做成循环数组,同时还可以考虑自动扩展等优化功能。</p>\r\n<h2 id=\"发送不完整\">发送不完整</h2>\r\n<p>程序的Send功能其实是把字节交给操作系统的网络缓冲区处理。然而系统缓冲区不够时，可能Send没有将完整信息写入缓冲区，导致信息丢失，因此需要检查EndSend返回发送的字节数，然后进行修正。</p>\r\n<h3 id=\"多次send消息\">多次Send消息</h3>\r\n<p>容易想到发送不成功就多发送几次。</p>\r\n<p>每次Send记录已进入系统缓冲的字节数，计算剩余字节数。如果剩余字节大于0，则再次调用Send，此时注意Send需要偏移已缓冲字节数。</p>\r\n<p>但这种方法有个问题，就是需要保证多次Send的过程中，存储的消息不变。比如在第一次发送不完整，第二次Send还没开始，此时有新的消息进入了程序覆盖掉了存储的消息，那么第二次Send就会出错。</p>\r\n<h3 id=\"消息队列\">消息队列</h3>\r\n<p>因此在程序中我们需要多个存储消息的空间，即创建一个发送消息队列。队列的元素是程序原来的消息缓冲区。</p>\r\n<p>每次想要发送消息，进入Send的回调函数，在消息队列后追加一个消息缓冲区，并且填充好需要发送的消息。</p>\r\n<p>判断进入时是否在队列头部进行Send：</p>\r\n<ol type=\"1\">\r\n<li>在队列头部，则进入上面【多次Send消息】的处理，保证这一条消息完整送达。直到完整发送完成，Pop队首，再提取下一条消息的发送。</li>\r\n<li>不在队列头部，不进行处理。</li>\r\n</ol>\r\n<p>这样保证了每次只发送一条消息，不会被后续消息干扰。但是还是有问题。</p>\r\n<p>写入队列是在各自的回调过程中进行的，因此写入队列时会有线程冲突：假如前一个线程执行到了【Pop队首】和【提取下一条】之间，后一个线程执行到【进入队列】——此时前一个线程会提取出下一条消息进行发送，后一个线程也会因为处在队列头部进行发送，导致重复。</p>\r\n<p>因此还要对上述会产生冲突的地方进行互斥锁处理，保证成原子操作。</p>\r\n<h2 id=\"协议类\">协议类</h2>\r\n<p>对于通信协议，初级做法是两边都写上对等的协议解析具体步骤。但这种做法的前提是两边都是你自己写，因为只有你知道协议应该怎么去解析。</p>\r\n<p>因此我们需要一个协议类，独立于客户端和服务器，来描述一个协议的相关参数。</p>\r\n<h2 id=\"错误排除\">错误排除</h2>\r\n<blockquote>\r\n<p>在Unity中，只有主线程可以操作UI组件。由于异步回调是在其他线程执行的，不能直接操作unityUI组件。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>启动8888端口的服务器后，总发现有一个不知名本地端口会连接上来，然后出现消息解析错误。想了半天代码哪里有问题，结果使用netstat\r\n-aon|findstr \"8888\"排查后发现是迅雷的后台服务和这个端口冲突了...</p>\r\n</blockquote>\r\n","tags":["网络","C#","Unity"]},{"title":"Swin Transformer","url":"/2022/03/30/Swin%20Transformer/","content":"<ul>\r\n<li>Liu Z, Lin Y, Cao Y, et al. Swin transformer: Hierarchical vision\r\ntransformer using shifted windows[C]//Proceedings of the IEEE/CVF\r\nInternational Conference on Computer Vision. 2021: 10012-10022.</li>\r\n<li>微软</li>\r\n</ul>\r\n<p>在视觉中做Transformer有两大问题，图片比起语言分辨率过高，以及图片中的目标尺度有大有小，变化很大。为了解决这两个问题，Swim\r\nTransformer一方面做了<strong>多分辨率的层级式结构</strong>，另一方面设计了\r\n<strong>shift of the window partition between consecutive self-attention\r\nlayers</strong>。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/Kojn8xQ.png\" alt=\"多分辨率层级结构\" />\r\n<figcaption aria-hidden=\"true\">多分辨率层级结构</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/inorpV4.png\"\r\nalt=\"shifted window：l+1层相对与l层，其子窗口划分进行了偏移。由于在新的一个子窗口内进行自注意力计算，会设计到上一级的多个窗口，因此提供了窗口的连接性。\" />\r\n<figcaption aria-hidden=\"true\">shifted\r\nwindow：l+1层相对与l层，其子窗口划分进行了偏移。由于在新的一个子窗口内进行自注意力计算，会设计到上一级的多个窗口，因此提供了窗口的连接性。</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h1 id=\"architecture\">Architecture</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/42v5Q1S.png\"\r\nalt=\"(a)整体结构 (b)两个级联的注意力模块，W-MSA为常规window的多头注意力。SW-MSA为shifted window的多头注意力。\" />\r\n<figcaption aria-hidden=\"true\">(a)整体结构\r\n(b)两个级联的注意力模块，W-MSA为常规window的多头注意力。SW-MSA为shifted\r\nwindow的多头注意力。</figcaption>\r\n</figure>\r\n<p>整体管线思路很清晰：</p>\r\n<ol type=\"1\">\r\n<li>将图像划分为多个不重合的partition，每个partition视为一个词元token。</li>\r\n<li>Stage1：对词元进行基础的变换，linear\r\nembedding和self-attention。</li>\r\n<li>Stage2~4：每一个层对patch进行特征融合以及新的注意力计算。</li>\r\n</ol>\r\n<h1 id=\"shifted-window-based-self-attention\">Shifted Window based\r\nSelf-Attention</h1>\r\n<p>标准的Transformer和ViT都在构造全局的自注意力计算。然而这样的计算复杂度很高，导致很多高分辨率场景无法使用。</p>\r\n<p><strong>Self-attention in non-overlapped\r\nwindows</strong>：为了节省效率，Swim Transformer希望在local\r\nwindow中计算自注意力。每一个window包含多个patch（即window不是patch）。</p>\r\n<p><strong>Shifted window partitioning in successive\r\nblocks</strong>：上述的window方法通过局部计算减少了计算量，但另一方面导致不同window之间缺乏联系，而不像全局自注意力那样计算的是全局联系。因此采用了上图所示的shifted\r\nwindow方法。</p>\r\n<p>但是shifted\r\nwindow带来的一个问题是window数目会变多，且大小会不一致。一个朴素的解决办法即\r\n<strong>填充法</strong>，将不同大小的window都pad到同样的大小，并且在计算自注意力时mask掉pad的区域。但是这样明显的增加了计算量（window数目增多）。</p>\r\n<p>一种高效的方法是\r\n<strong>割补法</strong>：如图所示，将不同大小的非邻接window组合成原大小的window，这样即保留了跨window的计算连接性，还保证了同样的计算量。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/oUUAWxq.png\"\r\nalt=\"割补法：凑齐原大小的window\" />\r\n<figcaption aria-hidden=\"true\">割补法：凑齐原大小的window</figcaption>\r\n</figure>\r\n<h1 id=\"relative-position-bias\">relative position bias</h1>\r\n<p>对于自注意力的每个head，引入了相对位置编码<span\r\nclass=\"math inline\">\\(B \\in \\mathbb{R}^{M^2 \\times M^2}\\)</span>：</p>\r\n<p><span class=\"math display\">\\[\r\n\\operatorname{Attention}(Q, K, V)=\\operatorname{SoftMax}\\left(Q K^{T} /\r\n\\sqrt{d}+B\\right) V\r\n\\]</span></p>\r\n<p>其中<span class=\"math inline\">\\(Q,K,V \\in \\mathbb{R}^{M^2 \\times\r\nd}\\)</span>, <span\r\nclass=\"math inline\">\\(M^2\\)</span>为window的数目。由于在每个轴上\r\n<strong>相对位置</strong> 的变化范围是<span\r\nclass=\"math inline\">\\([-M+1,M-1]\\)</span>，即最大位置差为2M-1。因此其又构造了一个更小一点的子矩阵<span\r\nclass=\"math inline\">\\(\\hat{B} \\in \\mathbb{R}^{(2M-1) \\times\r\n(2M-1)}\\)</span>，用于存储每个位置差对应的值。而真正的<span\r\nclass=\"math inline\">\\(B\\)</span>中所有的取值，都可以从<span\r\nclass=\"math inline\">\\(\\hat{b}\\)</span>中拿到。</p>\r\n<p>位置编码可以带来<strong>significant improvements</strong></p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/ZnI1aMA.png\" alt=\"位置编码的消融学习\" />\r\n<figcaption aria-hidden=\"true\">位置编码的消融学习</figcaption>\r\n</figure>\r\n","categories":["深度学习"],"tags":["深度学习","点云"]},{"title":"UnityShader半透明物体问题","url":"/2022/05/22/UnityShader%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E9%81%AE%E6%8C%A1%E9%97%AE%E9%A2%98/","content":"<p>为了写一个半透明物体的shader，有以下几点基础要求：</p>\r\n<ol type=\"1\">\r\n<li>更近的不透明物体要挡住透明物体。因此透明物体<strong>需要深度测试</strong>来决定是否渲染。</li>\r\n<li>透明物体不能挡住透明物体。因此透明物体之间不能进行深度测试来剔除渲染，即透明物体<strong>不能写入深度</strong>。\r\n<img src=\"https://i.imgur.com/eRfC2Zz.png\"\r\nalt=\"开启深度写入，透明物体错误地挡住透明物体\" /></li>\r\n<li>既然不能写入深度，不透明物体与透明物体之间的渲染顺序就十分关键。如果更远的不透明物体晚一点渲染，其会不合理地挡住更近的透明物体(因为透明物体没有写入深度值)。因此需要<strong>分离渲染顺序队列</strong>。</li>\r\n<li>透明物体之间的顺序问题。当然Unity也知道顺序很关键，由于没有fragment-level的顺序信息，因此unity会对透明物体按object-level从远到近排序，再进行渲染。这通常没有问题，但是当两个透明物体的深度是交叉的时候就会产生错误。因此理想解决方案是<strong>顺序无关透明（order\r\nindependent transparency, OIT）</strong>，即逐像素排序。 <img\r\nsrc=\"https://i.imgur.com/rcWdI9Y.png\"\r\nalt=\"透明物体之间的渲染顺序错误。交叉地带应该由A覆盖B，实际上由于B的中心点更近，因此其所有fragment都在A之后渲染，导致B错误的覆盖A。\" /></li>\r\n</ol>\r\n<span id=\"more\"></span>\r\n<p>总之，一个寻常的半透明shader，通常要设置渲染队列，关闭深度写入，开启透明混合，如下所示：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SubShader</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Tags </span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        &quot;Queue&quot;=&quot;Transparent&quot; </span><br><span class=\"line\">        &quot;IgnoreProjector&quot;=&quot;True&quot; </span><br><span class=\"line\">        &quot;RenderType&quot;=&quot;Transparent&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Pass</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class=\"line\">        ZWrite Off //关闭深度写入</span><br><span class=\"line\">        Blend SrcAlpha OneMinusSrcAlpha //设置Blend模式</span><br><span class=\"line\"></span><br><span class=\"line\">        CGPROGRAM</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        ENDCG</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/8BLR7zs.png\"\r\nalt=\"寻常的透明效果。透明的knot中间包含了一个不透明的球\" />\r\n<figcaption\r\naria-hidden=\"true\">寻常的透明效果。透明的knot中间包含了一个不透明的球</figcaption>\r\n</figure>\r\n<p>效果如上图所示，然而其中依然存在着一些问题:</p>\r\n<ol type=\"1\">\r\n<li><strong>非凸网格的自我遮挡问题</strong>(同上第4点，即透明物体的fragment-level顺序问题)。由于我们对这个shader关闭了深度写入，因此knot上前后自遮挡的几个透明fragment会产生渲染顺序问题(注意这里不是背面和正面的顺序关系，遮挡的几个fragment都是knot的正面)。这里可以选择<strong>优化分割网格，使其成为不自遮挡的凸网格</strong>。</li>\r\n<li><strong>双面渲染问题</strong>，我们看不到透明物体的背面。因为Unity默认将背对摄像机的面剔除了。然而这是不合理的，哪有透明物体对自己反而不透明的道理。因此我们需要<strong>关闭背面剔除\r\nCull\r\nOff</strong>。而同时渲染背面和正面之后，又会回到<strong>自我穿插问题</strong>，即由于没有顺序关系，背面可能挡住正面。</li>\r\n</ol>\r\n<p>自我遮挡问题可以通过切分网格解决，但是更寻常的双面渲染问题还是需要shader进行解决。由于核心问题是让<strong>背面比正面更早渲染</strong>，因此可以使用两个Pass，前面的Pass\r\nCull Front渲染背面，后面的Pass Cull Back渲染正面。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SubShader</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Tags </span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        &quot;Queue&quot;=&quot;Transparent&quot; </span><br><span class=\"line\">        &quot;IgnoreProjector&quot;=&quot;True&quot; </span><br><span class=\"line\">        &quot;RenderType&quot;=&quot;Transparent&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    Pass</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Cull Front</span><br><span class=\"line\">        Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class=\"line\">        ZWrite Off //关闭深度写入</span><br><span class=\"line\">        Blend SrcAlpha OneMinusSrcAlpha //设置Blend模式</span><br><span class=\"line\">        CGPROGRAM</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        ENDCG</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Pass</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Cull Back</span><br><span class=\"line\">        Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class=\"line\">        ZWrite Off //关闭深度写入</span><br><span class=\"line\">        Blend SrcAlpha OneMinusSrcAlpha //设置Blend模式</span><br><span class=\"line\">        CGPROGRAM</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        ENDCG</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","tags":["Unity"]},{"title":"VMware-虚拟机繁忙卡死-vmware-vmx进程杀不掉-拒绝访问","url":"/2020/02/17/VMware-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B9%81%E5%BF%99%E5%8D%A1%E6%AD%BB-vmware-vmx%E8%BF%9B%E7%A8%8B%E6%9D%80%E4%B8%8D%E6%8E%89-%E6%8B%92%E7%BB%9D%E8%AE%BF%E9%97%AE/","content":"<h2 id=\"问题\">问题：</h2>\r\n<h5\r\nid=\"前几天win10系统更新到了1909打开vmware-15.0.2时系统通知该版本可能无法运行-没管它开了虚拟机结果就是虚拟机黑屏卡死vm工作台无法结束后台vmware-vmx进程拒绝访问\">前几天win10系统更新到了1909，打开VMware\r\n15.0.2时系统通知该版本可能无法运行=\r\n=没管它开了虚拟机，结果就是虚拟机黑屏卡死，vm工作台无法结束，后台vmware-vmx进程拒绝访问。</h5>\r\n<h2 id=\"解决步骤\">解决步骤：</h2>\r\n<ol type=\"1\">\r\n<li><p>打开windows【服务】面板</p>\r\n<p>1.1 可以WIN+R 输入 services.msc 打开</p>\r\n<p>1.2 也可以在win10的搜索框中直接搜索 “服务”</p></li>\r\n<li><p>按【v】键，快速找到vmware相关服务，全部\r\n右键-属性-禁用，且停止运行。</p></li>\r\n<li><p>全部停止运行后，任务管理器已经可以关掉vm的主进程，但其实后台还有一个vmware-vmx没关掉，也关不掉。</p></li>\r\n<li><p>此时【重启】电脑，注意是重启，不是关机再开机，可以发现vmware-vmx已经没有了</p></li>\r\n<li><p>但和其他博客说的不同，此时恢复vmware相关服务，再开虚拟机一样是卡死，同样的问题。</p></li>\r\n<li><p>因此打开vmware的安装程序，准备修复，先别点下修复=\r\n=（文件夹里找，或者控制面板-卸载或更改程序里找）</p></li>\r\n<li><p>我修复运行的时候，提示无法写入文件glib-2.0.dll，vmPerfmon.dll，所以修复之前可以手动先删除这两个文件看看=\r\n=在vmware安装目录下面，假如无法删除可以把后缀名改为.txt，这样就不会阻碍vmware的修复程序。</p></li>\r\n<li><p>修复程序运行完成，打开vmware，提示你更新新版本，或者你自己选项里检查更新一下=\r\n=，换到新版本。当然你直接卸载下一个应该也是一样。</p></li>\r\n<li><p>我升级到15.5.1，重启之后可以正常运行，并且之前的虚拟机信息没有丢失。</p></li>\r\n</ol>\r\n<h2 id=\"总结\">总结：</h2>\r\n<h5\r\nid=\"应该是win-1909-和-vmware的15.0的版本冲突看其他人说1903也有问题总之要听信windows为数不多的劝告换新版本吧\">应该是win\r\n1909 和\r\nvmware的15.0的版本冲突，看其他人说1903也有问题。总之要听信windows为数不多的劝告，换新版本吧=\r\n=</h5>\r\n","categories":["工具"]},{"title":"Win10-cmd-PowerShell-SSH无法创建目录-和-SCP-找不到文件","url":"/2020/02/17/Win10-SSH%E9%94%99%E8%AF%AF/","content":"<h3 id=\"确定错误信息\">确定错误信息</h3>\r\n<p><strong>输入 SSH root@remotenode</strong></p>\r\n<blockquote>\r\n<p>输出: 无法创建目录 Could not create directory: C:\\123\\456\\789.ssh\r\n无法添加信任主机列表 Failed to add.....</p>\r\n</blockquote>\r\n<p>然而.ssh目录明明就在用户名文件夹下存在= =</p>\r\n<p>配置的免密登录远程主机也不能用</p>\r\n<p><strong>输入 scp ./test.txt root@remotenode:/root/test.win</strong>\r\n&gt;输出: 无法找到文件 : No Such File</p>\r\n<p>事实上这个文件存在</p>\r\n<h3 id=\"原因猜测-用户名带中文或特殊字符-导致路径无法识别\">原因猜测:\r\n用户名带中文或特殊字符, 导致路径无法识别</h3>\r\n<p>cmd和PowerShell 的编码都是GBK, 讲道理是可以用中文的...</p>\r\n<p>使用chcp 65001换成utf-8也不行</p>\r\n<p>当然也不可能重命名用户名文件夹..一大堆程序数据都在下面呢= =</p>\r\n<h3 id=\"可行方案\">可行方案 :</h3>\r\n<p><strong>1. 使用git bash 代替[cmd/PowerShel]</strong> 之前装git有装git\r\nbash. 并且git bash 里可以设置中文字符集,因此就试了一下,\r\n发现完全没有障碍= =</p>\r\n<p>环境什么的完全没变, 可以正常找到.ssh目录 , 可以正常写入 known_host\r\n,除了在第一次登的时候询问写入known_host, 之后免密登录也可以正常使用.</p>\r\n<p>scp可以正常发送用户名目录下的文件, 不会找不到.</p>\r\n<p>果然查遍全网也解决不了的问题是cmd自身的问题= =</p>\r\n<p><strong>2. 使用SSH工具,如Putty</strong> 使用Putty open登录主机,\r\n好像不会提示known_host 的事情, 但是可以顺利免密登录.</p>\r\n","categories":["工具"]},{"title":"git使用相关","url":"/2020/08/18/git%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%85%B3/","content":"<h1 id=\"奇怪的问题汇总\">奇怪的问题汇总</h1>\r\n<h2\r\nid=\"git连接github每次都需要输入账号密码\">git连接GitHub每次都需要输入账号密码</h2>\r\n<h3 id=\"背景\">背景</h3>\r\n<p>问题在于git clone\r\n的时候选择的链接是HTTPS的，因此在这个仓库中，git不会通过SSH密钥去进行免密认证。</p>\r\n<h3 id=\"解决方案\">解决方案</h3>\r\n<p>命令行输入<code>git config  -l</code></p>\r\n<p>可以看到一大堆信息，关注其中一条与链接相关的：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">remote.origin.url=https://...</span><br></pre></td></tr></table></figure>\r\n<p>我们需要url的https链接改回ssh即可。</p>\r\n<p>命令行输入 <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git config remote.origin.url git@github.com:你的仓库地址</span><br></pre></td></tr></table></figure></p>\r\n<p>试着<code>git push</code>一下=。=</p>\r\n<p><span id=\"more\"></span></p>\r\n<h2\r\nid=\"存在ssh密钥但访问github时permission-denied-publickey\">存在SSH密钥，但访问GitHub时Permission\r\ndenied (publickey)</h2>\r\n<h3 id=\"背景-1\">背景</h3>\r\n<p>在之前SSH默认路径下<code>C:/用户/xxx/.ssh</code>是存在id_rsa文件的。</p>\r\n<p>但我们命令行输入<code>ssh -vT git@github.com</code>，在identity\r\nfile开头，id_rsa结尾的行中 最后结尾是 -1 ,说明SSH找不到id_rsa。</p>\r\n<h3 id=\"解决办法\">解决办法</h3>\r\n<p>尝试重新生成SSH密钥，命令行输入</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -b 4096 -C &quot;你的邮箱“</span><br></pre></td></tr></table></figure>\r\n<p>在尝试生成时，命令行会提示一句请确认文件保存位置: <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Enter file in which to save the key (/c/WINDOWS/system32/config/systemprofile/.ssh/id_rsa):</span><br></pre></td></tr></table></figure></p>\r\n<p>注意那个默认位置...是的，这玩意把默认位置改了找不到原来的SSH文件了。憨憨</p>\r\n<p>复制原来的密钥文件过去即可。</p>\r\n<h3 id=\"参考资料\">参考资料</h3>\r\n<p><a\r\nhref=\"https://docs.github.com/cn/enterprise/2.19/user/github/authenticating-to-github/troubleshooting-ssh\">GitHub\r\nSSH故障排除文档</a></p>\r\n","categories":["工具"],"tags":["git"]},{"title":"ffmpeg常用命令","url":"/2021/10/12/ffmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"<h3 id=\"裁剪片段\">裁剪片段</h3>\r\n<p>ffmpeg -ss hh:mm:ss -i input.mp4 -t 60 -c copy output.mp4<br />\r\n&gt;ffmpeg -ss 起始时间 -i 输入视频 -t 持续时间 -c copy 输出视频</p>\r\n<h3 id=\"转换格式包括音频\">转换格式（包括音频）</h3>\r\n<p>ffmpeg -i input.mp4 output.mp3</p>\r\n<h3 id=\"转换分辨率\">转换分辨率</h3>\r\n<p>ffmpeg -i input.mp4 -filter:v scale=1280:720 -c:a copy output.mp4</p>\r\n","categories":["工具"],"tags":["ffmpeg"]},{"title":"pyqt安装找不到designer.exe问题","url":"/2021/03/31/pyqt%E5%AE%89%E8%A3%85%E6%89%BE%E4%B8%8D%E5%88%B0designer-exe%E9%97%AE%E9%A2%98/","content":"<blockquote>\r\n<p>又是一个被复制粘贴的脏教程坑的案例，此文献给从泥沼中求生的安装者。</p>\r\n</blockquote>\r\n<p>pip install pyqt5 pip install pyqt5-tools</p>\r\n<p>安装就这样，最好给个管理员权限。</p>\r\n<p><strong>designer所在目录<code>AppData\\Local\\Programs\\Python\\Python37\\Lib\\site-packages\\qt5_applications\\Qt\\bin</code></strong></p>\r\n<p>不是脏教程写的乱七八糟的什么在pyqt-tools下面，什么pyqt的QT下面，东抄西抄把过时的东西留到现代太烦了。</p>\r\n","tags":["python","pyqt"]},{"title":"七天上海狗狗攻略","url":"/2021/05/25/%E4%B8%83%E5%A4%A9%E4%B8%8A%E6%B5%B7%E7%8B%97%E7%8B%97%E6%94%BB%E7%95%A5/","content":"<h2 id=\"准备\">准备</h2>\r\n<p>必备：<br />\r\n- 身份证，很多地方刷身份证拿门票。<br />\r\n- 口罩，路上随意，地铁景点必需。<br />\r\n- 随申码（上海的健康码），支付宝或微信提前注册好。</p>\r\n<p>注意：<br />\r\n- 是否需要预约线上买票，疫情期间蛮多景点要的。<br />\r\n- 学生证，门票降价。<br />\r\n- 水，室内景点需要。<br />\r\n-\r\n地铁，手机有NFC功能可以开通NFC上海地铁卡，刷手机就行。没有的话下一个metro大都会APP刷二维码。<br />\r\n- 充电宝，看手机情况。<br />\r\n- 考虑考虑现金硬币？公交轮渡小玩具可能需要投币。<br />\r\n- 下个单车APP，美团什么的。</p>\r\n<p>Google\r\nMap做的景点标记图，可以分图层显示不同线路的景点。（需要科学上网查看）<br />\r\n名字，觉得狗狗可爱就叫狗狗了= =<br />\r\n<iframe src=\"https://www.google.com/maps/d/embed?mid=1EIKOKf1WJGIotRHoh_j30SSqckgMuhYY\" width=\"640\" height=\"480\"></iframe></p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"安顿\">安顿</h2>\r\n<p>下机<br />\r\n2线徐泾东方向-&gt;7线美兰湖方向-&gt;东安路站 1小时20分钟</p>\r\n<p>？还有磁悬浮列车。磁悬浮到龙阳路转7线 40分钟 54元</p>\r\n<p>到民宿<br />\r\n休息休息可以去周边吃个饭走一走 有个商场 <strong>正大乐城</strong></p>\r\n<p>离黄浦江1公里，随时可以去江边散步</p>\r\n<p>休息好了之后可以去比较近的一个景点，<strong>田子坊</strong> /\r\n<strong>武康路</strong> /<strong>天主教堂</strong>......</p>\r\n<p>景点分了不同线，默认上午一觉到12点......所以一天去一条线逛个下午和晚上就可以了=。=</p>\r\n<h2 id=\"田子坊线\">田子坊线</h2>\r\n<p>7线东安路-&gt;9线打浦桥 10分钟<br />\r\n预估时长：下午+晚上</p>\r\n<h3 id=\"田子坊\">田子坊</h3>\r\n<blockquote>\r\n<p>全天候开放<br />\r\n预估时长：2~3小时<br />\r\n但是一些商家和工作室一般都在早上10点左右开门。最好不太早去。</p>\r\n</blockquote>\r\n<p>很文艺的一个地方<br />\r\n&gt;在意想不到的地方发现一些新奇的小玩意！</p>\r\n<p>文化一条街，各种小店，吃的喝的卖的，文艺店，艺术气氛，弄堂气息。<br />\r\n钱可以不带，拍照设备请准备好。</p>\r\n<p>田子坊内沿路都是小吃，不过很商业化，有些一点也不好吃。其中\r\n<strong>洛神花冻</strong>（网友强推👍）</p>\r\n<p><strong>猫先生之家</strong> 撸猫，可以找找。</p>\r\n<p>甚至还有<strong>菜市场</strong>？卖一些水果什么的。可以顺便买点菜回民宿了=。=</p>\r\n<p>有一些别具特色的酒吧餐厅，晚上可以感受感受另一种氛围。</p>\r\n<blockquote>\r\n<p>田子坊的小店有太多陡峭的狭窄楼梯，尽量避免穿高跟鞋和超短裙。</p>\r\n</blockquote>\r\n<h3 id=\"琉璃艺术博物馆\">琉璃艺术博物馆</h3>\r\n<blockquote>\r\n<p>非周一 10：00~17:00（16:30停止入场） 门票30 预估时长：1~2小时</p>\r\n</blockquote>\r\n<p>田子坊7号门出来可以顺便看看琉璃艺术博物馆.<br />\r\n1楼是卖场，出售一些琉璃制品，2楼以上都是博物馆，展出世界艺术师的各种琉璃制品。</p>\r\n<blockquote>\r\n<p>如果错过入馆时间，夜景也很不错——外墙上一朵巨大的琉璃牡丹花在黑夜盛开。</p>\r\n</blockquote>\r\n<figure>\r\n<img src=\"琉璃艺术博物馆.jpg\" alt=\"夜景牡丹\" />\r\n<figcaption aria-hidden=\"true\">夜景牡丹</figcaption>\r\n</figure>\r\n<h3 id=\"可选日月光商场恋爱博物馆\">（可选）日月光商场/恋爱博物馆</h3>\r\n<blockquote>\r\n<p>预估时长：1小时+0.5小时<br />\r\n恋爱博物馆开放：10~21：30 门票68</p>\r\n</blockquote>\r\n<p>逛完景点旁边就是一个<strong>日月光商圈</strong><br />\r\n可以找点好吃的走走消化消化。</p>\r\n<p>日月光中心泰康区五楼有一个 <strong>恋爱博物馆</strong></p>\r\n<p>展出一些恋爱纪念品以及其背后的故事，欣赏爱情。<br />\r\n为热恋的情侣做一个见证，可同时寄存一件物品及其意义。一年后同时持证才能拿走。</p>\r\n<h2 id=\"上海博物馆\">上海博物馆</h2>\r\n<p>7线东安路 -&gt; 1线人民广场 27分钟</p>\r\n<h3 id=\"上海博物馆-1\">上海博物馆</h3>\r\n<blockquote>\r\n<p>非周一 9~17（16停止入场）<br />\r\n预估时长：4~5小时 半天<br />\r\n实名制预约，免费，上海博物馆官网、微信公众号。每日限额8000人</p>\r\n</blockquote>\r\n<p>文物界“半壁江山”之誉，是一座大型的中国古代艺术博物馆。馆藏文物近百万件，以青铜器、陶瓷器、书法、绘画为特色。</p>\r\n<p>人很多，高峰需要排队一小时，建议早上或者中午进去。</p>\r\n<p>需安检，别乱带东西。</p>\r\n<p>建议使用讲解辅助，上海博物馆APP即可，不用租实体导览器。</p>\r\n<p>中午去逛，晚上出来可以在<strong>人民广场</strong>看看夜景走一走。<br />\r\n上午去逛，下午可以走路去旁边<strong>上海当代艺术馆</strong> 、\r\n<strong>上海城市规划展示馆</strong> 看看。</p>\r\n<h3 id=\"可选上海当代艺术馆\">（可选）上海当代艺术馆</h3>\r\n<blockquote>\r\n<p>非周一 10~18（17停）<br />\r\n预估时长：1~2小时</p>\r\n</blockquote>\r\n<p>动态艺术展览，注意在网上看好当前展览项目。</p>\r\n<h3 id=\"可选上海城市规划展示馆\">（可选）上海城市规划展示馆</h3>\r\n<blockquote>\r\n<p>非周一 9~17 门票30<br />\r\n预估时长：1小时</p>\r\n</blockquote>\r\n<p>上海蓬勃发展的时代缩影，以1：500比例真实生动反映上海内环以内110平方公里核心城区的规划与现状。</p>\r\n<h2 id=\"武康路线旧法租界\">武康路线（旧法租界）</h2>\r\n<blockquote>\r\n<p>预估时长：1小时<br />\r\n7线东安路 -&gt; 常熟路 +步行1公里 20分钟<br />\r\n离民宿很近，哪天白天想出去走走去看看就可以了。</p>\r\n</blockquote>\r\n<p>散步拍照一条小街。<br />\r\n比较有上世纪上海最繁华的时候的烙印，沿途很多有腔调的咖啡馆。西班牙式、法国文艺复兴式等风格的建筑极富特色，两旁的古树郁郁葱葱。</p>\r\n<p>晚上不会亮灯，光线不好风景不好，白天去。</p>\r\n<p>一条路，随便怎么走。<strong>武康大楼</strong>或<strong>巴金故居</strong>，从其中一个往另一个的方向走。</p>\r\n<p>武康大楼、宋庆龄故居<br />\r\n意大利领事官宅（不开放）<br />\r\n武康庭<br />\r\nPeet‘s Coffee、Stack咖啡店<br />\r\nRosa Gallica花店<br />\r\n巴金故居<br />\r\n1984 Book Store</p>\r\n<figure>\r\n<img src=\"RosaGallica.jpg\" alt=\"Rosa Gallica花店\" />\r\n<figcaption aria-hidden=\"true\">Rosa Gallica花店</figcaption>\r\n</figure>\r\n<h2 id=\"甜爱路线\">甜爱路线</h2>\r\n<p>7线东安路 -&gt; 8线虹口足球场1号口 45分钟<br />\r\n预估时长：1~2小时</p>\r\n<h3 id=\"甜爱路\">甜爱路</h3>\r\n<blockquote>\r\n<p>预估时长：0.5小时+公园散步1小时</p>\r\n</blockquote>\r\n<p>一条很短的小路，墙上满是情话。留下爱的誓言和签名，在此合影留念。</p>\r\n<p>请手牵手走，不准松的那种。</p>\r\n<p>其实这条路很普通。但是普通带来的幽静，刚好适合情侣散步。<br />\r\n有牵手的人一起走过就足够浪漫。</p>\r\n<p>一头连着商业街四川北路，一头连着鲁迅公园。</p>\r\n<p>请带好一封贴好邮票的情书。<br />\r\n溧阳路1338号门卫处可以盖上“甜爱路\"以及“LOVE”的邮戳。</p>\r\n<p>旁边有<strong>鲁迅故居</strong>（非周一\r\n9~16）、<strong>鲁迅纪念馆</strong>（公园）。<br />\r\n北上有知名的<strong>临汾路小吃夜市</strong>（可能被整治了），东南有<strong>1933老场坊</strong>。</p>\r\n<h3 id=\"老场坊\">1933老场坊</h3>\r\n<blockquote>\r\n<p>预估时长：1小时</p>\r\n</blockquote>\r\n<p>有些艺术工作室在里面，建议非周末去，周末人走楼空挺落寞的。<br />\r\n旧屠宰场改为的艺术工作室圈。<br />\r\n没什么特殊亮点，建筑结构比较艺术，适合拍照散步。</p>\r\n<h2 id=\"外滩线\">外滩线</h2>\r\n<p>4线外圈东安路-&gt;8线-&gt;10线豫园 1号口 30分钟<br />\r\n预估时长：下午+晚上</p>\r\n<h3 id=\"豫园\">豫园</h3>\r\n<blockquote>\r\n<p>非周一 9~16:30 （16停止入园）门票40<br />\r\n预估时长：1~2小时<br />\r\n疫情期间需预约，携程/美团./去哪儿/同程/驴妈妈。</p>\r\n</blockquote>\r\n<p>古典园林，设计精巧，环境清幽，亭台楼阁、假山、池塘样样俱全。</p>\r\n<p>园林没特别喜好的话去过一个就可以了，豫园在市中心比较方便。上海五大园林哪个近可以去哪个。</p>\r\n<p>建议使用语音讲解，感受园林设计内涵。</p>\r\n<h3 id=\"城隍庙\">城隍庙</h3>\r\n<blockquote>\r\n<p>小吃街全天候开放<br />\r\n预估时长：1小时</p>\r\n</blockquote>\r\n<p>夜晚金碧辉煌的商业化小吃街。<br />\r\n在豫园对面，适合当豫园逛完的用餐点了。小吃街去过一个也就行了。</p>\r\n<p>南翔馒头店<br />\r\n鲜得来排骨<br />\r\n五芳斋点心<br />\r\n小绍兴的白斩鸡<br />\r\n......</p>\r\n<p>除开小吃街，也可以买票进寺庙，有财神殿和求姻缘之类的。（8: 30\r\n~16:30） 票价10</p>\r\n<h3 id=\"bfc外滩枫泾市集夜市\">BFC外滩枫泾（市集夜市）</h3>\r\n<blockquote>\r\n<p>周末 10~22</p>\r\n</blockquote>\r\n<p>大概是最嚣张最方便最豪华的夜市了。<br />\r\n城隍庙吃完直接往江边走就是夜市区域，正好去逛逛夜市消化放松。</p>\r\n<h3 id=\"外滩\">外滩</h3>\r\n<blockquote>\r\n<p>预估时长：2~3小时</p>\r\n</blockquote>\r\n<p>晚上7点，资本闪耀起了它的辉煌。<br />\r\n必须！晚上去！</p>\r\n<p>夜市逛完北上，沿江夜景走过去看看万国建筑景色。<br />\r\n也可以地铁到南京东路，穿南京东路逛逛商业街到外滩中心。</p>\r\n<p><strong>浦江观光隧道</strong>不推荐，光管隧道而已，没有风景。</p>\r\n<p>来回走走，可以回到夜市那边去渡口坐交通渡轮去<strong>东方明珠</strong>那边，2元可以往返。（不是观光游轮）<br />\r\n&gt;外滩金陵东路码头 -&gt;\r\n浦东东昌路码头（距陆家嘴15分钟路）08：00~21:30 some minutes</p>\r\n<p>一直北上的话，如果白天时间还早可以去<strong>外滩美术馆</strong>逛逛</p>\r\n<h3 id=\"可选上海外滩美术馆\">（可选）上海外滩美术馆</h3>\r\n<blockquote>\r\n<p>周一关门 10:00~18：00</p>\r\n</blockquote>\r\n<p>有兴趣可以看看，2021.6是《帘幕》主题展。<br />\r\n一系列关于监控时代的批判性问题，试图釐清不同地域间的共生关係，从被忽略的视角出发，理解跨国交流的重要性。</p>\r\n<h3 id=\"东方明珠\">东方明珠</h3>\r\n<blockquote>\r\n<p>9~21 预估时长：1小时<br />\r\n需要【东方明珠】公众号预约买票，推荐双球票。200左右<br />\r\n东昌路渡口要走1.2公里过来</p>\r\n</blockquote>\r\n<p>看外滩夜景</p>\r\n<p>想登高看城市夜景可以上去。几大高楼推荐东方明珠，靠江景色好且有城市情怀。不过也就只是用来看看夜景，上面没有其他的。</p>\r\n<p>第一颗球98m，商场娱乐项目。</p>\r\n<p>第二颗球263m，主要观光层。登高游览，晚上上去看外滩夜景还是不错。<br />\r\n有空中旋转餐厅——捞钱用的，午餐170/人，晚餐200/人。</p>\r\n<p>第三颗球340m...体现分级感，也是捞钱用的。特别不推荐！</p>\r\n<p>上电梯要排挺久队，可以拿点宣传手册或者看看书玩玩手机游戏。电梯直达二球，然后可以选择上下。</p>\r\n<p>下来后一楼0m有一个<strong>上海历史发展陈列馆</strong>，记载上海历史变迁的感觉。顺便去逛逛就可。</p>\r\n<p>需要安检，别乱带东西。</p>\r\n<blockquote>\r\n<p>雨天大风天雾天别上..非全封闭，大风大雨会感觉很危险。雾天也看不到啥。</p>\r\n</blockquote>\r\n<h2 id=\"中国花博会\">中国花博会</h2>\r\n<blockquote>\r\n<p>9~21（2021.7.2之前）<br />\r\n预估时长：半天<br />\r\n很远，7线-&gt;龙阳路 6号口-&gt;步行 龙阳路公交枢纽\r\n花博专线3线-&gt;花博园 2小时20分钟<br />\r\n实名提前一天18点前预约买票。平日票120，周末及特殊日180，“第十届中国花卉博览会”买票</p>\r\n</blockquote>\r\n<p>中国花卉博览会，刚好在上海崇明举办。</p>\r\n<p>世纪馆：沙谷绿洲、丛林秘境......<br />\r\n国内馆：各省市特色，澳门彩色建筑，江苏园林，北京红墙...<br />\r\n企业区：迪士尼标志性城堡<br />\r\n百花馆...</p>\r\n<p>入园记得拿好纸质地图或者电子地图。<br />\r\n园区非常大可能会累，带好饮料食物。</p>\r\n<p>建议路线：入园坐小火车到世纪馆-&gt;国内馆-&gt;复兴馆-&gt;企业区-&gt;设计师区-&gt;百花馆</p>\r\n<figure>\r\n<img src=\"花博会.jpg\" alt=\"花博会\" />\r\n<figcaption aria-hidden=\"true\">花博会</figcaption>\r\n</figure>\r\n<h2 id=\"泰晤士小镇线\">泰晤士小镇线</h2>\r\n<p>打车 45分钟</p>\r\n<p>~7线东安路-&gt;9线松江大学城 4号口 -&gt;\r\n步行240m至松江客运中心坐车13站，到弘翔路三新北路。 1小时32分钟~</p>\r\n<p>地方很偏，晕车要死，通勤也会比较累。</p>\r\n<p>预估时长：半天</p>\r\n<h3 id=\"泰晤士小镇\">泰晤士小镇</h3>\r\n<blockquote>\r\n<p>全天候开放 预估时长：2小时左右，不喜欢走路可能0.5小时就想回去了</p>\r\n</blockquote>\r\n<p>英伦风的安静街道<br />\r\n天气清爽适合情侣来压马路。<br />\r\n慢节奏的郊游之旅。</p>\r\n<p>风景很好，能进的建筑不多，钟书阁很出名。<br />\r\n钟书阁对面有个prince street，运气好可以看见一只萨摩耶！</p>\r\n<p>教堂前拍婚纱的好多，但不能进。</p>\r\n<h3 id=\"广富林遗址公园水下博物馆\">广富林遗址公园（水下博物馆）</h3>\r\n<blockquote>\r\n<p>预估时长：1小时<br />\r\n泰晤士小镇打车 14分钟</p>\r\n</blockquote>\r\n<p>还未完全建成，5月开放的还只是公园东片区。真正的遗址公园预计于10月1日前后基本开放</p>\r\n<p>5月开放的东片区包括，民俗文化展示区、宗教文化展示区，文化交流中心、多功能会议中心和广富林文化展示馆三座水下建筑</p>\r\n<h3 id=\"上海影视乐园\">上海影视乐园</h3>\r\n<blockquote>\r\n<p>8:30~16:30 预估时长：1.5小时<br />\r\n网上售票需谨慎，有些不认。建议现场买。<br />\r\n广富林遗址打车 40分钟</p>\r\n</blockquote>\r\n<p>著名影视取景城，老上海滩景色。<br />\r\n《功夫》《色戒》等</p>\r\n<p>可能能遇到拍片现场...然后被封路。</p>\r\n<h2 id=\"可选小景点\">可选小景点</h2>\r\n<h3 id=\"中华艺术宫\">中华艺术宫</h3>\r\n<blockquote>\r\n<p>非周一 10:00~18：00 预估时长：1小时<br />\r\n7线东安路 -&gt; 8线中华艺术宫 3号口 16分钟</p>\r\n</blockquote>\r\n<p>世博园仅剩下的中国馆<br />\r\n有点空旷东西不多，有超大动态清明上河图。</p>\r\n<p>附近有 <strong>上海宋城</strong> 世博公园区。</p>\r\n<h3 id=\"上海宋城\">上海宋城</h3>\r\n<blockquote>\r\n<p>周一~周五 10~21 节假日9:30~21<br />\r\n预估时长：2小时<br />\r\n7线东安路 -&gt; 8线中华艺术宫 3号口 16分钟</p>\r\n</blockquote>\r\n<p>演艺公园，可能偏亲子。消费很高。</p>\r\n<p>评价两极分化，好评很多，但也据说非常一般。</p>\r\n<p>门票399最低，内还要单独消费</p>\r\n<p>有换装区，数千套服装的换装体验，最低158/人</p>\r\n<p>也很多演出剧场，如《上海千古情》。但一张票只能看一场。399一场...</p>\r\n<p>可以关注 <strong>上海宋城</strong> 公众号。</p>\r\n<h3 id=\"m50创意园\">M50创意园</h3>\r\n<blockquote>\r\n<p>预估时长：1小时<br />\r\n7线-&gt;13线江宁路 1号口-&gt;步行1.2公里 35分钟</p>\r\n</blockquote>\r\n<p>艺术园区。类似1933老场坊。众多艺术工作室的园区。<br />\r\n墙上以前有很多涂鸦很酷，但好像被拆的所剩无几。</p>\r\n<p>天气清凉可以走走</p>\r\n<h3 id=\"圣依纳爵主教座堂\">圣依纳爵主教座堂</h3>\r\n<blockquote>\r\n<p>非周日9~16 周日 14~16<br />\r\n预估时长：0.5小时<br />\r\n在徐家汇游客服务中心取票免费参观</p>\r\n</blockquote>\r\n<p>徐家汇天主教大教堂<br />\r\n白天想散步消化可以过去看看</p>\r\n<p>弥撒时间为平日的06:15和7:00，周六06:15,07:00，16:30，18:00。</p>\r\n<h3 id=\"宜家静安city店\">宜家静安City店</h3>\r\n<blockquote>\r\n<p>预估时长：1~2小时<br />\r\n7线东安路-&gt;静安寺 10分钟</p>\r\n</blockquote>\r\n<p>离武康路有一点距离的宜家City店。比宝山概念店要小很多，小小三层体验店。但也不用像大店那样花太多时间，闲着散步走个一小时是可以的。</p>\r\n<p>旁边晚上有<strong>安义夜市</strong></p>\r\n<h3 id=\"安义夜市\">安义夜市</h3>\r\n<blockquote>\r\n<p>周五20：00~周日24:00<br />\r\n预估时长：0.5小时</p>\r\n</blockquote>\r\n<p>小吃散步热闹夜市</p>\r\n<h3 id=\"宜家宝山超大店\">宜家宝山超大店</h3>\r\n<blockquote>\r\n<p>预估时长：3小时，半天<br />\r\n7线-&gt;大场镇 30分钟</p>\r\n</blockquote>\r\n<p>超大，应有尽有。</p>\r\n<p>很多主题房间，家装完美示例。<br />\r\n每个房间还有很多小细节小装饰，值得瞅瞅。</p>\r\n<h3 id=\"思南集市\">思南集市</h3>\r\n<blockquote>\r\n<p>预估时长：1小时<br />\r\n7线-&gt;9线 打浦桥-&gt; 步行1公里 30分钟</p>\r\n</blockquote>\r\n<p>有吃有玩有艺术展</p>\r\n","categories":["生活"]},{"title":"二叉树的四种遍历（迭代法）","url":"/2020/07/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86/","content":"<p>假定树结构如下：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> </span></span><br><span class=\"line\"><span class=\"class\"> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    TreeNode *left;</span><br><span class=\"line\">    TreeNode *right;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>(<span class=\"keyword\">int</span> x) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">left</span>(<span class=\"literal\">NULL</span>), <span class=\"built_in\">right</span>(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>递归思路很简单，只记录迭代思路。</p>\r\n<h1 id=\"前序遍历\">前序遍历</h1>\r\n<p>先根，再左结点，再右结点。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    vector&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    </span><br><span class=\"line\">    stack&lt;TreeNode*&gt; s;</span><br><span class=\"line\">    s.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!s.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        TreeNode * current=s.<span class=\"built_in\">top</span>();s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        result.<span class=\"built_in\">push_back</span>(current-&gt;val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(current-&gt;right) s.<span class=\"built_in\">push</span>(current-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(current-&gt;left) s.<span class=\"built_in\">push</span>(current-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"中序遍历\">中序遍历</h1>\r\n<p>先左，再根，再右。</p>\r\n<p>迭代时注意没有对左结点的输出，是把左结点继续往下看，看成以它为根的树根结点，然后统一用输出根结点的方式输出所有结点。</p>\r\n<blockquote>\r\n<p>根节点同时也是根父节点的左子结点，因此回溯上去的时候顺序是”父（左）-右“、”父（左）-右“。</p>\r\n<p>即输出当前根，然后进入右树，然后往上一层，此时上一层的左树就是刚刚解决好的。因此继续同样的\"根\r\n- 右\"顺序进行遍历。</p>\r\n</blockquote>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    vector&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    stack&lt;TreeNode*&gt; mem;</span><br><span class=\"line\">    TreeNode *current=root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!mem.<span class=\"built_in\">empty</span>()||current)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//左节点压栈</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(current)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            mem.<span class=\"built_in\">push</span>(current);</span><br><span class=\"line\">            current=current-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        current=mem.<span class=\"built_in\">top</span>();mem.<span class=\"built_in\">pop</span>();<span class=\"comment\">//输出当前子树根结点</span></span><br><span class=\"line\">        result.<span class=\"built_in\">push_back</span>(current-&gt;val);</span><br><span class=\"line\">        current=current-&gt;right;<span class=\"comment\">//进入当前子树右树</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h1 id=\"后序遍历\">后序遍历</h1>\r\n<p>先左，再右，最后根。</p>\r\n<p>和中序遍历一样，首先要走到左树最深处。但是迭代很难控制从下一层返回上来的时候，不再压栈子结点，因此需要在第一次压栈时，断开根结点和子节点的链接。</p>\r\n<ol type=\"1\">\r\n<li><p>取当前结点，先找左子树，左子树里面同样还要找左子树啊，因此是while找下去。</p></li>\r\n<li><p>直至左子树为NULL，再找右子树，注意右子树里面优先找的是<strong>左子树</strong>，因此<strong>不能while</strong>持续找右子树，而是进入右子树后当作全新的树，再同样的查找。</p></li>\r\n<li><p>迭代到某个结点后，左子树为NULL，右子树也为NULL，递归迭代停止，终于可以作为根结点进行输出了。</p></li>\r\n</ol>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    vector&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    stack&lt;TreeNode*&gt; s;<span class=\"comment\">//递归栈</span></span><br><span class=\"line\">    TreeNode* current;<span class=\"comment\">//当前处理结点</span></span><br><span class=\"line\">    s.<span class=\"built_in\">push</span>(root);<span class=\"comment\">//初始化栈</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!s.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        current=s.<span class=\"built_in\">top</span>();<span class=\"comment\">//取结点</span></span><br><span class=\"line\">        root=current;<span class=\"comment\">//保留父结点，后续断开连接要用</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//先遍历这结点的左结点，左左结点，左左左...结点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(current-&gt;left)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">push</span>(current-&gt;left);</span><br><span class=\"line\">            current=current-&gt;left;</span><br><span class=\"line\">            root-&gt;left=<span class=\"literal\">NULL</span>;<span class=\"comment\">//断开连接，避免返回到这个结点时又递归左树死循环</span></span><br><span class=\"line\">            root=current;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//然后进入右子树，注意进入右子树后还是优先找左子子树，因此不能无脑压栈右子树。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(current-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">push</span>(current-&gt;right);</span><br><span class=\"line\">            current=current-&gt;right;</span><br><span class=\"line\">            root-&gt;right=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            root=current;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span><span class=\"comment\">//已经走到最左端了，作为最外面的子树，它的左结点必然是空，并且else说明右子树也空，则可以输出自己了。</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result.<span class=\"built_in\">push_back</span>(current-&gt;val);</span><br><span class=\"line\">            s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"层序遍历\">层序遍历</h1>\r\n<p>即逐层的 从左到右访问所有结点。</p>\r\n<p>算法上主要是遍历一个结点，先把左右子节点装进去。</p>\r\n<p>值得考虑的是，怎么把每层结果分开？使用一个length在每层开始，检查队列长度获得该层长度，这样后面加入的子节点就不在长度范围内。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt; <span class=\"built_in\">levelOrder</span>(TreeNode* root) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    vector&lt;vecotr&lt;<span class=\"keyword\">int</span>&gt;&gt; result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">    queue&lt;TreeNode*&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())<span class=\"comment\">//队列不空</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; temp;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length=q.<span class=\"built_in\">size</span>();<span class=\"comment\">//获取当前层结点</span></span><br><span class=\"line\">        TreeNode* current=q.<span class=\"built_in\">front</span>();q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;length;i++)<span class=\"comment\">//分层计数</span></span><br><span class=\"line\">        &#123;       </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(current!=<span class=\"literal\">NULL</span>)<span class=\"comment\">//当前为有效结点，加入result，检查子节点</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                temp.<span class=\"built_in\">push_back</span>(current-&gt;val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(current-&gt;left) q.<span class=\"built_in\">push</span>(current-&gt;left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(current-&gt;right) q.<span class=\"built_in\">push</span>(current-&gt;right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        result.<span class=\"built_in\">push_back</span>(temp);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"再见，狂野之心","url":"/2022/03/20/%E5%86%8D%E8%A7%81%EF%BC%8C%E7%8B%82%E9%87%8E%E4%B9%8B%E5%BF%83/","content":"<p>再见，狂野之心 Sayonara Wild Hearts</p>\r\n<h1\r\nid=\"极具视觉冲击和音画享受霓虹梦幻的非竞技音游\">极具视觉冲击和音画享受，霓虹梦幻的非竞技音游</h1>\r\n<h2 id=\"音游中最具有冲击力的唯美画面\">音游中最具有冲击力的唯美画面</h2>\r\n<p>场景维度大开大合，色彩很有霓虹绚丽的感觉，但是又没有让人不适的光污染。</p>\r\n<p>配合上音乐和速度的双重冲击，整个游戏氛围都让人疯狂。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.akamai.steamstatic.com/steam/apps/1122720/ss_03804e3335afd5edddceafe722ff1c4eb3c19931.jpg?t=1629747217\"\r\nalt=\"霓虹梦幻的画面\" />\r\n<figcaption aria-hidden=\"true\">霓虹梦幻的画面</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h2 id=\"玩法丰富多样\">玩法丰富多样</h2>\r\n<p>虽然主体都是收集躲避障碍式的音游，但这游戏愣是把流程做出了花...包括骑摩托车、踩滑板、斗舞、发射激光、挥舞利剑以及击破心脏寻找和声等各种元素。</p>\r\n<ul>\r\n<li>最基本的摩托模式，享受每小时200英里的速度感。</li>\r\n<li>最与众不同的2D电子模式，在一块类似于吃豆人的电子屏中享受慢节奏的冲击力。</li>\r\n<li>...</li>\r\n<li>还有四五场精彩的BOSS战，每个BOSS都有完全不同的攻击方式和画面效果，有让毁天灭地世界崩坏的，有双子变换空间的(类似titanfall2？)，有机甲式的（像蓝毒兽？？）...每一场BOSS战都是音乐与画面的淋漓尽致。</li>\r\n</ul>\r\n<h2 id=\"梦幻迷离的音乐\">梦幻迷离的音乐</h2>\r\n<p>激情温柔，疯狂又忧伤，梦幻迷离的电子声，就像游戏名的感觉一样：\r\n再见，狂野之心。</p>\r\n<p>别的不说，我先买OST为敬。（哦qq音乐有专辑...不用买了</p>\r\n<h2 id=\"缺点\">缺点</h2>\r\n<p><strong>流程过短</strong>...我时不时暂停聊天地玩，全通关也就100分钟。而且大部分关卡只有1~2分钟的流程，甚至让人觉得音乐都没来得及放完就结束了。只有BOSS战才能带来完整的3~4分钟的完整享受。</p>\r\n<blockquote>\r\n<p>当然如果想刷全满分的话，能玩一个月吧大概...</p>\r\n</blockquote>\r\n<p>难度曲线不友好，想要通关是挺容易的，死亡没有惩罚可以从自动存档点继续，即使分再低过了也就是过了，没有任何影响。但是想要追求高分的话，由于场景速度很快，并且场景整体色调和收集品没有特别大，你很难在场景空间高速迭代的过程中即时做出反应，只能通过背板预判应该走哪里。并且combo也不影响音乐节奏，并不是很需要追求分数。</p>\r\n<p>这个游戏重点还是在<strong>音乐和画面的交叉冲击中，给你带来音画沉浸的两小时，并不建议当成一个挑战性的音游</strong>。</p>\r\n<p><strong>愿你享受迷离</strong>。</p>\r\n","categories":["生活"],"tags":["游戏"]},{"title":"卷积神经网络CNN","url":"/2021/10/22/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN/","content":"<h1 id=\"cnn\">CNN</h1>\r\n<p>空间不变性： 检测对象和图像位置无关<br />\r\n局部性：先从局部区域特征做起，在高层再集成局部特征预测</p>\r\n<h2 id=\"从全连接层到卷积\">从全连接层到卷积</h2>\r\n<p><span class=\"math inline\">\\([\\mathbf{X}]_{i, j}\\)</span>和<span\r\nclass=\"math inline\">\\([\\mathbf{H}]_{i,\r\nj}\\)</span>分别表示输入图像和隐藏表示中位置<span\r\nclass=\"math inline\">\\((i,j)\\)</span>处的像素。且不妨使<span\r\nclass=\"math inline\">\\(k = i+a\\)</span>,<span\r\nclass=\"math inline\">\\(l=j+b\\)</span> <span class=\"math display\">\\[\r\n\\begin{split}\\begin{aligned} \\left[\\mathbf{H}\\right]_{i, j} &amp;=\r\n[\\mathbf{U}]_{i, j} + \\sum_k \\sum_l[\\mathsf{W}]_{i, j, k,\r\nl}  [\\mathbf{X}]_{k, l}\\\\ &amp;=  [\\mathbf{U}]_{i, j} +\r\n\\sum_a \\sum_b [\\mathsf{V}]_{i, j, a, b}  [\\mathbf{X}]_{i+a,\r\nj+b}.\\end{aligned}\\end{split}\r\n\\]</span></p>\r\n<h3 id=\"需要完成的目标\">需要完成的目标：</h3>\r\n<ol type=\"1\">\r\n<li><p><strong>平移不变形：</strong><span\r\nclass=\"math inline\">\\(\\mathsf{V}\\)</span>和<span\r\nclass=\"math inline\">\\(\\mathsf{U}\\)</span>实际上不依赖于<span\r\nclass=\"math inline\">\\((i,j)\\)</span>的值，即<span\r\nclass=\"math inline\">\\([\\mathsf{V}]_{i, j, a, b} = [\\mathbf{V}]_{a,\r\nb}\\)</span>。即卷积核不变，简化<span\r\nclass=\"math inline\">\\(\\mathsf{H}\\)</span>为：</p>\r\n<p><span class=\"math display\">\\[\r\n[\\mathbf{H}]_{i, j} = u + \\sum_a\\sum_b [\\mathbf{V}]_{a, b}\r\n[\\mathbf{X}]_{i+a, j+b}.\r\n\\]</span></p>\r\n<p>这就是<strong>卷积</strong>(准确来说卷积层是个错误的叫法，卷积层用到的其实是<strong>互相关运算\r\n(cross-correlation)</strong>，而不是卷积运算)，使用<span\r\nclass=\"math inline\">\\([\\mathbf{V}]_{a, b}\\)</span>对位置<span\r\nclass=\"math inline\">\\((i,j)\\)</span>附近的像素<span\r\nclass=\"math inline\">\\((i+a,j+b)\\)</span>进行加权得到<span\r\nclass=\"math inline\">\\([\\mathbf{H}]_{i, j}\\)</span></p></li>\r\n<li><p><strong>局部性：</strong> 即给<span\r\nclass=\"math inline\">\\(a,b\\)</span>一个范围限定，使其不要联系到很远的位置，得到<span\r\nclass=\"math inline\">\\([\\mathbf{H}]_{i.j}\\)</span>：<br />\r\n<span class=\"math display\">\\[\r\n[\\mathbf{H}]_{i, j} = u + \\sum_{a = -\\Delta}^{\\Delta} \\sum_{b =\r\n-\\Delta}^{\\Delta} [\\mathbf{V}]_{a, b}  [\\mathbf{X}]_{i+a, j+b}.\r\n\\]</span> 这就是卷积层，<span\r\nclass=\"math inline\">\\([\\mathbf{V}]\\)</span>即是卷积核</p></li>\r\n</ol>\r\n<h3 id=\"卷积数学定义\">卷积数学定义：</h3>\r\n<p>卷积是测量 f 和 g 之间（把其中一个函数“翻转”并移位 x\r\n时）的重叠。<br />\r\n&gt;注意这个翻转，实际上卷积层不使用翻转，是互相关运算</p>\r\n<p><span class=\"math display\">\\[\r\n(f * g)(\\mathbf{x}) = \\int f(\\mathbf{z}) g(\\mathbf{x}-\\mathbf{z})\r\nd\\mathbf{z}.\r\n\\]</span></p>\r\n<p>离散形式：</p>\r\n<p><span class=\"math display\">\\[\r\n(f * g)(i) = \\sum_a f(a) g(i-a).\r\n\\]</span></p>\r\n<h3 id=\"多通道\">多通道</h3>\r\n<p>图像往往包含三通道，即每个像素点还包括一个长度为3的数组，因此卷积操作也要扩展一个维度：</p>\r\n<p><span class=\"math display\">\\[\r\n[\\mathsf{H}]_{i,j,d} = \\sum_{a = -\\Delta}^{\\Delta} \\sum_{b =\r\n-\\Delta}^{\\Delta} \\sum_c [\\mathsf{V}]_{a, b, c, d} [\\mathsf{X}]_{i+a,\r\nj+b, c},\r\n\\]</span></p>\r\n<h3 id=\"多通道-1\">多通道</h3>\r\n<p>图像往往包含三通道，即每个像素点还包括一个长度为3的数组，因此卷积操作也要扩展一个维度：</p>\r\n<p><span class=\"math display\">\\[\r\n[\\mathsf{H}]_{i,j,d} = \\sum_{a = -\\Delta}^{\\Delta} \\sum_{b =\r\n-\\Delta}^{\\Delta} \\sum_c [\\mathsf{V}]_{a, b, c, d} [\\mathsf{X}]_{i+a,\r\nj+b, c},\r\n\\]</span></p>\r\n","categories":["深度学习"]},{"title":"双指针算法","url":"/2021/03/04/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/","content":"<h1 id=\"头尾双指针\">头尾双指针</h1>\r\n<h2 id=\"使用情景\">使用情景</h2>\r\n<p>从头尾两端逼近中间，寻求逼近，向中间迭代。</p>\r\n<p>和数据头尾两端相关的处理。</p>\r\n<p>可演化为三指针等变种。</p>\r\n<h2 id=\"典型例题\">典型例题：</h2>\r\n<h3 id=\"翻转字符串\">翻转字符串</h3>\r\n<blockquote>\r\n<p>反转数组中的元素。比如数组为 ['l', 'e', 'e', 't', 'c', 'o', 'd',\r\n'e']，反转之后变为 ['e', 'd', 'o', 'c', 't', 'e', 'e', 'l']。</p>\r\n</blockquote>\r\n<p>使用双指针技巧，即 lo 指针指向开头，hi\r\n指针指向末尾，交换开头末尾。</p>\r\n<p>lo，hi 不断向中间缩进且交换，最终完成翻转。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverseString</span><span class=\"params\">(vector&lt;<span class=\"keyword\">char</span>&gt;&amp; s)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lo=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hi=s.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(lo&lt;hi)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(s[lo],s[hi]);    </span><br><span class=\"line\">        lo++;</span><br><span class=\"line\">        hi--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><span id=\"more\"></span></p>\r\n<h1 id=\"快慢双指针\">快慢双指针</h1>\r\n<h2 id=\"使用情景-1\">使用情景</h2>\r\n<p>迭代数据时，慢指针的移动需要\r\n<strong>等待前方一些特殊条件的出现</strong>，此时就利用快指针来对前方条件进行探查。</p>\r\n<p>关键性的是快慢指针的移动条件。</p>\r\n<p>注意快慢移动迭代的出口是<code>while(fast &amp;&amp; fast-&gt;next)</code>\r\n还是<code>while(fast)</code></p>\r\n<h2 id=\"典型例题-1\">典型例题：</h2>\r\n<h3 id=\"原地移除数组元素\">原地移除数组元素</h3>\r\n<blockquote>\r\n<p>给你一个数组 nums 和一个值 val，你需要 <strong>原地</strong>\r\n移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>\r\n</blockquote>\r\n<p>非原地的话，很容易想到新建数组，把不是 val 的值移进去。</p>\r\n<p>原地普通算法的话，我们每移除一个元素，需要把数组后续元素往前移，移动效率较低。</p>\r\n<p>使用快慢指针，则慢指针保持新数组的尾后位置，则快指针往后每找一个<strong>非\r\nval 元素</strong>，即赋值给慢指针位置即可。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> val)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length=nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(length==<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> slow=<span class=\"number\">0</span>;<span class=\"comment\">//慢指针</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> fast=<span class=\"number\">0</span>;fast&lt;length;fast++)<span class=\"comment\">//快指针</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[fast]!=val)<span class=\"comment\">//快指针找到非 val 元素</span></span><br><span class=\"line\">            &#123;   </span><br><span class=\"line\">                nums[slow]=nums[fast];</span><br><span class=\"line\">                slow++;       <span class=\"comment\">//尾后++   </span></span><br><span class=\"line\">            &#125;       </span><br><span class=\"line\">        &#125;      </span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"判断链表是否有环\">判断链表是否有环</h3>\r\n<p>双指针————假如有环，快指针将迟早能和慢指针相遇</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode *head)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span> || head-&gt;next==<span class=\"literal\">NULL</span>)<span class=\"comment\">//空链表或单结点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode* fast=head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//快慢指针移动</span></span><br><span class=\"line\">        fast=fast-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fast!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            fast=fast-&gt;next;</span><br><span class=\"line\">        head=head-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//检查移动后是否相遇</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fast==head)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"寻找链表环的入口\">寻找链表环的入口</h3>\r\n<p><a\r\nhref=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/c-shuang-zhi-zhen-z-by-zrita/\">参考题解</a></p>\r\n<p><strong>双指针</strong>————同上方法等待快慢指针相遇。</p>\r\n<h5 id=\"第一次相遇时\">第一次相遇时：</h5>\r\n<ul>\r\n<li>环外距离 out</li>\r\n<li>环内距离 in</li>\r\n<li>环长 circle</li>\r\n<li>慢指针走过的距离：<code>len_s=out+in</code></li>\r\n<li>快指针走过的距离：<code>len_f= out+in+n*circle</code></li>\r\n</ul>\r\n<p>因为<code>len_f=2*len_s</code>\r\n推导出=》<code>len_s=n * circle</code></p>\r\n<p>此时把快指针置零，快慢指针同时走 out 距离。 ##### 第二次相遇时： -\r\n慢指针走过的距离：<code>len_s=out</code> -\r\n快指针走过的距离：<code>len_f= out+n*circle</code></p>\r\n<p>即快慢指针在 out 的末端，也就是环的起点相遇，此时找到环入口。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">detectCycle</span><span class=\"params\">(ListNode *head)</span> </span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">       ListNode* fast=head,*slow=head;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(fast==<span class=\"literal\">NULL</span> || fast-&gt;next==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">       <span class=\"keyword\">while</span>(fast &amp;&amp; fast-&gt;next)<span class=\"comment\">//第一次相遇</span></span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           fast=fast-&gt;next-&gt;next;</span><br><span class=\"line\">           slow=slow-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(fast==slow)</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(fast!=slow)<span class=\"comment\">//无环</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//有环</span></span><br><span class=\"line\">       fast=head;</span><br><span class=\"line\">       <span class=\"keyword\">while</span>(fast!=slow)<span class=\"comment\">//第二次相遇</span></span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           fast=fast-&gt;next;</span><br><span class=\"line\">           slow=slow-&gt;next;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"参考资料\">参考资料</h1>\r\n<p><a\r\nhref=\"https://leetcode-cn.com/leetbook/read/array-and-string/cmf5c/\">LeetCode\r\n双指针技巧</a></p>\r\n","categories":["算法"],"tags":["双指针"]},{"title":"四元数与三维旋转","url":"/2022/05/13/%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E%E4%B8%89%E7%BB%B4%E6%97%8B%E8%BD%AC/","content":"<p>在三维空间中描述旋转是一件挺麻烦的事。常用的<strong>欧拉角</strong>虽然直观简单，但是存在<strong>顺序依赖</strong>和<strong>万向节死锁</strong>的问题，在通用的旋转运算上并不可行。进而引入的<strong>四维数</strong>虽然在运算上很有效，但是对于第一次见到的人来说一点也不算直观、易懂。</p>\r\n<p><a\r\nhref=\"https://krasjet.github.io/quaternion/\">Krasjet的文章</a>从二维复数出发，进而理解三维四元数的表示意义，循序渐进，通俗易懂，因此记录一下学习笔记。</p>\r\n<h1 id=\"复数与2d旋转\">复数与2D旋转</h1>\r\n<p>复数的定义和运算性质不再赘述。对于$ z = a + bi $，相当于对复数基底 $\r\n(1,i) $ 的线性组合，因此可以表示为一个列向量 <span\r\nclass=\"math inline\">\\(z=[a,b]^T\\)</span>，但更进一步，其实我们能把复数表示为矩阵。</p>\r\n<p>对于两个复数<span class=\"math inline\">\\(z_1 = a + bi , z_2=c +\r\ndi\\)</span>，可以得到观察一下其乘法结果：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nz_1z_2&amp;=a \\boldsymbol{c} -b \\boldsymbol{d} \\\\\r\n    &amp;+(b \\boldsymbol{c}+a \\boldsymbol{d})i \\\\\r\n    &amp;=\\left[\\begin{array}{cc}\r\n        a &amp; -b \\\\\r\n        b &amp; a\r\n        \\end{array}\\right]\\left[\\begin{array}{l}\r\n        c \\\\\r\n        d\r\n        \\end{array}\\right]\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>我们知道右边的<span class=\"math inline\">\\([c,d]^T\\)</span>是<span\r\nclass=\"math inline\">\\(z_2\\)</span>的列向量表示形式，而左边的矩阵，也只和<span\r\nclass=\"math inline\">\\(z_1\\)</span>的系数有关，因此也可以看做是<span\r\nclass=\"math inline\">\\(z_1=a+bi\\)</span>的矩阵表示。我们不妨尝试将两边都写成矩阵形式：</p>\r\n<p><span class=\"math display\">\\[\r\nz_1z_2=\\left[\\begin{array}{cc}\r\n        a &amp; -b \\\\\r\n        b &amp; a\r\n        \\end{array}\\right]\r\n        \\left[\\begin{array}{l}\r\n        c &amp; -d\\\\\r\n        d &amp; c\r\n        \\end{array}\\right]\r\n    =\\left[\\begin{array}{cc}\r\n        ac-bd &amp; -(bc+ad) \\\\\r\n        bc+ad &amp; ac-bd\r\n        \\end{array}\\right]\r\n    =ac-bd + (bc+ad)i\r\n\\]</span></p>\r\n<p>上式可以看出<span\r\nclass=\"math inline\">\\(z_1,z_2,z_1z_2\\)</span>在矩阵表示下也同样满足复数基本运算。这时我们可以发现一个神奇的现象：<strong>复数可以表示为矩阵，复数乘法可以表示为矩阵乘法</strong>，而矩阵乘法进而可以让我们联想到矩阵表示的仿射变换：</p>\r\n<p><span class=\"math display\">\\[\r\nz=\\left[\\begin{array}{cc}\r\n        a &amp; -b \\\\\r\n        b &amp; a\r\n        \\end{array}\\right]\r\n=\\sqrt{a^2+b^2}\r\n\\left[\\begin{array}{cc}\r\n        \\frac{a}{\\sqrt{a^2+b^2}} &amp; \\frac{-b}{\\sqrt{a^2+b^2}} \\\\\r\n        \\frac{b}{\\sqrt{a^2+b^2}} &amp; \\frac{a}{\\sqrt{a^2+b^2}}\r\n        \\end{array}\\right]\r\n\\]</span></p>\r\n<p>这种式子是不是很眼熟——即以a，b为边的三角变换式：</p>\r\n<p><span class=\"math display\">\\[\r\nz=\\sqrt{a^2+b^2}\\left[\\begin{array}{cc}\r\n        cos\\theta &amp; -sin\\theta \\\\\r\n        sin\\theta &amp; cos\\theta\r\n        \\end{array}\\right]\r\n=\\left[\\begin{array}{cc}\r\n        ||z|| &amp; 0 \\\\\r\n        0 &amp; ||z||\r\n        \\end{array}\\right]\r\n\\left[\\begin{array}{cc}\r\n        cos\\theta &amp; -sin\\theta \\\\\r\n        sin\\theta &amp; cos\\theta\r\n        \\end{array}\\right]\r\n\\]</span></p>\r\n<p>此时复数<span class=\"math inline\">\\(z=a+bi=||z||(cos\\theta+sin\\theta\r\ni)\\)</span>表示的二维变换水落石出，左边的矩阵是一个\r\n<strong>等比放缩矩阵</strong>，右边的矩阵是一个\r\n<strong>旋转矩阵</strong>。<strong>复数乘法，即是两个变换矩阵的作用。</strong></p>\r\n<p>并且再将复数的三角形式代回<span\r\nclass=\"math inline\">\\(z_1z_2\\)</span>可知，<span\r\nclass=\"math inline\">\\(z_1z_2=cos(\\theta+\\alpha)+sin(\\theta+\\alpha)\r\ni\\)</span> ，即复数的累乘，在变换上体现为旋转角度的累加<span\r\nclass=\"math inline\">\\(\\theta+\\alpha\\)</span>，以及缩放上的累乘。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"三维旋转\">三维旋转</h1>\r\n<p>三维旋转描述起来比二维旋转更弯弯绕绕一些，但其实理解起来也不难。</p>\r\n<p>要旋转<span class=\"math inline\">\\(\\theta\\)</span>角，三维向量<span\r\nclass=\"math inline\">\\(v\\)</span>首先得确定一个三维的旋转轴心<span\r\nclass=\"math inline\">\\(u\\)</span>，并且通过投影分解成<strong>垂直平面的二维旋转</strong>：</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(v\\)</span>和<span\r\nclass=\"math inline\">\\(u\\)</span>构成的平面<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>：在这个平面上不进行任何旋转，因为这个平面的旋转是<strong>靠近或远离<span\r\nclass=\"math inline\">\\(u\\)</span>的旋转</strong>，而这不符合我们以<span\r\nclass=\"math inline\">\\(u\\)</span>为旋转轴的初心。</li>\r\n<li>垂直于<span class=\"math inline\">\\(\\alpha\\)</span>的平面<span\r\nclass=\"math inline\">\\(\\beta\\)</span>：在这个平面上<strong>以<span\r\nclass=\"math inline\">\\(u\\)</span>为圆心旋转<span\r\nclass=\"math inline\">\\(\\theta\\)</span>角</strong>。</li>\r\n</ul>\r\n<p>因此简单计算可得任意轴旋转公式为：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nv^`&amp;=\\mathbf{v}_{\\|}+\\cos (\\theta) \\mathbf{v}_{\\perp}+\\sin\r\n(\\theta)\\left(\\mathbf{u} \\times \\mathbf{v}_{\\perp}\\right) \\\\\r\n&amp;=cos\\theta v + (1-cos\\theta)(uv)u + sin\\theta (u \\times v)\r\n\\end{aligned}\r\n\\]</span></p>\r\n<blockquote>\r\n<p><span class=\"math inline\">\\(v_{\\|}=cos\\theta v\\)</span>即<span\r\nclass=\"math inline\">\\(v\\)</span>在<span\r\nclass=\"math inline\">\\(u\\)</span>上的投影向量，其不参与旋转。后面一大串即垂直平面上<span\r\nclass=\"math inline\">\\(v_{\\perp}\\)</span>的二维旋转，具体推导细节可参考<a\r\nhref=\"https://krasjet.github.io/quaternion/\">Krasjet的文章第2节</a></p>\r\n</blockquote>\r\n<h1 id=\"四元数与三维旋转\">四元数与三维旋转</h1>\r\n<p>四元数基本性质：</p>\r\n<p><span class=\"math display\">\\[\r\nq=a+bi+cj+dk \\\\\r\ni^2=j^2=k^2=ijk=-1 \\\\\r\nij=k, jk=i, ki=j \\\\\r\nqq^{-1}=1\r\n\\]</span></p>\r\n<p>同样我们可以写成向量形式：<span\r\nclass=\"math inline\">\\(q=[a,b,c,d]^T\\)</span>。将实部和虚部分离，可以写为:</p>\r\n<p><span class=\"math display\">\\[\r\nq=\\left[\\begin{array}{cc}\r\n        a  \\\\\r\n        \\boldsymbol{u}\r\n        \\end{array}\\right]\r\n， (\\boldsymbol{u}=[x,y,z]^T)\r\n\\]</span></p>\r\n<p>那么我们可以找到四元数的矩阵形式吗？同样通过<span\r\nclass=\"math inline\">\\(q_1q_2\\)</span>来尝试一下：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nq_{1} q_{2}=&amp; a e+a f i+a g j+a h k+\\\\\r\n&amp; b e i-b f+b g k-b h j+\\\\\r\n&amp; c e j-c f k-c g+c h i+\\\\\r\n&amp; d e k+d f j-d g i-d h \\\\\r\n=&amp;(a e-b f-c g-d h)+\\\\\r\n&amp;(b e+a f-d g+c h) i+\\\\\r\n&amp;(c e+d f+a g-b h) j+\\\\\r\n&amp;(d e-c f+b g+a h) k \\\\\r\n=&amp;\\left[\\begin{array}{cccc}\r\n    a &amp; -b &amp; -c &amp; -d \\\\\r\n    b &amp; a &amp; -d &amp; c \\\\\r\n    c &amp; d &amp; a &amp; -b \\\\\r\n    d &amp; -c &amp; b &amp; a\r\n    \\end{array}\\right]\\left[\\begin{array}{l}\r\n    e \\\\\r\n    f \\\\\r\n    g \\\\\r\n    h\r\n    \\end{array}\\right]\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>可以发现<span\r\nclass=\"math inline\">\\(q_1\\)</span>表现为这样的矩阵对我们帮助不大。一方面由于四元数乘法不满足交换律，<span\r\nclass=\"math inline\">\\(q_1\\)</span>用来左乘和右乘时的矩阵并不一样。另一方面，这样的矩阵晦涩抽象，难以整理出相关三维联系。</p>\r\n<p>因此借鉴之前实部与虚部分离的整理方式，可以写出<span\r\nclass=\"math inline\">\\(q_1q_2=[a,\\boldsymbol{u}] \\cdot\r\n[e,\\boldsymbol{v}]\\)</span>简化版本：</p>\r\n<p><span class=\"math display\">\\[\r\nq_1q_2=[ae-\\boldsymbol u \\boldsymbol v, a\\boldsymbol v+e\\boldsymbol\r\nu+\\boldsymbol u \\times \\boldsymbol v] \\\\\r\n\\]</span></p>\r\n<blockquote>\r\n<p>从中可以推导出一个有用的共轭性质：<span\r\nclass=\"math inline\">\\(qq^*=[a,\\boldsymbol{u}][a,\\boldsymbol{-u}]=[a^2+\\|v\\|^2,0]\\)</span></p>\r\n</blockquote>\r\n<p>再回想<span\r\nclass=\"math inline\">\\(\\boldsymbol{v}\\)</span>的旋转公式，可以发现形式有点相似了：</p>\r\n<p><span class=\"math display\">\\[\r\nv^`=\\mathbf{v}_{\\|}+\\cos (\\theta) \\mathbf{v}_{\\perp}+\\sin\r\n(\\theta)\\left(\\mathbf{u} \\times \\mathbf{v}_{\\perp}\\right)\r\n\\]</span></p>\r\n<p>此时不如尝试用四元数替换掉旋转公式里的三维向量，令<span\r\nclass=\"math inline\">\\(\\dot v=[0,\\boldsymbol v],\\dot u=[0,\\boldsymbol\r\nu]，\\dot v_\\|,\\dot v_\\perp\\)</span>等同理。这样一来，旋转公式中<span\r\nclass=\"math inline\">\\(v_\\|,v_\\perp\\)</span>可以直接替换成四元数<span\r\nclass=\"math inline\">\\(\\dot v_\\|,\\dot v_\\perp\\)</span>，但是<span\r\nclass=\"math inline\">\\(\\mathbf{u} \\times\r\n\\mathbf{v}_{\\perp}\\)</span>还不行。</p>\r\n<blockquote>\r\n<p><span\r\nclass=\"math inline\">\\([0,v],[0,u]\\)</span>中的向量即三维空间中的旋转向量<span\r\nclass=\"math inline\">\\(v\\)</span>和旋转轴向量<span\r\nclass=\"math inline\">\\(u\\)</span>。</p>\r\n</blockquote>\r\n<p>再看四元数乘积公式<span class=\"math inline\">\\(q_1q_2=[ae-\\boldsymbol\r\nv \\boldsymbol u, a\\boldsymbol u+e\\boldsymbol v+\\boldsymbol v \\times\r\n\\boldsymbol u]\\)</span>，<span\r\nclass=\"math inline\">\\(a,e\\)</span>是两个四元数的实部，而在我们的替换中，所有的实部都为0，此时四元数乘积为<span\r\nclass=\"math inline\">\\(q_1q_2=[0,\\boldsymbol v \\times \\boldsymbol\r\nu]\\)</span>。因此我们可以用四元数<span class=\"math inline\">\\(\\dot u \\dot\r\nv_\\perp=[0,\\boldsymbol u \\times \\boldsymbol v_\\perp]\\)</span> 来替换\r\n<span class=\"math inline\">\\(\\mathbf{u} \\times\r\n\\mathbf{v}_{\\perp}\\)</span> 。</p>\r\n<p>至此，可以得到四元数版本的旋转公式：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\dot v^`&amp;=\\dot{\\mathbf{v}_{\\|}}+\\cos (\\theta)\r\n\\dot{\\mathbf{v}_{\\perp}}+\\sin (\\theta)\\left(\\dot u \\dot v_\\perp\\right)\r\n\\\\\r\n&amp;= \\dot{\\mathbf{v}_{\\|}}+(\\cos (\\theta) +\\sin (\\theta)\\dot u) \\dot\r\nv_\\perp \\\\\r\n&amp;= \\dot{\\mathbf{v}_{\\|}} + \\dot q \\dot v_\\perp, \\ \\ \\ \\ \\ which \\\r\n\\   \\dot q=[cos\\theta,0]+[0,sin\\theta u]=\\cos (\\theta) +\\sin\r\n(\\theta)\\dot u\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>最终，我们实现通过一个额外的四元数<span class=\"math inline\">\\(\\dot\r\nq=[\\cos (\\theta),\\sin (\\theta) \\boldsymbol{u}]\\)</span>，即可表示<span\r\nclass=\"math inline\">\\(v\\)</span>绕任意轴<span\r\nclass=\"math inline\">\\(u\\)</span>的旋转<span\r\nclass=\"math inline\">\\(\\theta\\)</span>角。反过来，给定一个四元数，我们也可以很轻易地从实部得到其代表的<strong>旋转角度<span\r\nclass=\"math inline\">\\(\\theta\\)</span></strong>，从虚部得到其代表的<strong>旋转轴<span\r\nclass=\"math inline\">\\(\\boldsymbol{u}\\)</span></strong>。</p>\r\n<blockquote>\r\n<p>代码小提示：可以发现，四元数的x,y,z,w属性并不直接代表旋转角度，因此不能在旋转时直接修改四元数的属性。当然，也不能先转成欧拉角——修改——再存回四元数，这样就失去了四元数的意义。通常，我们构造一个表示旋转变换的四元数，然后与原来的角度相乘，即可完成旋转。</p>\r\n</blockquote>\r\n<p>根据四元数运算可以将旋转 <strong><span\r\nclass=\"math inline\">\\(\\theta\\)</span></strong> 角进一步化简为：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\dot v^`&amp;=\\dot p \\dot v \\dot p^* ,  \\ \\ \\ which \\ \\ \\ \\ \\dot\r\np=[cos\\frac{\\theta}{2},sin\\frac{\\theta}{2} \\boldsymbol{u}] \\\\\r\n&amp;= [0, \\cos (\\theta) \\mathbf{v}+(1-\\cos (\\theta))(\\mathbf{u} \\cdot\r\n\\mathbf{v}) \\mathbf{u}+\\sin (\\theta)(\\mathbf{u} \\times \\mathbf{v})]\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>而这种表示形式下也可以很方便地进行旋转的复合：</p>\r\n<p><span class=\"math display\">\\[\r\nv^`=\\dot p_2 ( \\dot p_1 v \\dot p_1^* ) \\dot p_2^*\r\n\\]</span></p>\r\n<p>当然，在已知最终变换<span\r\nclass=\"math inline\">\\(p=p_2p_1\\)</span>和初始变换<span\r\nclass=\"math inline\">\\(p_1\\)</span>的情况下，我们可能要求解中间变换<span\r\nclass=\"math inline\">\\(p_2\\)</span>，此时：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\np_2p_1&amp;=p \\\\\r\np_2p_1p_1^{-1} &amp;=p p_1^{-1} \\\\\r\np_2 &amp;= pp_1^{-1} \\\\\r\np_2 &amp;=pp_1^*\r\n\\end{aligned}\r\n\\]</span></p>\r\n<blockquote>\r\n<p>默认所有变换向量都是单位向量，因此变换四元数都是单位四元数，有<span\r\nclass=\"math inline\">\\(p^{-1}=p^*\\)</span></p>\r\n</blockquote>\r\n<p>更进一步，多次求解中间变换即可实现高阶变换插值。</p>\r\n","tags":["数学"]},{"title":"学习的旅程","url":"/2022/04/04/%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%97%85%E7%A8%8B/","content":"<p>看到几篇很棒的博客，<a\r\nhref=\"http://mindhacks.cn/2008/09/17/learning-habits-part3/\">如何阅读——刘未鹏</a>，<a\r\nhref=\"http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/\">怎样花两年时间去面试一个人</a>，想要从中汲取一些知识，并且记录一些自己的思绪。</p>\r\n<h1 id=\"学习的方向\">学习的方向</h1>\r\n<p>其实现在的在校生根本不缺学习的动力(特别是<strong>计算机</strong>，特别是<strong>研究生</strong>)，毕竟现在的大环境已经卷的不成样子。看着各大公司的招聘简历，以及相关面经，会发现<strong>大学的课程完全不足以培养你进入大厂工作</strong>，如果真只是按部就班上完了全部课程，那恭喜你达到了新成就<strong>毕业即失业</strong>。在这个能力为硬指标的行业，但凡对工作有所期望的人，都会想方设法去学习更多的东西，起码面试三轮可以有能力通过一轮吧。</p>\r\n<span id=\"more\"></span>\r\n<p>但是虽然学生们都有动力，对我自己来说，进入计算机专业之前也是充满期待，希望自己经过几年的大学培养能够拥有一定的能力来解决问题，进而能够利用技术去实现自己的兴趣爱好。但是，学生并不知道需要去学什么，需要去钻研什么，需要掌握什么理论框架，需要尝试什么技术手段。计算机是一个宛如宇宙一般的庞大领域，就算花个几百年也不可能各个领域都掌握精通，要成为一个有用的人必须选择一个细分领域进行学习。然而这时初生牛犊面对无止境的知识海洋，根本没有能力决定这个领域学到哪，那个领域应该了解多少，底层和顶层应该怎么分配学习。</p>\r\n<blockquote>\r\n<p>他们往往很想学点东西，但又不知道哪些重要哪些不重要，到底该学到什么程度，不知道导致不确定，不确定导致决策瘫痪，干脆嘛也不动，荒废时间。\r\n——刘未鹏</p>\r\n</blockquote>\r\n<p>另一方面，企业在招聘时如何挖掘出有潜力，有能力的学生也是一件很难的事。在微软进行招聘的刘给出的答案值得我们进行参考：<strong>书单+GitHub=长达两年的招聘</strong>。</p>\r\n<p><strong>书单</strong>：对于基础知识和底层原理来说，有没有看过这个领域的<strong>好书</strong>的人，有着质的不同。\"看了就是看了，必然能学到东西，没看就是没看。知道和不知道，区别是本质的\"。不管是不是用心看，真有去看过一遍，并且确实是被公认的<strong>好书</strong>，那自己也自然会被吸引进去。</p>\r\n<p>当然这里一个核心的问题就是，怎么去找<strong>好书</strong>？国内大学计算机课本的含金量有目共睹，只学过课本甚至称不上是读过书。选择好书的一个很简单有效的原则——去找企业或者招聘者，在官网或者博客中给出的书单。企业为了招到最合适的候选人，必然会给出最合适的书单，例如微软：</p>\r\n<ul>\r\n<li>Code: The Hidden Language of Computer Hardware and Software\r\n（《编码的奥秘》）</li>\r\n<li>Computer System: A Programmer’s Perspective\r\n（《深入理解计算机系统》） / Windows via C/C++ （《Windows核心编程》 /\r\n《程序员的自我修养》</li>\r\n<li>Code Complete 2（《代码大全》）/ The Pragmatic Programmer\r\n（《程序员修炼之道》，我也把这本书称为《代码小全》）</li>\r\n<li>Programming Pearls （《编程珠玑》） / Algorithms / Algorithm Design\r\n/ 《编程之美》</li>\r\n<li>The C Programming Language</li>\r\n<li>The C++ Programming Language / Programming: Principles and Practice\r\nUsing C++ / Accelerated C++</li>\r\n<li>The Structure and Interpretation of Computer Programs\r\n（《计算机程序的构造和解释》）</li>\r\n<li>Clean Code / Implementation Patterns</li>\r\n<li>Design Patterns （《设计模式》） / Agile Software Development,\r\nPrinciples, Patterns, and Practices</li>\r\n<li>Refactoring （《重构》）</li>\r\n</ul>\r\n<p><strong>GitHub</strong>：企业怎么鉴别读书之外的工程能力呢？GitHub。其不可伪造、不可短时间恶补。每个人的GitHub\r\nHistory都是这个人所作所为的见证，每一条commit，issue，pr，甚至为项目写的文档，都是构成一个代码人的重要结构。企业能从中看到信息，而作为学生，我们也自然应该维护好其中的信息。<strong>积极与同行交流，积极寻找同好，积极code，记住自己的每一步都在造就自己的历史。</strong></p>\r\n<blockquote>\r\n<p>从你的GitHub旅程开始，你就已经一脚踏进了真正的企业，而企业的面试也已经开始。</p>\r\n</blockquote>\r\n<h1 id=\"知识的输出\">知识的输出</h1>\r\n<p>第一个优点：大家都知道好记性不如烂笔头，记录我们的学习往往能够帮助我们巩固并理清知识脉络，而不是囫囵吞枣看完就算学完。</p>\r\n<p>第二个优点：从公司的角度来看，<strong>知识的输出，其实是招聘者认识你的重要途径</strong>：</p>\r\n<blockquote>\r\n<p>刘的招人渠道： 上 twitter，看 XXX 的 follower，一个一个看，看他们的\r\ntwitter，博客，Google Reader\r\n分享，想办法搞到邮件，联系，半夜电话骚扰。</p>\r\n<p>上豆瓣，前端后端挑几本重量级的书，去找想看，看过，正在看这本书的人，一个一个看，看他们的活动，博客，Google\r\nReader 分享，想办法搞到邮件，联系，半夜电话骚扰。</p>\r\n<p>找同事，问他们都看什么技术博客，想办法搞到邮件，联系，半夜电话骚扰。</p>\r\n</blockquote>\r\n<p>你在豆瓣写的书评，最简单的层次上，体现了你是否读过这本书(无意义无价值的书评，既不会被认为是读过，甚至还会拉低别人对你的评价)。如果写的好，更体现了你对这本书的理解与认识。</p>\r\n<blockquote>\r\n<p>就像你的Steam游戏评测历史，将你的游戏爱好与兴趣点暴露无遗：)</p>\r\n</blockquote>\r\n<p>你的技术博客，以及各大社交平台的文章专栏，和GitHub一样，都是一点一滴积累出的关于你的历史。你写过的每篇文章，无论是作为笔记，还是作为见解，都表明了你对知识的理解程度。(当然，没有人喜欢完全复制粘贴的垃圾文章。)所谓面试时所需要考察的问题分析能力、举止言谈能力，很大程度上就记录在你写过的东西里，一个人无法在一个长期博客中伪装自己的知识储备和习惯。</p>\r\n<p>另一方面，计算机行业从不缺乏鼓励、赞扬、与辩驳。精彩的知识输出往往会给你带来同行的支持，例如知名度和交友圈。也会带来同行的评审，当我们和不知名的网友在评论区讨论半天的时候，大概是提升最快的时候~</p>\r\n<p>当招聘者发现你的技术文章被几十个人点赞、或者十几个人讨论，或者你的博客知名度本身已经在圈内赫赫有名，那你这个人的质量早就经过了数不清的检验，还需要担心什么呢？</p>\r\n<p><strong>笔记与博客</strong>：我个人会将笔记也写在博客里，如工具使用笔记、论文笔记等。不过这合适吗？我并不知道。</p>\r\n","categories":["生活"]},{"title":"尼尔机械纪元：月光下的童话悲曲","url":"/2022/03/28/%E5%B0%BC%E5%B0%94%E6%9C%BA%E6%A2%B0%E7%BA%AA%E5%85%83/","content":"<p>尼尔机械纪元：NieR: Automata</p>\r\n<h1 id=\"瑕不掩瑜的黑童话\">瑕不掩瑜的黑童话</h1>\r\n<p>值得注意的是,\r\n即使我很欣赏这个游戏，但是不得不说它完全不是一款集大成的3A大作,\r\n它只是一个在受限的预算下, 尽可能把自己的核心领域做出了极高的素质,\r\n同样另一方面，其不足之处也多了去了。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.akamai.steamstatic.com/steam/apps/524220/ss_c538e630c5cc224124104cc42ec6220ab90b5852.jpg?t=1646911723\"\r\nalt=\"末世的静美\" />\r\n<figcaption aria-hidden=\"true\">末世的静美</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h2 id=\"剧情基调-充满月光的忧郁童话\">剧情基调: 充满月光的忧郁童话</h2>\r\n<p><strong>(带有轻微主题剧透)</strong> 游戏剧情的大致背景,\r\n在商店介绍里很详细了，大致是人类后末世时代，人造机器人重返地球解开末世与人类的秘密。</p>\r\n<p>不是勇者斗恶龙那种打败大坏蛋的正道之光,不是最终幻想那种命运钦定剑与水晶的标准日式RPG的王道之路，<strong>是\"鬼才\"横尾太郎的致郁童话。</strong></p>\r\n<ul>\r\n<li>你可能会遇到一个因战斗失去了自己机器人孩子的机器人,\r\n它因无法忍受痛苦请求你格式化它的记忆, 之后再找它,\r\n发现毫无记忆的它开心地批量贩卖着孩子的零件.</li>\r\n<li>你可能会遇到一个失忆的反抗军, 她不知道自己的过去和未来,\r\n只是身上有几张风景照, 在你帮他认出这几个地点后,\r\n她想起来这些是和挚爱一起到过的地方, 然而挚爱已经去世.\r\n迷茫但无忧无虑的她, 只能变得悲伤.</li>\r\n<li>你可能会遇到一个请你帮他换零件的人造人, 最后在更换了太多零件之后,\r\n疑问自己还是自己吗? ----致敬忒修斯之船</li>\r\n<li>你可能会遇到一个机械生物为了追求另一个机械生物的爱,\r\n逐渐病态的悲剧。</li>\r\n</ul>\r\n<blockquote>\r\n<p>\"看着我, 我会用其他机械生物伙伴的部位来装饰, 我...会变得更漂亮哦,\r\n.....可以喜欢上我吗?\"</p>\r\n<p>\"太愚蠢了...吃了人造人就能变美, 这没有一点道理,\r\n但是我实践了..我吃到快吐了...不仅是人造人, 连我自己的同胞也吞下肚,\r\n但始终无法让他回头看我一眼..我始终无法让他回头看我一眼\"</p>\r\n<p>\"最后, 我发现了, 没有意义, 我无法得到那个人的心,\r\n----我看着镜中自己毫无意义的姿态放声大叫, 谁来..认同..我\"</p>\r\n</blockquote>\r\n<p>基本整个尼尔世界中的基调都是这种小清新致郁风格。但又不是完全故意迫害玩家心灵,\r\n更确切地说这种小致郁的基调对于营造末世忧郁风格很有帮助,\r\n同时也铺垫着尼尔主线本身的结局性质。</p>\r\n<p>另一方面, 除了这些主格调的忧郁, 玩家其实在主线过程中,\r\n更多直接体验的反而是正面回馈，例如反抗军的热情友好, 反战村庄的欢乐,\r\n以及和战友并肩作战的羁绊, 只不过会和逐渐揭开的主格调形成鲜明对比,\r\n然后更加凸显这个欢乐中忧郁的世界氛围, 所谓月光般的欢乐,\r\n又温柔又冰冷至极。</p>\r\n<p>除了这些主线支线所带来的比较充分的剧情,\r\n尼尔的每个武器都包含一个小剧场类型的武器背景故事。每个小剧情被分割成了四段话,\r\n随着武器的强化, 故事逐渐解锁,\r\n最终的结局往往也是让人有点回味...这些故事大多和游戏剧情无关,\r\n但是也是强化了世界观的忧郁风...</p>\r\n<blockquote>\r\n<p>很久以前, 有七个少年快乐并和睦地生活在一起</p>\r\n<p>一位占卜师来了, 说\"你们当中有一人是叛徒\", 少年们没信</p>\r\n<p>从第二天开始 , 每晚都有一人被杀害, 少年们开始相互怀疑</p>\r\n<p>只剩下最后一个少年, 少年看着自己沾满鲜血的手, 笑了,\r\n\"必须要去找出谁是叛徒\"</p>\r\n</blockquote>\r\n<h2 id=\"角色扮演-纯粹的故事向-却又带点奇怪的自由度\">角色扮演:\r\n纯粹的故事向, 却又带点奇怪的自由度</h2>\r\n<p>虽然是开放世界的角色扮演，但大部分主线支线都是不具有选择权的,\r\n或者是给了你选项, 但只要你不选规定的那个,\r\n会一直重复让你选..直到你改变心意...也就是说其实是<strong>一本道类型的体验型角色扮演</strong>,\r\n当然我个人并不觉得多选择有什么必要，因为我不喜欢强行多刷去看每一条分支。</p>\r\n<blockquote>\r\n<p>所谓追求自由选择，难道核心目的不是让玩家更有代入感吗，为什么玩家非要去看完所有其他可能呢=\r\n=结果让游戏好好的多选择自由扮演，变成了多剧情打包卖。</p>\r\n</blockquote>\r\n<p>~ (像刺客信条奥德赛那种罐头多选择算了吧,\r\n你还不如不给我选项呢...给了还反胃..)~</p>\r\n<p><strong>装备系统</strong>： 即芯片系统,\r\n玩家可以通过装备不同的芯片增强不同的属性,\r\n比如加暴击加回血加移动速度啥的...奇怪的自由度----因为主角是人造人,\r\n芯片系统中有个OS芯片..你可以把它拆了, 然后全剧终...</p>\r\n<p><strong>武器和辅助机</strong>： 拥有数十个武器, 但种类只有几种,\r\n每个武器可以强化增强属性, 同时解锁一些独有的BUFF,\r\n例如在自身生命值高的时候伤害增加。辅助机也同样可以强化升级,\r\n可以更换不同的攻击方式, 可以收集装备不同的特殊技能。</p>\r\n<p><strong>26个结局, 和主线强制多周目</strong>：26结局有点噱头的意思,\r\n真正把游戏玩完整其实只有一个结局。但制作组在一些奇奇怪怪的地方给了玩家一点自由度...</p>\r\n<ul>\r\n<li>比如序章开局战死, 嗯全剧终。算一个结局...</li>\r\n<li>比如打BOSS的时候玩家逃跑, 嗯全剧终。算一个结局...</li>\r\n<li>有些友好型的敌对机械生物, 虽然大家是朋友,\r\n但玩家可以做些不太好的事，嗯全剧终。算一个结局，和成就。</li>\r\n<li>大部分类似于这样的小结局。</li>\r\n</ul>\r\n<p><strong>所谓强制多周目</strong>：并不是像其他游戏那种Game+形式,\r\n完全不变重复游玩, 事实上把尼尔的多周目理解为分章更好一些。</p>\r\n<ul>\r\n<li>第一章是作为2B, 以2B的视角体验前半段故事</li>\r\n<li>第二章是以9s的视角体验前半段故事, 故事大体是重复的,\r\n但会补充一些9s单独经历的剧情, 以及每个BOSS都会新增一些壁画形式的小故事,\r\n战斗方面在9s的侵入技能下, 会有较新的战斗体验,\r\n以及有一些只有9s的侵入才能做的支线和探索的宝箱.</li>\r\n<li>第三章是后半段全新故事, 接着第一章和第二章所描述的前半段,\r\n续写最后的篇章.\r\n第三章可以选择操作9s或者A2...当然我相信大部分人追求新意肯定是选A2了...</li>\r\n</ul>\r\n<h2 id=\"动作系统-易上手-强反馈的充实打击感-但欠缺深度\">动作系统: 易上手,\r\n强反馈的充实打击感, 但欠缺深度</h2>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.akamai.steamstatic.com/steam/apps/524220/extras/Nier_PRE_Launch-ENG_UK_Multi_06_Mod.jpg?t=1646911723\"\r\nalt=\"卡刀，火花，扎实的打铁之旅\" />\r\n<figcaption aria-hidden=\"true\">卡刀，火花，扎实的打铁之旅</figcaption>\r\n</figure>\r\n<p>尼尔动作系统本质就是 轻重攻击键的交替, 带来的不同的连招组合, 类似于\r\n无双大蛇2的连招系统。但是虽然听起来这样可以有很多连招组合,\r\n但尼尔武器类别其实只有几种, 同类别的武器打击方式基本是一样的,\r\n因此游玩过程中其实你从开头到结尾 , 打架的方式的新鲜感并不多。</p>\r\n<p><strong>当然作为白金出品,\r\n尼尔的打击感还是十分优秀的</strong>:该卡刀的卡刀, 视效音效应有具有,\r\n即使连招稍有单调, 但战斗体验还是很不错。还有一些辅助动作系统,\r\n算是增加了一些趣味。比如辅助机的几种辅助攻击方式, 例如机关枪,\r\n跟踪炮之类的。另外辅助机还可以装备一些特殊技能, 像重力场,\r\n激光炮....之类的。</p>\r\n<p><strong>讨巧的侵入系统</strong>：侵入敌人这个设定可以算是特别取巧刁钻!\r\n侵入过程是游玩一个弹幕小游戏, 没啥好介绍的, 但是侵入完成后 ,\r\n玩家可以选择操作敌人 (或者引爆敌人)。\r\n从开发方角度来看简直是神来一笔。一方面, 操作敌人不需要做新的素材,\r\n稍微适配一下玩家操作即可, 节省本就不高的预算。另一方面,\r\n本来单调的战斗体验在此时已经接近审美疲劳了,\r\n但是突然让玩家可以体验几乎每个敌人的战斗方式 (当然BOSS是不能操作的) ,\r\n于是玩家在接下来的每次战斗又可以获得全新的良好的体验。</p>\r\n<p><strong>较为优秀的BOSS战设计</strong>：虽然玩家打BOSS的方式大同小异,\r\n但是BOSS的攻击方式倒是千奇百怪 (当然脱离不了弹幕攻击这一大类) ,\r\n配合上优秀的氛围营造(音乐+剧情), 每场BOSS战虽然不是那种历久弥新,\r\n但也算是精彩。</p>\r\n<p><strong>再加上一些奇怪的战斗模式</strong>: 例如2D滚动卷轴空战模式,\r\n巨型机器人模式,\r\n横板卷轴动作...各种花里胡哨的小模式，填充了很大部分的游玩趣味。</p>\r\n<h2 id=\"bgm-氛围营造拉满\">BGM: 氛围营造拉满</h2>\r\n<p>即使大家对游戏素质有不同的评价,\r\n但音乐这一块毫无疑问压倒性的好评。(各大视频网站和音乐平台都有OST,\r\n音乐体验怎样可以听听看)。音乐技巧不谈，但是我从游玩角度来看 ,\r\n每个场景每段剧情每场战斗的BGM氛围营造的都特别棒.</p>\r\n<ul>\r\n<li>刚到废弃都市的时候, 空洞安静又带点忧郁。</li>\r\n<li>最著名的游乐园BGM, 一种末世之花的感觉?</li>\r\n<li>....所谓余音绕梁。</li>\r\n</ul>\r\n<p>游戏BGM不一定有很强的演奏编曲技术性，但是对氛围的营造这一块很成功，这作为游戏BGM已经够了。例如著名的水晶序曲Prelude，以及Final\r\nFantasy，Rivellon等</p>\r\n<h1 id=\"总结-核心体验十分优秀的神作\">总结, 核心体验十分优秀的神作</h1>\r\n<p>游戏大致风格就是如上所述, 剧情和音乐是尼尔的灵魂,\r\n但恰恰这两点不好在评测中描述出来, 因此只能把我感触中的音乐体验,\r\n和温柔忧郁的世界观风格介绍一下, 但只能提供一个概述的感觉,\r\n游戏本身的优秀与震撼人心最好能亲自体验。每个游戏都不会是完美的,\r\n必然有其重要想要给玩家体验到的东西 , 也必然有不足之处.\r\n用Gamker的话来说就是游戏的核心体验, 只要这个游戏把自己的核心体验做好了,\r\n给它的目标人群带来了一段优秀的游戏体验, 那它就是优秀的。</p>\r\n<p>当然再看综合素质的话, 尼尔还是有很多缺点：</p>\r\n<ul>\r\n<li>比如战斗系统虽然作为ARPG够用, 但真的不丰富多样, 也没有技能系统 ,\r\n战斗体验在三周目时趋于平淡</li>\r\n<li>比如画面优化很差, 虽然画面加上光影, 体积光和雾气效果的弥漫,\r\n其实还挺有末世感觉. 但不能掩盖细节缺失, 素材贫乏,\r\n优化还差的画面缺陷..</li>\r\n<li>比如地图设计反人类 (是用于看的地图,\r\n不是游戏整体地图结构)...虽然我不知道这种地图设计是为了满足世界观需要,\r\n还是单纯的为难玩家,\r\n还是单纯地技术不达标..总之这地图不太好用..甚至基本没用...</li>\r\n<li>比如大量的空气墙,\r\n大量的地方能看不能走.....因此虽然是开放世界鼓励探索..但其实空气墙的存在,\r\n事实上也只能走官方钦定的探索路线...让玩家不是很有探索欲望.</li>\r\n</ul>\r\n<p>在我看来, 尼尔想要营造的核心体验: 机械生物世界观,\r\n温柔忧郁又掺杂月光般的爱的悲剧风格,\r\n回味无穷的角色扮演体验。这些我都能够在游戏中充分地体验到,\r\n因此我个人认为这是一款特别优秀的游戏。</p>\r\n","categories":["生活"],"tags":["游戏"]},{"title":"屏蔽B站PC首页直播块舞蹈区","url":"/2021/01/28/%E5%B1%8F%E8%94%BDB%E7%AB%99%E9%A6%96%E9%A1%B5%E7%9B%B4%E6%92%AD%E5%9D%97%E8%88%9E%E8%B9%88%E5%8C%BA%E5%85%83%E7%B4%A0/","content":"<p>一直以来喜欢没事挂在B站首页，然后看看有没有些有趣的人直播好玩的东西什么的。然而，B站首推的主播大多都是舞见唱见，视频陪聊什么的，流量至上没有错，但是让我目标信息获取率极低就很烦。</p>\r\n<p>因此找了找根据分区删除元素的方式：</p>\r\n<p><code>www.bilibili.com##.live-card:has-text(舞见)</code></p>\r\n<h2 id=\"工具\">工具</h2>\r\n<ul>\r\n<li><p>Chrome系浏览器，可以用Chrome插件</p></li>\r\n<li><p>浏览器安装一个广告拦截插件，如Ads Killer Plus</p></li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<h2 id=\"添加屏蔽规则\">添加屏蔽规则</h2>\r\n<p>通常广告拦截插件都支持自定义规则，而显然舞见直播什么的不会被内置定义为广告，虽然实际上差不多。\r\n因此我们要自己写选择舞见的过滤器。 以Ads Killer Plus为例：</p>\r\n<p>首页直播块结构如下：.live-card &gt; a &gt; .up &gt; .txt &gt; .\r\ntag</p>\r\n<p>tag值即是主播分区名，如视频唱见、舞见...</p>\r\n<p>我们想要通过 tag=舞见\r\n去删除.live-card元素，正常的类选择器好像只能根据父元素选择子元素，而不能反过来。</p>\r\n<p>这时候就需要用到插件的扩展语法功能，例如这款插件有如下两个选择语法：</p>\r\n<h3 id=\"subjecthasarg\">subject:has(arg)</h3>\r\n<p>如果subject自身及其子元素有arg元素，则选定subject元素</p>\r\n<p>使用方法即正常选择器选出一个subject对象，然后后面加上<code>:has(arg)</code>，arg\r\n也是一个选择器对象。</p>\r\n<ul>\r\n<li>Description: Select element subject if and only if evaluating arg in\r\nthe context of subject returns one or more elements.</li>\r\n<li>Chainable: Yes.</li>\r\n<li>subject: Can be a plain CSS selector, or a procedural cosmetic\r\nfilter.</li>\r\n<li>arg: A valid plain CSS selector or procedural cosmetic filter, which\r\nis evaluated in the context of the subject element.</li>\r\n</ul>\r\n<h3 id=\"subjecthas-textneedle\">subject:has-text(needle)</h3>\r\n<p>如果subject自身及其子元素有needle文本值，则选定subject元素。\r\nneedle可用正则表达式。</p>\r\n<ul>\r\n<li>Description: Select element subject if the text needle is found\r\ninside the element subject or its children.</li>\r\n<li>Chainable: Yes.</li>\r\n<li>subject: Can be a plain CSS selector, or a procedural cosmetic\r\nfilter.</li>\r\n<li>needle: The literal text which must be found, or a literal regular\r\nexpression. If using a literal regular expression, you can optionally\r\nuse the i and/or m flags (version 1.15).</li>\r\n</ul>\r\n<blockquote>\r\n<p>注意冒号后面不能有空格</p>\r\n</blockquote>\r\n<p>我们只需判断分区文本值，因此用has-text即可，最终在自定义规则列表中添加如下规则应用：</p>\r\n<blockquote>\r\n<p>www.bilibili.com##.live-card:has-text(/电台|陪伴学习|萌宠|唱见|舞见|视频|虚拟主播/)</p>\r\n</blockquote>\r\n<h2 id=\"后话\">后话</h2>\r\n<p>上述规则会选定整个live-card板块，因此删除后B站直播块可能会有点排版不整齐，如果仅删除live-card下的a元素，则删除后会在原位置保留一块空白，保持元素排版整齐。</p>\r\n<p>另外这种方式应该适用于所有通过子类屏蔽父类的想法。</p>\r\n","categories":["工具"]},{"title":"开源协议(讲稿)","url":"/2021/12/30/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/","content":"<blockquote>\r\n<p>课程研讨讲稿，搜集资料的集合，完全非原创，仅供临时参考。</p>\r\n</blockquote>\r\n<p>近年来，开源正在变得越来越火，我们经常会看到\r\n“某企业宣布开源”、“某开源大会召开”、“某开源项目获得融资”。个人开发者与企业比以往任何时候都更愿意参与到开源项目的建设和贡献中，开源在国内\r\nIT 领域获得了前所未有的热度，也获得了产业界和投资圈的广泛关注。</p>\r\n<p>但总有些人听到开源一词时，就会误以为\r\n“<strong>开源软件是免费的，因此我可以不受限制地随意使用</strong>”。在开源诞生之初，自由软件是当时的主流提法，回顾开源的发展史，从自由软件到开源运动实现了非常大的跨越，前者更多的是一种精神的倡导，而后者着眼于软件的协同开放，因此会有非常严谨的开源许可证的规则和限制。开源软件能走到今天的发展程度，就是因为有了这么一套遵从开源精神的规则体系，才能够健康发展。开源精神的载体之一就是开源许可证，今天我们就来扒一扒开源许可证与开源的关系，以及它背后折射出的问题。</p>\r\n<span id=\"more\"></span>\r\n<hr />\r\n<h1 id=\"自由软件和开源软件\">自由软件和开源软件</h1>\r\n<p>开源软件与自由软件是两个不同的概念，只要符合开源软件定义的软件就能被称为开源软件。</p>\r\n<p>而自由软件有比开源软件更严格的概念，因此所有自由软件都是开放源代码的，但不是所有的开源软件都能被称为“自由”。但一般，绝大多数开源软件也都符合自由软件的定义。</p>\r\n<ol type=\"1\">\r\n<li>开源代码是，使用开放的开发方式，尽可能的使软件优化，公开，但不一定给予自由权。</li>\r\n<li>自由软件的原意就是要给予用户运用软件的自由，这个‘自由’就是自由软件的精神所在。</li>\r\n</ol>\r\n<p><strong>免费软件</strong>：是一种不须付费就可获取的软件，但是通常有其他的限制，用户并没有使用、复制、研究、修改和分发的自由。该软件的源代码不一定会公开。</p>\r\n<h1 id=\"什么是开源协议\">什么是开源协议？</h1>\r\n<p>OpenSource\r\nSoftware(OSS)：可以获取源代码的软件。如果一个程序员想将自己的代码开源，他有许多种选择，大致可以分成三类：</p>\r\n<ol type=\"1\">\r\n<li>将代码放入\"公共领域\"（public domain），彻底放弃版权。</li>\r\n<li>选择谨慎的许可证，如GPL，要求衍生代码必须开源。</li>\r\n<li>选择更宽松的许可证，比如BSD和Apache许可证，不要求衍生代码开源。</li>\r\n</ol>\r\n<p>两大阵营，FSF和OSI，对开源有着不同的理念。</p>\r\n<h2 id=\"fsffree-software-foundation自由软件基金会\">FSF（Free Software\r\nFoundation，自由软件基金会)</h2>\r\n<p>FSF 是开源泰斗 <strong>理查德·斯托曼 RMS</strong>\r\n创立的重要的开源软件基金会 (1985/10/04), FSF\r\n创立之初主要是为了筹集资金来建设 <strong>GNU：GNU is Not Unix</strong>\r\n的内核 Hurd 项目及工具链，虽然 GNU\r\n项目本身没有完成，但是该过程中创造出的大量软件工具，日后成为了 GNU/Linux\r\n的重要组成部分。</p>\r\n<p>FSF 建立了开源领域的第一个 <strong>copyleft</strong> 属性的许可证 -\r\n<strong>GPL (GNU Public License)</strong> 。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/n0x5S9v.png\" alt=\"RMS\" />\r\n<figcaption aria-hidden=\"true\">RMS</figcaption>\r\n</figure>\r\n<h3 id=\"copyleft\">CopyLeft</h3>\r\n<figure>\r\n<img src=\"https://i.imgur.com/LdcKipT.png\"\r\nalt=\"Copyleft：镜像而不是翻转。Copyleft保留著作权，而不是放弃著作权\" />\r\n<figcaption\r\naria-hidden=\"true\">Copyleft：镜像而不是翻转。Copyleft保留著作权，而不是放弃著作权</figcaption>\r\n</figure>\r\n<p>Copyleft是指任何人都可以重新分发软件，不管有没有进行修改，但必须同时保留软件所具有的自由特性。即拥有著作权，仅用于保护其自由。</p>\r\n<blockquote>\r\n<p>The licenses for most software and other practical works are designed\r\nto take away your freedom to share and change the works. By contrast,\r\nthe GNU General Public License is intended to guarantee your freedom to\r\nshare and change all versions of a program--to make sure it remains free\r\nsoftware for all its\r\nusers.（大多数软件许可是设计用以剥夺你的分享与修改软件的自由。相反地，GNU通用公共许可则是要保证您分享与修改自由软件的自由——确保软件对所有的用户而言都是自由的。）</p>\r\n</blockquote>\r\n<h3 id=\"gpl\">GPL</h3>\r\n<figure>\r\n<img src=\"https://i.imgur.com/bqc0c64.png\" alt=\"GPL\" />\r\n<figcaption aria-hidden=\"true\">GPL</figcaption>\r\n</figure>\r\n<p>GPL是第一个Copyleft类型的许可证，全身心追求软件的<strong>自由</strong>：</p>\r\n<ul>\r\n<li>基于任何目的，按你的意愿运行软件的<strong>自由</strong>。</li>\r\n<li>学习软件如何工作的自由，按你的意愿修改软件以符合你的计算的<strong>自由</strong>。</li>\r\n<li>分发软件副本的<strong>自由</strong>，因此你可以帮助你的好友。</li>\r\n<li>将你修改过的软件版本再分发给其他人的<strong>自由</strong>。这样可以让整个社区有机会共享你对软件的改动。</li>\r\n</ul>\r\n<p>GPL与其他一些更“许可的”自由软件许可证（比如BSD许可证）相比，主要区别就在于<strong>GPL寻求确保上述自由能在复制软件及派生作品中得到保障</strong>，要求GPL程序的派生作品也要在GPL之下。相反，BSD式的许可证并不禁止演绎作品变成专有软件。</p>\r\n<p>GPL保护的一个典型例子就是著名的 2009甲骨文收购SUN公司事件，Michael\r\nWidenius，MySQL创始人四处呼吁反对收购，因为他觉得甲骨文自己本来就做Oracle数据库，拥有了MySQL后只会杀死它。然而，MySQL是杀不死的：它的许可证是<strong>GPL</strong>。</p>\r\n<p>著名的应用：MySQL</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/dFsOCjk.png\" alt=\"MySQL许可证\" />\r\n<figcaption aria-hidden=\"true\">MySQL许可证</figcaption>\r\n</figure>\r\n<h2 id=\"osiopen-source-initiative开放源代码促进会\">OSI（Open Source\r\nInitiative，开放源代码促进会）</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/AR2BNJO.png\" alt=\"OSI\" />\r\n<figcaption aria-hidden=\"true\">OSI</figcaption>\r\n</figure>\r\n<p>OSI 由开源界泰斗 Bruce Perens 和 Eric S. Raymond (ESR) 在 1998\r\n年组建，目的是在理想的自由软件与商业之间达成一个平衡，务实的开源行动，负责管理各种开源规范。OSI\r\n组织认证过的许可大概有 80 种，包括 Apache License 、GPL 、MIT/BSD\r\n等。</p>\r\n<h1 id=\"开源许可证open-source-license\">开源许可证(Open Source\r\nLicense)</h1>\r\n<h2 id=\"lesser-gpl\">Lesser GPL</h2>\r\n<p>强制开源虽然很美好，但是现实不是理想国。除开一部分理想主义者，别人凭什么要居人篱下呢？LGPL允许LGPL授权的软件集成至他们自己的软件内（即使该软件是私有软件也被允许），同时不会受到Copyleft特性的许可证强制对软件开源的限制。该许可证常被用于一些（但不是全部）GNU程序库。</p>\r\n<blockquote>\r\n<p>\"After all, there are plenty of other C libraries; using the GPL for\r\nours would have driven proprietary software developers to use\r\nanother--no problem for them, only for us.\"\r\n\"毕竟，市场上的C库有的是。GPL许可证将迫使私有软件去使用他人的库，这不会给他们带来困扰，只会给我们带来困扰。\"</p>\r\n</blockquote>\r\n<h2 id=\"bsd\">BSD</h2>\r\n<p>是自由软件中使用最广泛的许可协议之一。从copyleft到copyright，BSD许可证往往认为是<strong>copycenter</strong>：</p>\r\n<ol type=\"1\">\r\n<li>源代码传播，则必须带有原来的BSD协议。</li>\r\n<li>二进制传播，则需在版权声明中带有原来的BSD协议。</li>\r\n<li>传播产品不能用原来的信息来进行市场推广。</li>\r\n</ol>\r\n<p>因此是对商业集成很友好的协议，而很多的公司企业在选用开源产品的时候都首选BSD协议。</p>\r\n<p>有意思的小故事：</p>\r\n<blockquote>\r\n<p>3.所有提及该软件功能或者使用该软件的广告材料必须展示以下致谢：本产品包含由加州大学伯克利分校及其贡献者开发的软件。</p>\r\n</blockquote>\r\n<p>最初，令人反感的BSD广告条款只是在伯克利软件发行版中使用。因为在广告中包含一句话并不是十分困难，所以此条款并没有引起特别的问题。</p>\r\n<p>如果其他使用BSD类许可证的开发者逐字拷贝了BSD广告条款—包含了指向加州大学的句子—，那么他们也没有使问题变大。</p>\r\n<p>但是，可能正如你所预见，有些开发者不是逐字拷贝该条款。他们做了改动，把“加州大学”换成了他们自己机构的名称。结果就是有了太多的许可证，需要使用太多的句子。</p>\r\n<h2 id=\"apache-license-asl\">Apache License (ASL)</h2>\r\n<p>ASL 也是商业公司偏爱的许可证，</p>\r\n<ol type=\"1\">\r\n<li>每个被修改的文件中，都需要说明更改。</li>\r\n<li>对所有未修改部分，保留所有原有的著作权，专利，商标等归属。</li>\r\n</ol>\r\n<p>著名的应用有 Android：</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/8SBygKM.png\" alt=\"Android许可证\" />\r\n<figcaption aria-hidden=\"true\">Android许可证</figcaption>\r\n</figure>\r\n<h2 id=\"mit-license\">MIT License</h2>\r\n<p>特此授予任何人免费获得本软件和相关文档文件（“软件”）副本的许可，不受限制地处理本软件，包括但不限于使用、复制、修改、合并\r\n、发布、分发、再许可的权利，\r\n被许可人有权利使用、复制、修改、合并、出版发行、散布、再许可和/或贩售软件及软件的副本，及授予被供应人同等权利，惟服从以下义务。</p>\r\n<p>在软件和软件的所有副本中都必须包含以上著作权声明和本许可声明。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/RyVOFow.png\" alt=\"开源协议简单对比\" />\r\n<figcaption aria-hidden=\"true\">开源协议简单对比</figcaption>\r\n</figure>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p><a href=\"https://zh.wikipedia.org/wiki/Copyleft\">Copyleft维基百科</a>\r\n<a\r\nhref=\"http://www.ruanyifeng.com/blog/2010/02/why_gpl_is_a_better_choice.html\">阮一峰-开源协议</a></p>\r\n","categories":["工具"]},{"title":"循环神经网络","url":"/2021/12/21/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","content":"<h2 id=\"rnn\">RNN</h2>\r\n<h3 id=\"循环层\">循环层：</h3>\r\n<p><span class=\"math display\">\\[\r\n\\mathbf{H}_t = \\phi(\\mathbf{X}_t \\mathbf{W}_{xh} + \\mathbf{H}_{t-1}\r\n\\mathbf{W}_{hh}  + \\mathbf{b}_h).\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"https://zh-v2.d2l.ai/_images/rnn.svg\"\r\nalt=\"隐状态循环神经网络\" />\r\n<figcaption aria-hidden=\"true\">隐状态循环神经网络</figcaption>\r\n</figure>\r\n<h3 id=\"困惑度损失函数\">困惑度损失函数：</h3>\r\n<p>一个更好的语言模型应该能让我们更准确地预测下一个词元。\r\n因此，它应该允许我们在压缩序列时花费更少的比特。\r\n所以我们可以通过一个序列中所有的 n\r\n个词元的交叉熵损失的平均值来衡量：</p>\r\n<p><span class=\"math display\">\\[\r\n\\frac{1}{n} \\sum_{t=1}^n -\\log P(x_t \\mid x_{t-1}, \\ldots, x_1)\r\n\\]</span></p>\r\n<p><strong>困惑度</strong>即更流行的指数形式交叉熵（历史原因）：</p>\r\n<p><span class=\"math display\">\\[\r\n\\exp\\left(-\\frac{1}{n} \\sum_{t=1}^n \\log P(x_t \\mid x_{t-1}, \\ldots,\r\nx_1)\\right).\r\n\\]</span></p>\r\n<ul>\r\n<li>在最好的情况下，模型总是完美地估计标签词元的概率为1。\r\n在这种情况下，模型的困惑度为1。</li>\r\n<li>在最坏的情况下，模型总是预测标签词元的概率为0。\r\n在这种情况下，困惑度是正无穷大。</li>\r\n<li>Baseline：该模型的预测是词表的所有可用词元上的均匀分布？\r\n在这种情况下，困惑度等于词表中唯一词元的数量。\r\n事实上，如果我们在没有任何压缩的情况下存储序列，\r\n这将是我们能做的最好的编码方式。 因此，这种方式提供了一个重要的上限，\r\n而任何实际模型都必须超越这个上限。</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<h3 id=\"初始化状态\">初始化状态</h3>\r\n<p><strong>使用onehot编码来代替直接输入索引值</strong></p>\r\n<p><strong>预热期</strong>：更新隐状态信息但不计算预测</p>\r\n<p><strong>初始化隐状态</strong>：</p>\r\n<ul>\r\n<li>顺序分区：下一个minibatch和当前minibatch取得的时间步相邻。因此当前minibatch的隐状态可以用于初始化下一个minibatch。\r\n为了降低计算量，在处理任何一个minibatch数据之前，\r\n我们先分离梯度，使得隐状态的梯度计算总是限制在一个minibatch数据的时间步中。</li>\r\n<li>随机分区：每个minibatch需要重新初始化隐状态。</li>\r\n</ul>\r\n<h3 id=\"时间步反向传播bbtt\">时间步反向传播BBTT：</h3>\r\n<p>对于每个时间步计算隐状态和输出，有：<span class=\"math inline\">\\(h_t =\r\nf(x_t, h_{t-1}, w_h),o_t = g(h_t, w_o)\\)</span>。在反向传播时，<span\r\nclass=\"math inline\">\\(L\\)</span>依赖于所有的<span\r\nclass=\"math inline\">\\(o_t\\)</span>，即<span class=\"math inline\">\\(L(x_1,\r\n\\ldots, x_T, y_1, \\ldots, y_T, w_h, w_o) = \\frac{1}{T}\\sum_{t=1}^T\r\nl(y_t, o_t).\\)</span>。因此在<span\r\nclass=\"math inline\">\\(L\\)</span>对<span\r\nclass=\"math inline\">\\(W_h\\)</span>求梯度时，有：</p>\r\n<p><span class=\"math display\">\\[\r\n\\frac{\\partial L}{\\partial w_h} = \\frac{1}{T}\\sum_{t=1}^T \\frac{\\partial\r\nl(y_t, o_t)}{\\partial o_t} \\frac{\\partial g(h_t, w_o)}{\\partial\r\nh_t}  \\frac{\\partial h_t}{\\partial w_h}\r\n\\]</span></p>\r\n<p>其中 <span class=\"math inline\">\\(h_t\\)</span> 递归依赖于 <span\r\nclass=\"math inline\">\\(h_{t-1}\\)</span>，<span\r\nclass=\"math inline\">\\(h_{t-1}\\)</span>同样依赖于<span\r\nclass=\"math inline\">\\(w_h\\)</span>，造成递归依赖，因此计算链式法则会很长，化简结果为：</p>\r\n<p><span class=\"math display\">\\[\r\n\\frac{\\partial h_t}{\\partial w_h}=\\frac{\\partial\r\nf(x_{t},h_{t-1},w_h)}{\\partial\r\nw_h}+\\sum_{i=1}^{t-1}\\left(\\prod_{j=i+1}^{t} \\frac{\\partial\r\nf(x_{j},h_{j-1},w_h)}{\\partial h_{j-1}} \\right) \\frac{\\partial\r\nf(x_{i},h_{i-1},w_h)}{\\partial w_h}.\r\n\\]</span></p>\r\n<h3 id=\"截断反向传播\">截断反向传播</h3>\r\n<p>显然完全计算整条时间链是非常昂贵的，而且容易梯度爆炸蝴蝶效应。</p>\r\n<p><strong>常规截断时间步</strong>：即常用的detach\r\nstate。把state链限定在相同长度的时间碎片内。</p>\r\n<p><strong>随机截断时间步</strong>：使用一个随机变量替换<span\r\nclass=\"math inline\">\\(\\partial h_t/\\partial w_h\\)</span>。\r\n这个随机变量是通过使用序列 <span class=\"math inline\">\\(ξ_t\\)</span>\r\n来实现的。 <span class=\"math inline\">\\(ξ_t\\)</span> 定义：对于$ 0≤π_t≤1\r\n$， 其中 <span class=\"math inline\">\\(P(ξ_t=0)=1−π_t\\)</span> 且\r\n$P(ξ_t=π^{−1}_t)=π_t $， 因此 <span\r\nclass=\"math inline\">\\(E[ξ_t]=1\\)</span>。，将<span\r\nclass=\"math inline\">\\(ξ_t\\)</span>放在<span\r\nclass=\"math inline\">\\(\\frac{\\partial h_t}{\\partial\r\nw_h}\\)</span>中，得到：</p>\r\n<p><span class=\"math display\">\\[\r\nX_t= \\frac{\\partial f(x_{t},h_{t-1},w_h)}{\\partial w_h} +\\xi_t\r\n\\frac{\\partial f(x_{t},h_{t-1},w_h)}{\\partial h_{t-1}} \\frac{\\partial\r\nh_{t-1}}{\\partial w_h}.\r\n\\]</span></p>\r\n<p>当<span class=\"math inline\">\\(ξ_t=0\\)</span>时即会截断递归。通过<span\r\nclass=\"math inline\">\\(E[ξ_t]=1\\)</span>，得到<span\r\nclass=\"math inline\">\\(E[X_t] = \\partial h_t/\\partial\r\nw_h\\)</span>。即不改变期望值，但是截断反向传播。</p>\r\n<h3 id=\"梯度裁剪\">梯度裁剪</h3>\r\n<p>使用给定半径 <span class=\"math inline\">\\(θ\\)</span> 的球来裁剪梯度\r\n<span class=\"math inline\">\\(g\\)</span>，<span class=\"math inline\">\\(g\r\n&lt; θ\\)</span> 则不变，$ g &gt; θ $ 则裁剪到 <span\r\nclass=\"math inline\">\\(θ\\)</span> ， 并且更新后的梯度完全与 <span\r\nclass=\"math inline\">\\(g\\)</span> 的原始方向对齐。\r\n它还有一个值得拥有的副作用，\r\n即限制任何给定的小批量数据（以及其中任何给定的样本）对参数向量的影响，\r\n这赋予了模型一定程度的稳定性。 如下式：</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathbf{g} \\leftarrow \\min\\left(1, \\frac{\\theta}{\\|\\mathbf{g}\\|}\\right)\r\n\\mathbf{g}.\r\n\\]</span></p>\r\n<h2 id=\"语言模型处理\">语言模型处理</h2>\r\n<h3 id=\"文本计数问题\">文本计数问题</h3>\r\n<p><strong>拉普拉斯平滑</strong> 具体方法是在所有计数中添加一个小常量。\r\n用 n 表示训练集中的单词总数，用 m 表示唯一单词的数量</p>\r\n<span class=\"math display\">\\[\\begin{split}\\begin{aligned}\r\n    \\hat{P}(x) &amp; = \\frac{n(x) + \\epsilon_1/m}{n + \\epsilon_1}, \\\\\r\n    \\hat{P}(x&#39; \\mid x) &amp; = \\frac{n(x, x&#39;) + \\epsilon_2\r\n\\hat{P}(x&#39;)}{n(x) + \\epsilon_2}, \\\\\r\n    \\hat{P}(x&#39;&#39; \\mid x,x&#39;) &amp; = \\frac{n(x,\r\nx&#39;,x&#39;&#39;) + \\epsilon_3 \\hat{P}(x&#39;&#39;)}{n(x, x&#39;) +\r\n\\epsilon_3}.\r\n\\end{aligned}\\end{split}\\]</span>\r\n<p>注意词频以一种明确的方式迅速衰减。齐普夫定律（Zipf’s law）， 即第 i\r\n个最常用单词的频率 <span class=\"math inline\">\\(n_i\\)</span> 为：<span\r\nclass=\"math inline\">\\(n_i \\propto\r\n\\frac{1}{i^\\alpha}\\)</span>，等价于<span class=\"math inline\">\\(\\log n_i\r\n= -\\alpha \\log i + c\\)</span>。</p>\r\n<p>因此对不常用单词进行计数统计和平滑建模是不可行的。</p>\r\n<h3 id=\"深度学习模型读取长数据\">深度学习模型读取长数据</h3>\r\n<p>从随机偏移量开始划分序列，\r\n以同时获得覆盖性（coverage）和随机性（randomness）</p>\r\n<p><strong>随机分区</strong>和<strong>顺序分区</strong></p>\r\n<h2 id=\"编码器-解码器\">编码器-解码器</h2>\r\n<h3 id=\"训练模式和预测模式\">训练模式和预测模式</h3>\r\n<p>训练模式中，解码器的输入可以就是真实label，而无需逐时间步计算出新的output，再给到下一个时间步进行计算。</p>\r\n<p>预测模式中，由于不知道解码器真实label，因此必须要按照正常的RNN计算方式，逐时间步计算output和state，并且把output和state再给到下一个时间步进行计算。</p>\r\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"排序算法总结","url":"/2021/03/17/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","content":"<h1 id=\"快速排序\">快速排序</h1>\r\n<h2 id=\"原理\">原理：</h2>\r\n<p>在数组中选定一个分界数<code>pivot</code>,\r\n然后将所有其他的数和它进行比较，大于的小于的分成两部分，<code>pivot</code>放中间，这样这一轮就确定了一个数的位置，然后递归左右两边继续快排即可。</p>\r\n<h2 id=\"算法流程\">算法流程</h2>\r\n<h3 id=\"首先确定一个分界数\">首先确定一个分界数</h3>\r\n<p>可以直接固定取最开始或者最后的那个数，也可以用随机算法。随机取数会使效率更加稳定。然后把这个数交换到\r\nend，以便前面进行分块。</p>\r\n<h3\r\nid=\"如何将大于和小于的两部分分开\">如何将大于和小于的两部分分开？</h3>\r\n<p>我们目标是让小于的部分在前，大于的部分在后————小于区 和\r\n大于区。两种分割方法： -\r\n一种是利用两个标志位，<code>lo=start</code>和<code>hi=end-1</code>。思想是两个标志位互相\r\n把<strong>应该分配给对方的数</strong> 给对方。 if\r\n(nums[lo]&gt;pivot)，显然 nums[lo] 的值不应该在 lo\r\n所处的小于区，因此我们把它丢到大于区<code>swap(nums[lo],nums[hi]);</code>。此时\r\nhi 所指的数是大于 pivot 的，是正确处于后半区的，因此 hi\r\n可以移动去处理下一个数，即 hi--。而 lo 获得了 hi\r\n交换过去的数，大于小于性未知，lo 不能动。</p>\r\n<pre><code>else，nums[lo] 正确处于小于区，那么 lo 去处理下一个数，lo++。</code></pre>\r\n<ul>\r\n<li><p>另一种需要一个标志位和一个遍历位，即<code>lo=start</code>和<code>cur=start+1</code>。cur\r\n从 start+1 遍历到 end-1 ，lo\r\n指示着小于区的最后一个数的位置。思想是把所有小于区的全部分好，那么大于区的也自然而然分好了。</p>\r\n<p>if (nums[cur]&gt;pivot), 即当前数应该在大于区，即在 lo 之外，因为 cur\r\n本来就一定指在 lo 之外，因此不用移动当前数， cur 去处理下一个，\r\ncur++。</p>\r\n<p>else, 即当前数应该添加到小于区，即在 lo\r\n的下一个，因此交换<code>swap(nums[cur],nums[lo+1]);</code>, 同时 lo++\r\n更新到新边界。此时这个小于区的数已经分好。lo+1 换给 cur 的数，必然是 cur\r\n处理过的，因此 cur 只需要去下一个数处理，cur++。</p></li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<h3 id=\"分好区之后把-pivot-插入到两区中间\">分好区之后，把 pivot\r\n插入到两区中间</h3>\r\n<p>因为我们之前把 pivot 放在了 end，因此需要把 pivot 和\r\n大于区的第一个数交换，如果 pivot 放在了 start，\r\n则是交换小于区的最后一个数。</p>\r\n<h3 id=\"递归两个分区\">递归两个分区</h3>\r\n<p>获得了两个分区数组，一个固定位置的 pivot\r\n，继续在两个分区里分别排序即可。</p>\r\n<h2 id=\"示例代码\">示例代码</h2>\r\n<p>这里使用的是第一种分割方法，比较常见和经典。</p>\r\n<p>实现上需要注意 while 循环出口时，lo 和 hi 的停留位置</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">sortArray</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;   </span><br><span class=\"line\">    <span class=\"comment\">//快速排序</span></span><br><span class=\"line\">    <span class=\"built_in\">sortArrayHelp</span>(nums,<span class=\"number\">0</span>,nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sortArrayHelp</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums,<span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> end)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(start&gt;=end)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pivot=nums[end];<span class=\"comment\">//end 为尾，不是尾后</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> lo=start,hi=end<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(lo&lt;=hi)<span class=\"comment\">//出口时 lo 和 hi 重叠在 hi 区的第一个</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[lo]&gt;pivot)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(nums[lo],nums[hi]);<span class=\"comment\">//交换两数</span></span><br><span class=\"line\">            hi--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            lo++;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">swap</span>(nums[lo],nums[end]);<span class=\"comment\">//注意 lo 的停留位置</span></span><br><span class=\"line\">    <span class=\"built_in\">sortArrayHelp</span>(nums,start,lo<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">sortArrayHelp</span>(nums,lo+<span class=\"number\">1</span>,end);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"性能分析\">性能分析</h2>\r\n<ul>\r\n<li><p>不稳定，存在打破 等值数 顺序的交换。</p></li>\r\n<li><p>时间复杂度最优 O(nlogn)，最差 O(n^2)。</p>\r\n<p>因为快排主要部分就是分区，分区好坏决定了递归树的深度，且每一层递归树的操作代价之和，都是\r\nO(n), 因此分析时间要从分区的可能情况入手。</p>\r\n<blockquote>\r\n<p>每层的操作代价——每次在 n 大小的分区中，都要进行 n-1 次比较。和 cn\r\n次的移动操作，每层的所有分区代价之和，必然是 O(n) 级。</p>\r\n<p>其实每一层相比前一层少了一个确定的数，操作代价也会少\r\n1，但我们分析上限暂且只考虑操作最高代价为 n。</p>\r\n</blockquote>\r\n<p>最优即对半分区，即最优情况下递归树的深度为 log n。运行时间表达式：\r\nT(n)=2*T(n/2)+O(n)，解为 T(n)=O(nlgn)</p>\r\n<p>最坏情况即完全逆序，每次划分只能划出一个分区，递归树深度为 n\r\n。运行时间表达式： T(n)=T(n-1)+O(n)，解为 T(n)=O(n^n)</p>\r\n<p>平均划分深度为 lg n 级，因为不论划分比例是 1：9，还是\r\n1：99，只要是常数比例划分，都必然形成一个 lg n\r\n的递归树深度，最终运行时间解 T(n)=O(nlgn)。</p></li>\r\n<li><p>空间复杂度即堆栈空间的大小，最优 O(log_2 n), 最坏 O(n), 平均 O(lg\r\nn)</p></li>\r\n</ul>\r\n<h1 id=\"堆排序\">堆排序</h1>\r\n<h2 id=\"原理-1\">原理</h2>\r\n<p>通过构建一个最大堆，这样从最大堆每次弹出\r\nroot，即可获得最大数，然后重新整理剩下的堆，循环类推。</p>\r\n<h2 id=\"算法流程-1\">算法流程</h2>\r\n<ol type=\"1\">\r\n<li><p>构建最大堆，最大堆本身是二叉树结构，只不过维护了父结点比子节点大的特征。而二叉树本身也可以通过数组的形式实现，因此我们这里可以直接用数组实现最大堆。当然，另建数据结构也行，理解上会更简单点。</p></li>\r\n<li><p>首先明确，在数组结构的二叉树中，i 结点的父结点是\r\n(i-1)/2，子结点是 2i+1, 2i+2。</p>\r\n<p>我们可以把当前数组看成已经成形的二叉树，构建最大堆即维护好父子结点的大小关系即可。</p>\r\n<p>因此对于每个结点，检查其是否比父结点大，是的话就换上去，同时递归往上检查。</p>\r\n<p>最终遍历检查好每个结点，即完成了最大堆的构建。</p></li>\r\n<li><p>弹出当前堆的最大数，整理剩下的堆，再维护成一个最大堆。</p></li>\r\n<li><p>因为最大堆由上往下依次变小，因此当 root\r\n被弹出后，只需要在它的直接子节点中选出最大的一个来当 root\r\n即可，此时最大子节点必是堆中最大的数。当然由于我们相当于在子堆中弹出了\r\nroot，因此也要递归维护下去。</p></li>\r\n<li><p>重建好堆后即可再次弹出，如此循环。</p></li>\r\n</ol>\r\n<h2 id=\"示例代码-1\">示例代码</h2>\r\n<p>注意重建堆的实现细节，需要考虑到子节点是否越界，还有递归重建的终止条件是否正确。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">sortArray</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> <span class=\"comment\">//堆排序</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;   </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> length=nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"built_in\">buildHeap</span>(nums);</span><br><span class=\"line\">        <span class=\"comment\">// for(int i=0;i&lt;length;i++)</span></span><br><span class=\"line\">        <span class=\"comment\">//     cout&lt;&lt;nums[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> end=length<span class=\"number\">-1</span>;end&gt;<span class=\"number\">0</span>;end--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//把根放到 end</span></span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(nums[<span class=\"number\">0</span>],nums[end]);</span><br><span class=\"line\">            <span class=\"comment\">//重建新堆</span></span><br><span class=\"line\">            <span class=\"built_in\">reBuildHeap</span>(nums,<span class=\"number\">0</span>,end<span class=\"number\">-1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">buildHeap</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length=nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;length;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> child=i;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> parent=(child<span class=\"number\">-1</span>)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(parent&gt;=<span class=\"number\">0</span> &amp;&amp; nums[parent]&lt;nums[child])<span class=\"comment\">//注意 parent&gt;=0 不是&gt;0</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(nums[parent],nums[child]);</span><br><span class=\"line\">                <span class=\"comment\">//递归往上更新</span></span><br><span class=\"line\">                child=parent;</span><br><span class=\"line\">                parent=(parent<span class=\"number\">-1</span>)/<span class=\"number\">2</span>; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reBuildHeap</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums,<span class=\"keyword\">int</span> root,<span class=\"keyword\">int</span> end)</span><span class=\"comment\">//弹出根后 重新整理 heap,end 为尾后</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left=<span class=\"number\">2</span>*root+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right=left+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> max=left;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(right&lt;=end &amp;&amp; nums[right]&gt;nums[left])</span><br><span class=\"line\">            max=right;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left&lt;=end &amp;&amp; nums[max]&gt;nums[root])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(nums[max],nums[root]);</span><br><span class=\"line\">            <span class=\"built_in\">reBuildHeap</span>(nums,max,end);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"性能分析-1\">性能分析</h2>\r\n<ul>\r\n<li>不稳定，构建堆和重建堆难以控制交换</li>\r\n<li>时间复杂度 O(nlog n), 构建堆和重建堆时，每个元素都需要经历等于\r\n<strong>O(log n) 层数</strong> 的比较，因此所有元素的代价是 O(nlog\r\nn)。</li>\r\n<li>空间复杂度使用原数组构建堆时，O(1)。</li>\r\n</ul>\r\n<h1 id=\"冒泡排序\">冒泡排序</h1>\r\n<h2 id=\"原理-2\">原理</h2>\r\n<p>第 n 轮遍历，找出一个第 n 大，放在最后或最前，这样 n-1\r\n轮下来即全部排好</p>\r\n<h2 id=\"算法流程-2\">算法流程</h2>\r\n<ol type=\"1\">\r\n<li><p>外层循环控制冒泡轮数</p></li>\r\n<li><p>内层循环为每次遍历，假如当前的比后一个大，则交换，最终一轮走下来会冒泡出最大的一个。</p></li>\r\n</ol>\r\n<h2 id=\"示例代码-2\">示例代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">sortArray</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length=nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=length<span class=\"number\">-1</span>;i&gt;<span class=\"number\">0</span>;i--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;i;j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[j]&gt;nums[j+<span class=\"number\">1</span>])</span><br><span class=\"line\">                    <span class=\"built_in\">swap</span>(nums[j],nums[j+<span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"性能分析-2\">性能分析</h2>\r\n<ul>\r\n<li>稳定，不需要交换 等值数</li>\r\n<li>时间复杂度 O(n^2), 冒泡轮数固定，冒泡时比较次数也固定，因此\r\nT(n)=n+n-1+...1=(1+n)*n/2=O(n)</li>\r\n<li>空间复杂度 O(1), 不需要额外空间</li>\r\n</ul>\r\n<h1 id=\"箱子排序桶排序\">箱子排序/桶排序</h1>\r\n<h2 id=\"原理-3\">原理</h2>\r\n<p>将待排序数按数值区间或什么规则，划分成 N 类，准备好 N\r\n个链表，将相应类的数接在相应的链表后面。</p>\r\n<p>然后对每个链表内部进行排序。</p>\r\n<p>最后把所有链表按类别顺序连接起来，或者重新填入原数组即可。</p>\r\n<h2 id=\"算法流程-3\">算法流程</h2>\r\n<ol type=\"1\">\r\n<li><p>按规则划分成 N 类，通常按取值范围划分。</p></li>\r\n<li><p>创建 N 个链表</p></li>\r\n<li><p>遍历输入数值，将所有元素放入相应的链表</p></li>\r\n<li><p>对桶内进行排序，可随意采用排序方法。</p></li>\r\n<li><p>将结果放回原数组，或者连接所有的链表并返回链表结果。</p></li>\r\n</ol>\r\n<h2 id=\"示例代码-3\">示例代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">bucketSort</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bucketSize=<span class=\"number\">100</span>; <span class=\"comment\">//桶大小</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> min_num=max_num=nums[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//找到数值范围</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> num:nums)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        min_num=<span class=\"built_in\">min</span>(min_num,num);</span><br><span class=\"line\">        max_num=<span class=\"built_in\">max</span>(max_num,num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//初始化桶</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> Count=(max_num-min_num+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bucketCount;<span class=\"comment\">//桶数量</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Count%bucketSize==<span class=\"number\">0</span>)<span class=\"comment\">//整除</span></span><br><span class=\"line\">        bucketCount=Count/bucketSize;</span><br><span class=\"line\">    <span class=\"keyword\">else</span><span class=\"comment\">//非整除</span></span><br><span class=\"line\">        bucketCount=Count/bucketSize+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;<span class=\"keyword\">int</span>&gt;[] buckets=<span class=\"keyword\">new</span> List[bucketCount];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//元素放入 List</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> num: nums)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index=(num-min)/bucketSize;<span class=\"comment\">//放入到 index 里</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(buckets[index]==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            buckets[index]=<span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        buckets[index].<span class=\"built_in\">add</span>(num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> length=nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//将元素放回原数组</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;length)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> bucket:buckets)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(bucket==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">//桶内部任意方法排序</span></span><br><span class=\"line\">                <span class=\"built_in\">sort</span>(bucket);</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> num : bucket)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    nums[i]=num;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"性能分析-3\">性能分析</h2>\r\n<ul>\r\n<li><p>稳定，按原顺序插入桶，不会改变同值数的顺序</p></li>\r\n<li><p>空间复杂度 O(n+k),n 个链表节点存放元素，k 个桶</p></li>\r\n<li><p>时间复杂度 O(n), 确定桶数量 O(n), 分类 O(n), 放回\r\nO(n)。（没考虑内部排序时间）</p></li>\r\n</ul>\r\n<h1 id=\"推荐资料\">推荐资料</h1>\r\n<p><a\r\nhref=\"https://leetcode-cn.com/problems/sort-an-array/solution/shi-er-chong-pai-xu-suan-fa-bao-ni-man-yi-dai-gift/\">十二种排序算法包你满意（带\r\nGIF 图解）</a></p>\r\n<p>《算法导论》</p>\r\n","categories":["算法"],"tags":["排序","算法"]},{"title":"数据结构基础题","url":"/2020/08/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E9%A2%98/","content":"<h1 id=\"数组相关算法\">数组相关算法</h1>\r\n<h2 id=\"查找两个升序数组的中位数\">查找两个升序数组的中位数</h2>\r\n<p><a\r\nhref=\"https://alobal.github.io/2020/02/17/LeetCode-No-4-/\">之前的题解分析</a></p>\r\n<p>遍历找第 k\r\n个数肯定是不行的。确定中位数，即变相要同时划分两个数组，左边所有数小于右边所有数，且数量关系要保持好，这样划分的边界即是中位数。</p>\r\n<p>划分点的确定可用二分查找，时间 O（log n）。</p>\r\n<h2 id=\"找数组中的众数\">找数组中的众数</h2>\r\n<p>排序直接定位数组一半的位置，时间 O（nlogn）。</p>\r\n<p><a\r\nhref=\"https://alobal.github.io/2020/07/20/LeetCode-%E5%89%91%E6%8C%87Offer-No-39/\">两两抵消算法</a>，时间\r\nO（n）</p>\r\n<h1 id=\"链表相关算法\">链表相关算法</h1>\r\n<h2 id=\"判断链表是否有环\">判断链表是否有环</h2>\r\n<p><strong>双指针</strong>————假如有环，快指针将迟早能和慢指针相遇</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode *head)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span> || head-&gt;next==<span class=\"literal\">NULL</span>)<span class=\"comment\">//空链表或单结点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode* fast=head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//快慢指针移动</span></span><br><span class=\"line\">        fast=fast-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fast!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            fast=fast-&gt;next;</span><br><span class=\"line\">        head=head-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//检查移动后是否相遇</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fast==head)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"寻找链表环的入口\">寻找链表环的入口</h2>\r\n<p><a\r\nhref=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/c-shuang-zhi-zhen-z-by-zrita/\">参考题解</a></p>\r\n<p><strong>双指针</strong>————同上方法等待快慢指针相遇。</p>\r\n<h3 id=\"第一次相遇时\">第一次相遇时：</h3>\r\n<ul>\r\n<li>环外距离 out</li>\r\n<li>环内距离 in</li>\r\n<li>环长 circle</li>\r\n<li>慢指针走过的距离：<code>len_s=out+in</code></li>\r\n<li>快指针走过的距离：<code>len_f= out+in+n*circle</code></li>\r\n</ul>\r\n<p>因为<code>len_f=2*len_s</code>\r\n推导出=》<code>len_s=n * circle</code></p>\r\n<p>此时把快指针置零，我们准备再让他俩走一遍直到相遇。</p>\r\n<h3 id=\"第二次相遇时\">第二次相遇时：</h3>\r\n<p>设快指针走了x步相遇 此时大家走过的总距离如下：</p>\r\n<ul>\r\n<li>快指针走过的距离：<code>len_f=x</code></li>\r\n<li>慢指针走过的距离：<code>len_s=x+n*circle</code></li>\r\n</ul>\r\n<p>可以发现，当快指针刚到环入口，即x=out的时候： -\r\n快指针走过的距离：<code>len_f=out</code> -\r\n慢指针走过的距离：<code>len_s=out+n*circle</code></p>\r\n<p>慢指针也恰好在环入口，只不过多走了n圈而已。</p>\r\n<p>此时他俩停留的地方即是环入口。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">detectCycle</span><span class=\"params\">(ListNode *head)</span> </span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">       ListNode* fast=head,*slow=head;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(fast==<span class=\"literal\">NULL</span> || fast-&gt;next==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">       <span class=\"keyword\">while</span>(fast &amp;&amp; fast-&gt;next)<span class=\"comment\">//第一次相遇</span></span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           fast=fast-&gt;next-&gt;next;</span><br><span class=\"line\">           slow=slow-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(fast==slow)</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(fast!=slow)<span class=\"comment\">//无环</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//有环</span></span><br><span class=\"line\">       fast=head;</span><br><span class=\"line\">       <span class=\"keyword\">while</span>(fast!=slow)<span class=\"comment\">//第二次相遇</span></span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           fast=fast-&gt;next;</span><br><span class=\"line\">           slow=slow-&gt;next;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"翻转链表\">翻转链表</h2>\r\n<p>不断将 head 后一个移到头部去。</p>\r\n<p>利用一个 root 维护头部</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ListNode* root=<span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    root-&gt;next=head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(head &amp;&amp; head-&gt;next)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ListNode* temp=head-&gt;next;<span class=\"comment\">//[1,2,3] </span></span><br><span class=\"line\">        head-&gt;next=temp-&gt;next;<span class=\"comment\">//1 接上 2 的后续</span></span><br><span class=\"line\"></span><br><span class=\"line\">        temp-&gt;next=root-&gt;next;<span class=\"comment\">//2 连上 头结点</span></span><br><span class=\"line\">        root-&gt;next=temp;<span class=\"comment\">//2 作为新的头结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"相交链表\">相交链表</h2>\r\n<p>找出两个链表的交点并返回</p>\r\n<p>容易知道用存储 map 做，但是需要较大存储空间</p>\r\n<p>假设： - 链表 A 长度为 a，独有部分长度为 c。 - 链表 B 长度为\r\nb，独有部分长度为 d。</p>\r\n<p>可以知道<code>a-c=b-d</code>，变换一下则是<code>a+d=b+c</code>。</p>\r\n<p>即一个指针走完 A，再去走 B 的独有部分，和另一个指针走完 B，再去走 A\r\n的独有部分，所需步数是相同的。</p>\r\n<p>换句话说，两个指针同时开始走，走到 NULL\r\n就切换到隔壁链表上走，此时两个指针对于交点是同距离的。</p>\r\n<p>继续同步走，双指针必然同时遇到交点，一直走到 NULL\r\n还没同时遇到则不存在交点。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ListNode* rootA=headA,*rootB=headB;</span><br><span class=\"line\">    <span class=\"comment\">//注意移动和跳转的顺序 是先跳到 root 再移动？还是用跳跃取代移动？</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(headA!=headB)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(headA==<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">            headA=rootB;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            headA=headA-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(headB==<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">            headB=rootA;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            headB=headB-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(headA==headB)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> headA;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"栈相关算法\">栈相关算法</h1>\r\n<h2 id=\"最小栈的实现\"><a\r\nhref=\"https://leetcode-cn.com/problems/min-stack/\">最小栈的实现</a></h2>\r\n<p>需要实现一个能随时获取<strong>当前</strong>最小元素的栈。</p>\r\n<h3 id=\"题解思路\">题解思路</h3>\r\n<p>一开始想的是维护一个 int min，但是次小值之类的是无法维护的。</p>\r\n<p>首先我们来看看当前最小值是怎么更新的，假设当前最小值是 min_cur： -\r\n入栈一个比它大的值，那么此时栈当前最小不变。 -\r\n在它上面的比它大的元素出栈，反正没 min_cur\r\n小，因此出了也不影响栈当前最小=min_cur。 -\r\n入栈一个比它小的值，那么栈当前最小更新到新值 min_new。而且在 min_new\r\n上面的情景和 min_cur 一样，不用考虑了。 - 出栈 min_new，则最小值由\r\nmin_new 往下的接管，而我们直到 min_new 往下之前一直是 min_cur\r\n管着最小值，因此又回到了 min_cur。</p>\r\n<p>即核心操作是，判断当前入出栈的元素是不是比之前的最小值小。且最小值的更新有着后进先出的特性，后面更新的最小值，必然也会先被出栈，然后返回上一个最小值，因此考虑使用一个<strong>辅助栈</strong>。</p>\r\n<p>辅助栈，存放有史以来的最小值记录，栈顶即当前状态最小值。假设当前最小值是\r\nmin_cur： -\r\n主栈入栈的元素比最小值大时，辅助栈保存的最小值保持不变，重复入栈一个\r\nmin_cur。 - 较小时，更新当前最小值，入栈一个 min_new。 -\r\n出栈时，辅助栈跟随主栈相应出栈。</p>\r\n<h2 id=\"每日温度单调栈\"><a\r\nhref=\"https://leetcode-cn.com/leetbook/read/queue-stack/genw3/\">每日温度</a>——单调栈</h2>\r\n<p>请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0\r\n来代替。</p>\r\n<p>气温列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在\r\n[30, 100] 范围内的整数。</p>\r\n<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76,\r\n73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>\r\n<h3 id=\"题解思路-1\">题解思路</h3>\r\n<p>有点类似接雨水的题目，要在一系列顺序高度中，找到一个凹区间。且易知较矮的凹区间，必然包含在较高的凹区间内（最外层区间除外）。</p>\r\n<p>换句话说，假如有 temperatures[i],temperatures[i+1] 两个气温： -\r\ntemperatures[i+1] &gt; temperatures[i]，则 i+1 就是 i 的新高温 -\r\ntemperatures[i+1] &lt; temperatures[i]，则 i+1 的新高温肯定比 i\r\n的新高温更先出现，即有点后进先出的特性，考虑用栈。</p>\r\n<p>遍历 temperatures，并且维护一个栈： -\r\n如果当前元素比栈顶元素小，那么它的新高温肯定比栈顶元素先出现，因此压入栈顶。\r\n-\r\n如果当前元素比栈顶元素大，那么它可以作为栈顶元素的新高温，并且也可能是栈顶往下的元素的新高温，保持出栈，直到比当前栈顶元素小。</p>\r\n<h3 id=\"题解代码\">题解代码</h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dailyTemperatures</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; T)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        stack&lt;<span class=\"keyword\">int</span>&gt; lower;<span class=\"comment\">//保存的是下标而不是值，便于下标相减</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">result</span><span class=\"params\">(T.size(),<span class=\"number\">0</span>)</span></span>;<span class=\"comment\">//结果数组</span></span><br><span class=\"line\">        lower.<span class=\"built_in\">push</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;T.<span class=\"built_in\">size</span>();i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!lower.<span class=\"built_in\">empty</span>() &amp;&amp; T[i]&gt;T[lower.<span class=\"built_in\">top</span>()])<span class=\"comment\">//把所有比它小的出栈，并且计算差值</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result[lower.<span class=\"built_in\">top</span>()]=i-lower.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">                lower.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            lower.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"栈模拟队列\">栈模拟队列</h2>\r\n<p>栈后进先出，队列先进先出，容易想到通过两个栈的负负得正实现。假设有\r\nS1，S2 两个栈。 S1 用来入队，S2 用来出队。</p>\r\n<h3 id=\"双栈负负得正\">双栈负负得正</h3>\r\n<p>出栈时，先把原 S1 栈里所有元素倒进另一个栈 S2，这样队首是在 S2\r\n的顶部，即可出栈队首元素。</p>\r\n<p>入栈时，则再把 S2 这些元素倒回去，此时队尾在 S1\r\n的顶部，把元素压入即可。</p>\r\n<h3 id=\"优化\">优化</h3>\r\n<p>考虑到，入栈时把 S2 元素倒回 S1\r\n挺浪费效率的，因为出栈时又得倒过来。</p>\r\n<p>而且值得注意的是，S2 元素倒给 S1，S1 压入 N 个元素，再全部倒回 S2，原\r\nS2 元素还是在 S2 的顶部，即压入对其出队不产生影响。因此每次将 S1\r\n的元素倒给 S2 后，就不必要再拿回来了。S1 该压栈压栈，S2 该出栈出栈，S2\r\n空了再把 S1 现有元素全部倒过去。</p>\r\n<h2 id=\"中缀运算表达式转后缀表达式\">中缀运算表达式转后缀表达式</h2>\r\n<p>准备两个栈，一个运算数栈，一个运算符栈。</p>\r\n<p>从左到右依次扫描中缀表达式每个元素：</p>\r\n<ol type=\"1\">\r\n<li>如果是'('，则入栈。</li>\r\n<li>如果是')', 则持续出栈运算，直到出了一个'('。</li>\r\n<li>是其他运算符，如果比栈顶运算符优先级高，压栈。如果比栈顶优先级低，则先出栈运算，再比较新的栈顶。</li>\r\n</ol>\r\n<p>出栈运算：出栈一个运算符和两个运算数进行运算，把运算结果压回运算数栈。</p>\r\n<h1 id=\"队列相关算法\">队列相关算法</h1>\r\n<h2 id=\"树层次遍历典型-bfs\">树层次遍历——典型 BFS</h2>\r\n<p>先将 Root\r\n入队，之后每出队一个结点，则同时把其孩子结点入队。因为先进先出的特性，下一层的结点必然会在这一层结点之后遍历，即实现了层次遍历。</p>\r\n<p>可以考虑在每层开始时，记录一个 queue.size(),\r\n此时可以获得当前层长度，可用于进行每层的输出分割。</p>\r\n<h2 id=\"打开轮盘锁可优化成双向-bfs\"><a\r\nhref=\"https://leetcode-cn.com/problems/open-the-lock\">打开轮盘锁——可优化成双向\r\nBFS</a></h2>\r\n<p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有 10 个数字： '0', '1',\r\n'2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把\r\n'9' 变为  '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。</p>\r\n<p>锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。</p>\r\n<p>列表 deadends\r\n包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>\r\n<p>字符串 target\r\n代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回\r\n-1。</p>\r\n<h3 id=\"基础-bfs-解法\">基础 BFS 解法</h3>\r\n<p>每个位置有两个滚动方向，四个位置即每个状态可以有 2*4=8\r\n个移动方向。我们要最短次数到达\r\ntarget，即完成一个最短路径搜索问题。容易想到就是 BFS 了。</p>\r\n<p>BFS 需要注意几个点： - 因为位置可以往回滚动，要限制不能走回头路，利用\r\nset 判重。 - 需要记录层次深度，考虑队列添加 null\r\n结点或者记录当前层次大小的办法。 - 当前状态滚动到 target\r\n状态是有趋向的，因此可以考虑通过每个位置的距离决定应该优先朝上还是朝下滚，当然由于\r\ndeadends 的存在，不能只滚优先的那边。</p>\r\n<h3 id=\"双向-bfs-解法\">双向 BFS 解法</h3>\r\n<p>由于单向 BFS\r\n是金字塔结构，越往里每个层次的数越来越多，甚至是指数级增长，搜索难度越来越大。末端每增加一个层次的搜索开销，是前期层次开销的指数倍。</p>\r\n<p>因此考虑从起点和 target 点两端同时\r\nBFS，即多进行前期层次的搜索，减少后期末端层次的搜索。相对而言即是用倍数级开销替代了指数级开销。</p>\r\n<p>双向 BFS 注意： - 搜索终点是两个 BFS 相交，因此要使用 set\r\n进行交集判断。</p>\r\n","categories":["算法"],"tags":["数组","链表"]},{"title":"数据集","url":"/2021/12/09/%E6%95%B0%E6%8D%AE%E9%9B%86/","content":"<h3 id=\"ntu-rgbd-60120\">NTU RGB+D 60/120</h3>\r\n<p>56880/114480个深度视频序列，60/120种动作，最大的人类动作数据集之一。</p>\r\n<h3 id=\"nvgesture\">NVGesture</h3>\r\n<p>NVIDIA Dynamic Hand Gesture Dataset</p>\r\n<p>三种格式RGB, depth, IR 的图片。25类的1532个视频</p>\r\n<h3 id=\"shrec17\">SHREC’17</h3>\r\n<p>SHREC’17 Track Dataset 动态手势数据集</p>\r\n<p>14个手势类别的2800个视频。其中手势要么是单指的，要么是整手的。同时也提供了22个手关节的3D坐标，广泛用于基于骨骼的手势识别。</p>\r\n<h3 id=\"msr-action3d\"><a\r\nhref=\"https://sites.google.com/view/wanqingli/data-sets/msr-action3d\">MSR\r\nAction3D</a></h3>\r\n<p>MSR Action3D Dataset</p>\r\n<p>20类，每个类下10个主题。包含了胳膊，腿，躯干，及它们的组合的不同运动。也提供了20个关节位置。</p>\r\n<h3 id=\"upt-time-of-flight-3d-hand-gesture-database\"><a\r\nhref=\"https://www.kaggle.com/cdcaleanu/upt-tof-3d-hand-gesture-database?select=01_amp.bin\">UPT\r\nTime of Flight 3D Hand Gesture Database</a></h3>\r\n<p>Politehnica University的ToF手势数据集</p>\r\n<h3 id=\"s3dis\">S3DIS</h3>\r\n<p>室内场景点云语义分割数据集。</p>\r\n<p>6个区域，271个房间。每个场景有13类点云。</p>\r\n<h3 id=\"n-ucla\">N-UCLA</h3>\r\n<p>小型3D动作识别数据集，10类动作，3个视角</p>\r\n<h3 id=\"uwa3d\">UWA3D</h3>\r\n<p>小型3D动作识别数据集，30类动作。</p>\r\n","categories":["工具"],"tags":["深度学习"]},{"title":"是躁动吧","url":"/2020/09/25/%E6%98%AF%E8%BA%81%E5%8A%A8%E5%90%A7/","content":"<h2 id=\"生活线\">生活线</h2>\r\n<p>　　最近突然变得烦躁了起来。突然意识到自己的机械生活持续了一个月、两个月，像个死人。</p>\r\n<p>　　本来之前还觉得这样早出晚归，每天不停地学不停地复习的生活还算充实，不会感到迷茫或者飘渺无聊。但最近不知道是啥拉动了我的脑神经，突然发现这一切好机械化啊。6：30\r\n起，吃饭背单词到 8：00\r\n等图书馆开门。然后学、吃饭、学、吃饭、学。忙碌是忙碌了，活得也像个齿轮了，每天唯一的新鲜感大概仅在于闭馆之后选择买啥夜宵吃。</p>\r\n<p>　　大概有点类似于【完形崩坏/语义饱和】？</p>\r\n<blockquote>\r\n<p>　语义饱和（英语：semantic\r\nsatiation），又称字形饱和、完形崩坏（日语：ゲシュタルト崩壊，德语：Gestaltzerfall），是一种心理学现象，指的是人在重复盯着一个字或者一个单词长时间后，会发生突然不认识该字或者单词的情况。此过程仅为暂时，心理学上认为其原因是人的大脑神经如果短时间内接收到太多重复的刺激，就会引起神经活动的抑制，造成对常用字突然不认识的现象。——维基百科</p>\r\n</blockquote>\r\n<p>　　重复久了，整个生活轨迹突然就变得被我排斥拒绝。上一次这么机械还是在高三，不过那时候是整个班一起学，每天虽然轨迹差不多，但看着憨憨们的日常也还是挺多样化的。考研好像就完全不一样，全程是自己一个人为了不知道什么在努力。每天来到图书馆学自己的，学完自己走，下一天。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"考研\">考研</h2>\r\n<p>　　考研的目标也完全不清晰，不像高中三年以来，大大小小的考试联考月考摸底，早就知道自己水平，虽然最后考的是真的差，大概也能无所谓地接受。考研复习了两个月左右，完全不清楚自己能做到什么程度，不知道自己比起竞争者有什么优势，只是拼命的赶啊赶。本来就时间紧张的考研，我还是从\r\n8 月份开始复习，也不知道我到底有什么勇气拿 4\r\n个月的努力挑战别人一年的沉淀：）</p>\r\n<p>　　更紧张的来了，9 月份招生简章大概出来之后，专业课改成 408\r\n真的很烦啊。本来就只有四个月时间，想着同专业优势可以少放点时间在专业课上，好好把其他的补一补，说不定还有希望\r\n... 突然改成 408，还有三个月的时间，408 的 1200\r\n页四本专业课哈哈哈哈哈靠。不怂，学嘛。做了下英语二真题，可能是 10\r\n年的卷子比较简单吧，暂时把英语废弃了，于是把以前每天上午翻译《卫报》的时间和晚上时间都拿去赶专业课，也不敢再在博客上敲笔记了=。=本来腾时间给其他科目的一夜之间变成抢其他科目的时间，有点意思。定的计划是最慢\r\n7 天过一本专业课，一天至少 50 页。还好，对我来说最难受的计组在 6\r\n天结束了，后续的计网和操作系统相对来说进展应该可以更顺畅一些，剩下的就是看我脑子能记多久了。</p>\r\n<p>　　剩下的问题就是摸底了。真的很想知道自己目前的水平，但又完全测不了。一轮最快也要下周末结束。即使结束了，政治也明显处于只能做选择题的阶段，分析题不背书根本不知道从哪答题。数学，不知道是考研难度如此，还是张宇的强化训练真的很难，几大证明板块推进的真的好吃力，有些题目看着题解觉得这辈子都不可能想得到的好吧。</p>\r\n<p>　　看着考研初始上岸分数要求好像不高的样子320 330 340 ...大概\r\n110+110+60+60 都能够上岸，这种成绩放在高中那是根本难以想象的吧= =\r\n。但从大环境和营销号的渲染下，突然感觉这个分数好像并没有看起来那么简单？？我数学和专业课真的能考110吗？？考110\r\n120 150\r\n到底有多难？？可能是被高中数学带偏了，整张卷子只有6、7道题要做，其他的大概都是送分，130是基本盘了。考研数学从环境上来看好像130已经是天之骄子级别了？哈，突然想到要是一摸底发现自己考研数学连110都考不到，这心理落差估计挺大。更别提目前完全放弃的英语以及第一次学的政治，更加没有任何底气。</p>\r\n<h2 id=\"负责\">负责</h2>\r\n<p>　　但是还是要为自己负责的。大四了已经，大二大三看起来忙忙碌碌，回想起来完全一片空白，没有能力和经历上的提升和丰富，消遣摸鱼一年年就过去了。大四上半学期秋招和考研的选择，最终决定投入在考研上，毕竟还是觉得本科懂得东西太少了，还是想再多学两年专业领域知识。当然这样失去的自然就是对就业开发技术的锻炼了。</p>\r\n<blockquote>\r\n<p>　四个月投入在提升开发技术上应该会有很明显的回报吧，而不是像考研一样石沉大海（笑。</p>\r\n</blockquote>\r\n<p>　　不过给自己说了考研那不管怎样一定会考下去，自己的承诺吧。其实也有想过考研失败了怎么办，失去了四个月的技术提升，剩下几个月要在毕设的时间压缩下准备更严苛的春招\r\n...\r\n也没什么好多愁善感的好像，做一件事患得患失挺烦的，到了那个地步再说。</p>\r\n<p>　　躁动归躁动，但down是不可能的，哀怨也绝对不是我。烦躁完了该捡起来的责任还是得扛着。</p>\r\n<p>　　一直以来的风格是做了再说，结果就不关我事了，留给未来的我承担起自己所作所为吧。</p>\r\n<p>　　都是为了自己，没有失败。给自己点一首《Somnus》——Final Fantasy\r\nXV</p>\r\n<p>　　吐槽完毕，滚去学习。</p>\r\n","categories":["生活"]},{"title":"本科生实训点云处理","url":"/2021/11/30/%E6%9C%AC%E7%A7%91%E7%94%9F%E5%AE%9E%E8%AE%AD%E7%82%B9%E4%BA%91%E5%A4%84%E7%90%86/","content":"<p>以点云为主体，提供两个方向自由选择：</p>\r\n<ul>\r\n<li>传统图形学点云处理</li>\r\n<li>深度学习下的点云处理</li>\r\n</ul>\r\n<blockquote>\r\n<p>点云，三维空间中的数据，例如二维空间下的数据是由像素组成的图像，三维空间下的数据就是由空间中的点组成的点云。</p>\r\n</blockquote>\r\n<h1 id=\"传统点云处理\">传统点云处理</h1>\r\n<p>根据点云处理库的教程学习实现以下任务</p>\r\n<ul>\r\n<li>可视化点云</li>\r\n<li>点云体素下采样</li>\r\n<li>点云滤波</li>\r\n<li>点云变换</li>\r\n<li>顶点法向估计</li>\r\n<li>点云表面重建</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<figure>\r\n<img src=\"https://i.imgur.com/66ncKvd.png\" alt=\"可视化点云\" />\r\n<figcaption aria-hidden=\"true\">可视化点云</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/XE2M5pM.png\" alt=\"体素下采样\" />\r\n<figcaption aria-hidden=\"true\">体素下采样</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/9Z318Q8.png\" alt=\"点云表面重建\" />\r\n<figcaption aria-hidden=\"true\">点云表面重建</figcaption>\r\n</figure>\r\n<h2 id=\"open3d-intel-2018\">Open3D [Intel 2018]</h2>\r\n<p>Intel 2018年提出的现代化的3D点云处理工具库。</p>\r\n<p><a\r\nhref=\"http://www.open3d.org/docs/release/introduction.html\">文档</a></p>\r\n<p>特性：</p>\r\n<ul>\r\n<li>支持Python，配置容易上手简单。也支持C++</li>\r\n<li>英文文档教程</li>\r\n<li>支持机器学习 TensorFlow 和 PyTorch</li>\r\n</ul>\r\n<h1 id=\"pcl\">PCL</h1>\r\n<p>老牌传统点云处理库</p>\r\n<p><a href=\"https://pointclouds.org/documentation/\">API文档</a>,<a\r\nhref=\"https://pcl.readthedocs.io/projects/tutorials/en/master/#\">教程</a>,<a\r\nhref=\"https://zhuanlan.zhihu.com/p/268524083\">PCL学习指南&amp;资料推荐（2021版）</a></p>\r\n<p>特性：</p>\r\n<ul>\r\n<li>仅支持C++，配置使用更繁杂</li>\r\n<li>发展久，点云算法涵盖更大更全，教程更加细致也更繁杂，网络资料也更容易找</li>\r\n</ul>\r\n<h1 id=\"点云深度学习\">点云深度学习</h1>\r\n<p>使用计图Jittor框架，了解深度学习基础，最后实现几个点云深度学习模型的实验,进行点云的分割、识别、处理等。</p>\r\n<h2 id=\"计图\">计图</h2>\r\n<p><a href=\"https://cg.cs.tsinghua.edu.cn/jittor/\">官网</a></p>\r\n<p><strong>清华开源机器学习框架——计图（Jittor）</strong>：动态编译,内部使用创新的元算子和统一计算图的深度学习框架，\r\n元算子和Numpy一样易于使用，并且超越Numpy能够实现更复杂更高效的操作。而统一计算图则是融合了静态计算图和动态计算图的诸多优点，在易于使用的同时，提供高性能的优化。</p>\r\n<p>前端语言为Python，类似于PyTorch。后端自动使用CUDA、CPU、GPU。平台：</p>\r\n<ul>\r\n<li>Linux(主要)</li>\r\n<li>Mac</li>\r\n<li>Windows(Beta，不稳定)</li>\r\n</ul>\r\n<p><strong>计图库支持的点云深度学习模型</strong>：</p>\r\n<ul>\r\n<li>PointNet</li>\r\n<li>PointNet++</li>\r\n<li>PointCNN</li>\r\n<li>DGCNN</li>\r\n<li>PointConv</li>\r\n</ul>\r\n<p>计图官网教程不多，需要自己主动找一些论文或者其他教程资料进行补充。</p>\r\n<figure>\r\n<img src=\"http://stanford.edu/~rqi/pointnet/images/teaser.jpg\"\r\nalt=\"PointNet的点云分类和分割\" />\r\n<figcaption aria-hidden=\"true\">PointNet的点云分类和分割</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"http://web.engr.oregonstate.edu/~wuwen/SegExp.png\"\r\nalt=\"PointConv点云分割\" />\r\n<figcaption aria-hidden=\"true\">PointConv点云分割</figcaption>\r\n</figure>\r\n","tags":["点云"]},{"title":"注意力机制","url":"/2021/12/21/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/","content":"<p>注意力机制三个核心要素：</p>\r\n<ul>\r\n<li>Query：即主动注意力。</li>\r\n<li>key：突出性的环境带给人的被动注意力</li>\r\n<li>value：注意力汇聚之后得到的最终输入</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://i.imgur.com/2ZgOmGZ.png\"\r\nalt=\"通过注意力汇聚将query和key结合在一起，然后对value进行选择输出\" />\r\n<figcaption\r\naria-hidden=\"true\">通过注意力汇聚将query和key结合在一起，然后对value进行选择输出</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h1 id=\"注意力本质是一种加权平均\">注意力——本质是一种加权平均</h1>\r\n<p>假设有<span class=\"math inline\">\\([(x_i,y_i), ...\r\n,(x_j,y_j)]\\)</span> 一系列配对输入，对于一个新的 <span\r\nclass=\"math inline\">\\(x\\)</span> ，我们想要预测它的 <span\r\nclass=\"math inline\">\\(y\\)</span>\r\n。此时我们会想参考过往的所有配对情况，来试着加权平均出这个 <span\r\nclass=\"math inline\">\\(y\\)</span>，例如我们可以平等对待所有过往经验：</p>\r\n<p><span class=\"math display\">\\[\r\nf(x)=\\frac{1}{n}\\sum_{i=1}^{n} y_{i}\r\n\\]</span></p>\r\n<p>显然这样是不准确的，对于任意输入<span\r\nclass=\"math inline\">\\(x\\)</span>都会得到同样的结果。因此我们还需要考虑<span\r\nclass=\"math inline\">\\(x\\)</span>的影响。继续直观地想，我们可以考虑<span\r\nclass=\"math inline\">\\(x\\)</span>与哪一个<span\r\nclass=\"math inline\">\\(x_i\\)</span>更接近，那么<span\r\nclass=\"math inline\">\\(y\\)</span>给到<span\r\nclass=\"math inline\">\\(y_i\\)</span>的权重也应该更大一些：</p>\r\n<p><span class=\"math display\">\\[\r\nf(x)=\\sum_{i=1}^{n} \\frac{K\\left(x-x_{i}\\right)}{\\sum_{j=1}^{n}\r\nK\\left(x-x_{j}\\right)} y_{i}=\\sum_{i=1}^{n} \\alpha\\left(x, x_{i}\\right)\r\ny_{i}\r\n\\]</span></p>\r\n<p>其中<span class=\"math inline\">\\(K\\)</span>是一种核函数，来表示<span\r\nclass=\"math inline\">\\(x_i\\)</span>与<span\r\nclass=\"math inline\">\\(x\\)</span>的权重关系，分母是权重和（即对于<span\r\nclass=\"math inline\">\\(x\\)</span>来说的固定值）。缩写之后得到<span\r\nclass=\"math inline\">\\(\\alpha(x,x_i)\\)</span>，即表示所谓的<strong>注意力权重</strong>，其累积和为1。回到注意力框架中，<span\r\nclass=\"math inline\">\\(x\\)</span>即是query,(x_i,y_i)即是(key,value)。<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>对<span\r\nclass=\"math inline\">\\(y_i\\)</span>的加权即是注意力汇聚，注意力权重即query和key的关系度量。</p>\r\n<p>对于核函数<span class=\"math inline\">\\(K\\)</span>，如果<span\r\nclass=\"math inline\">\\(K\\)</span>中计算函数固定，这样得到的就是<strong>非参数的注意力汇聚</strong>。如果<span\r\nclass=\"math inline\">\\(K\\)</span>中带有一些可变可学习的参数<span\r\nclass=\"math inline\">\\(w\\)</span>，那么得到的就是\r\n<strong>带参数的注意力汇聚</strong>。</p>\r\n<p>有了核函数以及加权平均的概念，此时就可以来看更细致的注意力机制：</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/Neqky4S.png\" alt=\"注意力机制的详细结构\" />\r\n<figcaption aria-hidden=\"true\">注意力机制的详细结构</figcaption>\r\n</figure>\r\n<p>其中核函数的单项计算部分可以看做是注意力评分函数（attention scoring\r\nfunction），核函数的多项累计部分可以看做softmax，转化评分为累计和为1的权重系数。最后与value数组进行加权计算，即是注意力汇聚的过程。</p>\r\n<h2 id=\"评分函数\">评分函数</h2>\r\n<h3 id=\"masked-softmax\">Masked Softmax</h3>\r\n<p>虽然是加权平均，但实际计算中存在很多value不需要进入加权计算。例如文本处理中的填充字符<pad>。因此可以使用一个Mask来过滤掉这些不必要的字符，再进行softmax。实际使用中对于想要去掉的元素，会赋值为一个非常大的负数，这样其softmax输出就是0.</p>\r\n<h3 id=\"additive-attention\">Additive Attention</h3>\r\n<p>当query和key是同样形状的张量时，各种核函数都可以简单的应用。但是query和key是不同长度的时候呢？这时可以使用Additive\r\nAttention作为评分函数，本质上就是通过两个<strong>线性变换层</strong>将它们投影到统一长度空间：</p>\r\n<p><span class=\"math display\">\\[\r\na(\\mathbf{q}, \\mathbf{k})=\\mathbf{w}_{v}^{\\top} \\tanh\r\n\\left(\\mathbf{W}_{q} \\mathbf{q}+\\mathbf{W}_{k} \\mathbf{k}\\right) \\in\r\n\\mathbb{R},\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(\\mathbf{W}_{q} \\in \\mathbb{R}^{h \\times\r\nq} 、 \\mathbf{W}_{k} \\in \\mathbb{R}^{h \\times k}\\)</span> 和 <span\r\nclass=\"math inline\">\\(\\mathbf{w}_{v} \\in \\mathbb{R}^{h}\\)</span>\r\n是用于学习自适应调整的参数。</p>\r\n<h3 id=\"scaled-dot-product-attention\">Scaled Dot-Product Attention</h3>\r\n<p>点积是一种很容易想到的计算query和key距离的方式，而且效率很高。因此结合缩放思想可以构造出方差为1的度量距离方式：</p>\r\n<p><span class=\"math display\">\\[\r\na(\\mathbf{q}, \\mathbf{k})=\\mathbf{q}^{\\top}\\mathbf{k}/\\sqrt{d}\r\n\\]</span></p>\r\n<p>其中<span\r\nclass=\"math inline\">\\(d\\)</span>为向量长度（显然query和key需要相同长度）。当然，为优化性能，实际计算会使用矩阵计算一个批量的点积。</p>\r\n<h2 id=\"编码器-解码器中的注意力机制\">编码器-解码器中的注意力机制</h2>\r\n<p>在编码器-解码器框架中，会将这一批所有的输入做成一个不变的上下文，再通过这个上下文去计算这一批所有的预测。显然<strong>对于某些预测计算来说，可能会与一部分输入毫无关系</strong>，这样粗暴的使用一个统一的上下文并不合理。因此可以想到对每次预测计算，定制一个属于它的上下文，即<strong>基于注意力机制定制上下文</strong>：</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathbf{c}_{t^{\\prime}}=\\sum_{t=1}^{T}\r\n\\alpha\\left(\\mathbf{s}_{t^{\\prime}-1}, \\mathbf{h}_{t}\\right)\r\n\\mathbf{h}_{t}\r\n\\]</span></p>\r\n<p>对于某时刻<span class=\"math inline\">\\(t\\)</span>的预测计算，<span\r\nclass=\"math inline\">\\(s\\)</span>为解码器上一时刻隐状态，<span\r\nclass=\"math inline\">\\(h\\)</span>为编码器该时刻隐状态。将<span\r\nclass=\"math inline\">\\(s\\)</span>视为query，<span\r\nclass=\"math inline\">\\(h\\)</span>视为key，同时也视为value，最终加权得到基于注意力的上下文<span\r\nclass=\"math inline\">\\(c_{t^`}\\)</span>,再与解码器的输入进行连接，送入RNN进行计算：</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/LruLfaD.png\"\r\nalt=\"基于注意力的编码器-解码网络：其中解码器的每一次计算都需要（编码器隐状态，解码器上一时间隐状态），并且这里评分函数使用的是加性注意力。\" />\r\n<figcaption\r\naria-hidden=\"true\">基于注意力的编码器-解码网络：其中解码器的每一次计算都需要（编码器隐状态，解码器上一时间隐状态），并且这里评分函数使用的是加性注意力。</figcaption>\r\n</figure>\r\n<h2 id=\"multihead-attention\">MultiHead Attention</h2>\r\n<p>和多个卷积核学习多种特征一样，我们也可以想到使用多个Attention来学习到多种联系。其中每一个Attention被称作一个Head。而为了实现多个Head学习到不同的联系，需要给它们不完全相同的数据，如使用全连接层进行线性投影，取一部分原数据的子空间给一个Head。当然汇聚不同Head的输出也需要一种连接方式，即也采用一个线性变换将Multi\r\nHead组合起来：</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/JbL6hlb.png\" alt=\"MultiHead Attention\" />\r\n<figcaption aria-hidden=\"true\">MultiHead Attention</figcaption>\r\n</figure>\r\n<p>因此可以容易给出MultiHead Attention的数学模型：给定query <span\r\nclass=\"math inline\">\\(\\mathbf{q} \\in \\mathbb{R}^{d_{q}}\\)</span> 、key\r\n<span class=\"math inline\">\\(\\mathbf{k} \\in \\mathbb{R}^{d_{k}}\\)</span>\r\n和value <span class=\"math inline\">\\(\\mathbf{v} \\in\r\n\\mathbb{R}^{d_{v}}\\)</span>, <span class=\"math inline\">\\(\\quad\r\nf\\)</span> 为注意力汇聚操作，每个Head <span\r\nclass=\"math inline\">\\(\\mathbf{h}_{i}(i=1, \\ldots, h)\\)</span>\r\n的计算方法为:</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathbf{h}_{i}=f\\left(\\mathbf{W}_{i}^{(q)} \\mathbf{q},\r\n\\mathbf{W}_{i}^{(k)} \\mathbf{k}, \\mathbf{W}_{i}^{(v)} \\mathbf{v}\\right)\r\n\\in \\mathbb{R}^{p_{v}}\r\n\\]</span></p>\r\n<h1 id=\"self-attention\">Self-Attention</h1>\r\n<p>顾名思义，就是query，key，value都是同一个序列<span\r\nclass=\"math inline\">\\([x_1,...,x_n]\\)</span>。其输出结果<span\r\nclass=\"math inline\">\\([y_1,...,y_n]\\)</span>为：</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathbf{y}_i = f(\\mathbf{x}_i, (\\mathbf{x}_1, \\mathbf{x}_1), \\ldots,\r\n(\\mathbf{x}_n, \\mathbf{x}_n)) \\in \\mathbb{R}^d\r\n\\]</span></p>\r\n<h1 id=\"注意力和卷积\">注意力和卷积</h1>\r\n<p>从某种直观上来看，卷积的局部加权平均 和\r\n注意力的加权平均(特别是自注意力) 有点相似？</p>\r\n<h1 id=\"推荐资料\">推荐资料</h1>\r\n<p><a href=\"https://jalammar.github.io/illustrated-transformer/\">The\r\nIllustrated Transformer</a></p>\r\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"深度学习在点云分类中的研究综述","url":"/2021/10/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%82%B9%E4%BA%91%E5%88%86%E7%B1%BB%E4%B8%AD%E7%9A%84%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0/","content":"<h1 id=\"背景\">背景</h1>\r\n<h2 id=\"点云特征\">点云特征</h2>\r\n<h3 id=\"无序性\">无序性</h3>\r\n<p>点云数据则是无序点的集合。使用不同的设备和位置获取采集目标，会得到排列顺序千差万别的点云数据。当采用不同顺序读入\r\nn 个点云时，其组合方式就有 n！种。</p>\r\n<p>对不同位置点云进行卷积算，结果会受<strong>点云的输入顺</strong>序的影响。通过对称函数、构造卷积算子或利用图与树的结构为解决点云的无序性做出贡献。</p>\r\n<h3 id=\"稀疏性\">稀疏性</h3>\r\n<p>通过不同方式获取到物体的点云数据在密度、点数以及点间距离都具有一定的差别。三维点云的不规则结构会导致某些区域的过采样和欠采样</p>\r\n<p>因此不同密度的点云的处理是研究点云分类策略的重点之一。在网络中嵌入<strong>密度模块</strong>的方法可以在一定程度上解决点云密度不均的问题。</p>\r\n<h3 id=\"非结构化\">非结构化</h3>\r\n<p>无结构的点云数据直接输入到神经卷积网络模型中往往比较困难。</p>\r\n<p>早期有<strong>体素</strong>方法或者<strong>多视图</strong>方法。但是会增加大量的数据计算。</p>\r\n<p>近年有<strong>图卷积神经网络</strong>处理非结构化数据。如有基于<strong>Reeb图</strong>卷积神经网络聚合点云特征。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"数据集\">数据集</h2>\r\n<ol type=\"1\">\r\n<li>ModelNet：3D CAD模型</li>\r\n<li>ScanNet：RGBD视频，室内场景</li>\r\n<li>ISPRS：城市目标，三维建筑</li>\r\n<li>2019 Data FusionContest Dataset：城市场景</li>\r\n</ol>\r\n<h1 id=\"深度学习点云分类\">深度学习点云分类</h1>\r\n<h2 id=\"基于投影\">基于投影</h2>\r\n<h3 id=\"体素网格\">体素网格</h3>\r\n<p>将环境状态表示为三维网格，借鉴二维图像的相似性。</p>\r\n<ol type=\"1\">\r\n<li>VoxNet：集成了体积网格和3D卷积网络</li>\r\n<li>3D\r\nShapenets：将点云特征表示为体素网格的二进制概率分布，卷积共享权值环节参数过剩。</li>\r\n<li>OctNet、OCNN等：优化体素结构，使用灵活的八叉树结构。</li>\r\n</ol>\r\n<p>体素网格存在丢失重要信息，存储和计算开销大，适用性不高等弊端。</p>\r\n<h3 id=\"多视角\">多视角</h3>\r\n<p>多个视角对点云投影，使用CNN对投影的2D影像进行加工。</p>\r\n<ol type=\"1\">\r\n<li>MVCNN：多视图CNN，将3D渲染成传统图像。将多个视图的特征信息通过卷积层和池化层整合成单一的3D描述符。最后进入全连接层计算。</li>\r\n<li>Qi在MVCNN基础上改进：通过变化仰角和方位角增强训练数据、引入三维滤波捕捉多尺度信息。</li>\r\n<li>GVCNN：对不同视图的视觉描述符分组，学习组间特征生成组级别的描述符，再加权获得3D描述符。</li>\r\n</ol>\r\n<p>在相机设置位置与角度时容易出现遮挡情况，视图不能得到有效处理将直接影响训练结果。3D\r\n到 2D 的转换过程中会造成点云信息的丢失。</p>\r\n<h2 id=\"基于原始点云\">基于原始点云</h2>\r\n<h3 id=\"mlp\">MLP</h3>\r\n<ol type=\"1\">\r\n<li>PointNet：通过MLP学习单个点的特征，利用对称函数编码全局信息<strong>解决无序性问题</strong>。利用空间变换网络STNs<strong>解决点云旋转不变性问题</strong>。对输入点云进行几何变换和特征变换，采用最大池化聚合点特征解决<strong>置换不变性问题</strong>。<br />\r\n缺陷在于只捕捉到单个点和全局点，没有有效的局部特征信息，且没有点的邻近关系。导致对细粒度效果较差。<br />\r\n</li>\r\n<li>PointNet++：引入多层次结构。每一层分为采样层、分组层、特征提取层。解决了局部点云特征的问题，点间联系依然没有充分学习。</li>\r\n<li>Momenet：对点云坐标使用多项式函数提高训练能力，高时效低消耗</li>\r\n<li>So-Net：利用自组织特征映射SOFM分析点云分布，实现置换不变性网络。结构简单、训练速度快。分类效果良好。</li>\r\n<li>SRN、PointWeb：学习点间局部联系。</li>\r\n<li><strong>PointASNL</strong>：自适应采样AS减弱噪声和异常。局部-非局部模块L-NL提供准确稳定的特征信息。</li>\r\n<li>BPS：针对无序性、提出点集概念。将输入点归一化，对一组点随机采样构成点集单元。</li>\r\n</ol>\r\n<h3 id=\"cnn\">CNN</h3>\r\n<ol type=\"1\">\r\n<li>PointCNN：避免点云输入顺序对卷积操作的影响。X-变换卷积算子将数据转换为顺序无关的特征。分类中使用膨胀卷积思想。证实了局部结构对点云的重要性。但变换算子仍效果不够好。</li>\r\n<li>RSCNN：基于几何关系，几何关系编码卷子算子RS-Conv。有良好的目标识别功能。</li>\r\n<li>DANCE-NET：密度感知卷积模块。</li>\r\n</ol>\r\n<h3 id=\"gcn\">GCN</h3>\r\n<ol type=\"1\">\r\n<li>GCN：提取图数据特征，在半监督分类任务中效果良好。</li>\r\n<li>ECC：将点云视作图结构的顶点，聚合顶点信息转换为图结构，但是需要大量计算，不理想。</li>\r\n<li>LDGCNN、PointGNN、PointVGG</li>\r\n</ol>\r\n<h3 id=\"注意力机制\">注意力机制</h3>\r\n<p>具有固定排列、不依赖于点间联系的特性。</p>\r\n<ol type=\"1\">\r\n<li>GAPNet：在MLP层中嵌入图注意力机制学习局域点云语义。<strong>GAPLayer</strong>和<strong>注意力层</strong>可以嵌入到其他模型中以提取局部几何特征。</li>\r\n<li>清华PCT：将点云编码至高维特征空间，经过四层注意力层（自注意力、offset注意力）获取局部几何信息。</li>\r\n</ol>\r\n","categories":["深度学习"],"tags":["点云"]},{"title":"点云序列深度学习","url":"/2022/01/15/%E7%82%B9%E4%BA%91%E5%BA%8F%E5%88%97%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","content":"<h1 id=\"点云数据格式\">点云数据格式</h1>\r\n<p>目前已有的大部分视觉识别工作都是在二维的基础上，而二维图像数据，本质上对环境鲁棒性不强，很容易受到光照等因素的影响。相对来说，三维数据则更好的描述了物体的几何结构信息，而且对环境影响更加鲁棒。</p>\r\n<p>点云是三维传感器的原始数据，同时表示格式简单。如果选择其他三维描述格式可能会损失很多精度，例如图像只能表达一个视角的3D数据。对于Mesh，可能要选择面片类型，面片大小，连接方式。对于网格，要选择网格大小，大了会损失精度。</p>\r\n<p>传统的点云特征都是人对于特定任务进行手工构造的，对于一个新的任务很难去继续使用这样的特征，因此进入到了深度学习时代，希望通过<strong>深度学习自动学习特征</strong>。</p>\r\n<p>点云是一种<strong>不规则</strong>的数据，因此有几种转换点云的方法来深度学习。</p>\r\n<p><strong>栅格化</strong>：的方式来表示点云，然后可以使用3D\r\nCNN[1]来抽取特征。然而有一些很大的缺点：</p>\r\n<ul>\r\n<li>3D CNN\r\n计算量非常大，空间时间复杂度随着分辨率都是三次方增长。因此分辨率提不了多高，一般30x30x30。</li>\r\n<li>量化噪声错误，本质上限制了识别精确度。</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://i.imgur.com/jsKaCiq.png\" alt=\"栅格化点云\" />\r\n<figcaption aria-hidden=\"true\">栅格化点云</figcaption>\r\n</figure>\r\n<p><strong>投影法</strong>：将三维数据投影到二维平面，然后用2DCNN处理[11]，然而如何选择投影的方式，角度，都不是一个简单的问题。同时投影本质上也会丢失一些三维信息。</p>\r\n<p><strong>手工提取点云特征，再简单的应用全连接</strong>：然而这种网络的性能被手工特征的局限给限制住了，而不理想。</p>\r\n<p>近期的趋势则是<strong>直接在点云数据格式上进行深度学习</strong>。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"点云帧内学习\">点云帧内学习</h1>\r\n<h2 id=\"空间邻域聚类\">空间邻域聚类</h2>\r\n<p>点的局部邻域作为一个小整体，可以表达出一些细节上的结构特征。</p>\r\n<p><strong>邻域密度问题</strong>：点云不像图像，图像的邻域都是规则化的，然而点云是离散的，不同区域的点密度完全不一样，而如果采用固定的半径构造邻域则会出现密度问题。PointNet++[3]提出了Multi-scale\r\ngrouping（MSG)，Multi-resolution\r\ngrouping（MRG）两种方法来对自适应密度构造邻域。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/mMZmjdb.png\"\r\nalt=\"点云的邻域密度问题。图源：祁芮中台：点云上的深度学习及其在三维场景理解中的应用\" />\r\n<figcaption\r\naria-hidden=\"true\">点云的邻域密度问题。图源：祁芮中台：点云上的深度学习及其在三维场景理解中的应用</figcaption>\r\n</figure>\r\n<p><strong>抽取邻域特征</strong>：\r\nPointNet缺失对局部邻域特征的学习，PointNet++[3]则加强了这一部分，其在局部点云上使用PointNet来抽取特征，即生成了一个可以代表这个局部的特征点，然后逐级往上进行层级式抽取特征。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/sn94pKw.png\"\r\nalt=\"PointNet++ Hierarchical Point Feature Learning，图源：祁芮中台：点云上的深度学习及其在三维场景理解中的应用\" />\r\n<figcaption aria-hidden=\"true\">PointNet++ Hierarchical Point Feature\r\nLearning，图源：祁芮中台：点云上的深度学习及其在三维场景理解中的应用</figcaption>\r\n</figure>\r\n<h2 id=\"空间维度编码方法\">空间维度编码方法</h2>\r\n<p><strong>Permutation不变性</strong>：静态点云可以看作是一个无序集合。作为集合类型的无序数据，它不能像图像那种规则数据一样，顺序地进行卷积操作，因为点云不同的输入顺序会在传统卷积下产生不同的结果。因此，PointNet[2]提出可以在点云上使用一个<strong>对称函数</strong>操作，即可保持点云的置换不变性。PointNet在实验中表明max\r\npooling是最有效的一种对称函数[2]。</p>\r\n<p><strong>Transform不变性</strong>：点云的平移旋转不应该影响点云的特征学习。PointNet[2]增加了一个数据变换模块T-Net，来自动学习如何将点云对齐。另外PointNet也同时将T-Net应用在特征维度上。</p>\r\n<h1 id=\"点云序列帧间学习\">点云序列帧间学习</h1>\r\n<p>点云序列在时间维度上的学习有两种思路，一种是空间时间串行编码，先对每个帧进行空间编码，再对一系列的帧编码进行序列学习。另一种是空间时间编码并行处理，此时时间编码需要寻找每个点对应的时间邻域，并且在时间邻域上聚合相应的特征信息。</p>\r\n<h2 id=\"搜索时间邻域\">搜索时间邻域</h2>\r\n<p>图像，骨架，网格之类的规则数据，有着序列帧间的对应关系，进而可以轻易地找到跨时间的对应关系。由于点云是不规则数据，直观上不存在帧与帧之间点的对应关系，进而<strong>如何搜索跨时间的邻域</strong>是点云序列学习中一个核心的问题。</p>\r\n<p>一种直觉的思路是<strong>直接搜索Direct grouping</strong>：\r\n<strong>PointLSTM</strong>[5]使用了最简单的Direct\r\ngrouping，其直接在不同的帧中基于同一个坐标点搜索k近邻。<strong>PSTNet</strong>[10]则加强了这一方法，提出\r\n<strong>Point Tube</strong> 。<strong>Point\r\nTube</strong>在前后相邻帧中搜索固定半径<span\r\nclass=\"math inline\">\\(r\\)</span>作为邻域，以形成一个\r\ntube形状的邻域结构。<strong>MeteorNet</strong>[4]提出一种动态搜索半径<span\r\nclass=\"math inline\">\\(r\\)</span>的Direct grouping，主要思想在于\r\n\"时间过得越久，点移动的就越远\"\r\n这一简单的事实，进而去搜索同一个坐标点半径为<span\r\nclass=\"math inline\">\\(R=r(|t^\\prime - t|)\\)</span>\r\n。的邻域。，即搜索半径与跨越的时间帧成正比关系。</p>\r\n<p>第二种思路是\r\n<strong>基于轨迹预测</strong>：由于物体的运动往往有轨迹趋势，因此PointLSTM[5]\r\n提出的 <strong>Aligned grouping</strong>\r\n通过反向流估计，如FlowNet[12]来计算上一帧中的点。\r\nMeteorNet[4]提出的<strong>Chained-flow grouping</strong>\r\n在反向估计的基础上，同时使用真实的过去帧来在一定程度上对更远的估计帧进行正则。然而<strong>如何进行反向流估计也是一个难题</strong>。</p>\r\n<p>另外还可以将<strong>每一帧的点云视为一个整体</strong>，而可以跳过寻找单个点的时间邻域的步骤，如PointLSTM-PSS[5]中即对整个点云编码成一个特征和隐状态。</p>\r\n<h2 id=\"时间维度编码方法\">时间维度编码方法</h2>\r\n<p>虽然基于时间邻域聚类可以聚合一些短期相邻帧的联系，但是其缺乏捕捉长期时间联系的能力。</p>\r\n<p>考虑到RNN和LSTM在序列模型上的大获成功，因此\r\n<strong>PointLSTM</strong>[5]\r\n通过在点云序列上建立LSTM层来获取点云序列的长期联系。考虑到时间聚类问题，PointLSTM建立了两种编码模型：简化版本\r\n<strong>PointLSTM-PSS</strong>\r\n，其跳过了时间聚类问题，将一帧的整个点云视为一个词元进行隐状态的编码，并且进入LSTM层进行更新计算，这种方式简单但是能够取得很不错的效果。完整版本\r\n<strong>PointLSTM</strong>\r\n对一帧内的每个点视为一个词元，具有单独的隐状态和编码。对任意一个点的隐状态计算需要利用到前一帧中该点邻域的所有点，因此计算量较大，但效果超过PointLSTM\r\n0.5~1%。</p>\r\n<p>另一个序列学习上大获成功的模型是Transformer[8]。Transformer的核心self-attention层是一个顺序无关的操作，，因此很适合进入点云领域。<strong>PCT:\r\nPoint cloud transformer</strong>[6] 和 <strong>Point\r\nTransformer</strong> [7] 致力于在点云序列上移植Transformer模型。</p>\r\n<p><strong>PCT</strong>提出 <strong>Naive\r\nPCT</strong>，其对Transformer进行了简单的修改应用。 Naive PCT\r\n将整个点云视为一个句子，将每个点视作一个词元，并且使用了point\r\nembedding和 Self-attention进行学习。由于\r\nself-Attention中Query，Key，Value的计算本身是顺序无关的，且softmax和加权累积也是顺序无关的，因此整个\r\nself-attention 操作是顺序无关的，可以直接用于点云学习。</p>\r\n<p>为避免点云的仿射变换影响，改进版<strong>PCT</strong>提出使用\r\n<strong>Offset-Attention</strong> 来对\r\nself-attention的输出再进一步进行残差编码：<span\r\nclass=\"math inline\">\\(F_{out}=OA(F_{in})=LBR(F_{in}-F_{sa})+F_{in}\\)</span>，并且其评分函数由Scale\r\nSoftmax改成了softmax + l1_norm\r\n以强化注意力权重。另外，和PointNet类似，<strong>Naive PCT</strong>\r\n的point embedding无法进行局部结构的学习，因此\r\n<strong>PCT</strong>还提出了 <strong>neighbor embedding</strong>\r\n来聚合邻域信息，其核心是在embedding空间进行<strong>采样+KNN</strong>的聚类，然后将邻域与中心点的相对特征进行拼接输出。</p>\r\n<p><strong>PointTransformer</strong>和 <strong>PCT</strong>\r\n类似，首先是在注意力计算中增加了一个基于位置差分的<strong>position\r\nencoding</strong> <span\r\nclass=\"math inline\">\\(\\mathbf{y}_{i}=\\sum_{\\mathbf{x}_{j} \\in\r\n\\mathcal{X}(i)}\r\n\\rho\\left(\\gamma\\left(\\varphi\\left(\\mathbf{x}_{i}\\right)-\\psi\\left(\\mathbf{x}_{j}\\right)+\\delta\\right)\\right)\r\n\\odot\\left(\\alpha\\left(\\mathbf{x}_{j}\\right)+\\delta\\right)\\)</span> 。\r\n另外基于残差网络思想， PointTransformer 提出了 <strong>point transformer\r\nblock</strong>来输出每个点的特征向量。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/AMxRPzg.png\"\r\nalt=\"PointTransformer的position encoding\" />\r\n<figcaption aria-hidden=\"true\">PointTransformer的position\r\nencoding</figcaption>\r\n</figure>\r\n<p>SequentialPointNet[9]提出一种 <strong>Temporal position\r\nembedding</strong>，\r\n通过将Transformer[8]的三角函数位置编码应用到点云的时间序列上，然后再通过共享MLP层直接对帧序列进行编码，来形成一种加强时间信息的时间特征放大模块。最终通过\r\n<strong>Hierarchical pyramid maxpooling</strong>\r\n进行一种类似于多卷积核的池化操作来抽取序列特征。</p>\r\n<p>PSTNet[10]通过时间空间计算解耦的想法，提出了 <strong>Point\r\nSpatio-Temporal\r\nConvolutional</strong>(PST卷积)，即完全独立空间卷积核和时间卷积核，使它们互不依赖：</p>\r\n<p><span class=\"math display\">\\[\r\n\\boldsymbol{F}_{t}^{\\prime(x, y, z)}=\\sum_{k=-\\lfloor l /\r\n2\\rfloor}^{\\lfloor l / 2\\rfloor} \\mathbf{T}_{k} \\cdot\r\n\\sum_{\\left\\|\\left(\\delta_{x}, \\delta_{y}, \\delta_{z}\\right)\\right\\|\r\n\\leq r} \\mathbf{S}^{\\left(\\delta_{x}, \\delta_{y}, \\delta_{z}\\right)}\r\n\\cdot \\boldsymbol{F}_{t+k}^{\\left(x+\\delta_{x}, y+\\delta_{y},\r\nz+\\delta_{z}\\right)},\r\n\\]</span></p>\r\n<p>并且由于点云的不规则分布，点云邻域与卷积中心的距离是连续变化的，难以使用传统卷积的权重模块来对这些邻域点进行加权。因此\r\nPSTNet将空间卷积定义为一个关于offset的计算函数 <span\r\nclass=\"math inline\">\\(f\\left(\\left(\\delta_{x}, \\delta_{y},\r\n\\delta_{z}\\right) ; \\boldsymbol{\\theta}\\right)=\\boldsymbol{\\theta}_{d}\r\n\\cdot\\left(\\delta_{x}, \\delta_{y}, \\delta_{z}\\right)^{T} \\cdot 1 \\odot\r\n\\boldsymbol{\\theta}_{s}\\)</span>，以实现对任意offset点的加权操作。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/AfhgtrM.png\" alt=\"Sequential序列编码\" />\r\n<figcaption aria-hidden=\"true\">Sequential序列编码</figcaption>\r\n</figure>\r\n<h1 id=\"骨架序列学习\">骨架序列学习</h1>\r\n<p>在骨架的时空图卷积的基础上，<strong>DDGCN</strong>[13]认为骨架的空间层级结构和动作的时间序列结构都包含了顺序信息，然而大多数ST\r\ngraph都是用了无向图结构，即无视了顺序信息，因此DDGCN提出了<strong>有向图骨架</strong>结构\r\n<strong>Directed Spatial-Temporal Graph (DSTG)</strong>\r\n。通过有向图中父子节点的定义，父节点的动作实际上会影响到子节点的动作，因此DDGCN在有向图的基础上定义了\r\n<strong>bone features</strong> <span\r\nclass=\"math inline\">\\(f_i^B=\\overrightarrow{v_{i-1}v_i}=f_{i-1}-f_i\\)</span>\r\n来表示父子节点的影响特征。\r\n另外针对<strong>图卷积的邻域不确定性</strong>，DDGCN提出 <strong>Dynamic\r\nConvolutional Sampling (DCS)</strong>\r\n来对一个节点的邻居列表进行动态的排序，形成动态邻域关系。然而卷积核的权重是有顺序的，而邻居列表是动态变化的，可能会造成权重分配的错序。因此DDGCN使用了一个\r\n<strong>Dynamic Convolutional Weights (DCW)</strong>\r\n模块来对邻居列表和权重列表进行一个Dynamic Time Warping\r\n(DTW)距离的最小化排序，再根据这个排序进行权重分配。</p>\r\n<p>无论是传统无向图骨架还是有向图骨架，都有着结构上的缺陷。静态的图结构限制了表达动态节点关系的能力，因此\r\n<strong>SkeletonTransformer</strong>[15]完全抛开了传统的静态骨架图结构，而是使用Self-attention来动态查找节点关系。SkeletonTransformer\r\n提出了 <strong>Spatial Self-Attention (SSA)</strong>模块 和\r\n<strong>Temporal Self-Attention (TSA)</strong> 模块。 SSA\r\n模块在一个帧内对所有关节点进行自注意力编码，最终输出一个带有动态节点关系的特征。TSA\r\n模块则是在时间上进行注意力计算，同样去找出动态的帧间关系。最终SkeletonTransformer使用了一个\r\n<strong>Two-Stream Spatial–Temporal Transformer (ST-TR)\r\nNetwork</strong>通过两个并行的运算流来结合两个模块，以得到一个时间空间上信息都很完整，并且不相互依赖的时空特征。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/MYJ50cH.png\" alt=\"SkeletonTransformer\" />\r\n<figcaption aria-hidden=\"true\">SkeletonTransformer</figcaption>\r\n</figure>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[1] Molchanov P, Gupta S, Kim K, et al. Hand gesture recognition with\r\n3D convolutional neural networks[C]//Proceedings of the IEEE conference\r\non computer vision and pattern recognition workshops. 2015: 1-7.</p>\r\n<p>[2] Qi C R, Su H, Mo K, et al. Pointnet: Deep learning on point sets\r\nfor 3d classification and segmentation[C]//Proceedings of the IEEE\r\nconference on computer vision and pattern recognition. 2017:\r\n652-660.</p>\r\n<p>[3] Qi C R, Yi L, Su H, et al. PointNet++: Deep Hierarchical Feature\r\nLearning on Point Sets in a Metric Space[J]. Advances in Neural\r\nInformation Processing Systems, 2017, 30.</p>\r\n<p>[4] Liu X, Yan M, Bohg J. Meteornet: Deep learning on dynamic 3d\r\npoint cloud sequences[C]//Proceedings of the IEEE/CVF International\r\nConference on Computer Vision. 2019: 9246-9255.</p>\r\n<p>[5] Min Y, Zhang Y, Chai X, et al. An efficient pointlstm for point\r\nclouds based gesture recognition[C]//Proceedings of the IEEE/CVF\r\nConference on Computer Vision and Pattern Recognition. 2020:\r\n5761-5770.</p>\r\n<p>[6] Guo M H, Cai J X, Liu Z N, et al. PCT: Point cloud\r\ntransformer[J]. Computational Visual Media, 2021, 7(2): 187-199.</p>\r\n<p>[7] Zhao H, Jiang L, Jia J, et al. Point transformer[C]//Proceedings\r\nof the IEEE/CVF International Conference on Computer Vision. 2021:\r\n16259-16268.</p>\r\n<p>[8] Vaswani, A.; Shazeer, N.; Parmar, N.; Uszkoreit, J.; Jones, L.;\r\nGomez, A. N.; Kaiser, L.; Polosukhin, I. Attention is all you need. In:\r\nProceedings of the 31st International Conference on Neural Information\r\nProcessing, 6000–6010, 2017.</p>\r\n<p>[9] Li X, Huang Q, Wang Z, et al. SequentialPointNet: A strong\r\nparallelized point cloud sequence network for 3D action recognition[J].\r\narXiv preprint arXiv:2111.08492, 2021.</p>\r\n<p>[10] Fan H, Yu X, Ding Y, et al. PSTNet: Point spatio-temporal\r\nconvolution on point cloud sequences[C]//International Conference on\r\nLearning Representations. 2020.</p>\r\n<p>[11] Hang Su, Subhransu Maji, Evangelos Kalogerakis, Erik\r\nLearned-Miller, \"Multi-view Convolutional Neural Networks for 3D Shape\r\nRecognition\", Proceedings of ICCV 2015</p>\r\n<p>[12] Liu X, Qi C R, Guibas L J. Flownet3d: Learning scene flow in 3d\r\npoint clouds[C]//Proceedings of the IEEE/CVF Conference on Computer\r\nVision and Pattern Recognition. 2019: 529-537.</p>\r\n<p>[13] Korban M, Li X. Ddgcn: A dynamic directed graph convolutional\r\nnetwork for action recognition[C]//European Conference on Computer\r\nVision. Springer, Cham, 2020: 761-776.</p>\r\n<p>[14] Yan, S., Xiong, Y., Lin, D.: Spatial temporal graph\r\nconvolutional networks for skeleton-based action recognition. In:\r\nThirty-Second AAAI Conference on Arti\fcial Intelligence (2018)</p>\r\n<p>[15] Plizzari C, Cannici M, Matteucci M. Skeleton-based action\r\nrecognition via spatial and temporal transformer networks[J]. Computer\r\nVision and Image Understanding, 2021, 208: 103219.</p>\r\n","categories":["深度学习"],"tags":["序列学习","点云"]},{"title":"点云深度学习写作素材","url":"/2022/01/06/%E7%82%B9%E4%BA%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%86%99%E4%BD%9C%E7%B4%A0%E6%9D%90/","content":"<h1 id=\"introduction\">Introduction</h1>\r\n<p>近年来，由于深度学习和计算机视觉领域取得的进展，以及在人机交互、老年人护理和医疗保健援助以及视频监控方面的应用，人类动作识别正获得越来越多的兴趣。最近在3D深度相机方面的进展，如微软Kinect\r\n(Zhang, 2012)和英特尔RealSense\r\n(Keselman等人，2017)传感器，以及先进的人体姿态估计算法(Cao等人，2019)，使得使用廉价设备快速准确地进行三维估计成为可能。</p>\r\n<p>Human Action Recognition is achieving increasing interest in recent\r\nyears for the progress achieved in deep learning and computer vision and\r\nfor the interest of its applications in human–computer interaction,\r\neldercare and healthcare assistance, as well as video surveillance. Re-\r\ncent advances in 3D depth cameras such as Microsoft Kinect (Zhang, 2012)\r\nand Intel RealSense (Keselman et al., 2017) sensors, and ad- vanced\r\nhuman pose estimation algorithms (Cao et al., 2019) made it possible to\r\nestimate 3D skeleton coordinates quickly and accurately with cheap\r\ndevices.</p>\r\n<h2 id=\"d数据格式\">3D数据格式</h2>\r\n<p>3D Data Representation Real scanned data has a collection of 3D point\r\ncoordinates. To adapt the data for con- volution, one straightforward\r\napproach is to voxelize it in a 3D grid structure [16, 23]. However, the\r\nrepresentation is clearly inefficient, since most voxels are usually\r\nunoccupied. Later, OctNet [21] explored the sparsity of voxel data and\r\nalleviated this problem. However, the memory occupancy is still high\r\nwhen it comes to deeper neural networks. Moreover, since voxels are\r\ndiscrete representation of space, this method still requires high\r\nresolution grids with large memory consumption as a trade-off to keep a\r\nlevel of representation quality. Another common 3D representation is in\r\nmulti-view [19, 24, 25], where the point data is projected to various\r\nspecific image planes in the 3D space to form 2D images. By this means,\r\npoint data can be processed using conventional convolution on 2D images.\r\nThis approach, however, ignores the intrinsic geometric relationship of\r\n3D points, and the choice of image planes could heavily affect results.\r\nOccluded parts in the 3D data due to projection are not handled.</p>\r\n<h1 id=\"静态点云\">静态点云</h1>\r\n<p>静态点云分析已经广泛应用在了多个任务之上，如分类，部件分割，语义分割等。(Qi\r\net al., 2017a;b; Li et al., 2018b;Wu et al., 2019; Thomas et al.,\r\n2019;Wang et al.,\r\n2019),近期大部分工作都致力于直接处理点云，而不是转换成体素网格之类的。由于点云本质上是一个无序点集，具有置换不变性，因此静态点云的处理方法都需要着力于设计一个与点的顺序无关的空间操作。</p>\r\n<p>Static point cloud analysis has been widely investigated for many\r\nproblems, such as classification, object part segmentation, scene\r\nsemantic segmentation(Qi et al., 2017a;b; Li et al., 2018b;Wu et al.,\r\n2019; Thomas et al., 2019;Wang et al., 2019),</p>\r\n<p>Most recent works aim to directly manipulate point sets without\r\ntransforming coordinates into regular voxel grids. Since a point cloud\r\nis essentially a set of unordered points and invariant to permutations\r\nof its points, static point cloud processing methods mainly focus on\r\ndesigning effective point based spatial correlation operations that do\r\nnot rely on point orderings.</p>\r\n<p>These Lagrangian representations are challenging for learning methods\r\ndue to their unordered nature, but are highly useful in a variety of\r\nsettings from geometry processing and 3D scanning to physical\r\nsimulations, and since the seminal work of Qi Charles et al. (2017), a\r\nrange of powerful inference tasks can be achieved based on point\r\nsets.</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"点云序列\">点云序列</h1>\r\n<p>相比于静态点云，动态点云序列更是一个较新的任务，但是对于理解我们身处的三维世界十分重要。</p>\r\n<p>Point cloud videos are a rich source of visual information and can be\r\nseen as a window into the dynamics of the 3D world we live in, showing\r\nhow objects move against backgrounds and what happens when we perform an\r\naction. Moreover, point cloud videos provide more flexibility for action\r\nrecognition in poor visibility environments, and covers more precise\r\ngeometry dynamics than conventional videos. Therefore, understanding\r\npoint cloud videos is important for intelligent systems to interact with\r\nthe world.Essentially, a point cloud video is a sequence of 3D\r\ncoordinate sets. When point colors are available, they are often\r\nappended as additional features. However, because coordinate sets are\r\nirregular and unordered, and points emerge inconsistently across\r\ndifferent sets/frames, modeling the spatiotemporal structure in point\r\ncloud videos is extremely challenging.</p>\r\n<p>Our world, and the objects within it, naturally move and change over\r\ntime, and as such it is crucial for flexible point-based inference to\r\ntake the time dimension into account.</p>\r\n<p>Point cloud videos are a rich source of visual information and can be\r\nseen as a window into the dynamics of the 3D world we live in, showing\r\nhow objects move against backgrounds and what happens when we perform an\r\naction. Moreover, point cloud videos provide more flexibility for action\r\nrecognition in poor visibility environments, and covers more precise\r\ngeometry dynamics than conventional videos. Therefore, understanding\r\npoint cloud videos is important for intelligent systems to interact with\r\nthe world.Essentially, a point cloud video is a sequence of 3D\r\ncoordinate sets. When point colors are available, they are often\r\nappended as additional features. However, because coordinate sets are\r\nirregular and unordered, and points emerge inconsistently across\r\ndifferent sets/frames, modeling the spatiotemporal structure in point\r\ncloud videos is extremely challenging.</p>\r\n<p>直接处理点云序列。由于点云序列具有不规则性和无序性，其使得点云在不同帧之间不具有连续性。因此通常会使用point\r\ntracking来捕获动态点云，但这是一个很难的任务。而且tracking通常都是依赖于点的颜色，这也不容易扩展到无色点云。</p>\r\n<p>相比于骨架和深度投影方法：</p>\r\n<p>Note that, skeleton-based methods rely on additional body keypoint\r\ndetection algorithms and cannot capture other objects’ motion except for\r\nhuman. Moreover, only using body keypoints ignores scene information\r\nthat may also provide rich and important cues for action recognition.\r\nDepth-based methods project 3D data to 2D depth frame and thus distort\r\nthe real 3D shape</p>\r\n<h2 id=\"相关工作\">相关工作</h2>\r\n<h3 id=\"基于点云进行处理\">基于点云进行处理</h3>\r\n<ul>\r\n<li>PointRNN (Fan &amp; Yang, 2019) leverages point based recurrent\r\nneural networks for raw point cloud sequence forecasting.</li>\r\n<li>MeteorNet (Liu et al., 2019e) extends 3D points to 4D points and\r\nthen appends a temporal dimension to PointNet++ to process these 4D\r\npoints.</li>\r\n<li>P4Transformer (Fan et al., 2021a) employs transformer to avoid point\r\ntracking for raw point cloud sequence modeling.</li>\r\n<li>Prantlet al. (2020) learned stable and temporal coherent feature\r\nspaces for point based super-resolution.</li>\r\n<li>CaSPR (Rempe et al., 2020) learns to encode spatio-temporal changes\r\nin object shape from point clouds for reconstruction and camera pose\r\nestimation.</li>\r\n<li>PSTNet(2021),to extract features of point cloud sequences in a\r\nhierarchical manner. Extensive experiments on widely-used 3D action\r\nrecognition and 4D semantic segmentation datasets demonstrate the\r\neffectiveness of PSTNet to model point cloud sequences.</li>\r\n</ul>\r\n<h3 id=\"基于其他类型的3d序列识别\">基于其他类型的3D序列识别</h3>\r\n<ul>\r\n<li>3DV (Wang et al., 2020) first integrates 3D motion information into\r\na regular compact voxel set and then applies PointNet++ to extract\r\nrepresentations from the set for 3D action recognition.</li>\r\n<li>Niemeyer et al. (2019) learned a temporal and spatial vector field\r\nfor 4D reconstruction.</li>\r\n<li>Fast and Furious (FaF)converts 3D point cloud frames into 2D bird’s\r\nview voxels and then extracts features via 3D convolutions.</li>\r\n<li>MinkowskiNet uses 4D Spatio-Temporal ConvNets to extract appearance\r\nand motion from 4D occupancy voxel grids.</li>\r\n</ul>\r\n<p>骨架和深度</p>\r\n<p>The existing 3D action recognition methods can be roughly divided\r\ninto skeleton-based methods and depth-based methods. For skeleton-based\r\n3D action recognition, the sequence-based methods and graph-based\r\nmethods are the main-stream approaches. By representing the skeleton\r\ndata as a sequence of skeleton joints based on the pre-designed\r\ntraversal strategy, the sequence-based methods [2]–[5] adopted the RNN\r\n(Recur- rent Neural Network) based approaches to exploit temporal\r\ndependency among these skeleton joints. The graph-based methods [6], [7]\r\nemployed GCN (Graph Convolution Net- work) to capture spatio-temporal\r\ndependency by represent- ing the skeleton data as a graph, in which\r\njoints are treated as the vertexes of the graph. For depth-based 3D\r\naction recognition, most works [9]–[14] extracted the appear- ance\r\nfeatures from 2D depth maps directly. However, both lines of works\r\ncannot fully exploit complete geometry information, which may degrade\r\nthe 3D action recognition performance. To this end, the recent work\r\n3DV-PointNet++ [15] devel- oped a new network together with a new 3D\r\nmotion rep- resentation method referred to as 3D dynamic voxel (3DV) for\r\n3D action recognition. However, the whole network of 3DV-PointNet++ with\r\nthe motion representation extraction module cannot be optimized in an\r\nend-to-end fashion. In con- trast, we propose a new fully end-to-end\r\noptimized two-stream framework, which achieves promising results for 3D\r\naction recognition.</p>\r\n<p>网格序列</p>\r\n<p>[PointLSTM]Deep neural networks have achieved excellent performance\r\non spatio-temporal modeling in RGB/RGBD videos. To capture the\r\ncomplementary information about appearance and motion, two-stream\r\nconvolutional neural networks [49, 56] use a spatial stream and an\r\noptical flow stream for video understanding. As video is a kind of\r\nsequence, recurrent neural networks [19, 7, 65] are employed to capture\r\nthe temporal dependencies [38, 13]. Similar to recurrent neural\r\nnetworks, 1D convolutional neural networks [24] can also be used to\r\nmodel the temporal structure across frame features. Besides, pooling\r\ntechniques [12] are also employed to select and merge frames into a\r\nglobal video representation. In addition, 3D convolutional neural\r\nnetworks [51, 4, 52] can directly learn spatio-temporal representations\r\nfrom videos by stacking 2D frames into 3D pixel tensors. Meanwhile,\r\ninterpretable video or action reasoning methods [66, 16] are proposed by\r\nexplicitly parsing changes in videos. For RGBD videos, grid based\r\nmethods are also widely used to fuse RGB and depth information [30,\r\n20].</p>\r\n<h3 id=\"d-动作识别\">2D 动作识别</h3>\r\n<p>With explosive growth of videos, a large number of meth- ods were\r\nproposed for various video understanding tasks, among which the 2D\r\naction recognition methods [18] aim to recognize human actions in\r\nvideos. Before the deep learn- ing era, many researchers proposed\r\ndifferent methods to design the hand-crafted features, such as HOG3D\r\n[19] and SIFT3D [18]. Recently, a large number of deep learning\r\napproaches [20]–[29] have been proposed for 2D action recog- nition and\r\nthese methods have achieved promising results on the benchmark datasets.\r\nThese methods can be roughly divided into two categories. The first line\r\nof works used 3D CNNs to directly exploit spatio-temporal information in\r\nvideos. 3D CNN can jointly learn the spatio-temporal features, in which\r\nthe representative works include C3D [21] and I3D [22]. C3D [21] is the\r\nfirst work to apply 3D CNN to the video understanding task. I3D [22]\r\nfurther extended the 2D filters into 3D convolution to better exploit\r\nspatio-temporal information. The second line of works adopted the\r\ntwo-stream strategy [20], in which the appearance and motion information\r\nare represented in the RGB stream and the flow stream, respec- tively.\r\nFor example, in TSN [24], Wang et al. proposed to aggregate the\r\nappearance and motion features extracted from different frames of\r\nmultiple segments for action recognition.——GeometryMotion-Net</p>\r\n<h3 id=\"其他领域序列模型\">其他领域序列模型</h3>\r\n<ul>\r\n<li>Transformer，BERT</li>\r\n</ul>\r\n<p>The attention mechanism can be viewed as a mechanism for reallocating\r\nresources according to the importance of activation.</p>\r\n<p>Transformer是自然语言处理(NLP)的领先神经模型，由Vaswani等人(2017)提出，作为循环网络的替代方案。它的设计是为了解决两个关键问题:(1)处理非常长的序列，这对于lstm和rnn来说都是难以解决的问题;(2)在标准rnn体系结构中，并行化句子处理通常是按顺序逐字执行的。Transformer遵循通常的编码器解码器结构，但它仅依赖于多头自我注意(Vaswani等人，2017)。最近,Transformer应用到了很多CV任务上。</p>\r\n<p>The Transformer is the leading neural model for Natural Language\r\nProcessing (NLP), proposed by Vaswani et al. (2017) as an alternative to\r\nrecurrent networks. It has been designed to face two key problems: (i)\r\nthe processing of very long sequences, which are often intractable both\r\nfor LSTMs and RNNs, and (ii) the limitations in parallelizing sentence\r\nprocessing, which is usually performed sequentially, word by word, in\r\nstandard RNNs architectures. The Transformer follows a usual\r\nencoder–decoder structure, but it relies solely on multi-head self-\r\nattention (Vaswani et al., 2017). Recently, Transformer self-attention\r\nhas been applied in many popular computer vision tasks. Wang et al.\r\n(2018) proposed a differentiable non-local operator based on self-\r\nattention, which allows to capture long-range dependencies both in space\r\nand time for a more accurate video classification. After the first\r\nattempt of Bello et al. (2019b) to use self-attention as an alterna-\r\ntive to convolutional operators, Dosovitskiy et al. (2020) proposed\r\na</p>\r\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"生化奇兵：疯狂独特的反乌托邦","url":"/2022/03/21/%E7%94%9F%E5%8C%96%E5%A5%87%E5%85%B5/","content":"<p>生化奇兵 BioShock</p>\r\n<h1\r\nid=\"体验了天空之城的一年后回到最初的朝圣之旅\">体验了天空之城的一年后，回到最初的朝圣之旅</h1>\r\n<p>当然相比无限来说，初代这部游玩体验肯定没有那种完美感，但是依然是为数不多的优质线性FPS。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.akamai.steamstatic.com/steam/apps/409710/ss_002c690e40603e3bccec0d84256f99a5b03fdbec.jpg?t=1598321131\"\r\nalt=\"art deco风格画面，不算精美但是让人沉浸\" />\r\n<figcaption aria-hidden=\"true\">art\r\ndeco风格画面，不算精美但是让人沉浸</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h2\r\nid=\"原始版的战斗与对味的反乌托邦剧情\">原始版的战斗与对味的反乌托邦剧情</h2>\r\n<p><strong>属于那个时代的枪械和质体战斗</strong>：枪械种类不多，但也算是标配枪械都有了，比如霰弹、机枪等。手感...说不上有手感吧，毕竟老游戏了。质体(特殊能力)上主要就电、冰、火、和策反，这几种能够反复使用，其他的质体更像是小玩具，刚拿到的时候玩玩就可以了，真打起来效果还不如抡扳手。另外敌人种类也偏少，战斗体验比起《生化奇兵：无限》来说还是原始了很多，不过枪械+质体本来也算挺独特的FPS体验。</p>\r\n<p><strong>剧情上是一贯的反乌托邦风</strong>：同样是以灯塔作为起点，不明身份的自我，脱离世界的独裁极乐城，人体生物实验的背景板。当然，也有生化奇兵系列最为典型的思维控制纽带。在逃离极乐城的过程中，逐渐认识到这个城市的黑暗“大链条”，逐渐发现自己究竟是什么...看似巧合的开始却是命中注定。喜欢生化奇兵的玩家肯定有一大部分是为了那个<strong>迷离的世界与剧情，这一点上即使是生化奇兵1也不会让你失望</strong>。</p>\r\n<blockquote>\r\n<p>和《生化奇兵：无限》的天堂氛围不同，海底城市极乐城环境氛围较为阴暗恐怖。（而且调亮度功能坏了....）虽然氛围恐怖了点，但实际上也不会有很吓人的东西，无非就是躺在地上的敌人站起来吓你一跳，或者大老爹沉重的脚步声在你耳边回绕。并没有那种恶鬼突然跳你脸上的环节...毕竟这是生化奇兵，它主要是想营造极乐城的生化黑暗的氛围，而不是为了吓你。</p>\r\n</blockquote>\r\n<h2 id=\"关卡任务设计不太有意思\">关卡任务设计不太有意思</h2>\r\n<p>即使这部老游戏的画面和战斗都体现出了一定的时代约束，关卡设计可以说是最突出年代感的环节。从开头到结尾，关卡敌人都是不多的几种，利用质体的解密也只有前期教程关有...后期质体互动的解密环节好像被开发者遗忘了...而且任务大多都是为了找什么到一个地方，然后这个地方又没有那个东西，于是又分散成几个小任务去别的地方找...</p>\r\n<p><strong>当然找地方的过程中，边听NPC边听录音带，其实才能了解到极乐城的剧情</strong>....制作组可能实在想不出怎么让玩家去跑这些地方，去体验他们精心的场景设计和隐藏在录音带中的背景故事，只能这样分散主线强行跑路....</p>\r\n<p><strong>但是强行跑路对玩家来说其实就是拖沓的节奏了</strong>。虽然前期听着录音带探索极乐城的往事的体验还不错，但是就连到尾声部分，也还是在拆解主线强行跑路，而这时候玩家已经不想管极乐城以前究竟发生什么了，玩家只想知道我自己究竟会面对什么样的结局，拖沓给让带来的烦躁最大化。</p>\r\n<h2 id=\"关于闪退bug\">关于闪退，BUG</h2>\r\n<p>WIN10+GTX1066+I7-7700HQ 9小时通关没有出现闪退</p>\r\n<p>唯一一次卡死崩溃是因为加载的时候切出了游戏。BUG也是有的，但唯一影响比较大的就是亮度调节无效，搞得整个游戏都黑黑的（比官方视频黑多了），加重了恐怖氛围，玩起来有点难受....</p>\r\n<h2 id=\"总结粗糙但是魅力只此一家\">总结：粗糙，但是魅力只此一家</h2>\r\n<p>这个游戏虽然现在来看粗糙生硬了点，但作为初代生化奇兵还是<strong>值得一玩</strong>的，剧情背景的构造也是充满了令人痴迷的生化奇兵的味道=\r\n=喜欢剧情丰富的，以及生化奇兵系列粉丝，并且能接受一些恐怖氛围的，<strong>强烈建议体验极乐城</strong>，是可以在你脑海里留下深刻一笔的地方00</p>\r\n","categories":["生活"],"tags":["游戏"]},{"title":"矩阵的压缩存储","url":"/2020/09/09/%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/","content":"<p>矩阵在数据表示中举足轻重。为了方便提取矩阵元素通常都是用二维数组进行存储。但是矩阵并不总是满元素矩阵，里面很多的空元素浪费了很多存储空间，因此有几种特殊矩阵的压缩存储方式。</p>\r\n<h2 id=\"对称矩阵\">对称矩阵</h2>\r\n<p>对一个 n 阶方阵，其元素 a_ij=a_ji, 则称其为对称矩阵。</p>\r\n<p>容易知道，对称矩阵其实只要记录半边的元素即可，使用二维数组会浪费大量空间。</p>\r\n<p>因此我们使用一个 A[n(n+1)/2] 的一维数组存储按行矩阵下三角部分。即\r\nA[0] 存储 a_11,A[1] 存储 a_21,A[2] 存储 a_22，A[3] 存储 a_31 ...\r\n依次按行存储。</p>\r\n<p>因此下三角元素 a_ij，在 A 中的下标即 k=1+2+ ... + (i-1) + j\r\n-1=i*(i-1)/2+j-1。</p>\r\n<p>而上三角元素即反转行列序号进行下标计算即可。</p>\r\n<blockquote>\r\n<p>注意按行还是按列存储对存储下标计算有影响。</p>\r\n</blockquote>\r\n<h2 id=\"三角矩阵\">三角矩阵</h2>\r\n<p>上/下三角矩阵一样，以下三角矩阵为例。下三角矩阵是下三角有任意元素，但上三角区元素均为同一常量。因此和对称矩阵的存储方式类似，只是在存储完下三角区后，追加一个元素表示上半区的所有元素。</p>\r\n<p>一维数组 A[n(n+1)/2+1]。下三角区元素 a_ij 下标\r\nk=i<em>(i-1)/2+j-1，上三角元素下标 k=n</em>(n+1)/2</p>\r\n<h2 id=\"三对角矩阵\">三对角矩阵</h2>\r\n<p>三对角矩阵也叫做带状矩阵，矩阵内元素 a_ij, 当|i-j|&gt;1\r\n时，a_ij=0。即所有元素集中在主对角线中心的三条对角线上，其余元素为\r\n0。</p>\r\n<p>易知存储上首行和末行只有两个元素，其余每行有三个元素。因此也可以使用\r\nA[3*(n-2)+4] 的一维数组进行存储。</p>\r\n<p>A 中元素 a_ij 的存储下标 k=2i+j-3。</p>\r\n<h2 id=\"稀疏矩阵\">稀疏矩阵</h2>\r\n<p>矩阵非零元素比零元素少得多得多，即为稀疏矩阵。例如 521X521\r\n的矩阵中，只有 802 个非零元素。</p>\r\n<p>因此我们肯定选择只存储非零元素即可，但是非零元素不像上面几个一样有分布规律，因此这里还需要记录非零元素的位置信息。</p>\r\n<p>所以采用三元组方式存储，每个存储结构保存位置 i，j，以及值\r\nv。至于实现可以采用结构体数组或是十字链表法。</p>\r\n<blockquote>\r\n<p>矩阵压缩的题目大多都是计算下标，注意按行按列的存储方式，注意矩阵起始下标是\r\n1 还是 0，注意存储数组的起始下标是 1 还是 0。</p>\r\n</blockquote>\r\n","categories":["杂记"]},{"title":"简书博客导入hexo","url":"/2020/07/16/%E7%AE%80%E4%B9%A6%E5%8D%9A%E5%AE%A2%E5%AF%BC%E5%85%A5hexo/","content":"<h1 id=\"下载原markdown集\">1. 下载原markdown集</h1>\r\n<p>登录简书作者后台，在个人设置--账号管理--打包下载所有文章。\r\n此时可以获得以文集为文件夹的所有markdown文章源文件</p>\r\n<h1 id=\"利用shell脚本添加hexo元数据\">2. 利用shell脚本添加hexo元数据</h1>\r\n<p>需要掌握 <strong>sed修改文件</strong>，<strong>shell脚本运行</strong>\r\n- <a\r\nhref=\"https://www.cnblogs.com/maxincai/p/5146338.html\"><strong>sed命令用法</strong></a>\r\n- shell脚本只要你安装好了git环境，即可在命令行中通过\r\n<code>sh xxx.sh</code>\r\n运行相关脚本，至于怎么去写，有兴趣可以自己了解</p>\r\n<p>以下是我使用的shell脚本：</p>\r\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> f <span class=\"keyword\">in</span> ./*/*;<span class=\"keyword\">do</span></span><br><span class=\"line\">sed -i  <span class=\"string\">&#x27;s/#####\\([^#]\\)/##### \\1/&#x27;</span> <span class=\"variable\">$f</span></span><br><span class=\"line\">sed -i  <span class=\"string\">&#x27;s/####\\([^#]\\)/#### \\1/&#x27;</span> <span class=\"variable\">$f</span></span><br><span class=\"line\">sed -i  <span class=\"string\">&#x27;s/###\\([^#]\\)/### \\1/&#x27;</span> <span class=\"variable\">$f</span></span><br><span class=\"line\">sed -i  <span class=\"string\">&#x27;s/##\\([^#]\\)/## \\1/&#x27;</span> <span class=\"variable\">$f</span></span><br><span class=\"line\">sed -i  <span class=\"string\">&#x27;s/#\\([^#]\\)/# \\1/&#x27;</span> <span class=\"variable\">$f</span></span><br><span class=\"line\">base=$(basename <span class=\"variable\">$f</span> .md)</span><br><span class=\"line\">categories=$(basename $(dirname <span class=\"variable\">$f</span>) <span class=\"variable\">$PWD</span>)</span><br><span class=\"line\">insert=<span class=\"string\">&quot;---\\ntitle: <span class=\"variable\">$&#123;base&#125;</span>\\ncategories:\\n- <span class=\"variable\">$&#123;categories&#125;</span>\\ndate:2020-02-17 02:17:00\\n---\\n&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">&quot;<span class=\"variable\">$&#123;insert&#125;</span><span class=\"subst\">$(cat $f)</span>&quot;</span> &gt; <span class=\"variable\">$f</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>前半段为sed在#字符后添加空格，因为在简书里 <code>#紧贴标题</code>\r\n也是可以成功识别的，但是其他的markdown不一定支持。这里注意需要用到的命令格式为<code>sed -i 's/old/new' file</code></li>\r\n<li><ul>\r\n<li>-i指在源文件上修改</li>\r\n</ul></li>\r\n<li><ul>\r\n<li>s\r\n指进行文本替换，但这里有一个巨大的坑点，假如old长度为3，new长度为4，那么该命令会吞掉原old后的一个字符，即它的替换是覆盖式替换，而不是删除old后插入new。</li>\r\n</ul></li>\r\n<li><ul>\r\n<li>因此需要使用到 ()\r\n格式，()在old中选定子字符串，然后在new中利用\\number，获取第number个子字符串，即我们保存下来了会被覆盖掉的字符，然后又重新给他加了回去。</li>\r\n</ul></li>\r\n<li><ul>\r\n<li>为了避免在诸如#####中匹配出单个#，利用了[^c]，即不匹配c字符，在这段代码中就是下一个不能是#。</li>\r\n</ul></li>\r\n<li>后半段是hexo文档评论区的大神写的，获取了目录名作为hexo的分类名，并且插入元数据，<strong>注意无法自动维护简书的时间</strong>，因此我这自己选了个日期插入。</li>\r\n</ul>\r\n<h1 id=\"运行脚本并检查文档\">3.运行脚本并检查文档</h1>\r\n<p>在简书文集解压出来的文件夹的根目录中，即在<code>user-xxxx</code>文件夹下，运行该脚本，等待运行完成后检查修改结果是否符合你的预期。</p>\r\n<h1 id=\"存在问题\">4.存在问题</h1>\r\n<ol type=\"1\">\r\n<li>无法维护时间</li>\r\n<li>简书代码块不需要注明语言，但是这样hexo的一些highlight就无法识别，想不到自动注明语言的办法。</li>\r\n<li>简述博客图片链接会失效，简书通过判断http请求头中的referer的值，如果来自本站才返回成功请求。因此可以通过修改referer复原图片链接，但是博客有些依赖referer的功能就会受影响。\r\n可以选用外部图床，但收费的挺贵，不收费的也难用，常规的发文网如微博、CSDN、简书都限制外链，挺难找图床的。</li>\r\n</ol>\r\n","categories":["工具"],"tags":["博客"]},{"title":"考研，结束","url":"/2021/03/29/%E8%80%83%E7%A0%94%EF%BC%8C%E7%BB%93%E6%9D%9F/","content":"<h2 id=\"欢呼\">欢呼</h2>\r\n<p>2020.9.1——2021.3.27</p>\r\n<p>3 月, 3 周, 4 天 + 3 月, 1 天 = 6 月, 3 周, 5 天</p>\r\n<p>116+91=207 天</p>\r\n<p>3.28 打电话通知预录取了。结束啦，我的仓促平凡的考研生活。</p>\r\n<span id=\"more\"></span>\r\n<p>打电话通知的时候还有一个乌龙。先是一位小哥哥电话早上把我喊起来了，告诉我后续加他微信，会有人通知填意向表。结果刚加微信一分钟，另一个小姐姐电话来了，是之前通知复试的学姐。也是加微信，然后给我填表二维码以及截至时间……然后她心态崩了，发现连打了几个电话都有人喊过了？？但是我们这批一直都是她负责的……不知名的好心人抢先一步通知了我们，可能是暗恋的娃嗯。</p>\r\n<p>考的是本校，没有冲高的勇气，毕竟我承担不了失败的后果……虽然初试考的挺高，干。不过也还算满意，毕竟是计算机专业，一切凭实力说话，与其纠结学历能给自己加分多少，多看几本书，多做几个开源项目才是实打实的硬能力。</p>\r\n<h3 id=\"初试\">初试</h3>\r\n<p>初试准备过程挺短的，四个月的时间，不过每一天都是很认真的分配了。\r\n7~22点，上午一小时半英语一小时半政治，下午全给数学，晚上全给专业课，偶尔累了可以看看政治放松放松：）</p>\r\n<p>仓促，每一天都在赶进度。不过好处就是，清晰的知道自己的进度进展，每一天都有明显的进步，多少天看完一本书，多少天做完模拟卷，最后留多少天给真题，每一天都有硬性任务硬性指标，也还算充实。</p>\r\n<p>花时间最多的数学考得最不理想……练了那么多难题，来了个过于简单的卷子，刚好让易粗心的我暴露了致命缺陷……</p>\r\n<p>惊喜的是花时间最少的英语，接近放弃复习的英语，比我想考的好很多……</p>\r\n<p>政治，考过了才知道，虽然题目都压中了，押题答案都背的滚瓜烂熟，但是没人保证押题答案得高分啊！！最后大题也就个30/50的样子，押题答案只是给你一种参考句式和思路，千万不要默写答案，分并不高，还是自己好好分析吧。</p>\r\n<p>408倒是很稳定，和自己做真题以及预测水平完全一致，不会的选择题也是那种超纲的，没有一点意外，稳定发挥。</p>\r\n<h3 id=\"复试\">复试</h3>\r\n<p>复试摸鱼两个月，一般般努力一个月，最后复试自我感觉也不太理想……等成绩看看，会拉后腿是肯定的，初试完千万不要放松啊同学们！</p>\r\n<p>初试考完就是放假，疯玩了好多天，然后开始学了学毕设。回家过年也是看看毕设然后疯玩摸鱼，直到查了初试成绩，考的不错更加放松了复习复试的心态……最后是把本科专业课大致看了看，口语大概准备了点，半吊子直接上复试战场了，虽然不知道成绩目前，自我感觉就是不太理想。</p>\r\n<p>好在初试能帮帮忙，至少成功上岸了。</p>\r\n<p>不过这也就是考个普通本校，初试还挺帮忙，如果往上考，并且初试一般般，建议初试结束就好好全方面准备复试，起码想想假如是自己面试自己，面对一问三不知，基础不牢，履历不优秀的人，凭什么给你战胜其他强有力竞争者的机会。</p>\r\n<h3 id=\"最后欢呼\">最后，欢呼！</h3>\r\n<h2 id=\"平凡的人怎么活下去\">平凡的人怎么活下去</h2>\r\n<p>逐渐面临毕业，逐渐被迫面对现实。</p>\r\n<p>平凡如我，怎么活下去。</p>\r\n<p>不像某人多才多艺，不会画画不会唱歌不会手艺不会运动，没有领导才能。\r\n不像某人学习刻苦，年年专业第一，奖学金拿到手软，竞赛履历写满整整一页。\r\n不像某人精通专业，从底层到应用，从代码算法到设计模式以及项目管理，前后端全都了解的一清二楚，顺利字节offer。</p>\r\n<p>得益于0~20岁的苟且修仙理念，我什么都不优秀。找不到任何一个特长，任何一个骄傲的点。</p>\r\n<p>虽然平凡如我，也在游戏里不知道为什么就收获了女朋友，可能是我太闲了？有大把的时间陪着对面。</p>\r\n<p>以前自诩比较温柔有耐心，后来发现其实这一点也不存在，也照顾不到别人的情绪，不懂相处，时间越久越发现自己毫无不可替代性。</p>\r\n<p>不过好在20~21岁改变了自己，变得上进了一些，虽然不够勇敢，但是也有所努力，收获也挺开心的。考研更算是一种赢得浪子回头三年的缓冲，希望自己能在三年里做到专业上的佼佼者，如果能稍微有些才艺有些其他优点就更好了。</p>\r\n<h3 id=\"我期待着什么样的关系\">我期待着什么样的关系</h3>\r\n<p>一直以来都主动的站在照顾别人的地位，承受别人的开心或愤怒。加上对自己温柔耐心的包装，表现出愿意接纳一切火焰吞下肚的样子。但实际上自己是一个很容易因为在乎的人受伤的人，愿意吸纳别人的不开心，但一旦把不开心牵连到我身上就是很委屈的一件事。明明想着是站在一起面对困难，最后愕然发现自己被推开了，是一个外人而已。最后哑口无言，不做什么会被说毫无作为，做点什么又要忍住委屈的伤口。</p>\r\n<p>自己表现得太过坚强了，别人也不知道我这么容易受伤。但怎么才能把软弱表现出去呢？有谁喜欢软弱。会喜欢男朋友软弱吗？猛男落泪一直被描写成在乎和真爱的样子，实际上只是当时的爱意的自我感动罢了，不存在喜欢这种行为，只是滤镜加了层戏，这个男生很在乎我的样子？……知道这个真相的时候脑海一片空白。我以为情侣能表现出这一面来着，委屈又封闭。</p>\r\n<p>哭哭啼啼是被嫌弃和厌恶，但是自己又对这一方面特别敏感。平常对所有其他事都漠不关心，但是在乎的朋友或者情侣稍微凶了我一点就能委屈的心里扎刀子。</p>\r\n<p>很期待一个能接纳软弱无能的我的人来着。但是和上面的平凡相互映衬了，本来别人就没有喜欢你的理由，凭什么还要接纳你令人讨厌的一面呢。</p>\r\n<p>很想能够有什么不可取代的吸引力，拥有平等的勇气，互相接纳对方的不足。</p>\r\n","categories":["生活"]},{"title":"英语作文句式整理","url":"/2020/11/09/%E8%8B%B1%E8%AF%AD%E5%8F%A5%E5%BC%8F%E6%90%AD%E9%85%8D%E6%95%B4%E7%90%86/","content":"<h1 id=\"小作文\">小作文</h1>\r\n<h2 id=\"开篇-12-句\">开篇 (1~2 句）</h2>\r\n<h3 id=\"告示\">告示</h3>\r\n<p>This is to notify that xxx will be held at XXX from xx:xx to xx:xx on\r\nJune 28^th. We cordially invite you to attend the [ceremony/event] .</p>\r\n<h3 id=\"信件\">信件</h3>\r\n<p>引出 This (letter) serves to</p>\r\n<ul>\r\n<li>邀请 (On behalf of ...) extend a warm invitation to you to attend\r\nthe .... ,on August 13-20, 2018 at Peking University</li>\r\n<li>推荐/建议 make some [suggestions/recommendations] with regard\r\nto(prep.) ..., (since you asked for my advice)</li>\r\n<li>申请 apply for ...</li>\r\n<li>申请兴趣/道歉/感谢/慰问 express my deepest\r\n[interest/apology/gratitude/sympathies] [over the loss of .../for what\r\nhappened], since ... <a href=\"#原因\">原因</a></li>\r\n<li>辞职 make a hard decision to quit due to personal reasons.</li>\r\n<li>祝贺 congratulate your achievement ,since I heard the news\r\nthat...</li>\r\n<li>投诉 draw your attention to the problem that ...</li>\r\n</ul>\r\n<p>感谢客套 I am so delighted that you trust me to arrange your ...</p>\r\n<p>道歉强调 I am terribly sorry for any inconvenience this causes you\r\n.</p>\r\n<span id=\"more\"></span>\r\n<p>自我介绍</p>\r\n<h2 id=\"中间段-34-句\">中间段 (3~4 句）</h2>\r\n<p><strong>活动目的</strong></p>\r\n<p>The event is prepared in the intention to...</p>\r\n<p><strong>推荐理由</strong></p>\r\n<p>I strongly recommend ... to you because I am sure...</p>\r\n<p><strong>道歉</strong></p>\r\n<p>让步 I have been looking forward to doing ... since we made the\r\nappointment.</p>\r\n<p>解释 Unexpectedly, ... [理由].</p>\r\n<p>补救 If it is possible ,I would like to reschedule our appointment to\r\na time convenient for you.</p>\r\n<p><strong>观点收尾</strong></p>\r\n<p>These are some important points that I wanted to mention.I am sure if\r\n... you will ...</p>\r\n<h2 id=\"结尾段-12-句\">结尾段 (1~2 句）</h2>\r\n<h3 id=\"期待\">期待</h3>\r\n<p>It would be much appreciated if you could please send back the reply\r\nslip (before June 21^st)</p>\r\n<ul>\r\n<li>参与 to inform us of your attendance.</li>\r\n<li>给机会 to grant me an interview</li>\r\n</ul>\r\n<p>We look forward to your reply.</p>\r\n<p>Thank you for your time and consideration.</p>\r\n<ul>\r\n<li>约谈 I look forward to speaking with you.</li>\r\n<li>投诉 If detailed information is required,please contact me at\r\n12345678.</li>\r\n<li>咨询 I am hoping that your answers to my queries would help me get a\r\nclear foresight on ...</li>\r\n</ul>\r\n<h3 id=\"推荐建议\">推荐/建议</h3>\r\n<p>Hopefully my [recommendations/suggestions/] are constructive and wish\r\nyou a delightful journey.</p>\r\n<h3 id=\"道歉\">道歉</h3>\r\n<p>Please accept my sincere apology for any inconvenience that my\r\nbehavior may have caused to (the company)...</p>\r\n<h3 id=\"祝贺\">祝贺</h3>\r\n<p>Many congratulations for your achievement and best wishes for future\r\ngrowth as well!</p>\r\n<h3 id=\"告示-1\">告示</h3>\r\n<p>Those who want to participate can find our desk by the dining hall\r\naround 12 a.m. every day this week. We look forward to your\r\nparticipation.</p>\r\n<h3 id=\"积极帮助\">积极帮助</h3>\r\n<p>Please do not hesitate to call if you think of anything at all you\r\nmight need.</p>\r\n<h1 id=\"图表大作文\">图表大作文</h1>\r\n<p>柱图 bar chart</p>\r\n<p>饼图 pie chart</p>\r\n<p>线图 line chart</p>\r\n<p>表格 table</p>\r\n<h2 id=\"开篇\">开篇</h2>\r\n<h3 id=\"引入\">引入</h3>\r\n<p>动态 The XXX chart clearly shows the changes in the number of ...\r\nover [the period from ... to .../past several decades] ...</p>\r\n<p>静态 This XXX chart, simple yet illuminating, illustrates the\r\n[proportions of/results of a survey of] how ...</p>\r\n<h3 id=\"描绘数据\">描绘数据</h3>\r\n<p><strong>两个变量趋势一样，但有细微差别</strong></p>\r\n<p>We can see steady growth/decline in ...(both figures) these years. A\r\ncloser look,however,shows a [striking contrast/subtle differences]\r\nbetween ... : sth.(the former) was growing/declining at a relatively\r\nfaster pace, from just 10% in 2017 to surprising 50% ,whereas sth.(the\r\nlatter) just witnessed a slight rise/decline (in ...) each year,with the\r\nnumber ....</p>\r\n<p><strong>此消彼长</strong></p>\r\n<p>[During the time span/As we can see from the chart,between 2017 to\r\n2019], sth increased rapidly from 10% to 50%. But in the meanwhile , sth\r\nhad declined ,falling from 50% to 10% ...</p>\r\n<p><strong>对比比例</strong></p>\r\n<p>As we can see from the chart, the biggest section is ...,accounting\r\nfor 50% of the total, followed closely by .... which represents 33%. By\r\ncomparison , the next two significant items are ..., which are 10%,20%\r\nrespectively.</p>\r\n<h2 id=\"阐释图表\">阐释图表</h2>\r\n<p><strong>总结</strong></p>\r\n<p>Undoubtedly，the chart reflects a common [social\r\nphenomenon/significant tendency] that [citizens/students/...] ... when\r\n...</p>\r\n<p><strong>引入原因</strong></p>\r\n<p>The main factors contributing to this phenomenon can be summarized as\r\nfollows.</p>\r\n<h3 id=\"列举词\">列举词</h3>\r\n<p><strong>并列</strong></p>\r\n<p>In the first place Moreover Meanwhile What is also worth mentioning\r\nhere is Last but not the least</p>\r\n<p><strong>转折</strong></p>\r\n<p>By contrast,... On the one hand,.....On the other hand...\r\nContrastingly，... In comparision，...</p>\r\n<h3 id=\"阐述原因\">阐述原因</h3>\r\n<p><strong>主观原因</strong></p>\r\n<p>With ...,people's [sense of responsibility//cooperation\r\n/environmental consciousness/desire for success] [improves/is on the\r\nrise], which will inevitably leads to ...</p>\r\n<p>With ...[某些原因]，[某主体现象]，and therefore more likely to\r\n[递进现象]。</p>\r\n<ul>\r\n<li>生活节奏 With the quickened pace of life</li>\r\n</ul>\r\n<p>There is a rising concern over ... among sb.</p>\r\n<p><strong>客观原因</strong></p>\r\n<p>随着发展 As [economy/technology] develops, more and more people [are\r\nconcerned about/can afford] ..., making it possible for ... to ...,</p>\r\n<p>优势竞争 With the advancement of technology and the promotion of\r\ninnovation, ... have achieved enhanced performance and imporved\r\nfeatures, able to rival counterparts.</p>\r\n<p><strong>社会政策原因</strong></p>\r\n<p>The authorities have released many preferential policies (such as\r\n...) to promote ..., which undoubtedly stimulate ...</p>\r\n<p><strong>传统文化</strong></p>\r\n<p>China, as one of the world's oldest cradles of civilization , is\r\nfamous for its ...</p>\r\n<p>In our traditional culture, ... is considered as [a thoughtful and\r\ncourteous behavior/an immoral action]</p>\r\n<h3 id=\"总结原因-可选\">总结原因 （可选）</h3>\r\n<p>With the joint efforts of all these factors ,it's natural that\r\n...</p>\r\n<h2 id=\"结尾\">结尾</h2>\r\n<h3 id=\"预测趋势\">预测趋势</h3>\r\n<p>Since ...<a href=\"#原因\">原因</a>, we have sound reasons to believe\r\nthat ... will ...(keep thriving) in the following years.</p>\r\n<ul>\r\n<li>抓住机遇 Only by grasping the opportunities and facing up to the\r\nchallenges can we take full advantage of this new trend and realize\r\n...</li>\r\n</ul>\r\n<h3 id=\"预测评论影响\">预测+评论影响</h3>\r\n<p>In conclusion, given that ...., in future , we can probably expect to\r\nsee more and more people ..., which would ...</p>\r\n<h3 id=\"发现问题建议\">发现问题+建议</h3>\r\n<p>However, this encouraging trend also poses multiple challenges, such\r\nas ...To deal with them, we need firstly to ... In addition, ...</p>\r\n<ul>\r\n<li>建议政府 the government should take multidimensional measures to\r\nbuch the unfavorable trend.</li>\r\n</ul>\r\n<h3 id=\"看好未来建议\">看好未来+建议</h3>\r\n<p>To be sure, it is an encouraging sign that ... But if ...(this\r\nbusiness) want to make continuous progress toward higher goals , ...\r\nmight be a good choice.</p>\r\n<h3 id=\"启发\">启发</h3>\r\n<p>The survey/chart serves as a good reminder of the importance of ...(a\r\nproductive life). In order to achieve ...,we should ...</p>\r\n<h1 id=\"素材\">素材</h1>\r\n<h2 id=\"主观动作\">主观动作</h2>\r\n<p><strong>情绪</strong></p>\r\n<p>I want to inform you of my dissatisfaction with ...</p>\r\n<p>I must complain about ...</p>\r\n<p>I beg to call your attention to the fact that ...</p>\r\n<p>To one’s dismay/surprise ...</p>\r\n<p><strong>行为</strong></p>\r\n<p>be/become increasingly aware of (the infinite power of ...)</p>\r\n<p>keep self-discipline, take full advantage of ...</p>\r\n<p>drifting with the tide is not advised 随波逐流</p>\r\n<p>take all factors into account/consideration and think twice before\r\nmaking a choice.</p>\r\n<h2 id=\"连接句\">连接句</h2>\r\n<h3 id=\"比较结构\">比较结构</h3>\r\n<p>coincident with A has been B<br />\r\n随着 A ... 与此同时 B ...</p>\r\n<blockquote>\r\n<p>Coincident with the developement of Chinese economy has been the\r\ngreat improvement of the education in China.</p>\r\n</blockquote>\r\n<p>it is not that ... but that ... 这并不是说 ... 而是 ...</p>\r\n<p>名词+or+名词 ... , 即 ...</p>\r\n<blockquote>\r\n<p>Technology includes techniques,or ways to do things.\r\n科技包括技艺，即制作方法。</p>\r\n</blockquote>\r\n<p>not ...(any) more than ... 不比 ... 怎样 正如 ... 一样不 ...</p>\r\n<blockquote>\r\n<p>The archaeologists' efforts are not directed at \"proving\" the\r\ncorrectness of the Bible any more than belief in Gog can be\r\nscientifically demonstrated.\r\n正如信仰上帝不能从科学证明一样，考古学家们的努力也不是为了“验证“《圣经》的正确性。</p>\r\n</blockquote>\r\n<p>not so much ... as ... 与其说 ... 不如说 ...</p>\r\n<blockquote>\r\n<p>Science moves forward,not so much through the insights of great men\r\nof genius as because of more ordinary things like improved techniques\r\nand tools. ... 与其说源于天才伟人的 ... 不如说源于更为普遍的 ...</p>\r\n</blockquote>\r\n<p>no less ... than ... 不但 ... 而且 ...</p>\r\n<p>other (...) than ... （ ... 中）除了 ...</p>\r\n<p>nothing but = nothing else than = nothing less than 不是而是</p>\r\n<p>to say nothing of 更不用说 ... （承接上文肯定或否定）</p>\r\n<p>cannot be too adj. ... 再 adj. 也不为过 （即不会太 adj.）</p>\r\n<blockquote>\r\n<p>We cannot be too faithful to our duties</p>\r\n</blockquote>\r\n<p>... only to ... 结果却 ... （与目的相反）</p>\r\n<p>(There be) no 主语 but 谓语 没有（否定谓语）的（主语） （but\r\n做否定关系代词，类似于 who not ，that not）</p>\r\n<blockquote>\r\n<p>There is no man but has his faults. 人皆有过</p>\r\n</blockquote>\r\n<p>sth. be the last thing that ... 决不会/决不至于。...sth</p>\r\n<blockquote>\r\n<p>Breach of promise is the last thing that he is likely to commit.\r\n违约是他决不会做的事</p>\r\n</blockquote>\r\n<h3 id=\"原因\">原因</h3>\r\n<p>...,Given ...</p>\r\n<blockquote>\r\n<p>The performance of American brand cars is to be expected,given their\r\nworldwide fame and reliable quality.</p>\r\n</blockquote>\r\n<h2 id=\"人物\">人物</h2>\r\n<p>kids on the verge of dropping out</p>\r\n<p>environmentally conscious people</p>\r\n<h2 id=\"利害\">利害</h2>\r\n<h3 id=\"客体优势\">客体优势</h3>\r\n<p>excellent performance</p>\r\n<p>drop in price, friendly price</p>\r\n<p>improved features, attractive appearance</p>\r\n<p>upgrading of technology , the promotion of innovation</p>\r\n<h3 id=\"提升自己\">提升自己</h3>\r\n<p>One should cultivate a broad knowledge base and keep abreast of\r\ncurrent events and issues.</p>\r\n<p>Moreover,be persistent.XXX learning is not a task that can be\r\naccomplished within a short time.Only with a lot of sustained efforts\r\ncan we improve our XXX skills.</p>\r\n<h3 id=\"个人益处\">个人益处</h3>\r\n<p>facilitate students' academic learning</p>\r\n<p>make new friends, learn new skills</p>\r\n<p>discover and grow 成长</p>\r\n<p>expand one's horizon</p>\r\n<p>learn to be independent</p>\r\n<p>This position will provide a challenging, stimulating and rewarding\r\ncareer opportunity</p>\r\n<h3 id=\"美德\">美德</h3>\r\n<p>working hard,honesty and integrity, persistence</p>\r\n","categories":["杂记"],"tags":["英语"]},{"title":"计算几何GDC2021记录","url":"/2021/10/10/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95GDC2021%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"iga-等几何分析\">IGA 等几何分析</h2>\r\n<p>用同样的表示语言去表示几何和物理场。\r\n比起有限元分析：避免了数据奇偶换，不存在几何离散误差，保证了 CAD\r\n几何的光滑性和高阶性质。</p>\r\n<ol type=\"1\">\r\n<li>曲面建模基础</li>\r\n</ol>\r\n<p>二项式展开 Bernstein 多项式 Bezier 曲线 B 样条 NURBS 非均匀有理 B\r\n样条</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>有限元求解</li>\r\n</ol>\r\n<p>弱约束：拉格朗日乘子法 罚函数法 Nitsche 方法</p>\r\n<p>刚度方程求解：线性——直接法和迭代法，非线性——牛顿迭代法。</p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>结构拓扑优化</li>\r\n</ol>\r\n<p>连续体结构拓扑优化：用物理意义的场函数来连续表示变化。 SIMP\r\n各向同性材料罚函数法</p>\r\n<p>为什么拓扑优化需要 IGA：计算几何与计算力学结合是未来趋势。用 CAD\r\n的样条基函数代替纯铜有限元的型函数</p>\r\n<p>结合的挑战：隐式几何描述丧失 IGA 几何造型能力，</p>\r\n<p>——&gt;显示几何拓扑优化+IGA：</p>\r\n<p>MMC，简单组件形成拓扑。组件可以形状和尺寸变化，组件相互覆盖可以改变拓扑，可变形组件描述：拉格朗日（横向长肉），欧拉</p>\r\n<p>MMV，基于 B 样条描述孔洞。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"计图深度学习\">计图深度学习</h2>\r\n<p><strong>元算子</strong></p>\r\n<p>18 个元算子，覆盖 TF 和 Pytorch 的 2000+算子的\r\n90%。大部分不用自己融合开发。</p>\r\n<ol type=\"1\">\r\n<li>重索引算子——一对多映射——广播</li>\r\n<li>重索引化简算子</li>\r\n<li>元素级算子——一对一映射，逐个元素运算</li>\r\n</ol>\r\n<p><strong>统一计算图</strong>——对动态图进行切分，保证一定性能</p>\r\n<p>可微渲染库 Jrender</p>\r\n<p>NeRF 渲染，性能差，将整个场景参数编码到网络。 改进版本\r\nRecursive-NeRF——递归神经场，不确定性预测，动态生长，性能更好。</p>\r\n<h3 id=\"点云\">点云</h3>\r\n<p><strong>困难</strong></p>\r\n<ol type=\"1\">\r\n<li>不规则</li>\r\n<li>无序性 点的存储矩阵可以任意交换顺序</li>\r\n<li>稀疏性</li>\r\n<li>旋转不变性<br />\r\n</li>\r\n<li>泛化性不太好</li>\r\n</ol>\r\n<p><strong>原则</strong></p>\r\n<ol type=\"1\">\r\n<li>排列不变</li>\r\n<li>聚合信息</li>\r\n<li>旋转不变</li>\r\n</ol>\r\n<p><strong>模型</strong></p>\r\n<ol type=\"1\">\r\n<li>PointNet, 没有层次结构的问题，没有局部邻域关系。</li>\r\n<li>PointNet++，解决——最远点采样 n/2，K 近邻采样，再通过 MLP\r\n聚合邻域信息。</li>\r\n<li>PointCNN，预测置换矩阵保证一定排列不变性。</li>\r\n<li>PointConv &amp; RS-CNN，</li>\r\n<li>DGCNN，不同之前 XYZ 找邻域，通过空间结构找邻域。</li>\r\n<li><strong>Transformer\r\n</strong>可能会比传统卷积更适合点云处理，但是需要深度定制。计图改造：Position\r\nembedding 补足局部信息，offset-attention\r\n原有的自注意力机制不适合处理点云。</li>\r\n<li><strong>PointContrast\r\n</strong>自监督学习，怎么利用没有标注的数据。</li>\r\n</ol>\r\n<p><strong>展望</strong></p>\r\n<p>处理点云的结构：CNN/Transformer/MLP 百家争鸣</p>\r\n<p>2D 数据预训练的模型迁移 3D，利用无标注数据。</p>\r\n<p>https://web.stanford.edu/~rqi/</p>\r\n<h3 id=\"网格学习\">网格学习</h3>\r\n<p>深度几何学习：多样的数据形式，特化的网格结构。</p>\r\n<ol type=\"1\">\r\n<li>数据表达简洁高效，对算力更友好。</li>\r\n<li>提供更完整的邻域信息。</li>\r\n</ol>\r\n<p><strong>关键</strong></p>\r\n<ol type=\"1\">\r\n<li>局部特征提取（卷积）：缺乏图像的规则结构</li>\r\n<li>层次特征聚合（Pooling）</li>\r\n</ol>\r\n<p><strong>模型</strong></p>\r\n<p>PointNet 架构，不适合</p>\r\n<p>GNN——离散 Laplacian/Dirac 算子，还是无法保证层次特征聚合。</p>\r\n<p>MeshCNN：边收缩构造层次结构</p>\r\n<p>SubdivNet：基于细分的网格卷积网络</p>\r\n<h2 id=\"兴趣论文\">兴趣论文</h2>\r\n<p>时空融合网络骨架手势识别 虚拟签名系统</p>\r\n<p>三维卷积，图卷积，点云分割</p>\r\n<p>点云关键点估计</p>\r\n<p>点云法向估计</p>\r\n<p>ACSCNN 各向异性卷积算子</p>\r\n<h2 id=\"杂项\">杂项</h2>\r\n<p>整车 CAE 分析：碰撞约束、驾驶员损伤分析、材料力学分析</p>\r\n<p>各种 CAE 理论数值方法的缺陷，以及高度的非线性。</p>\r\n<p>企业负担，不愿意迁移新系统</p>\r\n<p>汽车计算难点：计算效率，几何型面复杂，变形剧烈，多场耦合，交互迭代发展，没有几何清理工具</p>\r\n<p>基于虚几何修饰的网格生成：NURBS\r\n三线交化，背景网格封闭，网格点高速投影，超面的网格点修饰技术</p>\r\n<p>缺少 CAD\r\n可控的自主内核，脏几何问题，拓扑变换鲁棒性，复杂约束条件的适应性</p>\r\n<p>网格智能化，点云特征为输入特征探索三维网格</p>\r\n<p>航空发动机</p>\r\n","categories":["深度学习"]},{"title":"进击的论文","url":"/2021/12/03/%E8%BF%9B%E5%87%BB%E7%9A%84%E8%AE%BA%E6%96%87/","content":"<h3 id=\"flownet3d\">FlowNet3D</h3>\r\n<ul>\r\n<li>Liu X, Qi C R, Guibas L J. Flownet3d: Learning scene flow in 3d\r\npoint clouds[C]//Proceedings of the IEEE/CVF Conference on Computer\r\nVision and Pattern Recognition. 2019: 529-537.</li>\r\n<li>斯坦福</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://i.imgur.com/mRYyjkY.png\" alt=\"示意图\" />\r\n<figcaption aria-hidden=\"true\">示意图</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/XNT12QA.png\" alt=\"示意图\" />\r\n<figcaption aria-hidden=\"true\">示意图</figcaption>\r\n</figure>\r\n<h3\r\nid=\"pointweb-enhancing-local-neighborhood-features-for-point-cloud-processing\">PointWeb\r\nEnhancing Local Neighborhood Features for Point Cloud Processing</h3>\r\n<ul>\r\n<li>Zhao H, Jiang L, Fu C W, et al. Pointweb: Enhancing local\r\nneighborhood features for point cloud processing[C]//Proceedings of the\r\nIEEE/CVF Conference on Computer Vision and Pattern Recognition. 2019:\r\n5565-5573.</li>\r\n<li>MIT CSAIL</li>\r\n<li>CVPR</li>\r\n</ul>\r\n<p>PointWeb，一个新的抽取点云局部邻域上下文特征的方法。提出<strong>新的Adaptive\r\nFeature\r\nAdjustment(AFA)模块，着重于找到每个点与点之间的联系</strong>。在邻域中，通过adaptively\r\nlearned impact indicators\r\n每种特征都会受到其他特征的影响进行调整。这些调整后的特征都包含了邻域信息，因此可以有效帮助点云识别任务。在语义分割和形状分类上达到SOTA。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/zDYTehR.png\"\r\nalt=\"结构示意图：(a)PointNet++ (b)DGCNN (c)PointWeb\" />\r\n<figcaption aria-hidden=\"true\">结构示意图：(a)PointNet++ (b)DGCNN\r\n(c)PointWeb</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/y60T5Df.png\" alt=\"AKA模块示意图\" />\r\n<figcaption aria-hidden=\"true\">AKA模块示意图</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h3 id=\"position-and-rotation-invariant-sign-language\">Position and\r\nRotation Invariant Sign Language</h3>\r\n<p>Roy P, Bhattacharya S, Roy P P, et al. Position and Rotation\r\nInvariant Sign Language Recognition from 3D Point Cloud Data with\r\nRecurrent Neural Networks[J]. arXiv preprint arXiv:2010.12669, 2020.</p>\r\n<p>把手势看作3D深度图的时间序列（20个关节的3D坐标）。使用一个RNN作为分类器。并且使用一些几何变换来对深度图像矫正。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/PLFC2Xk.png\" alt=\"关节图\" />\r\n<figcaption aria-hidden=\"true\">关节图</figcaption>\r\n</figure>\r\n<h3\r\nid=\"一种改进的区域增长彩色3d点云分割算法\">一种改进的区域增长彩色3D点云分割算法</h3>\r\n<p>王雯, 任小玲, 陈逍遥. 一种改进的区域增长彩色 3D 点云分割算法[J].\r\n国外电子测量技术, 2018 (11): 10-14.</p>\r\n<p>选取局部邻域内法线间<strong>平均夹角最小的点</strong>作为种子点，减少了聚类类数，使得分割结果更加稳定。再次，在增长过程中，利用3D点云的彩色信息，将<strong>法线夹角和颜色差异小于某设定阈值的点聚为相同的类</strong>。最后，优化分割结果，检测过少或过多的聚类点数以避免过分割和欠分割。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/vvHyA9r.png\" alt=\"实验结果对比\" />\r\n<figcaption aria-hidden=\"true\">实验结果对比</figcaption>\r\n</figure>\r\n<h3 id=\"点云法向估计与匹配技术的研究-硕士\">点云法向估计与匹配技术的研究\r\n（硕士）</h3>\r\n<p>陈赫. 点云法向估计与匹配技术的研究[D]. 大连理工大学, 2018.</p>\r\n<p><strong>基于中心偏移的各向异性邻域构造的法向估计算法</strong>：在点的周围构造一种各向异性的邻域，而且该邻域的中心是偏离当前点的。这样，可以更好的区分来自不同曲面上的点，构造一种完全嵌入在单一光滑曲面的邻域，从而得到能真实反映当前点所在曲面信息的邻域，从而能够较好的保持特征。</p>\r\n<h3\r\nid=\"基于kinect的三维重建技术及算法研究硕士\">基于Kinect的三维重建技术及算法研究（硕士）</h3>\r\n<p>郭秋梦. 基于 Kinect 的三维重建技术及算法研究[D]. 西安工程大学,\r\n2018.</p>\r\n<p><strong>点云分割</strong>：RANSAC算法。首先，通过设置阈值的方式，将点云数据划分成内点和外点；其次，结合Hamming\r\n距离进行初始匹配，设置合适的角度和法向量两个约束条件以优化分割结果；再次，计算两个关键点之间的距离阈值以确保待分割点云表面特征的完整性，且不存在过度分割的问题；</p>\r\n<p><strong>点云拼接</strong>：基于改进ICP\r\n算法的点云拼接算法。该算法在选取特征点时，将坐标轴与阈值相结合，设定一个阈值约束候选点的搜索范围，以减少不必要的计算量。在此范围的约束条件下得到欧氏距离最近的点云数据集，并使用改进的ICP\r\n算法进行点云拼接。</p>\r\n<p><strong>三维重建</strong>：借助最小二乘法（Moving Least Squares,\r\nMLS）对数据进行观测和处理，完成三维重建的最后一步。首先，点云中的每个数据必须先使用法线估计算法进行预估；其次，对贪婪三角化算法、移动立方体算法、泊松曲面重建算法分别进行了介绍；再次，鉴于曲面重建算法对于三维重建高精度的要求，本文选择泊松曲面重建算法，通过对向量场进行定义，构造出泊松方程，借此求解出指示函数，将曲面重建问题转化为求解泊松方程的问题；最后，提取出等值面以完成曲面重建。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/KSk1j2H.png\" alt=\"泊松曲面重建效果\" />\r\n<figcaption aria-hidden=\"true\">泊松曲面重建效果</figcaption>\r\n</figure>\r\n<h3\r\nid=\"基于骨架提取的树木点云三维重建方法研究-硕士\">基于骨架提取的树木点云三维重建方法研究\r\n（硕士）</h3>\r\n<p><strong>点云去噪处理</strong></p>\r\n<p><strong>构建网格收缩算子</strong>，一般算子在进行网格收缩时，容易丢失网格模型狭长和尖锐处形态结构，特别是树木模型，为了充分保留原始模型的几何形状，<strong>曲率法线流算子</strong>是个很好的选择，它充分照顾到局部相邻点之间的空间位置联系。</p>\r\n<p><strong>构建局部网络</strong>，采用Deluanny三角剖分构建局部网格。以局部平面逼近全局网格的思想，通过由隐式方程对锚定点平滑来维持输入模型的全局形状。收缩点云以最小体积捕获输入的几何特征，提供最终曲线骨架位置的初始估计。</p>\r\n<p><strong>骨架提取</strong>：球采样和网格折叠。</p>\r\n","categories":["深度学习"]},{"title":"阅读：California Wildfire","url":"/2020/09/10/%E9%98%85%E8%AF%BB-California-Wildfire/","content":"<h1\r\nid=\"winds-fuel-wildfires-in-california-as-blazes-rage-across-us-west\">Winds\r\nfuel wildfires in California as blazes rage across US west</h1>\r\n<p>加州风燃野火，美国西部火灾肆虐</p>\r\n<figure>\r\n<img\r\nsrc=\"https://i.guim.co.uk/img/media/9eac650ea9b614ab4f67ef62a1a156e5b415fc19/0_299_5568_3341/master/5568.jpg?width=700&amp;quality=45&amp;auto=format&amp;fit=max&amp;dpr=2&amp;s=89029d62987a25df3294b21a6cef66e0\"\r\nalt=\"加州大火\" />\r\n<figcaption aria-hidden=\"true\">加州大火</figcaption>\r\n</figure>\r\n<p>Large, fast-moving fires <strong>raged</strong> on across the\r\nAmerican west on Wednesday, destroying hundreds of homes in the Pacific\r\nnorth-west and sending a dense <strong>plume</strong> of smoke that\r\nturned skies <strong>amber</strong> across parts of the region.</p>\r\n<p>周三，大规模的、扩散迅速的火灾在美国西部肆虐。火灾摧毁了太平洋西北部地区上百的房屋，并且生成了一股浓烟，以至于把这片地区的天空染成了琥珀色。</p>\r\n<p>More than 85 significant wildfires are burning across the west. In\r\nCalifornia, high, dry winds stoked dozens of out-of-control blazes that\r\nhave forced helicopter rescues and evacuations. In Washington, more\r\nacres burned in a single day than firefighters usually see all year, and\r\nthe fires <strong>scorched</strong> farming town of Malden. Fires also\r\nforced people to flee in Oregon and Idaho.</p>\r\n<p>整个西部发生了超过 85\r\n起严重的野外火灾。在加利福尼亚，高空干燥的大风燃起了数十起难以控制的火灾，以至于需要利用直升机进行救援和疏散。在华盛顿，消防员见过的单日燃烧面积比以往都要多。并且火灾把\r\nMalden 的农场燃烧殆尽。火灾也迫使在 Oregon 和 Idaho 的人们流离失所。</p>\r\n<span id=\"more\"></span>\r\n<p>“The geographic scale and intensity of what is\r\n<strong>transpiring</strong> is truly <strong>jarring</strong>,” wrote\r\nDaniel Swain, a <strong>climate</strong> scientist at the University of\r\nCalifornia, Los Angeles.</p>\r\n<p>“从地理学的角度，这次火灾的严重程度是让人震撼的，”洛杉矶的加州大学气候学家\r\nDaniel Swain 写道。</p>\r\n<p>“What’s remarkable is that there’s so many fires,” said Chris Field,\r\nwho directs the Stanford Woods <strong>Institute</strong> for the\r\nEnvironment. “Even as someone whose job is to understand what’s\r\nhappening, it’s really hard to keep up.”</p>\r\n<p>“特别是，发生了这么多起火灾。”斯坦福森林环境研究所的所长 Chris Field\r\n说道。“就算有人专职去了解发生了什么，也根本跟不上事情的发展。”</p>\r\n<p>In California, the Bear fire, which began in a remote northern region\r\nnot far from the town of Paradise, expanded by about a quarter-million\r\nacres over a 24-hour period. The blaze threatened the town of Oroville,\r\nwhere <strong>residents</strong> are under evacuation warnings just\r\nthree years after they were evacuated when heavy rains damaged the huge\r\nOroville dam.</p>\r\n<p>在加州，熊熊烈焰燃于一个距天堂镇东部不远的一个偏远地区，然后在 24\r\n小时之内扩大了大约 25 万英亩。火焰让 Oroville\r\n小镇的人们恐慌。那儿的居民在三年前因大雨摧毁了大 Oroville\r\n堤坝而被迫疏散，三年后又处于疏散警告当中。</p>\r\n<p>A vast cloud of smoke covered much of California on Wednesday,\r\ndimming the sun to an <strong>eerie</strong> orange\r\n<strong>glow</strong> in <strong>swathes</strong> of the region. “Smoke\r\nparticles scatter blue light and only allow yellow-orange-red light to\r\nreach the surface, causing skies to look orange,” the Bay Area Air\r\nDistrict said on Twitter.</p>\r\n<p>周三，一大股烟云遮蔽了加州大部分地区，甚至把大片地区的阳光染成了诡异的橘黄色。“烟雾粒子散射了蓝光，并且只允许黄-橘-红色的光到达地球表面，因此天空看起来就变橙色了。”海湾航空区在推特上说道。</p>\r\n<p>In Oregon, wildfires covering some 375,000 acres were distributed in\r\ncomplexes throughout the entire length of Cascade Mountains, with many\r\nmoving quickly towards its most populous cities. Blazes also sprung up\r\nin other forested areas in the state’s western third. Although no deaths\r\nhad been confirmed by emergency services by Wednesday afternoon, in a\r\n<strong>press conference</strong>, Governor Kate Brown told Oregonians\r\nto prepare for what could be “the greatest loss of life and structures\r\ndue to wildfire in state history”.</p>\r\n<p>在 Oregon，影响了约 375000 英亩的野火纷杂地分布在 Cascade\r\n山脉的全长中，并且其中有很多起火灾朝着其人口最稠密的城市蔓延。火焰也在这个州的西部三分之一地区的森林区域出现。尽管由于周三下午的紧急行动目前没有死亡案例，在一场新闻发布会上，Governor\r\nKate Brown 告诉 Oregon\r\n人做好心理准备，这将会是“整个州历史上死亡最多损失最大的野火。”</p>\r\n<p>By Wednesday afternoon, parts of at least seven counties were subject\r\nto evacuation orders, in communities scattered across the length of the\r\nstate, from the southern border to the Portland suburbs. These\r\nevacuations included much of the southern city of Medford (population\r\n82,000), half of Clackamas county, which <strong>comprises</strong> the\r\nsouth-eastern part of the Portland metropolitan area, and parts of\r\nWashington county, on the city’s west.</p>\r\n<p>到周三下午，至少七个县的部分地区被下达了疏散令。这些地区分布从南部边界到波特兰教区，遍布整个州。【这些疏散包括了\r\nMedford（人口 82000）的南部城市的大多数，Clackamas\r\n县的半数，其中包括波特兰市区的东南部，以及华盛顿县的西部的部分地区。】</p>\r\n<p>The wholly uncontained Santiam fire, meanwhile, had burned over\r\n159,000 acres by Wednesday, had forced evacuations in several small\r\nmountain communities, and sent thick smoke over the state capital,\r\nSalem, turning skies in the city blood red. As\r\n<strong>stretched</strong> fire crews struggled to contain the flames,\r\nthree prisons in Oregon were evacuated on Tuesday night.</p>\r\n<p>期间完全控制不住的圣地亚哥大火，直到周三已经燃烧了超过 159000\r\n英亩。迫使了数个小山区进行疏散，并且在州首府燃起了稀薄的烟雾，把天空染成了血红色。随着【大批】消防人员努力控制火势，Oregon\r\n的三个监狱得以在周二晚进行疏散。</p>\r\n<p>Throughout the region, firefighters have been racing to contain an\r\n<strong>onslaught</strong> of fire. The El Dorado fire in California’s\r\nSan Bernardino national forest had spread across 11,259 acres and was\r\n19% contained on Wednesday. The day before, 14 firefighters were\r\ntrapped, suffering burns. Three were critically injured, and are being\r\ntreated at a hospital in Fresno, the US Forest Service said.</p>\r\n<p>在整个地区，消防员一直都在努力和猛烈火势作斗争。在加州 San Bernardino\r\n国家森林 El Dorado 火灾已经扩散到了 11259 英亩，并且在周三有\r\n19%的火势被控制了。这天之前，14\r\n名消防员被困被烧。美国林业局称，有三名消防员严重烧伤，并且现在在 Fresno\r\n的医院中接受治疗。</p>\r\n<p>The Creek fire, in the Sierra national forest, remained out of\r\ncontrol, growing to nearly 153,000 acres and <strong>spurring</strong>\r\nthe evacuation of more than 30,000 people in Madera and Fresno counties.\r\nThe fire left dozens of campers and hikers <strong>stranded</strong> at\r\nthe Vermilion Valley Resort, after the only road, snaking along a steep\r\ncliff, was closed on Sunday.</p>\r\n<p>在 Sierra 国家森林的 Creek 大火，还是处于难以控制的状态，已经扩散到了\r\n153000 英亩，并且促使了在 Madera 和 Fresno 多县的超过 30000\r\n人的疏散行动。在周日，随着火灾使得 Vermilion Valley Resort\r\n的唯一一条蜿蜒悬崖小道被封锁，数十名露营者和远足者被困在了里面。</p>\r\n<p>A dramatic temperature <strong>plunge</strong>, caused by an\r\n<strong>intrusion</strong> of polar air, helped slow wildfires in\r\nColorado and Montana. Temperatures in Denver fell from over 100F (37.8C)\r\non Saturday to 33F (0.6C) on Tuesday. <strong>Searing</strong>\r\ntemperatures and orange, fire-tinged skies gave way to snow overnight,\r\nprompting Scott Dennings, a climate scientist at Colorado State\r\nUniversity, to caption before and after photos with a Robert Frost poem:\r\n“Some say the world will end in fire, / Some say in ice.”</p>\r\n<p>由于极地空气的入侵，一场突如其然的温度暴跌，有效减缓了 Colorado 和\r\nMontana 的火势。在周二，Denver 的温度从 100F（37.8℃）跌倒了\r\n33F（0.6℃）。灼热的温度和火染的天空在一夜之间下起了雪。这使得 Colorado\r\n州大学的环境科学家 Scott Dennings 给前后的照片加了个 Robert Frost\r\n的诗作为抬头：“Some say the world will end in fire, / Some say in\r\nice.”</p>\r\n<p>Although landscapes in California and much of the west are adapted to\r\nfire, global heating is driving more frequent and extreme fires. The\r\nmassive flames across the region are alarming, and\r\n<strong>unprecedented</strong>, “What we’ve been experiencing, we’ve\r\nbeen expecting,” Field said. Climate change has given rise to fires that\r\nbehave differently, burn more intensely and explosively and “are just\r\nharder for firefighters to fight”.</p>\r\n<p>尽管加利福尼亚的山水和绝大部分西部地区都适应了火灾，但是全球变暖还是带来了越来越多的大型火灾。在这整片区域的前所未有的大规模火灾让人震惊，“咎由自取”\r\nFiled\r\n说道，气候改变使火灾变得不太一样，火势更大、而且更具有爆发性，并且“对消防员来说很难扑灭”。</p>\r\n<p>Decades of fire suppression – wherein the US government put out\r\nwildfires that were beneficial to the landscape – have also driven\r\nlarger blazes. The government also <strong>criminalized</strong> the\r\nIndigenous practice of setting small intentional burns to clear out\r\nbrush and prevent more damaging, destructive burns. “The way we are\r\ninteracting with the ecosystems across the west is dramatically\r\ndifferent now,” Field said.</p>\r\n<p>数十年的火势抑制——数十年间美国政府总是扑灭对于环境有益的野外火灾——也让如今的火势变得更大。政府还把土著人故意引起小火灾清楚灌木丛，从而阻止更大更危险的火灾发生的行为定为犯罪。</p>\r\n<p>The wildfires this week came as the region suffers its second\r\nhistoric heatwave since August and widespread drought has dried out\r\nvegetation.</p>\r\n<p>这个星期，随着这个地区引来了它自八月以来第二高温的热浪，火灾再次发生了，并且随之大面积的干旱使植物完全枯死。</p>\r\n<p>California registered its first large fires this summer in\r\nmid-August, weeks ahead of peak fire season in the state, which comes in\r\nthe autumn, when powerful offshore winds have stoked some of the state’s\r\nbiggest, most dangerous blazes. The mid-August blazes were triggered by\r\nheat and a highly unusual <strong>bout</strong> of dry lightning.</p>\r\n<p>加州记载了它在这个夏季的八月中旬的最大的一场火，就在这个州的野火季几周前。野火季一般是在秋季，这时离岸向海的强风会燃起这个州最大最具危险的火灾。八月中的火灾是被温度和一阵高强度的不同寻常的干燥闪电。</p>\r\n<p>“The word ‘historic’ is a term we use often in the state of\r\nCalifornia, but these numbers bear fruit,” Gavin Newsom, the state’s\r\ngovernor, said on Tuesday, calling the challenge ahead\r\n“extraordinary”.</p>\r\n<p>“\r\n‘historic’这个词是一个在加州经常用得到的词，【并且这些数字也适合这个词。】”周二，州长\r\nGavin Newsom 说道，并且把将迎来的挑战称之为“无与伦比的”。</p>\r\n<p>“I have no patience for climate change deniers,” Newsom said. “That\r\nview is completely inconsistent with the reality on the ground, and the\r\nfacts of our experiences. You may not believe it, but our own\r\nexperiences tell a different story here in the state of California.”</p>\r\n<p>“对于拒绝承认气候变化的人，我没有任何耐心，” Newsom\r\n说道，“这副景观是的的确确和现实完全不一样，和我们的经验完全不一样。你可能不相信气候变化，但是此时此地加州的我们用经历告诉了你这个完全不一样的故事。”</p>\r\n<h1 id=\"词汇\">词汇</h1>\r\n<ul>\r\n<li>rage 狂怒；肆虐</li>\r\n<li>plume 羽毛；飘升物</li>\r\n<li>amber 琥珀色；琥珀</li>\r\n<li>scorched 烧焦</li>\r\n<li>transpiring 蒸腾；发生；发散；泄漏</li>\r\n<li>jarring 震撼</li>\r\n<li>climate 气候</li>\r\n<li>Institute 研究所；学院；学会</li>\r\n<li>residents 居民</li>\r\n<li>eerie 诡异</li>\r\n<li>glow 辉光；发光发热</li>\r\n<li>swathes 大片；绷带；裹</li>\r\n<li>press conference 新闻发布会</li>\r\n<li>comprises 包括</li>\r\n<li>stretched 广大的；极大需求 ...</li>\r\n<li>onslaught 猛攻</li>\r\n<li>spurring 刺激；带动</li>\r\n<li>stranded 困住；搁浅</li>\r\n<li>plunge 暴跌</li>\r\n<li>intrusion 入侵</li>\r\n<li>Searing 灼热的</li>\r\n<li>unprecedented 前所未有的</li>\r\n<li>criminalize 定罪</li>\r\n<li>indigenous 土著的；原生的</li>\r\n<li>bout 阵，短时间的一阵激烈运动</li>\r\n</ul>\r\n","categories":["杂记"],"tags":["英语"]},{"title":"阅读：California heatwave","url":"/2020/09/07/%E9%98%85%E8%AF%BB-California-heatwave/","content":"<h1\r\nid=\"californias-record-breaking-heatwave-sparks-wildfires-and-raises-health-concerns\">California's\r\nrecord-breaking heatwave sparks wildfires and raises health\r\nconcerns</h1>\r\n<p>加利福尼亚州破纪录的热浪引发了野火以及健康隐患</p>\r\n<p>California is <strong>sweltering</strong> under a record-breaking\r\nheatwave this holiday weekend, with dangerous conditions that have\r\nsparked several new wildfires and raised widespread public health\r\nconcerns.</p>\r\n<p>加州在这个周末迎来了破纪录的热浪，随之而来的是数起新的野外火灾，以及快速扩散的公共健康隐患。</p>\r\n<p>Triple-digit temperatures have spread over much of the state,\r\nincluding a record-high of 125F (52C) in Death Valley on Saturday. In\r\nsouthern California, Malibu authorities reported that one\r\n<strong>hiker</strong> died due to heat while on a trail in the Santa\r\nMonica Mountains.</p>\r\n<p>大多数州的温度已经到达了三位数，其中在周六 Death Valley\r\n到达了有史以来最高的 125F。在加州南部，Malibu\r\n当局报道称一名远足者热死在了 Saanta Monica Mountains 的一条小道上。</p>\r\n<p>The heat, coupled with a forecast of possible dry,\r\n<strong>gusty</strong> winds, has made for dangerous weekend fire\r\nweather, at a time when nearly 13,000 firefighters are currently\r\nbattling to contain nearly two dozen major fires around California.</p>\r\n<p>这个热度，加上预测可能有的干燥，阵风，合在一起构成了周末危险的火一般的天气。在此同时，有将近\r\n13000 名消防员正在和环绕加州的两打的大火作斗争。</p>\r\n<p>A wildfire that broke out near Shaver Lake in the Sierra National\r\nForest <strong>prompted</strong> <strong>evacuation</strong> orders\r\nSaturday as authorities urged people seeking relief from the heat wave\r\nto stay away from the popular lake. That <strong>blaze</strong>, called\r\nthe Creek fire, has burned 36,000 <strong>acres</strong>, trapping at\r\nleast 150 people near a <strong>reservoir</strong> in Fresno county and\r\ninjuring dozens who had to be airlifted to the hospital.</p>\r\n<p>一场在 Sierra 国家森林的 Shaver\r\n湖附近爆发的火灾，促使了周六的疏散令——当局要求想要从热浪中寻求放松的人们，远离那个著名的湖。那场叫做\r\nCreek fire 的火，已经燃烧了 36000 英亩，在 Fresno\r\n县的一个水库附近困住了至少 150\r\n个人，并且使数十人受伤以至于被空运到医院。</p>\r\n<span id=\"more\"></span>\r\n<p>In San Bernardino county east of Los Angeles, a fast-moving fire in\r\nthe foothills of Yucaipa forced the evacuation of Oak Glen, a farm\r\ncommunity that just opened its apple-picking season this weekend. A\r\nfast-moving fire in the San Diego area quickly grew to 1,500 acres on\r\nSaturday, prompting evacuations and destroying at least two homes.</p>\r\n<p>在洛杉矶东部的 San Bernardino 县，一场在 Yucaipa\r\n山麓移动迅速的大火，迫使 Oak Glen\r\n进行了疏散。那儿是一个农场区域，并且刚刚在周末迎来它的苹果采摘季。另一场在\r\nSan Diego 区域移动迅速的大火，在周六已经扩散到了 1500\r\n英亩，促使了当地的疏散，并且使至少两座房屋被摧毁。</p>\r\n<p>Families <strong>flocked</strong> to the beaches across southern\r\nCalifornia, where authorities closed parking lots after they filled to\r\ncapacity, and lifeguards reported massive crowds. Health authorities\r\nwarned that beaches could be closed if they become too crowded, due to\r\nconcerns about the spread of coronavirus, which the state continues to\r\nbattle.</p>\r\n<p>无数的家庭蜂拥而至南加州的海滩，在那儿政府关闭了载满的停车场，并且救生员不停地报道着大规模人群。政府健康部门警告如果沙滩变得太拥挤的话，由于对这个州仍在应对的新冠病毒的担心，沙滩很可能将要关闭。</p>\r\n<p>Gatherings during the Fourth of July weekend were blamed in part for\r\nCovid-19 spikes earlier this summer, and authorities have urged people\r\nto continue practicing social distancing and mask-wearing this weekend.\r\nIndoor gatherings are more dangerous, though the heat and poor air\r\nquality has made it difficult to be outside in some parts of California\r\nthis weekend.</p>\r\n<p>在 7 月 4 号的一场周末聚集，一定程度上是 Covid-19\r\n在这个夏季早期达到顶峰的始作俑者。并且政府督促人们在这个周末继续保持社交距离，并且带好口罩。室内聚会则是更加危险的，尽管这周末在加州几个地区，热度和较差的空气质量让人很难想着去户外。</p>\r\n<p>Campgrounds in the popular San Bernardino national forest east of LA\r\nwere also full, and <strong>rangers</strong> were out in force on\r\n<strong>“marshmallow</strong> patrols” – keeping an especially close\r\nwatch for campfires and barbecues outside of designated sites that pose\r\na potential risk of setting a wildfire.</p>\r\n<p>在洛杉矶东部著名的 San Bernardino\r\n国家森林中的露营也一样达到了爆满。并且出动了护林员以贯彻“棉花糖巡逻”——持续密切监控在规定区域以外的营火和烧烤，它们有着成为野外火灾的潜在风险。</p>\r\n<p>“On a day like today I’m glad I work inside and I can eat ice cream\r\nall day,” said Mai Emami, who said a steady number of customers were\r\ncoming to the Cup &amp; Cone Ice Cream shop in Woodland Hills to pick up\r\ntheir orders.</p>\r\n<p>“在一个像今天这样的一天，我很高兴我是在室内工作。并且我能一整天吃冰淇淋。”Mai\r\nEmami 说道。他说有稳定数量的消费者会来到在 Woodland 山脉的 Cup &amp;\r\nCone 冰淇淋店提取他们的订单。</p>\r\n<p>The heatwave has also raised concerns about power\r\n<strong>outages</strong>, with officials urging people to\r\n<strong>conserve</strong> electricity to ease strain on the state’s\r\npower grid.</p>\r\n<p>热浪也提升了电源断供的可能性，因此政府督促人们节约用电以减缓州电网的压力。</p>\r\n<p>The weather service predicted “brutally hot” temperatures through\r\nMonday as a high pressure system <strong>perches</strong> over the\r\nwestern US. Heat warnings were also in effect in Arizona and Nevada.\r\nDowntown Los Angeles reached 110F (43.3C) on Saturday. Temperatures in\r\ninland parts of the San Francisco Bay Area were <strong>soaring</strong>\r\nto the low 100s.</p>\r\n<p>天气服务部门在周一预测，由于美国西部上空悬浮的高压天气的停留，温度将会达到“酷热”的程度。热度警告在\r\nArizona 和 Nevada 也同样适用。洛杉矶市中心在周六达到了 110F\r\n华氏度。而在旧金山湾的内陆地区温度则飙升至【100 华氏度左右】。</p>\r\n<p>The extreme weather can also be <strong>brutal</strong> for people in\r\nCalifornia prisons, which have suffered major Covid outbreaks as well as\r\nterrible air quality from nearby fires.</p>\r\n<p>对于加州监狱的人来讲，这个极端天气更为残暴。他们经历了新冠病毒的爆发，并且经受了附近火灾的糟糕透顶的空气质量。</p>\r\n<p>The heatwave also poses significant challenges for the state’s large\r\nhomeless population, with thousands living outside in encampments and\r\ncars and other <strong>makeshift</strong> living quarters.</p>\r\n<p>随着成千上万的人在户外露宿生活、车旅生活以及在临时居住区生活，热浪也给这个州庞大的流浪人口问题带来了重大挑战。</p>\r\n<p>The Rev Andy Bales, president and CEO of Union Rescue Mission at Skid\r\nRow, the epicenter of LA’s homeless epidemic, said he told staff to hand\r\nout “the coldest of cold water bottles” to those coming by for to-go\r\nlunches over the weekend. “And I said if anyone comes to the door\r\noverheated and in peril, welcome them in,“ he said. “We do have an\r\nair-conditioned chapel.”</p>\r\n<p>Rev Andy Bales，联合救援团的主席兼首席执行官，在流浪者的中心 Skid Row\r\n说道他已经告诉工作人员分发“装着最冷的水的水瓶”给那些这周末想要过来吃午餐的人。“并且我也说了，如果任何人中暑或者处于危险，欢迎他们进来，”他说道，“我们确实有一个空调教堂。”</p>\r\n<p>Volunteers with the CHAM Deliverance Ministry in San Jose planned to\r\ndeliver bottled water and sports drinks to homeless people in Silicon\r\nValley.</p>\r\n<p>San Jose 的 CHAM\r\n运送部门以及相关志愿者，计划运送瓶装水和运动饮料给那些在 Silicon Valley\r\n的流浪者。</p>\r\n<p>“When it’s 105F and you’re living in a creek bed in a tent, it’s a\r\nlot of health issues out there. It’s a formula for disaster,” pastor and\r\nfounder Scott Wagers said.</p>\r\n<p>“当天气达到了 105\r\n华氏度，而你住在一个帐篷里的小床上，这将充满健康问题。这简直就是一个灾难的配方。”身为牧师的发起人\r\nScott Wagers 说道。</p>\r\n<h3 id=\"阅读原文\"><a\r\nhref=\"https://www.theguardian.com/us-news/2020/sep/06/california-dangerous-record-breaking-heatwave\">阅读原文</a></h3>\r\n<h1 id=\"词汇\">词汇</h1>\r\n<ul>\r\n<li>sweltering 闷热的</li>\r\n<li>hiker 远足者</li>\r\n<li>gusty 阵风的</li>\r\n<li>prompted 促使；激励；提示</li>\r\n<li>evacuation 遣散；疏散</li>\r\n<li>blaze 火焰；失火</li>\r\n<li>acres 英亩</li>\r\n<li>reservoir 水库</li>\r\n<li>flocked 蜂拥而至</li>\r\n<li>rangers 护林员；游骑兵</li>\r\n<li>marshmallow 棉花糖</li>\r\n<li>outages 断电</li>\r\n<li>conserve 保护</li>\r\n<li>perches 栖息；位于</li>\r\n<li>soaring 飙升</li>\r\n<li>brutal 野蛮的；残酷的</li>\r\n<li>makeshift 临时的</li>\r\n</ul>\r\n","categories":["杂记"],"tags":["英语"]},{"title":"阅读:Covid Children","url":"/2020/09/09/%E9%98%85%E8%AF%BB-Covid-Children/","content":"<h1\r\nid=\"fatigue-and-headache-most-common-covid-symptoms-in-children-study\">Fatigue\r\nand headache most common Covid symptoms in children – study</h1>\r\n<p>研究表明，疲劳和头痛是儿童最普遍的新冠感染症状</p>\r\n<p><strong>Fatigue</strong>, headache and fever are the most common\r\nsymptoms of coronavirus in children, with few developing a cough or\r\nlosing their sense of taste or smell, researchers have found, adding to\r\ncalls for age-specific symptom checklists.</p>\r\n<p>研究者们发现，疲劳、头痛和发烧是儿童感染新冠最普遍的症状，其中也有小部分会演变成咳嗽或者失去嗅觉或味觉。并且他们据此将这些症状添加到了根据年龄定制的症状检测清单中。</p>\r\n<p>The NHS lists three symptoms as signs of Covid-19 in adults and\r\nchildren: a high temperature, a new, continuous cough, and a loss or\r\nchange in the sense of smell or taste.</p>\r\n<p>NHS列举了三项成人和儿童的感染标志性症状：体温过高，突然的连续不断的咳嗽，和嗅觉或者味觉的变化或缺失。</p>\r\n<p>However, the team behind the Covid symptom study app say new data\r\nshows that the disease presents differently in children compared with\r\nadults.</p>\r\n<p>然而，在新冠症状学习app背后的团队称，新的数据显示儿童表现的症状和成人有所区别。</p>\r\n<span id=\"more\"></span>\r\n<p>“We need to start to telling people what are the key symptoms at\r\ndifferent ages rather than this <strong>blanket</strong>\r\n<strong>obsession</strong> with fever, cough and lack of smell,” said\r\nProf Tim Spector, of King’s College London, who led the work.</p>\r\n<p>“我们需要告诉人们什么年龄段有着什么样的关键症状，而不是死抓发烧、咳嗽和嗅觉丢失。”\r\napp项目的领导者，伦敦国王大学的Prof Tim Spector说道。</p>\r\n<p>The team’s latest findings are based on reports of symptoms among 198\r\nchildren who tested positive for the disease out of almost 16,000\r\ntested. Crucially, the team note, parents could have tested their\r\nchildren at the same time as they themselves took a test, meaning the\r\nchildren could have been tested even if they had no symptoms.</p>\r\n<p>这个团队最新发现是基于一个调查报告。这个调查在大约16000的儿童中，收集了198名检测阳性的儿童的症状。团队提到，至关重要的是，父母在他们自己进行检测的时候也可以同时给孩子进行检测，这意味儿童即使没有症状也会被检测。</p>\r\n<p>While a third of the children who tested positive showed no symptoms\r\n– adding weight to other work showing many infections are\r\n<strong>asymptomatic</strong> – the team say those who did showed a\r\ndifferent set of symptoms than adults.</p>\r\n<p>三分之一的测试阳性儿童没有任何症状——这表明很多感染是无症状的，给其他工作带来了更多的压力——团队称，他们确实表现除了和成人不一样的感染症状集。</p>\r\n<p>More than half of the Covid-positive children with symptoms – 55% –\r\nhad fatigue, while 54% had a headache and almost half had a fever.\r\n<strong>Sore</strong> throats were present in around 38% of the children\r\nwith symptoms, while almost 35% skipped meals, 15% had an unusual skin\r\n<strong>rash</strong> and 13% had <strong>diarrhoea</strong>.</p>\r\n<p>超过半数的新冠感染儿童有病状——55%，有疲劳症状，另外54%有头痛，并且绝大多数都会有发烧。有38%的有症状儿童呈现了喉咙痛的症状，35%的不想吃饭，15%的有不寻常的皮疹，13%有腹泻。</p>\r\n<p>By contrast, the team has found that the most common symptoms in\r\nadults are fatigue, headache, a persistent cough, sore throat and loss\r\nof smell.</p>\r\n<p>作为对比，这个团队发现在承认中最普遍的症状是疲劳、头痛、持续的咳嗽、喉咙痛以及嗅觉缺失。</p>\r\n<p>Spector noted that of children who tested positive and had symptoms,\r\naround a half didn’t have any of the three main signs listed by the\r\nNHS.</p>\r\n<p>Spector指出，有将近一半的检测阳性且有症状的儿童，没有表现出NHS列出的三大主要标志症状中的任何一个。</p>\r\n<p>“If you followed the government’s advice you’d be missing half of the\r\n[symptomatic] infections,” he said, adding that teachers and parents\r\nneeded to be aware that the virus can present differently in children\r\nand adults.</p>\r\n<p>“如果你听从政府的建议，你将会错失近半的有症状感染。”他说到。并且补充说老师和父母应该对病毒在成人儿童上有不同的症状而有所警觉。</p>\r\n<p>“What we want to do here is not push [children] to have tests, but\r\njust keep them away from school [if they show symptoms],” he said.</p>\r\n<p>“我们目前想要做的不是推动所有儿童去进行检测，而是如果他们有相关症状，则让他们远离校园。”他说道。</p>\r\n<p>While Spector noted some of the symptoms in children overlapped with\r\nthose for colds, which could become increasingly\r\n<strong>problematic</strong> as the winter months approach, other\r\nsymptoms, such as skin rashes, were unusual. The team have previously\r\nargued rashes should be added to the official list of symptoms, noting\r\nthat they also appear in adults with Covid.</p>\r\n<p>Spector指出儿童身上的一些感染症状和感冒很像，而随着冬季的到来这将越来越成为问题。另外一些症状，比如皮疹，则比较不寻常。团队在此之前就要求过将皮疹添加到官方的症状清单中，并且指出在感染新冠的成人中也有皮疹症状。</p>\r\n<p>“It is certainly as important as the other features, and in children\r\nit is much more important,” he said. “One in six children will have [a\r\nrash] and many times it will be the only sign, and you don’t get a funny\r\nrash with most coughs, colds [or] flus.”</p>\r\n<p>“皮疹完全和其他症状一样重要，并且在儿童中则更为突出。”他说，“1/6的儿童存在皮疹症状，并且很多时候是唯一症状。并且大多数咳嗽、着凉、流感都不会使你得了个疹子。”</p>\r\n<p>Spector said the difference in symptoms with age were probably down\r\nto differences in the way the immune system responded to the virus, and\r\nhe said the team were now calling for parents to track their children’s\r\nsymptoms on the app to help the team spot school outbreaks quickly.</p>\r\n<p>Spector称年龄间的症状差距可能是由于免疫系统对病毒的不同应对措施而造成的。并且他的团队目前正在要求父母们通过app及时跟踪他们孩子的症状，以帮助团队快速的识别校园疫情爆发。</p>\r\n<p>Dr Tom Waterfield of Queen’s University Belfast, who was not involved\r\nin the research, said the findings <strong>chimed with</strong> his own\r\nwork showing that symptoms such as fatigue, headaches and an upset\r\nstomach were common among children with Covid-19, while symptoms such as\r\ncoughs were rarer than in adults.</p>\r\n<p>没有参与到这项研究的贝尔法斯特女王大学的Tom\r\nWaterfield博士，说这些发现和他自己的研究工作相吻合。他的工作表明诸如疲倦、头痛、和胃部不适都是儿童感染新冠的普遍症状，另一方面像咳嗽之类的则比成人罕见的多。</p>\r\n<p>Dr Sanjay Patel, a <strong>paediatric</strong> infectious diseases\r\n<strong>consultant</strong> at Southampton children’s hospital cautioned\r\nthat while the NHS checklist would not mean all children with Covid were\r\ndetected, it still allowed school outbreaks to be spotted, while many of\r\nthe symptoms highlighted by the new study could be the result of a host\r\nof different illnesses, and keeping children home based on such signs\r\ncould be problematic.</p>\r\n<p>Southampton 儿童医院的儿童感染性疾病顾问，Sanjay\r\nPatel博士指出，NHS清单不会使所有新冠感染儿童得到检测，因此它仍会使校园疫情爆发。另一方面新研究强调的很多症状\r\n可能是多种疾病在一个宿主上共同作用的结果，只是根据这些症状就要把儿童隔离在家也是有问题的。</p>\r\n<p>“The harms of that approach are very <strong>tangible</strong>,” he\r\nsaid. “Many children would be missing a lot of school, and the majority\r\nof children being tested would still be negative.”</p>\r\n<p>“这种措施的不足是显而易见的，”他说到，“大量儿童将会错失大量校园时光，并且大多数儿童检测结果都是阴性的。”</p>\r\n<p>Prof Martin Marshall, the chair of the Royal College of GPs, welcomed\r\nthe study. “Understanding that children may exhibit symptoms that are\r\ndifferent to adults is useful in order for GPs and our teams, as well as\r\nour specialist paediatric colleagues, to identify the virus in children\r\nand respond appropriately,” he said.</p>\r\n<p>GPs皇家学院主席，Prof Martin\r\nMarshall，对这项研究表示支持。“明白儿童有着和成人不同的症状对GPs和我们的团队来说是很有帮助的。并且也有益于我们的儿科专家同事们，更好的是被儿童的感染情况，并做出合适的应对。”他说到。</p>\r\n<h1 id=\"词汇\">词汇</h1>\r\n<ul>\r\n<li>fatigue 疲劳</li>\r\n<li>blanket 毯子；完全的，总的，公共的</li>\r\n<li>obsession 痴迷；固执</li>\r\n<li>asymptomatic 无症状的</li>\r\n<li>sore 疮；溃痛</li>\r\n<li>rash 皮疹</li>\r\n<li>diarrhoea 腹泻</li>\r\n<li>problematic 有问题的；是问题</li>\r\n<li>chimed with 吻合</li>\r\n<li>paediatric 儿科</li>\r\n<li>consultant 顾问</li>\r\n<li>tangible 有形的；明确的；现实</li>\r\n</ul>\r\n","categories":["杂记"]},{"title":"阅读：Flood","url":"/2020/08/20/%E9%98%85%E8%AF%BB-Chinafloods/","content":"<h1\r\nid=\"china-floods-100000-evacuated-as-waters-reach-giant-buddha-statue\">China\r\nfloods: 100,000 <strong>evacuated</strong> as waters reach Giant\r\n<strong>Buddha</strong> statue</h1>\r\n<p>中国泛洪：水漫大佛像，十万余人撤离。</p>\r\n<p>Floods on the upper reaches of <strong>the Yangtze river</strong> in\r\nsouth-west China have forced authorities to evacuate more than 100,000\r\npeople and threatened a 1,200-year-old world heritage site.</p>\r\n<p>中国西南方长江上游的洪水，迫使政府撤离了十万余人，并且洪水威胁到了一个\r\n1200 多年的世界遗产。</p>\r\n<p>Staff, police and volunteers used sandbags to try to protect the\r\n71-metre (233ft) Leshan Giant Buddha, a <strong>Unesco</strong> world\r\nheritage site in the south-west Sichuan province, as muddy flood water\r\nrose over its <strong>toes</strong> for the first time since 1949, state\r\nbroadcaster CCTV reported.</p>\r\n<p>这是自 1949\r\n年以来浑浊的洪水第一次弥漫到佛脚，工作人员，警察，志愿者利用沙袋试图保护\r\n71 米高 (233\r\n英尺）的乐山大佛，它是一个在四川西南部的联合国教科文组织认定的世界文化遗产。</p>\r\n<p><span id=\"more\"></span></p>\r\n<p>However, the worst of the flooding appeared to be over in Sichuan by\r\nWednesday when the emergency level was lowered and the toes of a famous\r\n<strong>Buddhist</strong> statue <strong>re-emerged</strong> as waters\r\nreceded.</p>\r\n<p>然而，到了周三洪泛最恶劣的阶段似乎快要结束了。此时紧戒等级降低，并且随着退水大佛像的脚趾也重现露了出来。</p>\r\n<p>Five people were missing in neighbouring Yunnan province in the\r\nsouth-west after a landslide destroyed two houses, the official People’s\r\nDaily newspaper said.</p>\r\n<p>在西南邻接的云南，山体滑坡摧毁了两栋房子之后，有五个人失踪，人民日报的官方报道。</p>\r\n<p>In Sichuan, 21 <strong>vehicles</strong> parked in a square in Yibin\r\nfell into a hole after the road beneath them collapsed in the middle of\r\nthe night. No one was injured, according to media reports.</p>\r\n<p>根据媒体报道，在四川有21辆停在宜宾广场的汽车，在午夜他们下面的道路崩塌之后，坠入了塌陷的洞里，但是没有人受伤。</p>\r\n<p>Flooding has left more than 200 people dead or missing in China this\r\nyear and caused $25 billion in damage, authorities said last week.</p>\r\n<p>官方人员上周称，在中国今年以来，洪水至少造成了200人的死亡或失踪，并且造成了250亿的损失。</p>\r\n<p>Sichuan, through which the Yangtze river flows, raised its emergency\r\nresponse to the maximum level on Tuesday to <strong>cope with</strong> a\r\nnew round of <strong>torrential</strong> rainfall.</p>\r\n<p>长江流经的四川，在周二将它的紧急相应等级提到了最高，以应付新一轮的暴雨。</p>\r\n<p>The Yangtze water resources commission, the government body that\r\noversees the river, declared a red alert late on Tuesday, saying water\r\nat some monitoring stations was expected to <strong>exceed “guaranteed”\r\nflood protection levels by more than 5 metres.</strong></p>\r\n<p>政府监管长江的主体部门，长江水利委员会，在周二晚发表了一个红色警戒，宣称在一些监视站的水位预计会超过确保的防洪等级5米以上。</p>\r\n<p>Water inflows at the Three Gorges project, a major\r\n<strong>hydroelectric</strong> facility designed in part to\r\n<strong>tame</strong> floods on the Yangtze, rose to a record 72,000\r\ncubic meters (2.5 million cubic feet) per second on Wednesday, state\r\nmedia said. The inflow was expected to peak on Thursday at 76,000 cubic\r\nmeters per second, the ministry of water resources said.</p>\r\n<p>官方媒体表示，三峡工程，一个设计用来驯服长江流水的水力发电设施，周三的水流入量升至了创纪录的72000立方水（250万立方英尺）每秒。水利部宣称，而这个水流入量预计在周四达到76000立方水每秒的顶峰。</p>\r\n<p>The project restricts the amount of water flowing downstream by\r\nstoring it in its <strong>reservoir</strong>, which has been more than\r\n10 metres higher than its official warning level for more than a\r\nmonth.</p>\r\n<p>这个工程通过在水库蓄水限制了下游的水流量，而水库水位在至少一个月的时间里超出了官方警戒线十米以上。</p>\r\n<p>The facility was forced to raise water <strong>discharge</strong>\r\nvolumes on Tuesday in order to “reduce flood control pressures“, the\r\nwater ministry said.</p>\r\n<p>三峡设施在周二被迫提高了排水量，以减轻水位控制的压力，水利部说到。</p>\r\n<p>Authorities have been <strong>at pains to</strong> show that the\r\ncascade of giant dams and reservoirs built along the Yangtze’s upper\r\nreaches have shielded the region from the worst of the floods this year,\r\nthough critics say they might be making things worse.</p>\r\n<p>政府一直在努力表明，沿着长江上游修建的级联大坝和水库，在今年有效地保护了该地区免受洪水最恶劣的影响。尽管批评人士觉得他们可能只是把事情搞得更糟。</p>\r\n<p>The sprawling Yangtze river city of Chongqing saw its worst flooding\r\nsince 1981. Water covered roofs in low-lying areas of the historic town\r\nof Ciqikou, which was closed to tourists because of the rains from\r\nTuesday evening.</p>\r\n<p>重庆市的长江流域城区，见证了自1981年以来最恶劣的一次洪水。洪水淹没了历史名镇磁器口的低洼地带的屋顶。而这个景点也因为周二晚的暴雨对游客关闭。</p>\r\n<h3 id=\"阅读原文\"><a\r\nhref=\"https://www.theguardian.com/world/2020/aug/19/china-floods-100000-evacuated-as-waters-reach-leshan-giant-buddha-statue\">阅读原文</a></h3>\r\n<h1 id=\"词汇\">词汇</h1>\r\n<ul>\r\n<li>evacuated 撤离</li>\r\n<li>Buddha 佛；菩萨；浮屠</li>\r\n<li>the Yangtze river 长江</li>\r\n<li>heritage 遗产</li>\r\n<li>233ft 233 英尺</li>\r\n<li>Unesco 联合国教科文组织</li>\r\n<li>toes 脚趾</li>\r\n<li>Buddhist 佛教徒</li>\r\n<li>emerge 出现</li>\r\n<li>vehicles 汽车</li>\r\n<li>cope with 应付</li>\r\n<li>torrential 滂沱；滔滔</li>\r\n<li>Gorge 峡谷</li>\r\n<li>hydroelectric 水力发电</li>\r\n<li>tame 驯服</li>\r\n<li>reservoir 水库</li>\r\n<li>discharge 卸下；排出</li>\r\n<li>at pains to 竭尽所能</li>\r\n<li>sprawling 蔓延</li>\r\n</ul>\r\n","categories":["杂记"],"tags":["英语"]},{"title":"阅读：Dictionary Eliminate","url":"/2020/09/02/%E9%98%85%E8%AF%BB-Dictionary-Eliminate/","content":"<h1\r\nid=\"dictionary.com-revises-definitions-to-eliminate-prejudiced-language\">Dictionary.com\r\n<strong>revises</strong> definitions to eliminate prejudiced\r\nlanguage</h1>\r\n<p>Dictionary.com 修订了相关定义以消除偏见性语言</p>\r\n<p>Dictionary.com is making major changes to more than 15,000 of its\r\ndefinitions, from <strong>capitalising</strong> Black to updating\r\nentries about sexual orientation, aiming to foreground people over\r\n“<strong>clinical</strong> language”.</p>\r\n<p>Dictionary.com 正在对其超过 15000 项定义进行重大修订。从大写 Black\r\n到更新性取向相关条目都有所覆盖，旨在临床语言学上突出人群。</p>\r\n<blockquote>\r\n<p>capitalize Black，大写“Black”的“B”。查了下是因为 black\r\n通常是指黑色，但黑人种族肤色并不一定是黑色，因此用 black\r\n指代黑人种族不准确，创造了大写的 “Black” 和 “White” 以特指黑白种族。</p>\r\n</blockquote>\r\n<span id=\"more\"></span>\r\n<p>On Tuesday the website, which with 70m monthly users describes itself\r\nas the world’s leading digital dictionary, released what it called its\r\nlargest ever update.</p>\r\n<p>在周二，这个有着月活 7000\r\n万用户并且将自身描述为世界领先的数字字典的网站，发布了它自称有史以来最大的一次更新。</p>\r\n<p><strong>Across the board</strong>, Dictionary.com’s language\r\nreferring to LGBTQIA people has been revised to change “homosexual” to\r\n“gay” and “homosexuality” to “gay sexual orientation”, with the\r\ndictionary saying that the changes would put “the focus on people …\r\nremoving the implication of a medical <strong>diagnosis</strong>,\r\nsickness, or pathology when describing normal human behaviours and ways\r\nof being”.</p>\r\n<p>Dictionary.com 全面修订了有关 LGBTQIA\r\n群体的语言，从“homosexual”修改成“gay”，从“homosexuality”修改成“gay\r\nsexual\r\norientation”。这个网站认为这些改变能够：“使这些词汇重点突出人群本身 ...\r\n消除了在描述正常人行为时，医学诊断、疾病或者是病理方面的偏见影响。”</p>\r\n<p>It has also capitalised Black, a change that affects hundreds of\r\nentries, in what it said was “a mark of respect and recognition that’s\r\n<strong>in line with</strong> capitalising other cultures and\r\n<strong>ethnicities</strong>”. And it has added a separate entry for\r\nBlack, as it refers to a person, a move that breaks with dictionary\r\nconventions to group together words that share the same origin.</p>\r\n<p>它也将“Black”进行了大写化，而这个更改影响了上百的条目，其中它认为这是\r\n“一个尊重和认可的标记，就和大写化其他文化和种族一样。”【并且对于 Black\r\n指代的是一个人时】，它也给 Black\r\n添加了一个独立的条目。而这是一项打破字典传统【以将同源的词汇聚集起来的举动。】</p>\r\n<p>“This change reflects Dictionary.com’s point of view that language\r\nentries have consequences and go beyond being simply an academic\r\nexercise,” it said.</p>\r\n<p>“这个改变映射了 Dictionary.com\r\n的观点——语言条目会产生相关影响，而不止是简单的学术活动。” Dictionary.com\r\n说道。</p>\r\n<p>Another major revision updates language used around suicide and\r\naddiction, with use of the phrase “commit suicide” removed and replaced\r\nwith “die by suicide” or “end one’s life”, while instances of “addict”\r\nas a noun are replaced with “person addicted to” or “habitual user of”.\r\nIt said the changes were intended to eliminate language that implied\r\nmoral judgment or <strong>incorporated</strong> historical\r\nprejudice.</p>\r\n<p>另一个大型修订是更新了有关自杀和上瘾的相关语言。移除了 commit suicide\r\n并且用 die by suicide 或者是 end one's life 替代。另一方面 addict\r\n作为名词的示例中，用了 person addicted to 或者 habitual user of\r\n进行替代。Dictionary.com\r\n认为，这些改动能够消除语言上暗喻的道德评判和汇聚的历史上的偏见。</p>\r\n<p>“2020 has been a year of change like never before, affecting how we\r\nlive, work, interact – and how we use language,” said Jennifer\r\nSteeves-Kiss, chief executive of Dictionary.com. “Our biggest release\r\nyet represents a <strong>tireless</strong> commitment from our entire\r\nteam not only to documenting how language evolves, but to ensuring our\r\nusers always find the meaning they need.”</p>\r\n<p>“2020\r\n貌似是一个从未有过的变动之年，影响到了我们怎么去活着、工作、交互——以及怎么去使用语言，”Jennifer\r\nSteeves-kiss，Dictionary.com\r\n的首席执行官说道，“我们有史以来最大的发行版本，后面代表的是我们整个团队不知疲倦地奉献。【不仅仅是为了记录语言的演变，而是确保我们的用户总是能找到他们需要的意思。”】</p>\r\n<p>Along with the revisions, Dictionary.com has added 650 new entries,\r\nfrom words relating to race and ethnicity (such as Afro-Latina and\r\nAfro-Latino) to those reflecting environmental issues (such as\r\n<strong>ecoanxiety</strong>) or sexuality (such as ace, referring to\r\nasexuality). <strong>Abbreviations</strong> used on social media, such\r\nas af (“as fuck; to a great degree”), DGAF (“to not care at all; a\r\n<strong>euphemistic</strong> <strong>initialism</strong> used to\r\nindicate an indifferent or unbothered attitude, without\r\n<strong>explicit</strong> vulgarity”), and slang terms such as jabroni\r\n(“a stupid, foolish, or <strong>contemptible</strong> person; loser”)\r\nand janky (“untrustworthy; disreputable”) have also been added.</p>\r\n<p>随着修订的进行，Dictionary.com 添加了 650\r\n条新条目，其中从种族相关（例如非裔拉丁美洲人）到那些映射环境问题的词（例如生态焦虑），以及性相关词（例如\r\nace，指代着无性恋）。在社交媒体上用的缩略词，例如 af（as\r\nfuck；在很大程度上），DGAF（一点也不关心；一种没有明面上粗语的委婉缩写，用于指出冷漠无所谓的态度）。以及一些俗语，例如\r\njabroni（一个愚蠢，憨憨，可鄙的人；失败者）和\r\njanky（靠不住；声名狼藉）也被加入到条目中。</p>\r\n<p>“The work of a dictionary is more than just adding new words. It’s an\r\nongoing effort to ensure that how we define words reflects changes in\r\nlanguage – and life,” said senior editor John Kelly. “Among our many new\r\nentries are thousands of deeper, dictionary-wide revisions that touch us\r\non our most personal levels: how we talk about ourselves and our\r\nidentities, from race to sexual orientation to mental health. Our\r\nrevisions are putting people, in all their rich humanity, first, and\r\nwe’re extremely proud of that.”</p>\r\n<p>“一个字典的工作不仅仅是添加新词。它应不停努力确保我们对词汇的定义反映着语言和生活上的变化，”高级编辑\r\nJohn Kelly\r\n说道，“在我们的许多新条目之中，有上千个深入的，全字典范围性的修订，这些修订触动了我们最人性的那部分：我们怎么谈论我们自己，我们的身份，从种族、性取向到精神健康。【我们的修订将人类丰富的人性赋予了人，而且是首位。】我们对此十分自豪骄傲。”</p>\r\n<h3 id=\"阅读原文\"><a\r\nhref=\"https://www.theguardian.com/books/2020/sep/01/dictionarycom-revises-definitions-eliminate-prejudiced-language\">阅读原文</a></h3>\r\n<h1 id=\"词汇\">词汇</h1>\r\n<ul>\r\n<li>revises 修订</li>\r\n<li>capitalize 大写</li>\r\n<li>clinical 临床的；冷漠的</li>\r\n<li>Across the board 全面</li>\r\n<li>diagnosis 诊断</li>\r\n<li>ethnicities 种族</li>\r\n<li>in line with 符合</li>\r\n<li>incorporated 合并</li>\r\n<li>tireless 不知疲倦的</li>\r\n<li>ecoanxiety 生态焦虑</li>\r\n<li>Abbreviations 缩略语</li>\r\n<li>euphemistic 委婉的</li>\r\n<li>initialism 首字母缩写</li>\r\n<li>explicit 显性的；清晰的；直率的</li>\r\n<li>contempt 鄙视</li>\r\n</ul>\r\n","categories":["杂记"],"tags":["英语"]},{"title":"阅读：Fall Guys","url":"/2020/09/08/%E9%98%85%E8%AF%BB-Fall-Guys/","content":"<h1\r\nid=\"fall-guys-fortnite-meets-its-a-knockout-in-uk-video-game-hit\">Fall\r\nGuys: Fortnite meets It's a Knockout in UK video game hit</h1>\r\n<p>《糖豆人》：堡垒之夜遇见了来自英国游戏业的“It's a Knockout”的冲击</p>\r\n<p>Fat little jelly beans playing a <strong>neon-coloured</strong>\r\nversion of the <strong>cult</strong> classic gameshow Takeshi’s Castle\r\nmight not sound like the British answer to the craze that is Fortnite,\r\nbut tens of millions of people have downloaded the London-made hit Fall\r\nGuys in less than a month since its release.</p>\r\n<p>以肥肥点点的糖豆人形象游玩一个霓虹色版本的狂热经典游戏秀 《Takeshi's\r\nCastle》，这可能听起来不像英国人对堡垒之夜热潮的有力武器。但是在其发行了不超过一个月的情况下，超千万的玩家已经下载了这个伦敦出品的大热门《糖豆人》。</p>\r\n<span id=\"more\"></span>\r\n<p>“When you’re designing games you want to give people an experience\r\nthey’ve never felt before,” says its lead designer, Joe Walsh. “And for\r\nus, it was a middle-aged slightly <strong>unwieldy</strong> Japanese\r\nbusinessman, on the sideline of a giant obstacle course that he has\r\nabsolutely no right attempting.”</p>\r\n<p>“当你正在设计一个游戏时，你会想要它带给人们一种前所未有的体验，”它的首席设计师Joe\r\nWalsh说道，“对我们来说，我们想要的体验就是，一个中年的日本商人，笨拙憨憨地跑在一个巨大的四处碰壁的障碍物竞赛的路上。”</p>\r\n<p>The resulting game is a joy. Like its predecessor, it sees a huge\r\nnumber of players competing in ever-smaller numbers to be the last one\r\nstanding; similar too is its explosion in popularity, becoming the most\r\ndownloaded game on Sony’s PlayStation Plus (PS+) online service ever,\r\nbeating Fortnite on Twitch, and gathering celebrity fans too: Manchester\r\nCity’s Sergio Agüero scoring a goal in one of Fall Guys’ minigames\r\nprovided an early boost, as did F1 driver Lando Norris.</p>\r\n<p>最终成品游戏是一个欢乐向。就像它的前辈一样，一方面它的每场比赛拥有数量众多的玩家同时竞争，随着存留人数越来越少，最终留下最后一个赢家。另一方面，它也是在玩家数上有着爆炸式的增长，直接成为了PS+在线服务有史以来下载最多的游戏，在Twitch上和堡垒之夜同台竞争，并且也收获了众多名人簇拥：曼城的Sergio\r\nAgüero\r\n在《糖豆人》早期的小游戏中进了的那个球，给这个游戏带来了早期的爆发。F1赛手Lando\r\nNorris也是一样。</p>\r\n<p>But where most popular “Battle Royale” games are fundamentally a\r\n<strong>vicious</strong>, weapons-<strong>laden</strong> contest to kill\r\nor be killed, Fall Guys has carved its own niche. Players are thrown\r\ninto a series of mini games straight out of the team’s gameshow\r\ninspiration – or, for older readers, the inflatable-filled obstacle\r\ncourses of It’s a Knockout.</p>\r\n<p>虽然最热门的“大逃杀”游戏都是基于一个狠毒的、全副武装的互相击杀的竞赛，《糖豆人》在其中找到了自己的细分市场。玩家们被扔进一系列的迷你游戏中——这是来自那个游戏秀的直接灵感。或者对年长的读者来说，这个充气式障碍竞赛更像是来自于《It's\r\na Knockout》。</p>\r\n<p>Each round, the worst players are eliminated, perhaps for falling off\r\nthe rotating <strong>cylinder</strong>, failing to run a gauntlet of\r\n<strong>see-saws</strong> fast enough, or being a member of the team\r\nwhich has gathered the fewest eggs in a life-size version of Hungry\r\nHungry Hippos.</p>\r\n<p>每一轮，表现最差的玩家都会被淘汰。可能是因为从圆筒上滚落，可能是因为没有足够快的通过跷跷板，又或者是因为他的团队在真人版的《Hungry\r\nHungry Hippos》中收集了最少的蛋。</p>\r\n<p>Crucially, whether you win or lose, the experience is\r\n<strong>hilarious</strong>. Much of the credit goes to the\r\n<strong>eponymous</strong> Fall Guys themselves – though better known by\r\nthe community as “Jelly Beans”. Squat little ovoids, their design was\r\nplanned from the ground up for physical comedy, Walsh says. “Having\r\nlittle legs is funnier, because they fall over; having big arms is\r\nfunnier because they throw them in the air as they get hit by something\r\nand go flying. They need to be <strong>padded</strong> so that they\r\n<strong>bounce</strong>, because bouncing stuff is funnier.”</p>\r\n<p>最重要的一点，不论你赢了还是输了，这场体验都是欢快的。【大部分的赞扬都给到了同名的“Fall\r\nGuys”——尽管在圈子中它更多被叫做《糖豆人》】。矮小的蛋形，他们的设计是以物理搞笑为目的从头开始的。Walsh说道：“小短腿会很有意思，因为他们会摔翻天；有个大大的胳膊也好玩，这样他们被啥东西打上天之后可以飞起来。他们应该是被填充了的，这样他们走起来就是蹦蹦哒哒的，而且这样很好笑。”</p>\r\n<p>Created by just 48 people, largely from developer Mediatonic’s London\r\nstudios, the game was nearly thrown off course by the Covid lockdown,\r\nwhich forced staff home just as the two-year development was reaching\r\nits crucial final stages. But they <strong>persevered</strong>, and when\r\nthe game launched in early August, had high hopes.</p>\r\n<p>仅由48人开发，大部分是Mediatonic的伦敦工作室的开发者的这个游戏，在新冠封锁期间几乎被搁置了。因为新冠期间强制在家办公，而此时这个长达两年的开发正在它最紧要的冲刺阶段。但是他们坚持了下来，并且当这个游戏在八月早期正式发售的时候，他们有着很高的期望。</p>\r\n<p>The game had been selected by Sony for free distribution on PS+, a\r\n£50-a-year subscription service, which would hopefully push it over a\r\ncrucial barrier for any multiplayer experience: ensuring enough players\r\nare actually online for people to find a match. Beyond that, though, was\r\na mystery. “We were hopeful that if we could get, I think, maybe 100,000\r\nsales that would be considered a great success,” Walsh says. “And now\r\nwe’re into multiple millions.”</p>\r\n<p>这个游戏被索尼的PS+免费分发选中了——PS+是一个50英镑一年的订阅服务，而这被寄希望让这个游戏度过每个多人游戏最至关重要的困难：确保有足够多的玩家在线匹配。【除此之外，还有一个奇怪的地方。】“我们当初期望有，大概100000份的销量，这已经算是一个巨大的成功了。”Walsh说道，“然而现在我们已经翻了百万倍。”</p>\r\n<p>With that success has come problems, some difficult for a small team\r\nto handle. “We knew that probably our first weekend after launch was\r\ngoing to be the critical weekend,” Walsh says, “and we had plans for how\r\nmany people we thought we were going to have.” But by the Monday before\r\nthat, they were already seeing triple the players they had hoped for,\r\nsparking a mad rush to try and ensure their servers could keep up with\r\nthe inflated demand. In the end, they managed to ensure that the game\r\nwas working more than 90% of the time in that crucial first week.</p>\r\n<p>成功了，问题也随之而来，而且是一些小团队很难解决的问题。“我们知道在发行一周后的首个周末可能将会是一个生死攸关的周末。”Walsh说道，“并且我们根据我们大概会有多少玩家进行了相应的规划。”但是在此之前的周一，他们已经看到了三倍期望的玩家数，于是点燃了一股疯劲努力确保服务器能够跟得上膨胀的需求。在最终，他们设法确保了在这个至关重要的首周游戏能够正确运行超过90%的时间。</p>\r\n<p>The massive success also brought unexpected demands. The team had\r\nlong planned for players to be able to buy <strong>outfits</strong> to\r\ndress their beans up in – a standard <strong>monetisation</strong>\r\ntechnique for multiplayer games – but the success on social media\r\nprompted a <strong>deluge</strong> of requests from brands for\r\nsponsorship. Instead of going the profitable route, the team opened up\r\none costume slot for <strong>auction</strong> for charity; the contest,\r\nwhich ends on Monday, has so far raised more than $420,000 for the\r\naccessibility charity Special Effect.</p>\r\n<p>这个超大的成功也带来了没考虑过的需求。团队有着长期的运营计划，以使玩家可以买服装打扮他们的小人——这是一个标准的多人游戏营利手段——但是由于在社交媒体上的爆火，品牌商蜂拥而至想要赞助。与走向利益最大化的路线相反，团队开放了一个慈善拍卖的插件；在周一结束的比赛中，已经为无障碍慈善“Special\r\nEffect”筹集了超过420,000 美元。</p>\r\n<p>Getting to the top is one thing, staying there is another, and\r\nMediatonic has a long road ahead to provide enough regular new content\r\nto stay current in the minds of <strong>fickle</strong> gamers. But for\r\nnow, Walsh is happy with his team’s achievements: “Good, wholesome\r\nBritish comedy, on a scale that has brought a lot of joy, a lot of\r\ncolour and a lot of <strong>distraction</strong> to people’s lives.”</p>\r\n<p>到达巅峰是一方面，能保持在巅峰则是另一方面。Mediatonic还有很长的路要走，他们要提供足够多的定期更新的新内容来留住现在这些善变的玩家的心。“很棒，健康的英国喜剧，某种程度上来说给人们的生活带来了无数的欢乐、色彩、波澜。”</p>\r\n<h3 id=\"阅读原文\"><a\r\nhref=\"https://www.theguardian.com/games/2020/aug/28/fall-guys-fortnite-meets-its-a-knockout-in-uk-video-game-hit\">阅读原文</a></h3>\r\n<h1 id=\"词汇\">词汇</h1>\r\n<ul>\r\n<li>neon-coloured 霓虹色</li>\r\n<li>cult 狂热</li>\r\n<li>unwieldy 笨重的；不灵巧的</li>\r\n<li>vicious 狠毒的；恶毒的</li>\r\n<li>laden 满载</li>\r\n<li>cylinder 圆筒；柱面；气缸</li>\r\n<li>see-saws 跷跷板</li>\r\n<li>hilarious 搞笑的；滑稽的</li>\r\n<li>eponymous 同名的</li>\r\n<li>padded 被填充的</li>\r\n<li>bounce 蹦跶；弹跳</li>\r\n<li>persevered 坚持</li>\r\n<li>outfits 服装</li>\r\n<li>monetisation 营利</li>\r\n<li>deluge 洪水；泛滥</li>\r\n<li>auction 拍卖</li>\r\n<li>fickle 善变的</li>\r\n<li>distraction 使人分心的事情；极端情绪</li>\r\n</ul>\r\n","categories":["杂记"],"tags":["英语"]},{"title":"阅读：Global Heating","url":"/2020/08/24/%E9%98%85%E8%AF%BB-Global-Heating/","content":"<h1\r\nid=\"earth-has-lost-28-trillion-tonnes-of-ice-in-less-than-30-years\">Earth\r\nhas lost 28 trillion tonnes of ice in less than 30 years</h1>\r\n<p>在不到 30 年里，地球已经失去了 28 万亿吨冰</p>\r\n<p>A total of 28 <strong>trillion</strong> tonnes of ice have\r\ndisappeared from the surface of the Earth since 1994. That is stunning\r\nconclusion of UK scientists who have analysed satellite surveys of the\r\nplanet’s poles, mountains and <strong>glaciers</strong> to measure how\r\nmuch ice coverage lost because of global heating triggered by rising\r\ngreenhouse gas <strong>emissions</strong>.</p>\r\n<p>自从 1994 年以来，地球表面总计消失了 28\r\n万亿吨的冰。英国科学家们，分析了卫星关于地球两极，山脉，冰川的探测数据，以测量温室气体排放量上升导致的全球变暖引起了多少冰覆盖面积的损失，最终得出了这个惊人的结论。</p>\r\n<span id=\"more\"></span>\r\n<p>The scientists – based at Leeds and Edinburgh universities and\r\nUniversity College London – describe the level of ice loss as\r\n“<strong>staggering</strong>” and warn that their analysis indicates\r\nthat sea level rises, triggered by melting glaciers and ice sheets,\r\ncould reach a metre by the end of the century.</p>\r\n<p>来自 Leeds and Edinburgh universities 和 University College London\r\n的科学家们，将这种程度的冰损失称为“惊人的”。并且警告，他们的分析结果表明，冰川和冰盖的融化会引起在世纪末可达一米高度的海平面上升。</p>\r\n<p>“To put that in <strong>context</strong>, every centimetre of sea\r\nlevel rise means about a million people will be displaced from their\r\nlow-lying homelands,” said Professor Andy Shepherd, director of Leeds\r\nUniversity’s Centre for Polar Observation and Modelling.</p>\r\n<p>“具体放在情境中来讲，每一厘米的海平面上升都会导致百万低洼地带的人民流离失所。”。Leeds\r\n大学的两极观察和建模中心主任，Andy Shepherd 教授说到，</p>\r\n<p>The scientists also warn that the melting of ice in these quantities\r\nis now seriously reducing the planet’s ability to reflect solar\r\nradiation back into space. White ice is disappearing and the dark sea or\r\nsoil exposed beneath it is <strong>absorbing</strong> more and more\r\nheat, further increasing the warming of the planet.</p>\r\n<p>科学家们还警告称，这种数量级的冰融化正在严重地降低地球反射太阳辐射回太空的能力。白色的冰正在消失，而在其之下的黑色的海面或者是土壤正在吸收越来越多的热量，进而加剧了全球变暖。</p>\r\n<p>In addition, cold <strong>fresh water</strong> pouring from melting\r\nglaciers and ice sheets is causing major disruptions to the biological\r\nhealth of Arctic and Antarctic waters, while loss of glaciers in\r\nmountain ranges threatens to <strong>wipe out</strong> sources of fresh\r\nwater on which local communities depend.</p>\r\n<p>另外，冰川冰盖消融的冷淡水的倾泻，正在对南北极水域的生态健康造成严重破坏，另一方面山脉冰川的流失，也危及着当地生态圈赖以生存的淡水源。</p>\r\n<p>“In the past researchers have studied individual areas – such as the\r\nAntarctic or Greenland – where ice is melting. But this is the first\r\ntime anyone has looked at all the ice that is disappearing from the\r\nentire planet,” said Shepherd. “What we have found has stunned us.”</p>\r\n<p>“在之前，研究者们调查了个别冰正在消融的地区——例如南极和格陵兰岛。但是，这是第一次有人统计了从这个星球上消失的所有冰，”\r\nShepherd 说道，“而随之而来的结论震惊到了我们。”</p>\r\n<p>The level of ice loss revealed by the group matches the\r\nworst-case-<strong>scenario</strong> predictions outlined by the\r\nIntergovernmental Panel on Climate Change (IPCC), he added.</p>\r\n<p>他称，“这个团队揭示出的冰块消融程度，也大致上符合政府间气候变化委员会作出的最坏情景预测。”</p>\r\n<p>The group studied satellite surveys of glaciers in South America,\r\nAsia, Canada and other regions; sea ice in the Arctic and Antarctic; ice\r\nsheets that cover the ground in Antarctica and Greenland; and\r\n<strong>ice shelves</strong> that <strong>protrude</strong> from the\r\nAntarctic mainland into the sea. The study covered the years 1994 to\r\n2017.</p>\r\n<p>这个团队调查了，来自南美、亚洲、加拿大和其他国家的卫星冰川探测数据；南北极的海冰数据；南极和格陵兰岛的冰盖数据；以及从南极主板块向海面突出的冰架。这个调查涵盖了1994至2017年。</p>\r\n<p>The researchers’ conclusion is that all the regions have suffered\r\n<strong>devastating</strong> reductions in ice cover in the past three\r\ndecades and these losses are continuing.</p>\r\n<p>这些研究者的结论表明，在过去的三十年中，所有国家都存在毁灭性的冰盖减少，并且如今仍在继续发生。</p>\r\n<p>“To put the losses we’ve already experienced into context, 28\r\ntrillion tonnes of ice would cover the entire surface of the UK with a\r\nsheet of frozen water that is 100 metres thick,” added group member Tom\r\nSlater from Leeds University. “It’s just mind-blowing.”</p>\r\n<p>“这些我们已经经受的损失具体来看，28万亿吨的冰，能够以100米的厚度的大冰盖的形式覆盖整个英国表面，”\r\nLeeds 大学的团队成员Tom Slater 补充道，“这是十分让人难以置信的。”</p>\r\n<p>As to the cause of these staggering losses, the group is\r\n<strong>adamant</strong>: “There can be little doubt that the vast\r\nmajority of Earth’s ice loss is a direct consequence of climate\r\nwarming,” they state in their review paper, which is published in the\r\nonline journal Cryosphere Discussions.</p>\r\n<p>至于这惊人损失的始作俑者，团队坚定不移地认为：“毫无疑问，地球巨量的冰损失是全球变暖的一个直接结果，”\r\n在网络杂志Cryosphere Discussions出版的一篇采访文章中，他们这样说明。</p>\r\n<p>“On average, the planetary surface temperature has risen by 0.85C\r\nsince 1880, and this signal has been amplified in the polar regions,”\r\nthey state. Both sea and atmospheric temperatures have risen as a result\r\nand the resulting double <strong>whammy</strong> has triggered the\r\n<strong>catastrophic</strong> ice losses uncovered by the group.</p>\r\n<p>“平均来讲，地球的表面温度自从1880年以来上升了0.85℃，而这一特征在在极地地区则进一步被放大，”\r\n他们说道。就结果而言，海洋和大气层温度都上升了，并且随之产生的双重打击引发了被这个团队发现的灾难性冰损失。</p>\r\n<p>In the case of the melting ice sheet in Antarctica, rising sea\r\ntemperatures have been the main driver while increasing atmospheric\r\ntemperatures have been the cause of ice loss from inland glaciers such\r\nas those in the Himalayas. In Greenland, ice loss has been triggered by\r\na combination of both sea and atmospheric temperatures increasing.</p>\r\n<p>对于南极的冰盖消融来讲，上升的海水温度是主要导致因素，另一方面，上升的大气层温度则是例如在Himalayas之类的内陆冰川消融的主要元凶。在格陵兰岛，则是由海水和大气层两者的升温联合导致了冰消融。</p>\r\n<p>The team stressed that not all the ice that was lost over that period\r\nwould have contributed to sea level rises. “A total of 54% of the lost\r\nice was from sea ice and from ice shelves,” said Leeds University\r\nresearcher Isobel Lawrence. “These float on water and their melting\r\nwould not have contributed to sea level rises. The other 46% of\r\nmeltwater came from glaciers and ice sheets on the ground, and they\r\nwould have added to sea level rise.”</p>\r\n<p>团队强调，在这段时期内的冰消融并没有都助力了海平面上升。“总计54%的冰消融是来自于海洋冰和冰架，”\r\nLeeds 大学的研究员 Isobel Lawrence\r\n说道，“它们是附在水面上的，并且它们的消融不会导致海平面升高。另外的46%融水来自地面上的冰川和冰盖，这些才会导致海平面上升。”</p>\r\n<p>The group’s results were published 30 years after the first\r\n<strong>assessment</strong> report of the IPCC was published, at the end\r\nof August 1990. This outlined, in <strong>stark</strong>\r\n<strong>terms</strong>, that global warming was real and was being\r\ntriggered by increasing emissions of greenhouse gases from the burning\r\nof <strong>fossil</strong> fuels.</p>\r\n<p>距IPCC的第一份评估报告于1990八月末发布的三十年之后，这个团队的成果发表了他们的成果。简而言之，全球变暖被证实了，并且由于持续增长的化石燃料燃烧，进而导致的温室气体排放的影响，全球变暖仍在继续发生。</p>\r\n<p>Despite warnings from scientists, these emissions have continued to\r\nrise as global temperatures continued to <strong>soar</strong>.\r\nAccording to figures released by the Met Office last week, there was a\r\n0.14C increase in global temperatures between the decade 1980-89 and the\r\ndecade 1990-1999, then a 0.2C increase between each of the following\r\ndecades. This rate of increase is expected to rise, possibly to around\r\n0.3C a decade, as carbon emissions continue on their upward\r\n<strong>trajectory</strong>.</p>\r\n<p>不顾科学家们的警告，尽管全球温度持续升高，温室气体排放量仍在增长。据英国气象局上周公布的数据，在1980~1989和1990~1999间都有0.14℃的增长，而在接下来的每十年中，都有0.2℃的增长。随着碳排放量持续上升，变暖速率也预计会增加，可能会达到每十年0.3℃左右。</p>\r\n<h3 id=\"阅读原文\"><a\r\nhref=\"https://www.theguardian.com/environment/2020/aug/23/earth-lost-28-trillion-tonnes-ice-30-years-global-warming\">阅读原文</a></h3>\r\n<h1 id=\"词汇\">词汇</h1>\r\n<ul>\r\n<li>trillion （a million million） 兆；万亿； 10^12</li>\r\n<li>survey 调查</li>\r\n<li>glaciers 冰川</li>\r\n<li>emission 排放物；排放</li>\r\n<li>staggering 惊人的</li>\r\n<li>context 上下文；语境</li>\r\n<li>put sth in context ：give extra information so people can\r\nunderstand</li>\r\n<li>absorbing 吸收</li>\r\n<li>fresh water 淡水</li>\r\n<li>wipe out 抹除</li>\r\n<li>scenario 情境</li>\r\n<li>ice shelves 冰架</li>\r\n<li>protrude 突出</li>\r\n<li>devastating 毁灭性的</li>\r\n<li>adamant 坚定的</li>\r\n<li>amplified 放大的</li>\r\n<li>whammy 打击；有害的冲击</li>\r\n<li>catastrophic 灾难性的</li>\r\n<li>assessment 评定；评估</li>\r\n<li>stark 鲜明</li>\r\n<li>terms 术语；条款</li>\r\n<li>fossil 化石</li>\r\n<li>soar 飞涨；翱翔</li>\r\n<li>trajectory 弹道；轨迹</li>\r\n</ul>\r\n","categories":["杂记"],"tags":["英语"]},{"title":"阅读：Getting ahead","url":"/2020/09/01/%E9%98%85%E8%AF%BB-Getting-ahead/","content":"<h1 id=\"getting-ahead-isnt-a-nasty-business-us-study-reveals\">Getting\r\nahead isn't a nasty business, US study reveals</h1>\r\n<p>美国研究表明，出人头地并不非要当个混蛋。</p>\r\n<p>The question has puzzled humans from the earliest philosophers to the\r\nranks of home workers who have swapped water cooler\r\n<strong>gossip</strong> for <strong>rants</strong> on Zoom: does being a\r\n<strong>jerk</strong> help people get to the top?</p>\r\n<p>有个问题一直困扰着最早的一批哲学家，并且也困扰着在 Zoom\r\n上把闲谈八卦转换为怒吼的在家办公人员：变成一个混蛋能够变得杰出吗？</p>\r\n<span id=\"more\"></span>\r\n<p>Now, after a study lasting more than a decade, researchers believe\r\nthey finally have the answer. Nasty colleagues are no more likely to\r\nreach positions of power than those who are nice, they conclude.</p>\r\n<p>如今通过一个持续长达十多年的研究，研究者们认为他们找到了答案。他们得出结论，比起友好的同事，令人讨厌的同事不存在接触权力位置的优势。</p>\r\n<p>“Disagreeable people – selfish, bullying, nasty people – did not\r\nattain power any more in their careers than nice, generous, caring\r\npeople,” said Cameron Anderson, a professor at the Haas School of\r\nBusiness at the University of California, Berkeley. “Being a jerk simply\r\ndidn’t help people attain higher power.”</p>\r\n<p>“讨嫌的人——自私，霸道，令人厌恶的人——比起友好，慷慨，善于关心的人，并不会在事业中获得更多的权力。”Cameron\r\nAnderson 说道，他是一位 Berkeley 的 California 大学 Haas\r\n商学院的教授。“当个混蛋根本做不了大事。”</p>\r\n<p>Anderson and his colleagues <strong>delved</strong> into the issue\r\nbecause aggressive, selfish and <strong>manipulative</strong> people can\r\ncreate a <strong>toxic</strong> work environment and cause businesses to\r\nfail. They can also give people the wrong impression of the attributes\r\nthat seed success. Writing in Proceedings of the National Academy of\r\nSciences, they note one <strong>take-home message</strong> from a\r\npopular biography of Steve Jobs, the former Apple CEO, was: “Maybe if I\r\nbecome an even bigger asshole I’ll be successful like Steve.”</p>\r\n<p>因为盛气凌人的、自私的、控制欲的人总是会带来极其恶劣的工作环境，并且最终导致任务失败。因此\r\nAnderson\r\n和他的同事对上述情况进行了钻研。那种人还会给人们带来错误的印象——好像为了成功就需要这样糟糕的人格。在美国国家科学院院刊中写到，他们备注了一条来自前苹果\r\nCEO，Steve Jobs\r\n的热门传记中的核心观点：“假如我变成了一个更坏的混蛋，说不定我也会像乔布斯一样成功。”</p>\r\n<p>To find out whether nasty people really did fare better at work, the\r\nresearchers invited 671 US students to take personality tests between\r\n1999 and 2008. Disagreeable people tend to behave in\r\n<strong>quarrelsome</strong>, cold and selfish ways, and the\r\n<strong>trait</strong> is reasonably stable throughout life.</p>\r\n<p>为了探究到底混蛋能否在工作中表现的更好，研究者们在 1999 到 2008\r\n之间邀请了 671\r\n名学生进行人格测试。讨人嫌的人倾向于表现地更易争吵、冷漠、自私。并且这些特征在生活中都合理地稳定。</p>\r\n<p>Anderson then went back to the volunteers, on average about 14 years\r\nlater, when most were well into their careers. He quizzed them on their\r\nworkplace, the position they held, and what power they held in the\r\ncompany. <strong>Crucially</strong>, he also asked hundreds of\r\nco-workers to share their own thoughts on the volunteers.</p>\r\n<p>Anderson 在平均 14\r\n年后，重新去找到这些志愿者，他们之中大部分都有不错的职业生涯。他对他们进行了一些调查测试，关于他们的工作环境，他们的工作地位，以及拥有的公司权力。至关重要的是，他也循环了数百名他们的同事来分享他们对这些志愿者的私人看法。</p>\r\n<p>Contrary to Anderson’s expectations, the study showed that nice\r\npeople reached positions of power just as much as nasty people,\r\nregardless of the organisation they worked in. “It would make sense if\r\ndisagreeable people had an advantage in organisations that are more\r\ncut-throat and competitive, where everyone is looking out for\r\nher/himself,” he said. “But we didn’t find that.” In fact, being nasty\r\ndid not seem to help anyone in any setting.</p>\r\n<p>和 Anderson\r\n的预期相反的是，研究表明，与工作组织无关，好人能接触到的权力和混蛋几乎是一样多的。“假如混蛋在那种竞争性强的团队中有优势是比较合理的，毕竟那里人人都只是为自己着想。”他说，“但我们没有发现这种现象。”事实上，当个混蛋在任何环境下都不能帮助任何人。</p>\r\n<p>The research revealed that while nasty people displayed more\r\naggressive behaviour, which could help them climb the corporate\r\n<strong>ladder</strong>, bad relationships with their colleagues\r\nappeared to cancel out any benefits.</p>\r\n<p>研究表明，尽管混蛋们表现地更加有侵略性，而这可以帮助他们攀爬事业阶梯，然而与同事的恶劣关系把所有好处都抵消了。</p>\r\n<p>All of which has made Anderson happy. “I was relieved and\r\n<strong>heartened</strong> that disagreeableness had no effect.\r\nEspecially because my students consistently bring up examples of\r\npowerful people who are jerks, for example the late Steve Jobs, and\r\nargue that bullying and selfishness must be necessary to be powerful.\r\nThis study will help me argue against that commonly held myth.”</p>\r\n<p>这一切研究结果让Anderson感到开心。“我终于松了一口气，并且很高兴看到讨人嫌是没有任何帮助的，尤其是当我的学生连续不断地举了一些杰出的人都是混蛋的例子时，例如晚年乔布斯，并且他们还辩论到霸道和自私是成功的必要条件。这项研究可以让我很好的反驳这个流传广泛的谣言。”</p>\r\n<h3 id=\"阅读原文\"><a\r\nhref=\"https://www.theguardian.com/science/2020/aug/31/getting-ahead-isnt-a-nasty-business-us-study-reveals\">阅读原文</a></h3>\r\n<h1 id=\"词汇\">词汇</h1>\r\n<ul>\r\n<li>gossip 闲谈；八卦</li>\r\n<li>rants 怒吼</li>\r\n<li>jerk 混蛋；性情古怪的人</li>\r\n<li>delved 钻研</li>\r\n<li>toxic 有毒的</li>\r\n<li>manipulative 操纵性的；控制欲的</li>\r\n<li>take-home message 核心要点</li>\r\n<li>quarrelsome 易吵架的</li>\r\n<li>trait 特征</li>\r\n<li>Crucially 至关重要的</li>\r\n<li>ladder 阶梯</li>\r\n<li>heartened 被鼓舞</li>\r\n</ul>\r\n","categories":["杂记"],"tags":["英语"]},{"title":"阅读：Indian COVID-19","url":"/2020/08/28/%E9%98%85%E8%AF%BB-Indian-COVID-19/","content":"<h1 id=\"ten-in-remote-indian-tribe-of-59-test-positive-for-covid-19\">Ten\r\nin remote Indian tribe of 59 test positive for Covid-19</h1>\r\n<p>在 59 人的印度偏远部落中出现了 10 名新冠测试阳性者。</p>\r\n<p>Ten members of a <strong>dwindling</strong> <strong>tribe</strong>\r\nwho live on a <strong>secluded</strong> island in the Andaman Islands\r\n<strong>archipelago</strong> have tested positive for coronavirus, as\r\nthe <strong>pandemic</strong> continues to affect even the most remote\r\nregions of India.</p>\r\n<p>随着新冠病毒持续在印度大流行，甚至影响到了其最偏远的地区，在一个\r\nAndaman\r\n群岛中的一个幽僻小岛上，一个逐渐没落的部落也出现了十名阳性测试结果的人。</p>\r\n<span id=\"more\"></span>\r\n<p>There are only 59 surviving members of the Great Andamanese tribe,\r\nall of them on Strait Island in the Andaman archipelago.</p>\r\n<p>在 the Great Andamanese 部落，仅有 59\r\n名成员生活着。他们所有人都生活在 Andaman 群岛中的 Strait 岛上。</p>\r\n<p>A team of healthcare workers sailed over to the small island last\r\nweek to carry out tests after six members of the tribe, who had\r\ntravelled to the region’s capital, Port Blair, for work, tested positive\r\nfor the virus on the mainland.</p>\r\n<p>在六名因工作曾经去过这个地区的首都——Port\r\nBlair，的部落成员在陆地上被检测出病毒阳性特征之后，一组保健工作者，在上周航行到这个小岛上以进行检测。</p>\r\n<p>The samples showed that four other members of the tribe who had never\r\nleft the island were also infected with the virus.</p>\r\n<p>样本显示，其他四位从来没有离开小岛的部落成员，也一样被病毒感染。</p>\r\n<p>Dr Avijit Roy, a regional senior health director, said the virus had\r\nreached the island even though Covid tests were being carried out on\r\nevery person travelling to any of the 38 inhabited islands.</p>\r\n<p>Dr Avijit Roy，一个地区性高级卫生总监，说尽管对所有曾去过 38\r\n个有人岛屿之一的人都进行了新冠测试，病毒还是抵达了这个岛。</p>\r\n<p>“Over the last few months, every person who has been travelling to\r\nthese islands, particularly the restricted travel areas, has been\r\ntested, but it seems that someone carrying the virus must have gone\r\nundetected,” he said.</p>\r\n<p>“在前几个月，所有曾去过这些岛屿的人，特别是去过限制旅行区域的人，都被测试过了。但是看起来还是有某些携带病毒的人没有被检测到。”他说。</p>\r\n<p>On Thursday India reported a record daily tally of 75,760 new\r\ncoronavirus infections, pushing its total to 3.1 million. There were\r\n1,023 deaths recorded in the same 24-hour period, taking the country’s\r\ntoll to 60,472.</p>\r\n<p>在周四，印度进行了每日报告——新增 75760\r\n新冠感染，而这表明总感染数已经达到了 310 万。同时这 24\r\n小时中，也新增记录了 1023 名死亡，让这个国家的总死亡数达到了 60472。</p>\r\n<p>While the virus was initially concentrated in India’s densely\r\npopulated cities such as Delhi, Mumbai and Chennai, it has now spread\r\ninto rural and isolated communities that have limited healthcare\r\nresources. The Andaman and Nicobar Islands, which have a population of\r\n400,000, have reported a total of 2,944 coronavirus cases among the\r\nnon-tribal population.</p>\r\n<p>尽管病毒最初还只是集中在印度的密集繁华城市，例如 Delhi，Mumbai 和\r\nChennai。如今它已经扩散进了乡村和孤立社区，而这些地方的保健资源十分有限。有着\r\n400000 人口的 Andaman 和 Nicobar\r\n群岛，报告称在非部落人口中已经出现了总计 2944 名的新冠感染。</p>\r\n<p>The four tribespeople on the island who tested positive were aged\r\nbetween 26 and 55, and all have been taken to hospital as a\r\nprecautionary measure, though Roy said none showed any severe symptoms.\r\nThe six who originally tested positive for the virus in Port Blair are\r\nunder observational home <strong>quarantine</strong>.</p>\r\n<p>那个岛上四名检测阳性的部落人，年龄分布在 26 到 55 之间。尽管 Roy\r\n说没有人表现出任何严重的症状，但作为一种预防措施，还是把他们都送进了医院。而那六名最初在\r\nPort Blair 检测阳性的人，目前在居家隔离观察。</p>\r\n<p>Roy was confident that with continued testing and further\r\nrestrictions on movement, the Great Andamanese people would remain safe.\r\n“All routes of possible transmission are being monitored,” he said. “No\r\none is allowed on to the island until they have been tested negative,\r\nand so right now we have ruled out the possibility of new cases.”</p>\r\n<p>Roy 有自信通过在持续的检测和更严格的移动限制下，the Great Andamanese\r\n的人民一定可以保障安全。</p>\r\n<p>Arjun Munda, the union minister of tribal affairs, voiced concern at\r\nthe Great Andamanese infections and said the government was taking “all\r\nprecautionary measures” to keep them safe.</p>\r\n<p>Arjun Munda，部落事务联合部长，发声表示了对 the Great Andamanese\r\n的感染情况的关心，并且说政府正在用尽“一切预防措施”来保障他们的安全。</p>\r\n<p>The Great Andamanese are one of five tribes living on the Andaman\r\nIslands who are feared to be highly <strong>vulnerable</strong> to the\r\ncoronavirus pandemic.</p>\r\n<p>the Great Andamanese 是生活在 Andaman\r\n群岛上的五大部落之一，而他们被担心极易受到新冠流行的感染。</p>\r\n<p>In 1788, when the British first tried in vain to\r\n<strong>invade</strong> the islands, the Great Andamanese numbered\r\nbetween 5,000 and 8,000, and were made up of 10 different tribes.</p>\r\n<p>在 1788，当英国第一次尝试入侵这些群岛时，the Great Andamanese\r\n人口还在 5000 到 8000 中间，并且时由是个不同的部落组成。</p>\r\n<p>Today there are just over 50 people left, and members from only two\r\nof the 10 tribes have survived. Their language has largely been lost –\r\nin April this year the last speaker of the Sare Great Andamanese\r\nlanguage died from multiple health problems – and the tribe now mostly\r\nspeaks Hindi.</p>\r\n<p>如今，仅剩下了 50\r\n个人，十个部落中也仅有两个存活了下来。他们的语言已经很大程度上遗失了——在今年四月，the\r\nSare Great Andamanese\r\n语言最后的掌握者死于多项健康疾病——并且部落如今基本都是说印度语。</p>\r\n<p>The <strong>indigenous</strong> Andamanese population has been\r\nfalling for decades as they have poor immunity to many diseases and have\r\nbeen particularly vulnerable to <strong>tuberculosis</strong> and\r\n<strong>alcoholism</strong>.</p>\r\n<p>由于 Andamanese\r\n的原住民缺乏对大多数疾病的免疫能力，他们的人口数十年来都在持续下跌，并且对于酗酒和肺结核来说也十分脆弱。</p>\r\n<p>There are only about 200 surviving members of the Shompen tribe, 150\r\nof the Sentinelese tribe, 100 of the Onge and about 400 of the\r\n<strong>nomadic</strong> Jarawa tribe, who have reportedly moved deep\r\ninto the <strong>jungle</strong> since the outbreak of the pandemic in\r\nan attempt to protect themselves.</p>\r\n<p>Shompen 部落目前仅有 200 的存活成员，Sentinelese 部落仅有 150\r\n名，Onge 有 100 名，Jarawa 游牧部落则有大约 400 人。据报道 Jarawa\r\n的人是在病毒大爆发的时候，为了尝试保护他们自己，而迁移到了丛林深处。</p>\r\n<p>The Sentinelese tribe, who are <strong>hostile</strong> to outsiders\r\nand made the headlines in 2018 when they shot dead an American\r\nmissionary, John Allen Chau, with bows and arrows after he travelled to\r\ntheir island, are unlikely to be aware of the coronavirus pandemic.</p>\r\n<p>Sentinelese 部落，是一个对外来者十分敌对的部落。在 2018\r\n他们还因为用弓箭击毙了刚抵达他们岛屿的美国传教士 John Allen Chau\r\n而上了头条新闻。这个部落也不太可能意识到新冠病毒的爆发。</p>\r\n<p>“It is extremely alarming that members of the Great Andamanese tribe\r\ntested positive for Covid-19,” said Sophie Grig, a senior researcher\r\nwith Survival International, an organisation representing tribal people\r\nacross the world. “They will be all too aware of the devastating impact\r\nof <strong>epidemics</strong> that have <strong>decimated</strong> their\r\npeople.”</p>\r\n<p>“令人相当震惊的时，the Great Andamanese 部落的大部分成员都对 Covid-19\r\n检测为阳性。”Survival International 的一名高级研究员 Sophie Grig\r\n说道。Survival International\r\n是一个代表世界各地部落民族的组织。“他们将对摧毁他们民族的流行病的灾难性冲击很有体会。”</p>\r\n<h3 id=\"阅读原文\"><a\r\nhref=\"https://www.theguardian.com/world/2020/aug/27/tribespeople-of-andaman-islands-in-bay-of-bengal-test-positive-for-covid-19\">阅读原文</a></h3>\r\n<h1 id=\"词汇\">词汇</h1>\r\n<ul>\r\n<li>dwindling 逐渐减少</li>\r\n<li>tribe 部落</li>\r\n<li>secluded 偏远；幽静</li>\r\n<li>archipelago 群岛</li>\r\n<li>pandemic 大流行</li>\r\n<li>quarantine 隔离</li>\r\n<li>vulnerable 脆弱的</li>\r\n<li>invade 入侵</li>\r\n<li>indigenous 原住民</li>\r\n<li>tuberculosis 肺结核</li>\r\n<li>alcoholism 酗酒</li>\r\n<li>nomadic 游牧的</li>\r\n<li>jungle 丛林</li>\r\n<li>hostile 敌对的</li>\r\n<li>epidemics 流行病</li>\r\n<li>decimated 摧毁</li>\r\n</ul>\r\n","categories":["杂记"],"tags":["英语"]},{"title":"阅读：Drop Death","url":"/2020/08/20/%E9%98%85%E8%AF%BB-USIsis/","content":"<h1\r\nid=\"us-to-drop-death-penalty-for-british-isis-members-accused-of-beheadings\">US\r\nto drop death penalty for British Isis members accused of\r\nbeheadings</h1>\r\n<p>美国对被指控斩首的，英国 Isis 成员，处以死刑。</p>\r\n<p>The US has promised not to pursue the death penalty against two\r\nBritish Isis members accused of taking part in the beheadings of western\r\nhostages, in return for UK cooperation with the prosecution.</p>\r\n<p>美国保证不对——两名参与西方人质斩首的英国 Isis\r\n成员——追究死刑，以换取英国能与起诉方合作。</p>\r\n<p>The pledge was given in a letter from the US attorney general,\r\nWilliam Barr, to UK home secretary Priti Patel, in the case of Alexanda\r\nKotey and El Shafee Elsheikh, members of the “Beatles” group of British\r\nIsis members, who were captured by Syrian Kurds and then handed over to\r\nUS custody in October last year. They are still being held at a US\r\nfacility overseas.</p>\r\n<p>这个承诺是在美国总检察长 William Barr，致英国内政大臣 Priti Patel\r\n的一封信中作出的。此时在去年十月被 Syrian Kurds\r\n逮捕并转送至美国押守的，英国 Isis 的披头士团成员 Alexanda Kotey 和 El\r\nShafee Elsheikh，他们仍然被拘留在一处美国海外设施中。</p>\r\n<p><span id=\"more\"></span></p>\r\n<p>Barr’s offer came with an ultimatum: if the UK failed to hand over\r\nevidence in the case by 15 October, the two detainees would be handed\r\nover to the Iraqi justice system.</p>\r\n<p>Barr 的最终通牒：如果英国不在 10 月 15\r\n之前转交证据，两名被拘留者将会被移交至伊拉克司法系统。</p>\r\n<p>“Further delay is no longer possible if Kotey and Elsheikh are to be\r\ntried in the United States, and the further delay is an injustice to the\r\nfamilies of the victims,” Barr said in the letter to Patel, which has\r\nbeen seen by the Guardian. “Kotey and Elsheikh are currently held by\r\nUnited States military authorities in an overseas theater of military\r\noperations, and it is not tenable to continue holding them there for an\r\nextended period. Final decisions must be made about this matter.”</p>\r\n<p>“如果 Kotey 和 Elsheikh\r\n要在美国被审判，那么再也不能继续拖延下去了。并且拖延也是一种对受害者亲属的不公平。”Barr\r\n在给 Patel 的信中说到，而卫报也见到了这封信。“Kotey 和 Elsheikh\r\n目前被美国军事当局拘留在海外的军事行动设施中，并且继续保留他们一段额外的时间显然是站不住脚的。这件事必须要做出最终决定了。”</p>\r\n<p>British cooperation with the US prosecution had been blocked under a\r\nruling by the UK supreme court in March, and is still in effect, UK\r\nofficials pointed out.</p>\r\n<p>英国官方指出，在英国最高法院三月颁布并且至今依然生效的一条法令下，英国和美国起诉方的合作是被禁止的。</p>\r\n<p>“The government’s priority has always been to protect national\r\nsecurity and to deliver justice for the victims and their families,” a\r\nUK Home Office spokesperson said. “We continue to work closely with\r\ninternational partners to ensure that those who have committed crimes in\r\nthe name of Daesh [Isis] are brought to justice.”</p>\r\n<p>“政府一直以保护国家安全优先，并且也会给受害者和他们的家属带来正义。”一个英国内政发言人说到，“我们将继续和国际伙伴密切合作，以确保以\r\nDaesh Isis 之名犯罪的人将会被绳之以法。”</p>\r\n<p>Kotey and Elsheikh were part of a group of four who are accused of\r\nbeing involved in the filmed beheadings of two British aid workers,\r\nDavid Haines and Alan Henning, as well as of two US journalists, James\r\nFoley and Steven Sotloff.</p>\r\n<p>Kotey 和 Elsheikh\r\n是一个四人团队的成员。这个团队被指控参与了——两名英国救助工人，David\r\nHaines 和 Alan Henning，和两名美国记者 James Foley 和 Steven\r\nSotloff——的摄像斩首行动。</p>\r\n<p>The group’s leader, Mohammed Emwazi, was killed in a US drone strike\r\nin 2015, while another, Aine Davis, was caught in Turkey and jailed for\r\nmore than seven years in 2017 for membership of a terrorist\r\norganisation.</p>\r\n<p>这个团队的首领，Mohanmmed Emwazi，在 2015\r\n年被美国的无人机击杀，而另一个首领 Aine Davis，因加入恐怖组织，在 2017\r\n年被土耳其逮捕并且被判入狱 7 年以上。</p>\r\n<p>Nicholas Henin, a former French Isis hostage, welcomed the news that\r\nthe death penalty would be dropped, saying on Twitter it was “great news\r\nthat opens the way for a trial in the US”.</p>\r\n<p>Nicholas Henin，一个曾被法国 Isis\r\n劫持的人质，对这个死刑将被执行的消息感到开心，他在推特上说到：“这是一个为美国审判开辟了新道路的伟大新闻。”</p>\r\n<h3 id=\"阅读原文\"><a\r\nhref=\"https://www.theguardian.com/world/2020/aug/19/us-to-drop-death-penalty-for-british-isis-members-accused-of-beheadings\">阅读原文</a></h3>\r\n<h1 id=\"词汇\">词汇</h1>\r\n<ul>\r\n<li>penalty 罚款；惩罚；刑罚</li>\r\n<li>death penalty 死刑</li>\r\n<li>accused of beheadings 受到斩首的指控</li>\r\n<li>prosecution 起诉</li>\r\n<li>hostage 人质</li>\r\n<li>pledge 保证</li>\r\n<li>attorney general 总检察长</li>\r\n<li>home secretary 内政大臣</li>\r\n<li>facility 设施；工厂</li>\r\n<li>detainees 被拘留者</li>\r\n<li>Iraqi 伊拉克</li>\r\n<li>authorities 当局</li>\r\n<li>tenable 站得住脚</li>\r\n<li>commit crime 犯罪</li>\r\n<li>drone 无人机</li>\r\n<li>strike 罢工；打击；</li>\r\n<li>jail 监狱</li>\r\n</ul>\r\n","categories":["杂记"],"tags":["英语"]},{"title":"阅读：cosmic event","url":"/2020/09/03/%E9%98%85%E8%AF%BB-cosmic-event/","content":"<h1\r\nid=\"it-just-sounds-like-a-thud-astronomers-hear-biggest-cosmic-event-since-big-bang\">'It\r\njust sounds like a thud': astronomers hear biggest\r\n<strong>cosmic</strong> event since big bang</h1>\r\n<p>“就像雷鸣一样”：天文学家听到了自宇宙大爆炸以来最大的宇宙事件</p>\r\n<p>Scientists have announced the detection of a signal from a long-ago\r\ncollision between two black holes that created a new one of a size never\r\nseen before.</p>\r\n<p>科学家们宣布检测到了一个来自远古的两个黑洞的碰撞信号，这个碰撞创造了一个前所未有的尺寸的新黑洞。</p>\r\n<p>\"It’s the biggest bang since the big bang observed by humanity,\" said\r\nCaltech professor of physics Alan Weinstein, who was part of the\r\ndiscovery team.</p>\r\n<p>“这是人类观测到的自宇宙大爆炸以来最大的一次冲击，”勘测团队中的一员，Caltech\r\n物理教授 Alan Weinstein 说道。</p>\r\n<span id=\"more\"></span>\r\n<p>Black holes are <strong>compact</strong> regions of space so densely\r\npacked that not even light can escape them. Until now, astronomers only\r\nhad observed them in two general sizes: “small” ones called\r\n<strong>stellar</strong> black holes that are formed when a star\r\ncollapses and are about the size of small cities, and supermassive black\r\nholes that are millions, perhaps billions, of times more massive than\r\nour sun and around which entire galaxies revolve.</p>\r\n<p>黑洞是空间紧凑的区域，紧凑到以至于光都不能从黑洞逃离。直到今天，天文学家们仅仅观测到两种通常的尺寸：小号的，被叫做恒星黑洞，形成于一个星球的塌缩，大小大约是小型城市的大小。超大规模黑洞则是比我们的太阳大了百万倍，甚至有十亿倍，并且整个星系都会围绕着其旋转。</p>\r\n<p>According to astronomers’ calculations, anything in between didn’t\r\nquite make sense, because stars that grew too big before collapse would\r\nessentially consume themselves, leaving no black hole.</p>\r\n<p>根据天文学家的计算，在两者之间的任何尺寸实际上都意义不大。因为在塌缩之前变得太大的星球，在本质上会消解它们自己，不会留下任何黑洞。</p>\r\n<p>Star collapses could not create stellar black holes much bigger than\r\n70 times the mass of our sun, scientists thought, according to physicist\r\nNelson Christensen, research director of the Artemis research unit at\r\nthe French National Centre for Scientific Research.</p>\r\n<p>据法国国家科学研究院的阿耳忒弥斯研究所的研究主任，物理学家 Nelson\r\nChristensen——科学家们认为星球塌缩至多不会产生超过太阳 70\r\n倍大小的恒星级黑洞。</p>\r\n<p>Then in May 2019 two detectors picked up a signal that turned out to\r\nbe the energy from two stellar black holes — each large for a stellar\r\nblack hole — crashing into each other. One was 66 times the mass of our\r\nsun and the other 85 times its mass. The result was the first known\r\nintermediate black hole, at 142 times the mass of the sun.</p>\r\n<p>之后在 2019 年 5\r\n月，两个检测器检测到了一个信号，并且最终发现是两个恒星级黑洞产生的能量——两者大小都和恒星级黑洞相当——撞向了对方。一个是\r\n66 倍太阳质量，另一个是 85\r\n倍太阳质量。最终它们产生了一个人类第一次已知的中间尺寸黑洞，大约是 142\r\n倍太阳质量。</p>\r\n<p>Lost in the collision was an enormous amount of energy in the form of\r\na gravitational wave, a <strong>ripple</strong> in space that travels at\r\nthe speed of light. It was that wave that physicists in the US and\r\nEurope, using detectors called LIGO and Virgo, captured last year. After\r\n<strong>deciphering</strong> the signal and checking their work, the\r\nscientists published the results on Wednesday in the journals Physical\r\nReview Letters and Astrophysical Journal Letters.</p>\r\n<p>在碰撞中，由于引力波的形成而损失了大量的能量，引力波即是一个光速传播的空间波纹。它就是那个在欧美的物理学家们，利用叫做\r\nLIGO 和 Virgo\r\n的监测装置，于去年检测到的波动。在破译信号并且检查之后，在周三，科学家们在\r\nthe journals Physical Review Letters 和 Astrophysical Journal Letters\r\n上公开了研究成果。</p>\r\n<p>Because the detectors allow scientists to pick up the gravitational\r\nwaves as audio signals, scientists actually heard the collision. For all\r\nthe violence and drama, the signal lasted only a tenth of a second. \"It\r\njust sounds like a thud,” Weinstein said. “It really doesn’t sound like\r\nmuch on a speaker.\"</p>\r\n<p>因为检测器可以让科学家们将引力波看作音频信号，科学家们实际上是听到了那场碰撞。【对于所有的声音】，信号只持续了十分之一秒。“听起来就像雷鸣，”Weinstein\r\n说道，【“在扬声器声听起来也不是很像。”】</p>\r\n<p>This crash happened about 7 bn years ago, when the universe was half\r\nits current age, but is only being detected now because it happened so\r\nfar away.</p>\r\n<p>这场碰撞发生在大约 70\r\n亿年前，当时宇宙还是如今一半的年龄。但因为它实在是在太远的地方发生了，只有到了现在才可以检测到。</p>\r\n<p>Black hole collisions have been observed before, but the black holes\r\ninvolved were smaller to begin with, and even after the merger didn’t\r\ngrow beyond the size of typical stellar black holes.</p>\r\n<p>之前也观测过黑洞碰撞，但是所涉及的黑洞一开始都是较小的，而且就算是融合后的尺寸也没有超过典型的恒星级黑洞。</p>\r\n<p>Scientists still don’t know how supermassive black holes at the\r\ncentre of galaxies formed, Christensen said, but this new discovery may\r\noffer a clue.</p>\r\n<p>科学家们仍然不知道银河系中心的超大黑洞是如何形成的，Christensen\r\n说道，但是如今的新发现可能可以提供一些线索。</p>\r\n<p>It may be that smaller blocks combine to make bigger ones and those\r\ncombine to make even bigger ones, said Harvard astronomer Avi Loeb, who\r\nwasn’t part of the study but said the results <strong>chart</strong> new\r\nastronomical <strong>territory</strong>.</p>\r\n<p>可能是由小的结合成大的，再结合成更大的，Havard 天文学家 Avi Loeb\r\n说道。他不是研究团队的一员，但是他把结果制成了新的天文版图。</p>\r\n<p>Indeed, the larger of the two black holes involved in this crash may\r\nhave been the result of an earlier merger, both Weinstein and\r\nChristensen said.</p>\r\n<p>确切来说，碰撞中两个黑洞较大的那一个，可能就是一场更早的融合的产物，Weinstein\r\n和 Christensen 都这么认为。</p>\r\n<p>\"It’s <strong>conceivable</strong> that this pair of black holes\r\nformed entirely differently, possibly in a dense system with lots of\r\ndead stars <strong>whizzing</strong> about, which allows one black hole\r\nto capture another during a fly-by,\" said Barnard College astronomer\r\nJanna Levin, author of the book Black Hole Survival Guide.</p>\r\n<p>“可以想象，这对黑洞形成方式完全不同。可能是在一个稠密的众多死星流落的星系中，一个黑洞捕获了另一个经过的黑洞。”Barnard\r\n大学的天文学家 Janna Levin 说道，他也是《Black Hole Survival\r\nGuide》的作者。</p>\r\n<p>On the other hand, scientists can’t quite explain how merged black\r\nholes, flying around the universe, would meet so many others to merge\r\nagain and grow ever bigger. It could instead be that supermassive black\r\nholes were formed in the immediate <strong>aftermath</strong> of the big\r\nbang.</p>\r\n<p>另一方面，科学家们还无法很好地解释，【在宇宙中飞行的融合黑洞，怎么遇到如此多的其他黑洞并且不停地融合变大。】因此相反，超大规模黑洞也可能是大爆炸瞬间的产物。</p>\r\n<p>\"In astrophysics, we’re always faced with surprises,\" Weinstein\r\nsaid.</p>\r\n<p>“在天文学，我们总是能有惊喜。”Weinstein 说道。</p>\r\n<h3 id=\"阅读原文\"><a\r\nhref=\"https://www.theguardian.com/science/2020/sep/02/sounds-like-thud-astronomers-biggest-cosmic-event-since-big-bang\">阅读原文</a></h3>\r\n<h1 id=\"词汇\">词汇</h1>\r\n<ul>\r\n<li>cosmic 宇宙的；有秩序的</li>\r\n<li>compact 紧凑</li>\r\n<li>stellar 恒星</li>\r\n<li>ripple 波纹</li>\r\n<li>deciphering 破解；破译</li>\r\n<li>chart 图表；制图</li>\r\n<li>territory 领土</li>\r\n<li>conceivable 可想象的</li>\r\n<li>whizzing 呼啸</li>\r\n<li>aftermath 后果</li>\r\n</ul>\r\n","categories":["杂记"],"tags":["英语"]},{"title":"阅读：Win the car,dodge the goat","url":"/2020/08/31/%E9%98%85%E8%AF%BB-car-goat/","content":"<h1 id=\"did-you-solve-it-win-the-car-dodge-the-goat\">Did you solve it?\r\nWin the car, dodge the goat</h1>\r\n<p>你搞定了吗？赢得汽车，躲避山羊</p>\r\n<p>Earlier today I set you the following problem, about a game show\r\nwhere objects are hidden behind three doors. Behind one door is a car.\r\nBehind a second door are the car keys. Behind the third door is a goat.\r\nThe car, the keys and the goat were placed there randomly, meaning that\r\neach item has a 1/3 chance of being behind any particular door.</p>\r\n<p>早些天我给你们留了如下谜题，它是一个东西藏在三扇门后面的游戏秀。其中一扇门之后是一辆车，另一扇门之后是车钥匙，第三扇门之后是一个山羊。车，钥匙，山羊是随机分布在门后的，这意味着每扇门后每个东西出现的机会都是\r\n1/3.</p>\r\n<!---more-->\r\n<p>Twins Timmy and Tammy, the <strong>contestants</strong>, are\r\nbackstage on the game show. They are told the rules:</p>\r\n<p>参赛者Timmy和Tammy双胞胎，在游戏秀的后台被告知如下规则：</p>\r\n<ol type=\"1\">\r\n<li>Timmy will be taken on stage first. He will be asked to open two of\r\nthe doors, and then shut them. Timmy will then be led off stage to a\r\nholding room on his own.</li>\r\n</ol>\r\n<p>1）Timmy会先被带上舞台。他将被要求打开两扇门，并且紧接着就关上。Timmy之后则会被带离舞台，到达一个独处的等待室。</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>Tammy will then be taken on stage. She will be asked to open two of\r\nthe doors.</li>\r\n</ol>\r\n<p>2）然后就是Tammy被带上舞台，她也要打开两扇门。</p>\r\n<p>If Timmy opens the door with the car, and Tammy opens the door with\r\nthe keys, then they both get to keep the car. In all other outcomes,\r\nthey leave with nothing.</p>\r\n<p>如果Timmy打开了车的那扇门，Tammy打开了钥匙的那扇门，那么他俩都可以带走那辆车。而其他任何的结果下，他们都不能带走任何东西。</p>\r\n<p>The twins are given 10 minutes to think up a door-opening strategy\r\nbefore Timmy goes on stage. What strategy gives them the best chance of\r\nwinning the car?</p>\r\n<p>这对双胞胎在Timmy上台前有十分钟的时间去思考一个开门的策略。什么策略能给他们赢得汽车的最大机会呢？</p>\r\n<p>Just to be clear: The twins do not know what is behind any of the\r\ndoors before they ask for a door to be opened. When one door is opened,\r\nall they can see is what is behind that door. The car, car keys and goat\r\nstay behind the same door for the duration of the programme. When Timmy\r\nis on stage opening his two doors, Tammy cannot see or hear what is\r\ngoing on. Thus when Tammy is choosing her two doors, she has no idea\r\nwhat was behind the two doors that Timmy opened. Also (as was pointed\r\nout by readers of the earlier article), Timmy does not need to open both\r\nhis doors at the same time. He can open one, and then based on what he\r\nsees, decide which one to open second. As can Tammy.</p>\r\n<p>先搞清楚：双胞胎在开门之前不知道门后会有什么。当开了一扇门，他们仅能看到这扇门后面的东西。在游戏过程中，汽车、钥匙、山羊都会在同一扇门后面不变。当Timmy在台上开两扇门的时候，Tammy看不到听不到发生了什么。因此Tammy选开哪两个门的时候，无法利用Timmy开门的信息。并且（这是读者在前期的文章中指出的）Timmy不需要同时开两扇门。他可以先开一个，然后根据他看到的什么再选另一个。Tammy也一样。</p>\r\n<p>If the twins had no strategy, that is, if both of them choose two\r\ndoors at random, the probability Timmy gets the car is 2/3, and the\r\nprobability Tammy gets the keys is also 2/3. The probability they get to\r\nkeep the car is thus 2/3 x 2/3 = 4/9 = 44 per cent.</p>\r\n<p>如果双胞胎没有任何策略，即他们都是随机选门，Timmy有2/3的几率开到车，Tammy有2/3的几率开到钥匙，他们都能赢得汽车的概率是2/3\r\nx 2/3 =4/9 = 44%。</p>\r\n<p>Yet, rather incredibly, there is a strategy that gives them well over\r\n50 per cent chance of keeping the car. What is it?</p>\r\n<p>不过，让人难以置信的是，这有一个策略可以让他们有超过50%的概率赢得汽车。是什么呢？</p>\r\n<blockquote>\r\n<p>盲猜利用了 Timmy开的两扇门其中一扇门后面是汽车\r\n的信息hhh，这样Tammy可以避开这个门，只要预设好Timmy开门的选择。</p>\r\n</blockquote>\r\n<p>Solution 解决方案</p>\r\n<p>Let’s call the doors 1, 2 and 3. The <strong>optimal</strong>\r\nstrategy is for Timmy to open 1 first. If it reveals either the car or\r\nthe keys, he should open door 2 next. But if door 1 reveals the goat, he\r\nshould open door 3.</p>\r\n<p>让我们将门命名为1，2，3。最优策略是。Timmy先开1门。如果开的是汽车或者钥匙，则继续开2门。反之如果1门开的是山羊，则他应该接着开3门。</p>\r\n<p>Tammy should then open door 2. If it reveals either the car or the\r\nkeys, she should open door 1 next. But if door 2 reveals the goat, he\r\nshould open door 3.</p>\r\n<p>Tammy应该开2门。如果开的是汽车或者是钥匙，则她接着开1门。如果2门是山羊，则开3门。</p>\r\n<p>Here are the six possible arrangements of car, keys and goat behind\r\ndoors 1, 2 and 3: 以下是车、钥匙、山羊在门1、2、3后的排列组合。</p>\r\n<ul>\r\n<li><strong>CKG</strong></li>\r\n<li><strong>CGK</strong></li>\r\n<li>KGC</li>\r\n<li><strong>KCG</strong></li>\r\n<li>GCK</li>\r\n<li><strong>GKC</strong></li>\r\n</ul>\r\n<p>I have marked in bold the ones in which Timmy gets the car, and Tammy\r\nthe keys, which happens in four out of the six equally likely cases.\r\nThis the chances of them winning the car is 4/6 = 66 per cent.</p>\r\n<p>我把Timmy开到汽车，而Tammy开到钥匙的情况用粗体标了出来，而这有4/6=66%的概率.</p>\r\n<p>If you discovered this solution, please discuss your thought\r\nprocesses below. 如果你想出了这个解法，请在下面讨论一下你的思路。</p>\r\n<p>Today’s puzzle is taken from Surprises in Probability- Seventeen\r\nShort Stories, by Dutch mathematician Henk Tijms</p>\r\n<p>今天的谜题是 Surprises in Probability- Seventeen Short\r\nStories中的，作者是 Dutch mathematician Henk Tijms。</p>\r\n<p>I set a puzzle here every two weeks on a Monday. I’m always on the\r\nlook-out for great puzzles. If you would like to suggest one, email\r\nme.</p>\r\n<p>每两周的周一我都会留下一个谜题。我总是在寻找很棒的谜题，如果你想推荐几个，请发邮件给我。</p>\r\n<h3 id=\"阅读原文\"><a\r\nhref=\"https://www.theguardian.com/science/2020/aug/24/did-you-solve-it-win-the-car-dodge-the-goat\">阅读原文</a></h3>\r\n<h1 id=\"词汇\">词汇</h1>\r\n<ul>\r\n<li>contestants 参赛者</li>\r\n<li>optimal 最佳</li>\r\n</ul>\r\n","categories":["杂记"],"tags":["英语"]},{"title":"阅读:mathematician prize","url":"/2020/09/11/%E9%98%85%E8%AF%BB-mathematician-prize/","content":"<h1 id=\"uk-mathematician-wins-richest-prize-in-academia\">UK\r\nmathematician wins richest prize in academia</h1>\r\n<p>英国数学家获学术界最高奖</p>\r\n<p>A mathematician who <strong>tamed</strong> a nightmarish family of\r\nequations that behave so badly they make no sense has won the most\r\nlucrative prize in academia.</p>\r\n<p>一位解决了一组噩梦般的方程的数学家，毫无疑问地摘得了学术界最丰厚的奖励。</p>\r\n<p>Martin Hairer, an Austrian-British researcher at Imperial College\r\nLondon, is the winner of the 2021 Breakthrough prize for mathematics, an\r\nannual $3m (£2.3m) award that has come to <strong>rival</strong> the\r\nNobels in terms of <strong>kudos</strong> and\r\n<strong>prestige</strong>.</p>\r\n<p>Martin Hairer，一位在Imperial College\r\nLondon的澳大利亚裔英国研究院，是2021数学突破奖获得者。数学突破奖是一个年度高达300万美元的奖项，它的荣誉性和威望性可以和诺贝尔奖一较高下。</p>\r\n<p>Hairer landed the prize for his work on <strong>stochastic</strong>\r\nanalysis, a field that describes how random effects turn the maths of\r\nthings like stirring a cup of tea, the growth of a forest fire, or the\r\nspread of a water droplet that has fallen on a <strong>tissue</strong>\r\ninto a <strong>fiendishly</strong> complex problem.</p>\r\n<p>Hairer是因随机分析上的工作而获奖。随机分析是一个阐述了随机效应怎么将诸如搅动茶杯、森林火灾的扩散、掉在薄纸上的水滴的扩散等问题的数学状态，转变成一个非常复杂的问题。</p>\r\n<p>His major work, a 180-page <strong>treatise</strong> that introduced\r\nthe world to “regularity structures”, so <strong>stunned</strong> his\r\ncolleagues that one suggested it must have been transmitted to Hairer by\r\na more intelligent alien civilisation.</p>\r\n<p>他的主要工作，一篇180页论文，向世界介绍了“regularity\r\nstructures”。而这让他的同时目瞪口呆——甚至有个人觉得这一定是一个更聪明的外星文明教给Hairer的。</p>\r\n<span id=\"more\"></span>\r\n<p>Hairer, who rents a London flat with his wife and fellow Imperial\r\nmathematician, Xue-Mei Li, heard he had won the prize in a Skype call\r\nwhile the UK was still in lockdown. “It was completely unexpected,” he\r\nsaid. “I didn’t think about it at all, so it was a complete shock. We\r\ncouldn’t go out or anything, so we celebrated at home.”</p>\r\n<p>当时英国还在封锁当中，Hairer还在和他的妻子以及帝国理工的数学家Xue-Mei\r\nLi租在伦敦一个公寓里，在一个Skype电话里得悉他获奖了。“这我完全没想到，”他说到，“我根本就没考虑过这个东西，所以真的，它让我非常震惊。因为我们不能外出干些什么，所以我们在家里庆祝了一下。”</p>\r\n<p>The award is one of several Breakthrough prizes announced each year\r\nby a foundation set up by the Israeli-Russian <strong>investor</strong>\r\nYuri Milner and Facebook’s Mark Zuckerberg. A committee of previous\r\nrecipients chooses the winners who are all leading lights in mathematics\r\nand the sciences.</p>\r\n<p>数学突破奖是几个突破奖的其中之一。它们是每年都会由以色列裔俄国投资者Yuri\r\nMilner和Facebook的Mark\r\nZuckerberg设立的一个基金会进行颁布。一个由往届获奖者组成的委员会，挑选在数学和科学上作为领航灯塔的人作为获奖者。</p>\r\n<p>Other winners announced on Thursday include a Hong Kong scientist,\r\nDennis Lo, who was inspired by a 3D Harry Potter movie to develop a test\r\nfor genetic <strong>mutations</strong> in DNA shed by unborn babies, and\r\na team of physicists whose experiments revealed that if extra dimensions\r\nof reality exist, they are <strong>curled</strong> up smaller than a\r\nthird of a hair’s width.</p>\r\n<p>在周四宣布了其他获奖者，其中包括一位香港科学家Dennis\r\nLo，他受3D哈利波特电影的灵感启发，发明了一种为尚未出生的婴儿检测基因变异的方法。另外一个物理学家组成的获奖团队，他们的实验揭示了如果现实中存在额外的尺度，它们将是被卷曲得比头发宽度的三分之一还要小。</p>\r\n<p>Yet another winner, Catherine Dulac at Harvard University, has\r\n<strong>overturned</strong> misconceptions around parenthood by showing\r\nthat the neural circuits for maternal and paternal behaviour are found\r\nin both males and females.</p>\r\n<p>还有一个获奖者，Harvard University的Catherine\r\nDulac，通过展现父系和母系的行为神经电路在男女双方上都存在，颠覆了关于父母的误解理论。</p>\r\n<p>Hairer grew up in Geneva where he soon established himself as a rare\r\ntalent. His entry for a school science competition became Amadeus – “the\r\nSwiss army knife of sound editing” – now used in updated form by music\r\nproducers and games designers. He still maintains the software as a\r\n<strong>sideline</strong> to his academic work.</p>\r\n<p>Hairer\r\n在Geneva长大，在那儿他很快就认为自己是一个少数天才。他的一个学校竞赛参赛作品演变成了\r\nAmadeus——“一个声音编辑领域的瑞士军刀”——现在以崭新的形态被音乐工作者和游戏设计师所使用。他现在仍然将这个软件作为他学术工作的副业。</p>\r\n<p>After <strong>dallying</strong> with physics at university, Hairer\r\nmoved into mathematics. The realisation that ideas in theoretical\r\nphysics can be overturned and swiftly <strong>consigned</strong> to the\r\ndustbin did not appeal. “I wouldn’t really want to put my name to a\r\nresult that could be <strong>superseded</strong> by something else three\r\nyears later,” he said. “In mathematics, if you obtain a result then that\r\nis it. It’s the universality of mathematics, you discover absolute\r\ntruths.”</p>\r\n<p>在大学探究过一阵物理之后，Hairer转向了数学。他意识到理论物理领域的想法可能会被推翻并且很快就丢到垃圾桶里，而这并不吸引人。“我真的不想看到写着我的名字的成果在三年后被一些其他的东西取而代之。”他说到，“在数学领域，如果你做出了成果那它就固定在那儿了。这就是数学的共性，你的发现一定是绝对真理。”</p>\r\n<p>Hairer’s expertise lies in stochastic partial\r\n<strong>differential</strong> equations, a branch of mathematics that\r\ndescribes how randomness throws disorder into processes such as the\r\nmovement of wind in a wind tunnel or the <strong>creeping</strong>\r\nboundary of a water droplet landing on a tissue. When the randomness is\r\nstrong enough, solutions to the equations get out of control. “In some\r\ncases, the solutions <strong>fluctuate</strong> so wildly that it is not\r\neven clear what the equation meant in the first place,” he said.</p>\r\n<p>Hairer的专长在随机偏微分方程，这是一个数学的分支，描述了随机性怎么使过程变得混乱，例如在风洞中的风的运动，或者是滴在薄纸上的水滴的蔓延边界。当随机性足够强的时候，这些方程的解法是难以捉摸的。“在有些时候，解的变化太大了以至于甚至搞不清楚方程最初是代表着什么。”他说到。</p>\r\n<p>With the invention of regularity structures, Hairer showed how the\r\ninfinitely <strong>jagged</strong> noise that threw his equations into\r\nchaos could be reframed and tamed. When he published the theory in 2014,\r\nit made an immediate splash. “Like everyone else, I was amazed to see a\r\ntheory like this, worked out in detail <strong>from scratch</strong>,\r\nwith few precedents,” said Jeremy Quastel, a mathematician at the\r\nUniversity of Toronto who first mused on the extraterrestrial provenance\r\nof the theory.</p>\r\n<p>随着规则结构的发现，Hairer展示了将他的方程变得混沌的无限锯齿噪音能够被重构并且解决。当他在2014年发布他的理论时，这个成果立刻就炸开了。“就像其他人一样，我对这样一种从头开始、深究细节，并且几乎没有先例的理论感到很震惊。”Toronto大学的数学家Jeremy\r\nQuastel说道，他是第一个沉迷于这个理论的地外起源论的人。</p>\r\n<p>While his peers roundly consider Hairer a genius, he admits\r\nmathematics can be <strong>infuriating</strong>. “Most of the time it\r\ndoesn’t work out. As pretty much every single graduate student in\r\nmathematics can <strong>attest</strong>, during your PhD you probably\r\nspend two-thirds of your time getting stuck and banging your head\r\nagainst a wall.”</p>\r\n<p>当他的同行们都认为Hairer是一个天才时，他承认数学有时候很气人。“大多数时候都没有什么成果。绝大多数的数学方向研究生都能证明，甚至在博士期间你三分之二的时间都是在卡壳和疯狂碰壁。”</p>\r\n<p>Hairer’s <strong>windfall</strong> has yet to land in his bank\r\naccount, but when it does, his life will change. “We moved to London\r\nsomewhat recently, three years ago, and we are still renting. So it\r\nmight be time to buy a place to live,” he said.</p>\r\n<p>Hairer的横财还没有抵达他的银行账户，但当钱到账了，他的生活将完全不一样了。“我们最近搬到了伦敦，大概有三年吧，并且我们还在租房。所以这应该是时候买一个居住地了。”他说到。</p>\r\n<h1 id=\"词汇\">词汇</h1>\r\n<ul>\r\n<li>tame 驯服；解决</li>\r\n<li>rival 队首；角逐；竞争的</li>\r\n<li>kudos 荣誉</li>\r\n<li>prestige 威望</li>\r\n<li>stochastic 随机</li>\r\n<li>tissue 组织；薄纸</li>\r\n<li>fiendishly 凶恶地</li>\r\n<li>treatise 论文</li>\r\n<li>stunned 震惊</li>\r\n<li>investor 投资者</li>\r\n<li>mutations 变异</li>\r\n<li>curled 卷曲；蜷缩</li>\r\n<li>overturned 颠覆；推翻</li>\r\n<li>sideline 副业；附带物</li>\r\n<li>dallying 追随；玩弄；赋闲</li>\r\n<li>consigned 交付；委托</li>\r\n<li>superseded 取代</li>\r\n<li>differential 微分</li>\r\n<li>creeping 爬行；蔓延</li>\r\n<li>fluctuate 波动；变幻</li>\r\n<li>jagged 锯齿状的</li>\r\n<li>from scratch 从头开始</li>\r\n<li>infuriating 气死人；真气</li>\r\n<li>attest 证明；表明</li>\r\n<li>windfall 横财</li>\r\n</ul>\r\n","categories":["杂记"],"tags":["英语"]},{"title":"阅读：meteorite crater","url":"/2020/09/04/%E9%98%85%E8%AF%BB-meteorite-crater/","content":"<h1\r\nid=\"massive-meteorite-crater-found-in-western-australia-thought-to-be-100-million-years-old\">Massive\r\nmeteorite crater found in Western Australia thought to be 100 million\r\nyears old</h1>\r\n<p>在澳大利亚西部找到的超大陨石坑被认为有 1 亿年历史</p>\r\n<p>A massive 100 million-year-old meteorite crater has been found while\r\na company was drilling for gold in <strong>outback</strong> Western\r\nAustralia.</p>\r\n<p>在一个公司在澳大利亚西部的内陆钻探黄金时，发现了一个大规模的一亿年历史的陨石坑。</p>\r\n<p>The impact crater is <strong>estimated</strong> to have a\r\n<strong>diameter</strong> of about 5km. Although not visible from the\r\nsurface, experts found the crater using electromagnetic surveys.</p>\r\n<p>据估计这个冲击坑直径有大约 5km\r\n长。尽管从表明看不到它，专家们还是利用了电磁探测装置找到了这个坑。</p>\r\n<p>Located near the Goldfields mining town of Ora Banda, north-west of\r\nKalgoorlie-Boulder, the crater is believed to be five times bigger than\r\nthe famous Wolfe Creek crater in the Kimberley.</p>\r\n<p>陨石坑位于 Kalgoorlie-Boulder 的西北部，Ora Banda\r\n的一个金矿镇附近。与之前著名的 Kimberley 的 Wolfe Creek\r\n比起来，它被认为超前者五倍大。</p>\r\n<span id=\"more\"></span>\r\n<p>The geologist and <strong>geophysicist</strong>, Dr Jayson Meyers,\r\nsaid the find was significant and unexpected.</p>\r\n<p>地理学家和地球物理学家，Jayson Meyers\r\n博士说道，这个发现是意义重大且意料之外的。</p>\r\n<p>“This discovery was made in an area where the landscape is very flat.\r\nYou wouldn’t know it was there because the crater has been filled in\r\nover geological time,” he said.</p>\r\n<p>“这个坑是在一个非常平坦的区域发现的。你根本想象不到它在那，因为随着地质学时间的飞逝它已经被填充了。”他说道。</p>\r\n<p>The crater was discovered on land owned by Australia’s third-largest\r\ngold-mining company, Evolution Mining.</p>\r\n<p>陨石坑是被澳大利亚的第三大金矿公司，Evolution\r\nMining，在陆地上发现的。</p>\r\n<p>With a diameter of 5km, the Ora Banda crater is thought to be one of\r\nthe largest meteorite craters in the world.</p>\r\n<p>由于有着 5km 的直径 ，Ora Banda\r\n的陨石坑被认为是世界上最大的陨石坑之一。</p>\r\n<p>Using modern techniques, such as gravity surveying, geologists were\r\nable to map out the crater and Meyers thinks their successful find will\r\nlead to more discoveries.</p>\r\n<p>运用现代科技，例如重力勘测，地质学家能够标记出陨石坑的位置，并且\r\nMeyers 认为这个成功的探测会是更多发现的一个开头。</p>\r\n<p>“There’s probably quite a few more out there,” he said. “We’ve\r\nprobably been hit by more <strong>asteroids</strong> than we thought. If\r\nwe start recognising more of these, then the landscape begins changing,\r\nand we have to ask ourselves what’s the frequency and why are they\r\nhappening?”</p>\r\n<p>“那儿很可能有着更多，”他说道，“地球已经被超乎想象的多的小行星砸中过了。如果我们对此想的更远一些，【那么视角就会开始不一样了】，我们必须问自己撞击频率是怎么样的，并且为什么会发生这种事？”</p>\r\n<p>Meyers said more discoveries could help scientists better predict\r\nwhen a meteorite may next strike Earth.</p>\r\n<p>Meyers\r\n说更多的发现将帮助科学家们更好地预测何时一个陨石可能撞击地球。</p>\r\n<p>“If we can understand more of the geological history, we can predict\r\nwhen the next event will happen, or see when another rogue asteroid\r\ncould hit us.”</p>\r\n<p>“如果我们理解更多的地质历史，我们能预测下一次大事变会是什么时候，或者知道什么时候下一个陨石会袭击我们。”</p>\r\n<p>Close inspections of drilling samples included\r\n<strong>telltale</strong> signs of a meteorite strike, including\r\n“shatter cones”, which are known to form in the <strong>bedrock</strong>\r\nbelow craters or underground nuclear explosions.</p>\r\n<p>钻探样本的分析结果包含着陨石撞击的视觉信息，包含了“破裂锥”，而这是由陨石坑之下的基岩或者地下核爆炸形成。</p>\r\n<p>Meyers <strong>hypothesises</strong> the meteorite had to have been\r\nquite large in diameter to cause such an impact.</p>\r\n<p>Meyers 假设陨石应该有一个很大的直径才能造成这样的冲击。</p>\r\n<p>“To cause an impact of that size, the asteroid would’ve been\r\napproximately 100-200 metres in diameter, so it was a pretty big rock\r\nthat came sailing into our planet. The ground was actually pushed down\r\nfrom the pressure, but then the Earth rebounded, almost like a\r\n<strong>spring</strong>. It bounced back up.”</p>\r\n<p>“为了造成这种规模的冲击，小行星应该大概有 100-200\r\n米的直径。【所以它应该是一个很大的飞进我们星球的石头。】整个地面实际上都被压力压下去了，但是之后地球反弹了起来，就像一个弹簧。它反弹了回去。”</p>\r\n<p>Scientists discovered the world’s oldest meteorite crater in Western\r\nAustralia’s mid-west earlier this year.</p>\r\n<p>科学家们今年早些在西澳大利亚的中西部发现了这个世界最老的陨石坑。</p>\r\n<p>The Yarrabubba crater, located near Meekatharra in WA’s mid-west, was\r\nfound to be around 2.23 billion years old. That makes it over 200\r\nmillion years older than the next oldest crater.</p>\r\n<p>Yarrabubba 陨石坑，位于西澳大利亚中西部的 Meekatharra\r\n附近。它被发现有着 22.3 亿年的历史。这比起次老的陨石坑超了约 2\r\n亿年。</p>\r\n<h3 id=\"阅读原文\"><a\r\nhref=\"https://www.theguardian.com/science/2020/sep/03/massive-meteorite-crater-found-in-western-australia-thought-to-be-100-million-years-old\">阅读原文</a></h3>\r\n<h1 id=\"词汇\">词汇</h1>\r\n<ul>\r\n<li>outback 内陆</li>\r\n<li>estimate 估计</li>\r\n<li>diameter 直径</li>\r\n<li>geophysicist 地球物理学家</li>\r\n<li>asteroids 小行星</li>\r\n<li>telltale 告密者；视觉指示器</li>\r\n<li>bedrock 基岩</li>\r\n<li>hypothesises 假设</li>\r\n<li>spring 弹簧；弹；春天的</li>\r\n</ul>\r\n","categories":["杂记"],"tags":["英语"]},{"title":"骨架手语翻译","url":"/2021/12/15/%E9%AA%A8%E6%9E%B6%E6%89%8B%E8%AF%AD%E7%BF%BB%E8%AF%91/","content":"<p><strong>基于三维手部骨架数据的连续手语识别</strong></p>\r\n<p>王卓程,张景峤.基于三维手部骨架数据的连续手语识别[J/OL].计算机辅助设计与图形学学报:1-9[2021-12-15].http://kns.cnki.net/kcms/detail/11.2925.tp.20211007.1936.008.html.</p>\r\n<h2 id=\"手部骨架连续手语识别\">手部骨架连续手语识别</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/Z4LWl3N.png\"\r\nalt=\"手部骨架连续手语识别模型\" />\r\n<figcaption aria-hidden=\"true\">手部骨架连续手语识别模型</figcaption>\r\n</figure>\r\n<ol type=\"1\">\r\n<li>以腕部关节点为原点，计算相对坐标来替代绝对坐标</li>\r\n<li><strong>双路残差网络</strong>解决深度退化问题。</li>\r\n<li>注意力机制的Seq2Seq。由于注意力机制，编码器需要双向RNN。</li>\r\n<li>CTC算法，输入序列远长于输出序列时，且单调对齐。</li>\r\n</ol>\r\n<span id=\"more\"></span>\r\n<h2 id=\"多部位特征融合识别\">多部位特征融合识别</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/bOTmeW5.png\" alt=\"融合识别模型\" />\r\n<figcaption aria-hidden=\"true\">融合识别模型</figcaption>\r\n</figure>\r\n<ol type=\"1\">\r\n<li>Z-score 标准化预处理数据</li>\r\n<li>构建一系列并行多路时空图卷积网络，分别对不同部位的骨架提取特征。</li>\r\n<li>使用自适应融合方式对不同部位加权</li>\r\n<li>将融合特征输入基于注意力机制的编码解码网路</li>\r\n</ol>\r\n<h2 id=\"手语识别与翻译\">手语识别与翻译</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/DwGC84g.png\" alt=\"编码-编解码-解码\" />\r\n<figcaption aria-hidden=\"true\">编码-编解码-解码</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/JeyhN7L.png\" alt=\"编码-CTC-解码\" />\r\n<figcaption aria-hidden=\"true\">编码-CTC-解码</figcaption>\r\n</figure>\r\n<ol type=\"1\">\r\n<li>直接进行双路端到端翻译</li>\r\n<li>编码-双解码：相互依赖程度不高，没有手语识别作为中间监督。</li>\r\n<li>编码-编解码-解码：引入了中间监督，分散了编解码器的职能，降低了识别质量。</li>\r\n<li>编码-CTC-解码：手语识别和语音识别相似，都是输入序列远长于输出序列，且两序列单调对齐。使用语音识别中的联结主义时间分类(CTC)，成本比编解码更低。</li>\r\n</ol>\r\n","categories":["深度学习"],"tags":["深度学习","手语"]},{"title":"Hexo+Next7.8 功能性配置","url":"/2020/07/23/Next7-8-%E5%8A%9F%E8%83%BD%E6%80%A7%E9%85%8D%E7%BD%AE/","content":"<p>环境信息：</p>\r\n<ul>\r\n<li>Next 7.8.0</li>\r\n<li>hexo 4.2.1</li>\r\n<li>npm 6.14.5</li>\r\n<li>Next 配置文件指 **项目根目录/themes/next/_config.yml**</li>\r\n<li>项目配置文件指 **项目根目录/_config.yml**</li>\r\n<li>安装命令没特别说明都在 项目根目录 下进行</li>\r\n<li>注意在配置文件中配置字段时，请严格控制缩进</li>\r\n</ul>\r\n<p><strong>请根据目录章节按需阅读。所有配置都建立在2020年 7.8\r\n版本的基础之上实现的，保新保质，绝对不是复制偷搬那些祖传博客。</strong></p>\r\n<blockquote>\r\n<p>在吗？吐槽无数遍，2020 的人为什么写博客还抄的 Next4.0\r\n版本！就算你不想用 2020 大改版的版本，好歹和我一样用个 7.8\r\n吧！！至少来个 7.0+吧孩子们！！退一万步 6.0+也是可以的啊！！</p>\r\n</blockquote>\r\n<p>一些比较常规的功能性配置 Next\r\n文档里都有的。虽然是英文文档，虽然可能和你的版本有一点点不同，但它是基本跟着最新版本，比较全面。另外可以多摸摸\r\nNext\r\n配置文件，里面注释写的蛮详细的，有些东西看注释就知道能开启什么功能，当然，有很多功能需要额外插件支持。</p>\r\n<p><a href=\"https://theme-next.js.org/docs/\">Next 官方手册</a></p>\r\n<p>友情建议：进行较大更改之前，先通过git等方式进行保存。并且更改后为了避免样式不刷新，尽量先<code>hexo clean</code>清除样式再生成，并且最好先在本地<code>hexo s</code>部署。确认没有千疮百孔再推到线上吧。</p>\r\n<p><span id=\"more\"></span></p>\r\n<h2 id=\"站点概览描述\">站点概览描述</h2>\r\n<p>在项目配置里，第一段填写相关描述，如果是 next\r\n主题，会显示在侧边栏中。</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Site</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">我是一个标题</span></span><br><span class=\"line\"><span class=\"attr\">subtitle:</span> <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">&#x27;我是一段描述&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">keywords:</span> <span class=\"string\">Sitch,Blog</span></span><br><span class=\"line\"><span class=\"attr\">author:</span> <span class=\"string\">Sitch</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-CN</span></span><br><span class=\"line\"><span class=\"attr\">timezone:</span> <span class=\"string\">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"配置头像\">配置头像</h2>\r\n<p>在 Next 配置文件下找到 <code>avatar</code>字段，有如下配置项：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Sidebar Avatar</span></span><br><span class=\"line\"><span class=\"attr\">avatar:</span></span><br><span class=\"line\">  <span class=\"comment\"># Replace the default image and set the url here. 你的头像图片路径</span></span><br><span class=\"line\">  <span class=\"attr\">url:</span> <span class=\"string\">/images/avatar.png</span></span><br><span class=\"line\">  <span class=\"comment\"># If true, the avatar will be dispalyed in circle. 要不要圆化</span></span><br><span class=\"line\">  <span class=\"attr\">rounded:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"comment\"># If true, the avatar will be rotated with the cursor. 要不要在指针悬停时旋转头像</span></span><br><span class=\"line\">  <span class=\"attr\">rotated:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\r\n<p>如上给了个示例路径，然后将头像放在 <strong>主题</strong>目录下的\r\nsource/images/avatar.png 即可。</p>\r\n<p>另外两个属性可以按需配置。</p>\r\n<p>重新生成部署网站，瞅瞅你的大头照吧。</p>\r\n<blockquote>\r\n<p>头像图片大小没关系，会自动缩放，但是比例不变，即使圆化也会变成椭圆。因此请注意图片比例最好是正方形，美观。</p>\r\n</blockquote>\r\n<h2 id=\"next-的分类和标签\">Next 的分类和标签</h2>\r\n<p>在 next\r\n主题配置里，选择下列字段进行注释和取消注释即可启用相关页面，例如分类页和标签页。\r\n&gt;分类有层级，标签没有层级。</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">menu:</span> <span class=\"comment\"># 子链接 || font-font awesome 图标</span></span><br><span class=\"line\">  <span class=\"attr\">home:</span> <span class=\"string\">/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-home</span></span><br><span class=\"line\">  <span class=\"comment\">#about: /about/ || fa fa-user</span></span><br><span class=\"line\">  <span class=\"comment\">#tags: /tags/ || fa fa-tags</span></span><br><span class=\"line\">  <span class=\"attr\">categories:</span> <span class=\"string\">/categories/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-th</span></span><br><span class=\"line\">  <span class=\"attr\">archives:</span> <span class=\"string\">/archives/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-archive</span></span><br><span class=\"line\">  <span class=\"comment\"># schedule: /schedule/ || fa fa-calendar</span></span><br><span class=\"line\">  <span class=\"comment\"># sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class=\"line\">  <span class=\"comment\">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>\r\n<p>需要生成两个对应主页，在项目根目录下输入相应命令，创建相关页面。</p>\r\n<ul>\r\n<li><code>hexo new page categories</code></li>\r\n<li><code>hexo new page tags</code></li>\r\n</ul>\r\n<p>并且打开生成的页面，在元数据中相应添加字段</p>\r\n<ul>\r\n<li><code>type: categories</code></li>\r\n<li><code>type: tags</code>。</li>\r\n</ul>\r\n<p>想要为博客分类，即在自己的每篇博客描述头中，加入<code>categories:</code>\r\n<code>tags:</code>的相关字段，例如这篇：</p>\r\n<figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\">categories: </span><br><span class=\"line\"><span class=\"bullet\">-</span> 博客搭建</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"hexo文章资源管理\">hexo文章资源管理</h2>\r\n<p>想要简单使用懒得管理，直接放在\r\n<strong>项目目录/source/images</strong> 中。然后通过\r\n<strong>/images/something.jpg</strong> 路径进行调用。</p>\r\n<p>想要有规律的整理的话，hexo也有自带组织方式。资源管理功能打开后，Hexo会在hexo\r\nnew的时候创建一个和文章同名文件夹，将文章相关资源放进去即可。生成网页时资源和文章在同一路径，因此可以利用相对路径直接调用资源。</p>\r\n<p><a\r\nhref=\"https://hexo.io/zh-cn/docs/asset-folders\">hexo文档相关章节</a></p>\r\n<p>项目配置中设置：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">post_asset_folder:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>图片推荐使用Win10照片编辑器质量调整进行压缩。\r\n用照片编辑器打开图片，右键--调整大小--自定义尺寸--质量40%。压缩比高的惊人，粗略观感也没有太大区别。例如我1.8KB的图片质量40%可以变成0.09KB。</p>\r\n</blockquote>\r\n<h2 id=\"音乐\">音乐</h2>\r\n<h3 id=\"网易云音乐\">网易云音乐</h3>\r\n<p>先去网易云音乐里歌曲页面生成<strong>外链播放器</strong>，\r\n不能生成的可查找特殊方法生成。</p>\r\n<p>在 项目/themes/next/layout/_macro/sidebar.swig 中，\r\n插入复制的代码，比如插入在最下面某一段。 &gt;注意 2020 版本后缀不是\r\nswig，相关文件也不一样</p>\r\n<h3 id=\"aplayer全局音乐播放器\">aplayer全局音乐播放器</h3>\r\n<p>虽然网易云音乐足够播放一首歌或一个歌单，但是仅限定于网易云可怜的版权库里。</p>\r\n<p>通过使用APlayer播放器，可以播放任意来源的音乐，例如QQ音乐【我喜欢】的歌单。</p>\r\n<blockquote>\r\n<p>注意是原版APlayer，不是hexo-tag-aplayer</p>\r\n</blockquote>\r\n<p>无基础偷懒可以复制以下代码至 **主题目录/layout/_layout.swig**\r\n中，我放在了<code>&lt;/html&gt;</code>的前一行。</p>\r\n<blockquote>\r\n<p>有基础可以去看看中文文档，安装npm包，并且自定义使用。</p>\r\n</blockquote>\r\n<p>可以通过文档查看各个参数的意义，进行播放的设置。\r\n示例代码中是以<strong>QQ音乐</strong>为服务器，以<strong>我自己的歌单</strong>为播放列表。</p>\r\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- require APlayer --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- require MetingJS --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--如果将本体放在body里面，导致页面加载出现问题，请尝试放到body体后面--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;aplayer&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">data-id</span>=<span class=\"string\">&quot;3036324986&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">data-server</span>=<span class=\"string\">&quot;tencent&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">data-type</span>=<span class=\"string\">&quot;playlist&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">data-fixed</span>=<span class=\"string\">&quot;true&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">data-order</span>=<span class=\"string\">&quot;list&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">data-volume</span>=<span class=\"string\">&quot;0.65&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">data-autoplay</span>=<span class=\"string\">&quot;false&quot;</span>   </span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">date-preload</span>=<span class=\"string\">&quot;auto&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">data-theme</span>=<span class=\"string\">&quot;#cc543a&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\r\n<p>当然，全局播放器会在每一次切换站内页面时中断。\r\n要不中断播放请安装<strong>pjax</strong>功能，详见下一节。</p>\r\n<blockquote>\r\n<p>我为了百度统计，hexo-douban等功能不冲突，关闭了pjax。</p>\r\n</blockquote>\r\n<p>参考资料：<a\r\nhref=\"https://hakurei.red/2019/11/25/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80APlayer%E6%92%AD%E6%94%BE%E5%99%A8/\">Macyrate的APlyaer博客</a></p>\r\n<p><a href=\"https://aplayer.js.org/#/zh-Hans/\">Aplayer文档</a></p>\r\n<h2 id=\"pjax\">pjax</h2>\r\n<p>pjax可以使网页变成单页应用，即在站内切换页面并不会刷新网页，极大提高网页运行速度。</p>\r\n<p>但是！这么好的东西为什么不是默认开启的呢？\r\npjax会扰乱网站的一些其他功能。如hexo-douban页面，百度统计的访客记录\r\n......</p>\r\n<p>如果网站没有其他功能需求，建议开Pjax，否则建议不安装。</p>\r\n<p>在Next配置文件中设置pjax为true，并且去对应网站查看安装插件的方法。\r\n如git\r\nclone安装：<code>git clone https://github.com/theme-next/theme-next-pjax themes/next/source/lib/pjax</code>。</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Easily enable fast Ajax navigation on your website.</span></span><br><span class=\"line\"><span class=\"comment\"># Dependencies: https://github.com/theme-next/theme-next-pjax</span></span><br><span class=\"line\"><span class=\"attr\">pjax:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"数学公式支持\">数学公式支持</h2>\r\n<p>参考官方文档，需要切换到带有渲染mathjax的渲染引擎</p>\r\n<p>安装pandoc软件，<a\r\nhref=\"https://github.com/jgm/pandoc/releases/\">下载地址</a></p>\r\n<blockquote>\r\n<p>出现错误exit with code null\r\n大概是没有安装pandoc软件就直接安装了插件，补安装后如果还报错重启一下。</p>\r\n</blockquote>\r\n<p>命令行安装插件</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm uninstall hexo-renderer-marked --save</span><br><span class=\"line\">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure>\r\n<p>在 主题/_config.yml中，打开mathjax功能：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Math Formulas Render Support</span></span><br><span class=\"line\"><span class=\"attr\">math:</span></span><br><span class=\"line\">  <span class=\"comment\"># Default (true) will load mathjax / katex script on demand.</span></span><br><span class=\"line\">  <span class=\"comment\"># That is it only render those page which has `mathjax: true` in Front-matter.</span></span><br><span class=\"line\">  <span class=\"comment\"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span></span><br><span class=\"line\">  <span class=\"attr\">per_page:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span></span><br><span class=\"line\">  <span class=\"attr\">mathjax:</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"comment\"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class=\"line\">    <span class=\"attr\">mhchem:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\r\n<p>效果如下：</p>\r\n<p><span\r\nclass=\"math display\">\\[a^n+b^n=(a+b)(a^{n−1}b^0−a^{n−2}b^1+a^{n−3}b^2−…−ab^{n−2}+a^0b^{n−1})\\]</span>\r\n<code>$$a^n+b^n=(a+b)(a^&#123;n−1&#125;b^0−a^&#123;n−2&#125;b^1+a^&#123;n−3&#125;b^2−…−ab^&#123;n−2&#125;+a^0b^&#123;n−1&#125;)$$</code></p>\r\n<p>最后重新运行即可</p>\r\n<h2 id=\"导入豆瓣评价页面\">导入豆瓣评价页面</h2>\r\n<p>个人博客肯定想记录点自己生活向的东西，看过的电影，玩过的游戏,看过的书就是一个很好的记录对象。</p>\r\n<blockquote>\r\n<p>程序员大概很少有时间看文学书</p>\r\n</blockquote>\r\n<p>之前我是用 <strong>markdown</strong>\r\n写了个文本条目性质的，不说难看吧，但起码豆瓣条目自带一些影片介绍信息。..</p>\r\n<h3 id=\"安装-hexo-douban-插件\">安装 hexo-douban 插件</h3>\r\n<p>命令行输入</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-douban --save</span><br></pre></td></tr></table></figure>\r\n<p>将下面的配置写入<strong>项目</strong>配置文件：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">douban:</span> <span class=\"comment\">#不想启用的页面注释掉即可</span></span><br><span class=\"line\">  <span class=\"attr\">user:</span> <span class=\"string\">豆瓣</span> <span class=\"string\">id</span>  </span><br><span class=\"line\">  <span class=\"attr\">builtin:</span> <span class=\"literal\">false</span>  <span class=\"comment\">#是否将生成豆瓣页面功能嵌入到 hexo s 和 hexo g</span></span><br><span class=\"line\">  <span class=\"attr\">book:</span></span><br><span class=\"line\">    <span class=\"attr\">title:</span> <span class=\"string\">&#x27;This is my book title&#x27;</span>  <span class=\"comment\">#页面标题</span></span><br><span class=\"line\">    <span class=\"attr\">quote:</span> <span class=\"string\">&#x27;This is my book quote&#x27;</span>  <span class=\"comment\">#页面序言</span></span><br><span class=\"line\">  <span class=\"attr\">movie:</span></span><br><span class=\"line\">    <span class=\"attr\">title:</span> <span class=\"string\">&#x27;This is my movie title&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">quote:</span> <span class=\"string\">&#x27;This is my movie quote&#x27;</span></span><br><span class=\"line\">  <span class=\"attr\">game:</span></span><br><span class=\"line\">    <span class=\"attr\">title:</span> <span class=\"string\">&#x27;This is my game title&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">quote:</span> <span class=\"string\">&#x27;This is my game quote&#x27;</span></span><br><span class=\"line\">  <span class=\"attr\">timeout:</span> <span class=\"number\">10000</span> <span class=\"comment\">#爬取豆瓣数据的超时时间，别管了</span></span><br></pre></td></tr></table></figure>\r\n<p>豆瓣 id 可以在进入你的豆瓣个人主页，观察网址获得。通常为：</p>\r\n<p><code>https://www.douban.com/people/你的id/</code></p>\r\n<h3 id=\"hexo-douban-命令\">hexo douban 命令</h3>\r\n<p>用法如下：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Usage:</span> <span class=\"string\">命令行输入</span> <span class=\"string\">hexo</span> <span class=\"string\">douban</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">Description:</span></span><br><span class=\"line\"><span class=\"string\">爬取生成豆瓣相关页面</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">Options:</span> <span class=\"comment\">#默认参数 -bgm</span></span><br><span class=\"line\">  <span class=\"string\">-b,</span> <span class=\"string\">--books</span>   <span class=\"string\">Generate</span> <span class=\"string\">douban</span> <span class=\"string\">books</span> <span class=\"string\">only</span></span><br><span class=\"line\">  <span class=\"string\">-g,</span> <span class=\"string\">--games</span>   <span class=\"string\">Generate</span> <span class=\"string\">douban</span> <span class=\"string\">games</span> <span class=\"string\">only</span></span><br><span class=\"line\">  <span class=\"string\">-m,</span> <span class=\"string\">--movies</span>  <span class=\"string\">Generate</span> <span class=\"string\">douban</span> <span class=\"string\">movies</span> <span class=\"string\">only</span></span><br><span class=\"line\">  <span class=\"string\">-h，显示帮助</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"使用方法\">使用方法</h3>\r\n<ul>\r\n<li><code>hexo douban</code>生成相关页面再进行部署。</li>\r\n<li>builtin 开启时，直接 hexo s 和 hexo g 即包含生成过程。</li>\r\n</ul>\r\n<blockquote>\r\n<p>注意安装了 hexo-douban\r\n之后，我们多了个<code>hexo douban</code>的命令，因此不能再用<code>hexo d</code>作为<code>hexo deploy</code>的缩写了。</p>\r\n</blockquote>\r\n<h3 id=\"开个主页栏\">开个主页栏</h3>\r\n<p>生成部署后就可以通过<code>/主网址/movies</code>类似的形式访问了，但这样显然不方便，因此我们开个主页栏给它。</p>\r\n<p>和之前开启分类页一样，在<strong>主题</strong>配置文件中，找到 menu\r\n字段，添加相应的值，如下以 movies 举例进行修改：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">menu:</span> <span class=\"comment\"># 子链接 || font-font awesome 图标</span></span><br><span class=\"line\">  <span class=\"attr\">home:</span> <span class=\"string\">/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-home</span></span><br><span class=\"line\">  <span class=\"comment\">#about: /about/ || fa fa-user</span></span><br><span class=\"line\">  <span class=\"attr\">tags:</span> <span class=\"string\">/tags/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-tags</span></span><br><span class=\"line\">  <span class=\"attr\">categories:</span> <span class=\"string\">/categories/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-th</span></span><br><span class=\"line\">  <span class=\"attr\">archives:</span> <span class=\"string\">/archives/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-archive</span></span><br><span class=\"line\">  <span class=\"attr\">movies:</span> <span class=\"string\">/movies/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-film</span>  <span class=\"comment\">#添加了 movies 页</span></span><br><span class=\"line\">  <span class=\"comment\">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class=\"line\">  <span class=\"comment\">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class=\"line\">  <span class=\"comment\">#commonweal: /404/ || fa fa-heartbeat</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>但是这样开启之后，显示的是 movies\r\n，想改成中文显示需要在<code>主题目录/languages/zh-CN</code>中配置一下，自己打开看看就懂得怎么配了，懒得贴实例了哈=。=</p>\r\n<h3 id=\"参考资料\">参考资料</h3>\r\n<p><a href=\"https://github.com/mythsman/hexo-douban\">hexo-douban\r\n文档</a></p>\r\n<h2 id=\"字数统计和阅读时长已废弃\">字数统计和阅读时长（已废弃）</h2>\r\n<p><strong>hexo-symbols-count-time 已失去维护，且其依赖项highlight\r\nversion9 已经过时，无法使用。</strong></p>\r\n<p>在 next 主题配置文件中搜索 wordcount，可以看到它默认支持的插件是 <a\r\nhref=\"https://github.com/theme-next/hexo-symbols-count-time\">hexo-symbols-count-time</a></p>\r\n<p>使用命令行 npm\r\n输入命令进行安装：<code>npm i hexo-symbols-count-time --save</code></p>\r\n<p>项目_config.yml 里追加一段（没追加这一段导致统计为 NaN</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">symbols_count_time:</span></span><br><span class=\"line\"> <span class=\"attr\">symbols:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"> <span class=\"attr\">time:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"> <span class=\"attr\">total_symbols:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">total_time:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">awl:</span> <span class=\"number\">2</span>      <span class=\"comment\">#设置 2 个字符看作一个字</span></span><br><span class=\"line\">  <span class=\"attr\">wpm:</span> <span class=\"number\">200</span>    <span class=\"comment\">#每分钟阅读字数</span></span><br></pre></td></tr></table></figure>\r\n<p>next 主题的_config.yml 里找到字段 symbols_count_time\r\n按需配置即可：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Post wordcount display settings</span></span><br><span class=\"line\"><span class=\"comment\"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class=\"line\"><span class=\"attr\">symbols_count_time:</span></span><br><span class=\"line\">  <span class=\"attr\">separated_meta:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">item_text_post:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">item_text_total:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>重新生成部署即可，如果没有效果，试试 hexo clean 再重新生成</p>\r\n<h2 id=\"首页摘要-阅读全文\">首页摘要 阅读全文</h2>\r\n<p>如果你是找了半天博客，发现他们都说 Next\r\n自带自动摘要功能，但自己这就是不起作用的时候，恭喜你，和我一起把那些馊饭博客砸了吧。</p>\r\n<p>7.6 以后的 Next 删除了自动摘要功能，原因是它觉得它负担了太多。..</p>\r\n<p>我 7.8 的 Next\r\n配置文件里只有个<code>excerpt_description</code>，这个功能是自动将博客头描述里的<code>description</code>字段当作摘要。</p>\r\n<p>所以现在首页摘要只有两种办法：</p>\r\n<ul>\r\n<li>为每个博客写好 description</li>\r\n<li>在博客中间手动添加<code>&lt;!-- more --&gt;</code>以截断</li>\r\n</ul>\r\n<h2 id=\"添加百度分析\">添加百度分析</h2>\r\n<p>登陆 <a\r\nhref=\"https://tongji.baidu.com/web/10000256460/welcome/login\">百度统计</a></p>\r\n<p>进入个人页，选择侧栏的代码获取页</p>\r\n<p>可以看到如下一段代码，找到<code>hm.js?</code>之后的序列号复制。</p>\r\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">var</span> _hmt = _hmt || [];</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> hm = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;script&quot;</span>);</span><br><span class=\"line\">  hm.src = <span class=\"string\">&quot;https://hm.baidu.com/hm.js? 复制这段&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> s = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">&quot;script&quot;</span>)[<span class=\"number\">0</span>]; </span><br></pre></td></tr></table></figure>\r\n<p>填写在 next 配置里的百度分析字段中：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Baidu Analytics</span></span><br><span class=\"line\"><span class=\"attr\">baidu_analytics:</span> <span class=\"string\">粘贴到这里</span></span><br></pre></td></tr></table></figure>\r\n<p>之后等待一段时间就可以去百度分析主页看网站情况啦。</p>\r\n<p>然后你就能开心地发现几天，几十天，几百天，访问量蹭蹭蹭的涨，访问 ip\r\n一直都只有 1 个 hhhh。</p>\r\n<p>嗯，其实在被搜索引擎收录之前别人是搜不到你的博客的。</p>\r\n<p>请捞一捞下面的 Google 收录方法。</p>\r\n<h2 id=\"搜索引擎收录\">搜索引擎收录</h2>\r\n<p>以 Next 主题配置 Google 收录为例。</p>\r\n<p>登录 <a href=\"https://search.google.com/search-console/\">Google\r\nSearch Console</a></p>\r\n<blockquote>\r\n<p>当然，没有账号的话需要自己搞好 Google 账号</p>\r\n</blockquote>\r\n<h3 id=\"选择资源类型\">选择资源类型</h3>\r\n<p>我是 GitHub Pages\r\n域名的个人网站，所以选右边的单网址的资源类型。把博客网址复制过去即可创建资源。</p>\r\n<h3 id=\"验证网站所有权\">验证网站所有权</h3>\r\n<p>Goolge 推荐验证方法是下载 HTML\r\n文件。但是，我们不用。毕竟一个<code>hexo clean</code>网页就没了。..</p>\r\n<p>选下面的 HTML 标记验证，可以看到形如下面的一段代码。</p>\r\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;google-site-verification&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\r\n<p>把 xxxx 的东西复制好。</p>\r\n<p>打开 Next\r\n的配置文件，搜索到<code>google_site_verification</code>字段，把复制的字段填进去就好。</p>\r\n<p><code>hexo clean;hexo g;hexo d</code>一套刷新网站组合拳。</p>\r\n<p>回刚才的 Google 家里点击进行验证即可。</p>\r\n<p>验证成功后可以 Google\r\n搜索<code>site: 你的网址</code>试试，理应看到你的博客网址。</p>\r\n<blockquote>\r\n<p>这里很多看很多博客都是在抄几年前的方法，明明 2020 了啊哥哥们，Next\r\n已经传宗接代到 8.0\r\n了！！已经有内置<code>google-site-verification</code>字段了！！</p>\r\n<p>明明限制了搜索时间是半年以内，结果 2020 年这群人写的教程还是抄的 10\r\n年的东西看着好烦啊喂！！！！！！！！！！！！！！</p>\r\n</blockquote>\r\n<h3 id=\"添加站点地图-sitemap\">添加站点地图 SiteMap</h3>\r\n<p>站点地图可以将我们网站的组织架构提供给 Google，都是为了搜索优化==</p>\r\n<p>安装 hexo 自动生成站点地图的插件：</p>\r\n<p><code>npm install hexo-generator-sitemap --save</code></p>\r\n<p>安装成功后在项目配置文件中添加：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">sitemap:</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">sitemap.xml</span></span><br></pre></td></tr></table></figure>\r\n<p>这样插件每次会在<code>hexo g</code>时自动生成 sitemap.xml\r\n文件，放在/public/下面。</p>\r\n<blockquote>\r\n<p>注意博客文件名带有<code>&amp;</code>时，生成的 sitemap.xml\r\n会有错误，我的解决办法是修改文件名。</p>\r\n</blockquote>\r\n<p>其实我们也知道每次部署出去的网站也就是/public/目录，所以 sitemap.xml\r\n相当于放在网站根目录下面。</p>\r\n<p>因此我们把<code>你的网站地址/sitemap.xml</code>这个链接提交给 Google\r\n即可。</p>\r\n<p>执行<code>hexo g;hexo d</code>生成 sitemap 并部署出去。</p>\r\n<p>在 <a\r\nhref=\"https://search.google.com/search-console/sitemaps/\">Google\r\nSearchConsole</a> 侧栏找到站点地图，提交上面说的链接，完毕。</p>\r\n<h3 id=\"百度收录\">百度收录</h3>\r\n<p>百度收录也是完全同理，next\r\n也内置了验证字段。需要注意的是，百度收录仅支持一级域名收录，所以假如没有自己的域名，GitHub\r\nPages 必须是个人主页user.github.io。</p>\r\n<p>并且由于百度无法爬取github\r\npages，因此需要自己主动提交网址供索引：</p>\r\n<ul>\r\n<li>next可以开启<strong>主动推送 baidu_push:\r\ntrue</strong>功能，每次点击你的某个网址时，会推送该网址给百度。(注意要在自己网站上关闭浏览器的广告拦截插件，这个会限制hexo脚本运行)</li>\r\n<li>自己去站点管理页主动提交sitemap。</li>\r\n</ul>\r\n<h2 id=\"站内本地搜索\">站内本地搜索</h2>\r\n<p>安装插件：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>\r\n<p>编辑<strong>项目</strong>配置文件，新增字段：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">search:</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">search.json</span>  <span class=\"comment\">#支持 json 或者 xml，默认 xml，但我用的有问题，推荐 json</span></span><br><span class=\"line\">  <span class=\"attr\">field:</span> <span class=\"string\">post</span></span><br><span class=\"line\">  <span class=\"attr\">format:</span> <span class=\"string\">html</span></span><br><span class=\"line\">  <span class=\"attr\">limit:</span> <span class=\"number\">10000</span></span><br></pre></td></tr></table></figure>\r\n<p>编辑<strong>主题</strong>配置文件，修改字段：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Local search</span></span><br><span class=\"line\"><span class=\"attr\">local_search:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"评论系统-valine\">评论系统 Valine</h2>\r\n<blockquote>\r\n<p>“会有人讨论吗？”——好的，回来填评论系统的坑了。</p>\r\n</blockquote>\r\n<p>Next 支持多评论系统同时存在 ...\r\n虽然我不知道哪个憨憨会同时装躲个评论系统，评论数据又不能共享。</p>\r\n<p>Next 内建支持很多评论系统，我选择了在国内支持比较友好的 Valine。</p>\r\n<p>可以跟着 Next\r\n官方教程做，当然不愿意看英文也无所谓，欢迎继续跟着我~</p>\r\n<p><a\r\nhref=\"https://theme-next.js.org/docs/third-party-services/comments.html\">Next-Valine</a></p>\r\n<p><strong><a\r\nhref=\"https://leancloud.cn/dashboard/login.html#/signin\">LeanCloud\r\n注册登录</a></strong>： Valine 使用了 LeanCloud 作为数据段，因此去\r\nLeanCloud 注册登录就行，然后创建应用。虽然这个注册需要实名制 ...\r\n有点小小小在意。</p>\r\n<p><strong>获取 ID 和\r\nKey</strong>：进入创建好的应用，选择<code>设置-&gt;应用 Keys</code>子页，复制<code>APP ID</code>和<code>App Key</code>。</p>\r\n<p><strong>Next 配置</strong>，在<strong>主题</strong>配置文件中搜索\r\ncomments, 找到字段如下，这里基本不用修改，按需看注释选择配置吧：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Multiple Comment System Support</span></span><br><span class=\"line\"><span class=\"attr\">comments:</span></span><br><span class=\"line\">  <span class=\"comment\"># Available values: tabs | buttons</span></span><br><span class=\"line\">  <span class=\"attr\">style:</span> <span class=\"string\">tabs</span></span><br><span class=\"line\">  <span class=\"comment\"># Choose a comment system to be displayed by default.</span></span><br><span class=\"line\">  <span class=\"comment\"># Available values: changyan | disqus | disqusjs | gitalk | livere | valine</span></span><br><span class=\"line\">  <span class=\"attr\">active:</span> <span class=\"string\">valine</span></span><br><span class=\"line\">  <span class=\"comment\"># Setting `true` means remembering the comment system selected by the visitor.</span></span><br><span class=\"line\">  <span class=\"attr\">storage:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\"># Lazyload all comment systems.</span></span><br><span class=\"line\">  <span class=\"attr\">lazyload:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"comment\"># Modify texts or order for any navs, here are some examples.</span></span><br><span class=\"line\">  <span class=\"attr\">nav:</span></span><br><span class=\"line\">    <span class=\"comment\">#disqus:</span></span><br><span class=\"line\">    <span class=\"comment\">#  text: Load Disqus</span></span><br><span class=\"line\">    <span class=\"comment\">#  order: -1</span></span><br><span class=\"line\">    <span class=\"comment\">#gitalk:</span></span><br><span class=\"line\">    <span class=\"comment\">#  order: -2</span></span><br></pre></td></tr></table></figure>\r\n<p>在<strong>主题</strong>配置文件中搜索 valine\r\n，找到相应的字段如下：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">valine:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"attr\">appid:</span> <span class=\"comment\">#你的 APPID</span></span><br><span class=\"line\">  <span class=\"attr\">appkey:</span> <span class=\"comment\">#你的 APPkey</span></span><br><span class=\"line\">  <span class=\"attr\">notify:</span> <span class=\"literal\">false</span> <span class=\"comment\"># 邮件提醒</span></span><br><span class=\"line\">  <span class=\"attr\">verify:</span> <span class=\"literal\">false</span> <span class=\"comment\"># 验证码</span></span><br><span class=\"line\">  <span class=\"attr\">placeholder:</span> <span class=\"string\">欢迎用你的脸滚一滚键盘~</span>  <span class=\"comment\">#评论输入框预置文字</span></span><br><span class=\"line\">  <span class=\"attr\">avatar:</span> <span class=\"string\">mm</span> <span class=\"comment\"># Gravatar style</span></span><br><span class=\"line\">  <span class=\"attr\">guest_info:</span> <span class=\"string\">nick,mail,link</span> <span class=\"comment\"># 自定义评论区头部</span></span><br><span class=\"line\">  <span class=\"attr\">pageSize:</span> <span class=\"number\">10</span> <span class=\"comment\"># 分页限制大小</span></span><br><span class=\"line\">  <span class=\"attr\">language:</span> <span class=\"comment\"># 语言，可用值：en, zh-cn</span></span><br><span class=\"line\">  <span class=\"attr\">visitor:</span> <span class=\"literal\">false</span> <span class=\"comment\"># Article reading statistic</span></span><br><span class=\"line\">  <span class=\"attr\">comment_count:</span> <span class=\"literal\">true</span> <span class=\"comment\"># If false, comment count will only be displayed in post page, not in home page</span></span><br><span class=\"line\">  <span class=\"attr\">recordIP:</span> <span class=\"literal\">false</span> <span class=\"comment\"># 是否记录 IP</span></span><br><span class=\"line\">  <span class=\"attr\">serverURLs:</span> <span class=\"comment\"># 注意国际版需要填写这里。</span></span><br><span class=\"line\">  <span class=\"comment\">#post_meta_order: 0</span></span><br></pre></td></tr></table></figure>\r\n<p>把 enable 置 true，并且对应粘贴好之前的 AppID 和 AppKey。</p>\r\n<p>重新部署就可以用了，默认为每个页面开启评论系统。</p>\r\n<blockquote>\r\n<p>特别注意LeanCloud国际版需要填写serverURLs字段：在LeanCloud\r\n设置--应用凭证--REST API服务器地址。</p>\r\n</blockquote>\r\n<h3 id=\"页面单独关闭评论\">页面单独关闭评论</h3>\r\n<p>在 markdown\r\n文件的元数据描述符中，添加<code>comments: false</code>，即可在当前页面关闭评论。</p>\r\n<blockquote>\r\n<p>推荐导航栏的那几个导航页都关掉，例如分类页、标签页、关于页。</p>\r\n</blockquote>\r\n<h3 id=\"管理评论数据\">管理评论数据</h3>\r\n<p>登录 LeanCloud\r\n对应应用的管理页面，选择<code>存储-&gt;结构化数据-&gt;Comment</code>，即可看到评论数据，并且可以偷偷行使你的管理权限。</p>\r\n<h3 id=\"评论邮件通知-valine-admin\">评论邮件通知 valine-admin</h3>\r\n<p><a href=\"https://github.com/DesertsP/Valine-Admin\">官网地址</a></p>\r\n<h2 id=\"更换自定义域名\">更换自定义域名</h2>\r\n<p>首先，找一个卖域名的网站买好自己的域名= =并且做好DNS解析转到Github\r\nPages，腾讯云是可以一键解析到目标网址如： alobal.github.io。</p>\r\n<p>然后在你的博客source文件夹下，新建一个CNAME文件，内容写上你的域名如：sitchzou.com，重新部署即可。</p>\r\n<blockquote>\r\n<p>注意Github\r\npages设置里也可以改域名，但是只在那里改的话，你会发现每次部署域名都失效。因为它本质上就是在你的仓库根目录下创建了CNAME文件，但是你自己没在source里建的话，每次部署就把这个文件删除了。</p>\r\n</blockquote>\r\n<h2 id=\"hexo忽略文章\">Hexo忽略文章</h2>\r\n<p>不要用Hexo配置文件的 exclude字段来忽略 'source/_posts/'\r\n中的文章，这样没有用。在要忽略的文件的文件名之前加一个下划线\"_\"即可忽略。</p>\r\n<blockquote>\r\n<p>使用 'skip_render'可跳过指定文件的渲染，即将文件原封不动发布。</p>\r\n</blockquote>\r\n<h2 id=\"错误排除\">错误排除</h2>\r\n<h3 id=\"hexo升级到5.4引发bug\">hexo升级到5.4引发BUG</h3>\r\n<p><strong>next7.8的目录跳转功能失效</strong>：<a\r\nhref=\"https://www.github.com/next-theme/hexo-theme-next/commit/0d2b3af50b3b597fb3d0ecd6a6ffdfbf6b92745b\">参考该commit修改文件即可</a></p>\r\n<p><strong>阅读全文失效</strong>：严格按照<code>&lt;!-- more --&gt;</code>分割，之前的版本中格式比较随意也能兼容，5.4不行。</p>\r\n<h3 id=\"mathjax配置好但不渲染\">Mathjax配置好但不渲染</h3>\r\n<p>主题_config中vendors下的mathjax误添加了enable字段，删掉留空即可。</p>\r\n<h1 id=\"参考资料-1\">参考资料</h1>\r\n<p><a href=\"https://theme-next.js.org/docs/\">Next Document</a>， <a\r\nhref=\"http://theme-next.iissnan.com/\">Next 中文入门文档</a></p>\r\n","categories":["工具"],"tags":["博客"]},{"title":"VSCode 配置 Microsoft C++","url":"/2020/08/25/VSCode%E9%85%8D%E7%BD%AEMicrosoftC/","content":"<h2 id=\"前言\">前言</h2>\r\n<p>本文是我自己翻译 Microsoft 的 <a\r\nhref=\"https://code.visualstudio.com/docs/cpp/config-msvc\">英文原文</a></p>\r\n<p>因为自己刚学 C++的时候，直接是装的 Visual Studio 2017，一套 20G 的\r\nIDE 解决所有事情，但是用着用着发现了 Visual Studio Code\r\n这个极致现代美感的编辑器！再看 VS 那傻大粗的体量实在不想用。</p>\r\n<p>然而 VSCode 只是个编辑器，要用来写\r\nC++还需要配置相应的编译器环境。网上大部分配置教程都是从下一个 MinGW 出发\r\n... 然而我本身已经装过了 VS，Microsoft C++环境已经有了，想着能不能直接给\r\nVSCode 用。</p>\r\n<p>但是找了半天没发现什么有用的教程，最后在微软官方文档中找到了英文教程，虽然也不是很全面，但入门使用是够了的。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"预备环境\">预备环境</h2>\r\n<h3 id=\"安装-visual-studio-code\">安装 <a\r\nhref=\"https://code.visualstudio.com/download\">Visual Studio\r\nCode</a></h3>\r\n<p>希望代码业非代码业都能试试这个编辑器（笑</p>\r\n<p>无论敲 markdown 还是代码都很舒服。</p>\r\n<h3 id=\"安装-vscode-的-cc-扩展\">安装 <a\r\nhref=\"https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools\">VSCode\r\n的 C/C++ 扩展</a></h3>\r\n<p>如果已经安装好了 VSCode，可以直接在如下的扩展视图 (Ctrl+Shift+X)\r\n里搜索'C++'然后安装作者是 Microsoft 的即可。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/cpp/cpp-extension.png\"\r\nalt=\"扩展视图\" />\r\n<figcaption aria-hidden=\"true\">扩展视图</figcaption>\r\n</figure>\r\n<h3 id=\"安装-microsoft-visual-c-编译工具集\">安装 Microsoft Visual C++\r\n编译工具集</h3>\r\n<p>本身之前在 VS 写 C++的人已经安装好了，不用管。</p>\r\n<p>有 VS 的人可以直接在 VS Installer 中勾选 C++ 工具集进行安装即可。</p>\r\n<p>没有 VS 的人可以直接单独下载 Microsoft C++ 工具集，去 <a\r\nhref=\"https://visualstudio.microsoft.com/downloads#other\">下载页面</a>\r\n滚动到最底部，展开 All downloads 直到找到 <strong>Build Tools for Visual\r\nStudio</strong>，进行下载。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/build-tools-for-vs.png\"\r\nalt=\"下载 Build Tools\" />\r\n<figcaption aria-hidden=\"true\">下载 Build Tools</figcaption>\r\n</figure>\r\n<p>点击这个会运行 Visual Studio Installer， 然后会展示 Visual Studio\r\n可用的构建工具集，选中 C++的安装即可。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/cpp-build-tools.png\"\r\nalt=\"VS Installer 安装 C+=\" />\r\n<figcaption aria-hidden=\"true\">VS Installer 安装 C+=</figcaption>\r\n</figure>\r\n<h3 id=\"检查安装效果\">检查安装效果</h3>\r\n<p>为了从命令行或者 VSCode 中使用 MSVC，你必须以 <strong>VS\r\n开发人员提示符 (Developer Command Prompt for Visual Studio)</strong>\r\n为基础运行。常规的 Shell，例如 PowerShell，Bash，或者 Windows\r\n命令行都不具有必须的路径环境变量集。</p>\r\n<p>为了打开 VS 开发人员提示符，在 Windows\r\n开始菜单中搜索“开发人员”（安装的英文版请搜索\"developer\"），即可在搜索结果中打开。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/developer-cmd-prompt-menu.png\"\r\nalt=\"搜索“开发人员”\" />\r\n<figcaption aria-hidden=\"true\">搜索“开发人员”</figcaption>\r\n</figure>\r\n<p>你可以测试你是不是真的有了 C++\r\n编译器，<code>cl.exe</code>，在打开的提示符中输入\r\n'cl'，如果输出版权和版本信息，以及基础用法描述，则恭喜你安装正确。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/check-cl-exe.png\"\r\nalt=\"安装正确\" />\r\n<figcaption aria-hidden=\"true\">安装正确</figcaption>\r\n</figure>\r\n<p>在开始使用之前，如果提示符的初始路径是在构建工具集所在的位置，请将提示符中的当前目录切换到你想要的项目目录，毕竟你不会想要把程序写在那个疙瘩角落。</p>\r\n<h2 id=\"创建-hello-world\">创建 Hello World</h2>\r\n<p>请跟着下面的代码做，在提示符中，创造一个新文件夹\r\n“projects”，用于存储所有 VSCode\r\n项目，然后创建一个子文件夹名叫“helloworld”，并且用 VSCode\r\n打开这个子文件夹。</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir projects</span><br><span class=\"line\">cd projects</span><br><span class=\"line\">mkdir helloworld</span><br><span class=\"line\">cd helloworld</span><br><span class=\"line\">code .</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>注意这里个人推荐你使用纯英文路径。你永远不知道什么时候会挖一天一个月的中文路径\r\nBUG。</p>\r\n</blockquote>\r\n<p><code>code .</code>命令会用 VSCode\r\n打开当前目录，并且构建成“工作区（workspace）”，当你继续跟着教程走，最终会在这个工作区中创建一个<code>.vscode</code>文件夹，里面有文件如下：\r\n- tasks.json （编译指令） - launch.json （调试器设置） -\r\nc_cpp_properties.json （编译器路径及 智能感知 IntelliSense 设置）</p>\r\n<h3 id=\"添加一个源代码文件\">添加一个源代码文件</h3>\r\n<p>在 VSCode 资源管理器 (<code>Ctrl+Shift+E</code>)\r\n中，点击<strong>新建文件</strong>按钮，并且命名为<code>helloworld.cpp</code>。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/new-file-button.png\"\r\nalt=\"new file\" />\r\n<figcaption aria-hidden=\"true\">new file</figcaption>\r\n</figure>\r\n<p>打开新建的文件，粘贴如下代码：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    vector&lt;string&gt; msg &#123;<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;C++&quot;</span>, <span class=\"string\">&quot;World&quot;</span>, <span class=\"string\">&quot;from&quot;</span>, <span class=\"string\">&quot;VS Code&quot;</span>, <span class=\"string\">&quot;and the C++ extension!&quot;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> string&amp; word : msg)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; word &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>然后按下<code>Ctrl+S</code>保存文件。注意你可以看到刚添加的文件会在\r\nVSCode 的资源管理器中出现。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/file-explorer.png\"\r\nalt=\"出现文件\" />\r\n<figcaption aria-hidden=\"true\">出现文件</figcaption>\r\n</figure>\r\n<p>你也可以在上方菜单栏的<strong>文件</strong>菜单下，打开<strong>自动保存</strong>，以自动保存文件的修改。</p>\r\n<p>最左边的活动栏可以让你打开不同的视图，例如<strong>搜索</strong>，<strong>源代码管理</strong>，和<strong>运行</strong>。待会你会用到<strong>运行</strong>，其他的你可以在\r\nVSCode 的 <a\r\nhref=\"https://code.visualstudio.com/docs/getstarted/userinterface\">用户交互文档</a>\r\n中查阅相关信息。</p>\r\n<blockquote>\r\n<p>注意当你保存或打开一个 C++文件时，你可能可以看到一个来自\r\nC/C++扩展的关于测试版本的通知，这可以让你体验扩展的新特性。你可以点<code>X</code>无视它。</p>\r\n</blockquote>\r\n<h3 id=\"探索智能感知intellisense\">探索智能感知（IntelliSense）</h3>\r\n<p>在你新建的<code>helloworld.cpp</code>文件中，鼠标悬浮在<code>vector</code>或<code>string</code>上可以看到相应的类型信息。在<code>msg</code>的声明语句之后，敲入<code>msg.</code>以尝试调用一个成员函数。这是你会立刻看到一个语法补全列表，展示了所有的成员函数，并且还能看到一个有关<code>msg</code>类型信息的窗口。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/wsl/msg-intellisense.png\"\r\nalt=\"msg\" />\r\n<figcaption aria-hidden=\"true\">msg</figcaption>\r\n</figure>\r\n<p>你可以按下<code>Tab</code>直接插入选中的那一项。之后，当你输入小括号时，你可以看到有关函数参数的相关信息。</p>\r\n<h3 id=\"编译-helloworld.cpp\">编译 helloworld.cpp</h3>\r\n<p>接下来，你将创建一个<code>tasks.json</code>文件，以告诉 VSCode\r\n怎么去编译这个程序。这个编译配置（task）会唤醒 Microsoft C++\r\n编译器，编译这个源代码生成可执行文件。</p>\r\n<p>在主菜单中，点击 <strong>终端 &gt;\r\n配置默认生成任务</strong>，这会展示一系列预定义好的 C++\r\n编译器编译配置，选择<code>C/C++ cl.exe build active file</code>，这会在当前目录中生成一个<code>.vscode</code>子文件夹，并且在里面创建<code>tasks.json</code>文件。</p>\r\n<p>你新建的<code>tasks.json</code>文件应该长得和下面差不多：\r\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">&quot;version&quot;</span>: <span class=\"string\">&quot;2.0.0&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">&quot;tasks&quot;</span>: [</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;shell&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">&quot;label&quot;</span>: <span class=\"string\">&quot;C/C++: cl.exe build active file&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">&quot;command&quot;</span>: <span class=\"string\">&quot;cl.exe&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">&quot;args&quot;</span>: [</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">&quot;/Zi&quot;</span>,</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">&quot;/EHsc&quot;</span>,</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">&quot;/Fe:&quot;</span>,</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">&quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">&quot;$&#123;file&#125;&quot;</span></span><br><span class=\"line\">\t\t\t],</span><br><span class=\"line\">\t\t\t<span class=\"attr\">&quot;options&quot;</span>: &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">&quot;cwd&quot;</span>: <span class=\"string\">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">&quot;problemMatcher&quot;</span>: [</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">&quot;$msCompile&quot;</span></span><br><span class=\"line\">\t\t\t],</span><br><span class=\"line\">\t\t\t<span class=\"attr\">&quot;group&quot;</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">&quot;kind&quot;</span>: <span class=\"string\">&quot;build&quot;</span>,</span><br><span class=\"line\">                <span class=\"attr\">&quot;isDefault&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li><strong>command</strong> 指定了想要运行的程序是\"cl.exe\"</li>\r\n<li><strong>args</strong> 指定了 cl.exe\r\n的一系列命令行参数，这些参数必须按照编译器期望的顺序进行指定。</li>\r\n<li><strong>/Fe:</strong> 指定生成可执行文件的输出目录 这个配置告诉 C++\r\n编译器去找到<code>$&#123;file&#125;</code>文件，编译它，并且在当前目录<code>$&#123;fileDirname&#125;</code>下生成和源文件同名但扩展名是<code>.exe</code>的可执行文件<code>$&#123;fileBasenameNoExtension&#125;.exe</code>，在我们的例子中会得到<code>helloworld.exe</code>。</li>\r\n</ul>\r\n<blockquote>\r\n<p>你可以在 <a\r\nhref=\"https://code.visualstudio.com/docs/editor/variables-reference\">变量参考</a>\r\n中了解更多关于<code>tasks.json</code>的信息</p>\r\n</blockquote>\r\n<ul>\r\n<li>label\r\n的值是你在配置列表里看到的关于配置的描述，你可以随便乱改。</li>\r\n<li>problemMatcher 的值指定了用于查找错误或警告的输出解析器。对于 cl.exe\r\n，<code>$msCompile</code>是最好的选择。</li>\r\n<li>isDefault: true\r\n是指定了当你按下<code>Ctrl+Shift+B</code>时，会运行的配置。仅仅是图个方便而已。设为\r\nfalse 了一样可以从 <strong>终端 &gt; 运行生成任务</strong>中运行。</li>\r\n</ul>\r\n<h3 id=\"编译运行\">编译运行</h3>\r\n<ol type=\"1\">\r\n<li><p>返回<code>helloworld.cpp</code>页面。因为你想要编译<code>helloworld.cpp</code>，而你的配置会编译当前文件（the\r\nactive file）。</p></li>\r\n<li><p>按下<code>Ctrl+Shift+B</code>或者从 <strong>终端 &gt;\r\n运行生成任务</strong>中运行编译任务。</p></li>\r\n<li><p>编译开始后，你可以看到 VSCode\r\n的集成终端面板会出现在源代码编辑器的下方。在编译完成后，可以看到编译成功或者失败。假如成功，输出应该长这样（中文环境应该是如图的对应翻译）</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/build-output-in-terminal.png\"\r\nalt=\"successful output\" />\r\n<figcaption aria-hidden=\"true\">successful output</figcaption>\r\n</figure></li>\r\n<li><p>点击终端面板的<code>+</code>按钮创建一个新的终端。在里面输入运行<code>ls</code>，你可以看到<code>helloworld.exe</code>文件和一些\r\nC++ 中间文件已经生成了，并且还有 Debug\r\n相关文件（<code>helloworld.obj</code>,<code>helloworld.pbd</code>）</p></li>\r\n</ol>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/helloworld-in-terminal.png\"\r\nalt=\"ls\" />\r\n<figcaption aria-hidden=\"true\">ls</figcaption>\r\n</figure>\r\n<ol start=\"5\" type=\"1\">\r\n<li>你可以命令行输入<code>./helloworld.exe</code>运行文件。</li>\r\n</ol>\r\n<h3 id=\"修改-tasks.json\">修改 tasks.json</h3>\r\n<p>你可以用<code>$&#123;workspaceFolder&#125;\\\\*.cpp</code>代替<code>$&#123;file&#125;</code>，以同时编译多个\r\nC++ 文件。这回编译所有的当前目录下的\r\n<code>.cpp</code>文件。当然你也可以通过修改<code>$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe</code>，以替换输出文件的名字。</p>\r\n<h2 id=\"调试-helloworld.cpp\">调试 helloworld.cpp</h2>\r\n<p>接下来你会创建一个<code>launch.json</code>文件，以配置当你按下<code>F5</code>进行调试时，VSCode\r\n怎么去运行 Microsoft C++\r\n调试器。在主菜单中，点击<code>运行 &gt;  添加配置</code>，选择\r\n<strong>C++ （Windows）</strong>。</p>\r\n<p>接下来可以看到一个预定义的调试配置列表，选择\r\n<code>cl.exe build and debug active file</code>。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/build-and-debug-active-file.png\"\r\nalt=\"debug\" />\r\n<figcaption aria-hidden=\"true\">debug</figcaption>\r\n</figure>\r\n<p>这时 VSCode 会创建一个<code>launch.json</code>的文件如下：\r\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;</span>: <span class=\"string\">&quot;0.2.0&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;configurations&quot;</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;cl.exe build and debug active file&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;cppvsdbg&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;request&quot;</span>: <span class=\"string\">&quot;launch&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;program&quot;</span>: <span class=\"string\">&quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;args&quot;</span>: [],</span><br><span class=\"line\">      <span class=\"attr\">&quot;stopAtEntry&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;cwd&quot;</span>: <span class=\"string\">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;environment&quot;</span>: [],</span><br><span class=\"line\">      <span class=\"attr\">&quot;externalConsole&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;preLaunchTask&quot;</span>: <span class=\"string\">&quot;cl.exe build active file&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li>program\r\n指定了想要调试的程序，即当前目录下，和当前文件同基础名的<code>.exe</code>文件。</li>\r\n<li>stopAtEntry 默认为\r\nfalse，调试器不会事先添加任何断点。我们修改为<code>true</code>，则会在进入<code>main</code>函数时暂停并等待我们的调试。</li>\r\n</ul>\r\n<h3 id=\"开始调试\">开始调试</h3>\r\n<ol type=\"1\">\r\n<li><p>返回<code>helloworld.cpp</code>，这样它就是“当前文件”了。</p></li>\r\n<li><p>按<code>F5</code>或者点击<code>运行 &gt; 启动调试</code>。此时会有一些\r\nUI 界面的变化：</p></li>\r\n</ol>\r\n<ul>\r\n<li><p>集成终端会在底部出现，在\r\n<code>调试输出</code>标签下，你可以看到体现调试器正在运行的输出。</p></li>\r\n<li><p>在<code>main</code>函数的第一行编辑器会产生高亮。这是之前的修改导致的\r\nC++ 扩展预先帮我们打好的断点。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/stopAtEntry.png\"\r\nalt=\"main\" />\r\n<figcaption aria-hidden=\"true\">main</figcaption>\r\n</figure></li>\r\n<li><p>左边侧栏会出现<strong>运行</strong>视图</p></li>\r\n<li><p>编辑器上方会出现调试控制面板。你可以随便挪动。</p></li>\r\n</ul>\r\n<h3 id=\"逐步执行代码\">逐步执行代码</h3>\r\n<p>现在我们已经做好了逐步执行代码的准备。</p>\r\n<ol type=\"1\">\r\n<li><p>在调试控制面板点击<strong>单步跳过（F10）</strong>按钮，直到语句<code>for (const string&amp; word : msg)</code>高亮。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/cpp/step-over-button.png\"\r\nalt=\"Step Over\" />\r\n<figcaption aria-hidden=\"true\">Step Over</figcaption>\r\n</figure>\r\n<p><strong>单步跳过</strong>命令会跳过在<code>msg</code>变量创建并初始化时，所有<code>vector</code>和<code>string</code>类的内部函数调用。注意到左边<strong>变量</strong>窗口，此时看起来可能有点不对劲。虽然调试器已经能看到循环控制的变量名了，但此时当前语句还没有执行，因此读取不到变量值。另一方面，因为<code>msg</code>的语句执行完了，它的值是可以看到的。</p></li>\r\n<li><p>再按一下<strong>单步跳过</strong>以进入下一条语句（跳过了所有内部代码）。此时**变量*窗口可以看到循环变量的信息了。</p></li>\r\n<li><p>再按一下<strong>单步跳过</strong>以执行<code>cout</code>语句。<strong>注意</strong>如果是\r\n2019.3 的扩展版本，直到循环完成前是看不到任何输出的。</p></li>\r\n<li><p>你可以一直按下去直到所有输出结束。当然如果你想要更细致一点，试着点击<strong>单步调试（F11）</strong>,\r\n以逐步执行 C++ 标准库中的内部代码。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/msvc-system-header-stepping.png\"\r\nalt=\"incode\" />\r\n<figcaption aria-hidden=\"true\">incode</figcaption>\r\n</figure>\r\n<p>如果想要返回你自己的代码。可以一直按<strong>单步跳过</strong>直到返回。另外也可以切换到<code>helloworld.cpp</code>中在某个语句处按<code>F9</code>打一个断点，此时在左边会出现一个红点表明这一行已经打上了断点：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/cpp/breakpoint-in-main.png\"\r\nalt=\"breakpoint\" />\r\n<figcaption aria-hidden=\"true\">breakpoint</figcaption>\r\n</figure>\r\n<p>这时按下<code>F5</code>会自动执行到断点处再次暂停。再次在断点位置按<code>F9</code>也可以取消掉断点。</p></li>\r\n</ol>\r\n<h3 id=\"设置监视\">设置监视</h3>\r\n<p>调试时，有些时候我们想要盯着程序中某些变量进行观察。可以通过<strong>监视变量</strong>功能实现这一想法。</p>\r\n<ol type=\"1\">\r\n<li><p>在调试时，左侧的<strong>监视</strong>窗口，点击<code>+</code>按钮，即可创建一个新的监视对象，例如输入循环控制变量的名字<code>word</code>,此时监视窗口会一直显示这个变量的值。请在逐步执行循环时观察监视窗口的变化。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/cpp/watch-window.png\"\r\nalt=\"watch\" />\r\n<figcaption aria-hidden=\"true\">watch</figcaption>\r\n</figure></li>\r\n<li><p>同样的，假如修改程序，在循环语句前假如<code>int i=0;</code>，在循环内部假如<code>++i;</code>。此时我们可以和刚才一样添加对<code>i</code>的监视。</p></li>\r\n<li><p>为了在暂停时快速查看任何变量的值，我们也可以把鼠标指针悬浮在变量上，即显示变量值。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/cpp/mouse-hover.png\"\r\nalt=\"hover\" />\r\n<figcaption aria-hidden=\"true\">hover</figcaption>\r\n</figure></li>\r\n</ol>\r\n<h2 id=\"cc-配置\">C/C++ 配置</h2>\r\n<p>如果你想要更多关于 C/C++\r\n扩展的配置，你可以创建一个<code>c_cpp_properties.json</code>文件，在其中你可以修改编译器路径、编译C++标准等等。</p>\r\n<p>通过（Ctrl+Shift+P）打开命令面板，输入<code>C/C++: 编辑配置(UI)（ C/C++: Edit configurations(UI) ）</code>，你可以查看\r\nC/C++ 的UI配置界面。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/cpp/command-palette.png\"\r\nalt=\"C++ UI\" />\r\n<figcaption aria-hidden=\"true\">C++ UI</figcaption>\r\n</figure>\r\n<p>这会打开 <strong>C/C++ 配置页面</strong>\r\n，当你在这里进行修改，VSCode会把变动写进<code>.vscode</code>文件夹下的<code>c_cpp_properties.json</code>文件中。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/configurations-ui.png\"\r\nalt=\"C/C++\" />\r\n<figcaption aria-hidden=\"true\">C/C++</figcaption>\r\n</figure>\r\n<p>如果你直接打开json文件，可以看到长得如下：</p>\r\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;configurations&quot;</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;Win32&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;includePath&quot;</span>: [<span class=\"string\">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>],</span><br><span class=\"line\">      <span class=\"attr\">&quot;defines&quot;</span>: [<span class=\"string\">&quot;_DEBUG&quot;</span>, <span class=\"string\">&quot;UNICODE&quot;</span>, <span class=\"string\">&quot;_UNICODE&quot;</span>],</span><br><span class=\"line\">      <span class=\"attr\">&quot;windowsSdkVersion&quot;</span>: <span class=\"string\">&quot;10.0.18362.0&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;compilerPath&quot;</span>: <span class=\"string\">&quot;C:/Program Files (x86)/Microsoft Visual Studio/2019/BuildTools/VC/Tools/MSVC/14.24.28314/bin/Hostx64/x64/cl.exe&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;cStandard&quot;</span>: <span class=\"string\">&quot;c11&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;cppStandard&quot;</span>: <span class=\"string\">&quot;c++17&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;intelliSenseMode&quot;</span>: <span class=\"string\">&quot;msvc-x64&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;</span>: <span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>如果你的程序包含 不在当前目录或者不在标准库路径的\r\n头文件，则你只需要在这里添加<strong>IncludePath</strong>即可。</p>\r\n<h3 id=\"编译器路径\">编译器路径</h3>\r\n<p><code>compilerPath</code>编译器路径配置是十分重要的一项配置。扩展会利用它推断\r\nC++\r\n标准库头文件的路径。只有当扩展知道怎么去找这些文件了，它才能提供<strong>智能补全</strong>和<strong>找到定义</strong>的相关功能。</p>\r\n<p>C/C++\r\n扩展会尝试通过它在你系统上找到的默认编译器位置，自动填充<code>compilePath</code>。</p>\r\n<p>一般搜索路径和顺序如下： - 首先检查 Microsoft Visual C++ compilerOpe\r\n- 然后检查 Windows Subsystem for Linux (WSL) 的g++ - 之后是 Mingw-w64的\r\ng++</p>\r\n<p>如果你安装了 g++ 或者\r\nWSL，你可能需要更改<code>compilerPath</code>以匹配项目偏好的编译器。对于\r\nMicrosoft\r\nC++，编译器路径一般和下面差不多，但是根据特定安装版本不同而有差异：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:/Program Files (x86)/Microsoft Visual Studio/2017/BuildTools/VC/Tools/MSVC/14.16.27023/bin/Hostx64/x64/cl.exe</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>注意，你可能不是安装在默认C盘位置。找到你的VS安装位置，然后找里面的VC子目录即可。</p>\r\n</blockquote>\r\n<h2 id=\"复用-c-配置\">复用 C++ 配置</h2>\r\n<p>VSCode 现在已经配置好使用 Microsoft C++\r\n编译器了。这个配置目前仅对当前工作区生效。为了复用配置，请把<code>.vscode</code>中的JSON文件复制到新的项目文件夹中，并且按需修改相关源文件和可执行文件的名字。</p>\r\n<h2 id=\"错误排除\">错误排除</h2>\r\n<h3 id=\"无法识别cl.exe\">无法识别\"cl.exe\"</h3>\r\n<p>如果你看到：</p>\r\n<ul>\r\n<li>cl : 无法将“cl”项识别为\r\ncmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。</li>\r\n<li>The term 'cl.exe' is not recognized as the name of a cmdlet,\r\nfunction, script file, or operable program.</li>\r\n</ul>\r\n<p>这通常意味着你不是通过 <strong>VS开发人员命令提示符（Developer\r\nCommand Prompt for Visual Studio\r\n）</strong>打开的VSCode，因此VSCode不知道<code>cl.exe</code>编译器的路径。</p>\r\n<p>你总是可以通过在VSCode终端中输入<code>cl</code>检查有没有在开发人员提示符中打开VSCode。</p>\r\n<blockquote>\r\n<p>...这个官方解决方案和没说一样，可以自行配置全局Path系统变量。</p>\r\n</blockquote>\r\n<h2 id=\"更进一步\">更进一步</h2>\r\n<ul>\r\n<li><p>探索<a\r\nhref=\"https://code.visualstudio.com/docs/editor/codebasics\">VSCode\r\n用户指南</a></p></li>\r\n<li><p>复习<a\r\nhref=\"https://code.visualstudio.com/docs/languages/cpp\">C++\r\n扩展概述</a></p></li>\r\n<li><p>创建一个新的工作区，复制<code>.vscode</code>下的JSON文件过去，并且对设置进行适当的调整，开始你的代码生活！</p></li>\r\n</ul>\r\n","categories":["工具"],"tags":["C++","VSCode"]},{"title":"深度学习框架","url":"/2021/11/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/","content":"<h1 id=\"网络结构\">网络结构</h1>\r\n<ul>\r\n<li>one-hot: 对离散的类别数据进行编码,\r\n如词元、标签等。通过编码可以将所有类别一视同仁,\r\n而避免造成label=5的标签比label=1的标签更重要。</li>\r\n<li>embedding:\r\n对词元进行one-hot编码之后，通常维度都会成千上万，并且除了一个维度是1以为，其他维度全都是0，编码很稀疏，效率很低。为了压缩维度使用embedding层进行维度压缩。</li>\r\n<li>残差层: 用于在网络F的基础上构造残差连接,\r\n如ReLU、GELU。在激活函数之前。</li>\r\n<li>Batch Normalization:\r\n每层网络运算之后的归一化。在网络计算与激活层之间。</li>\r\n<li>激活层:\r\n在两层神经网络之间，切断两层的线性联系，使网络组合可以变成非线性网络。</li>\r\n</ul>\r\n<h2 id=\"激活函数\">激活函数</h2>\r\n<p><a\r\nhref=\"https://microsoft.github.io/ai-edu/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/A2-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%AC%AC4%E6%AD%A5%20-%20%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/08.0-%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0.html\">原理讲解</a></p>\r\n<h3 id=\"sigmoidlogistictanh\">Sigmoid(Logistic/Tanh)</h3>\r\n<ul>\r\n<li>有输出概率的实际意义, 导数易求。</li>\r\n<li>但是计算需要指数运算, 效率低。而且梯度最大值≤0.25,\r\n在链式传播乘起来后会越来越小,\r\n最终网络一多就会造成梯度消失。另外Logistic均值不为0,\r\n会影响一点输入数据的均值分布, Tanh则不会。</li>\r\n</ul>\r\n<h3 id=\"reluleaky-relu\">ReLU/Leaky ReLU</h3>\r\n<p><span class=\"math display\">\\[\r\nReLU(z) = max(0,z) = \\begin{cases}z, &amp; z \\geq 0 \\\\\\\\0, &amp; z &lt;\r\n0\\end{cases}\r\n\\]</span></p>\r\n<ul>\r\n<li>正常的反向导数恒等于1, 收敛快。无论链式传播多少层梯度都为1,\r\n不存在梯度消失。且计算简单, 并且会造成神经元的稀疏性,\r\n降低计算成本。</li>\r\n<li>输出无界==&gt;输出可能很大==&gt;损失很大==&gt;梯度很大==&gt;梯度下降造成神经元参数W和b小于0==&gt;激活前的神经元输入小于0,\r\n激活时ReLU梯度恒为0, 即ReLU神经元死亡。</li>\r\n<li>在RNN中难以使用ReLU==RNN时间步中共享W参数矩阵, 相当于会对W做连乘,\r\n且ReLU不抑制输出, 最终输出结果很大。除非W初始化为I。</li>\r\n</ul>\r\n<blockquote>\r\n<p>ReLU不能接受小于0的输入, 不代表原始输入数据不能小于0,\r\n因为原始数据起码也在一层WX+b之后才会进入ReLU。而初始化的W是0对称分布,\r\nb则是恒为0, 因此会将输入数据变成有正有负, 不用担心。</p>\r\n</blockquote>\r\n<p><strong>Leaky ReLU</strong>: 在ReLU的基础上,\r\n给小于0的部分泄漏了一点点梯度,避免神经元死亡</p>\r\n<p><span class=\"math display\">\\[\r\nLReLU(z) = \\begin{cases} z &amp; z \\geq 0 \\\\\\\\ \\alpha \\cdot z &amp; z\r\n&lt; 0 \\end{cases}\r\n\\]</span></p>\r\n<h2 id=\"batch-normalization\">Batch Normalization</h2>\r\n<p>网络每一层的计算都会使输入数据的分布发生一点变化，变化随着层数放大。因此最后训练中间层数据分布可能已经不是原始数据分布了，BN（BatchNormalization）就是为了解决这种分布变化，从而获得以下优点：</p>\r\n<ul>\r\n<li>可以选择比较大的初始学习率，让你的训练速度提高</li>\r\n<li>减少对初始化的依赖</li>\r\n<li>减少对正则的依赖</li>\r\n</ul>\r\n<p><strong>使用方法</strong>：nn.BatchNorm1d/2d/3d(num_features)</p>\r\n<ul>\r\n<li>全连接层：置于全连接计算和激活层之间</li>\r\n<li>卷积层：分通道处理，一个通道一个批量归一化</li>\r\n<li>测试和预测时：由于只有一个样本不能批量归一化，因此可以采用训练时的全局均值来做归一化。在pytorch中把模型置为eval会自动做好。</li>\r\n</ul>\r\n<p><a\r\nhref=\"https://microsoft.github.io/ai-edu/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/A2-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%AC%AC7%E6%AD%A5%20-%20%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/15.5-%E6%89%B9%E9%87%8F%E5%BD%92%E4%B8%80%E5%8C%96%E7%9A%84%E5%8E%9F%E7%90%86.html\">详细原理</a>：BN即是在每一层都把数据分布归一化到0点附近，使得每一层网络都有着相同分布的数据。具体做法：</p>\r\n<ol type=\"1\">\r\n<li>先对方差、均值归一化，将数据分布移动0点附近：仅这一步还不够，由于区间在[-1,1]，可能会减弱激活函数效果，另外压缩了网络的学习空间，可能会破坏网络学习效果。</li>\r\n<li>通过可学习的参数\r\nγ，β，对数据进行可学习的线性变换来适当拉宽数据分布，解决上述问题。</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\n\\mu_B = \\frac{1}{m}\\sum_1^m x_i\\\\\r\n\\sigma^2_B = \\frac{1}{m} \\sum_1^m (x_i-\\mu_B)^2\\\\\r\nn_i = \\frac{x_i-\\mu_B}{\\sqrt{\\sigma^2_B + \\epsilon}} \\\\\r\nz_i = \\gamma n_i + \\beta\r\n\\]</span></p>\r\n<h1 id=\"优化\">优化</h1>\r\n<h2 id=\"网络参数\">网络参数</h2>\r\n<h3 id=\"参数初始化\">参数初始化</h3>\r\n<p>在自己的init_func中利用nn.init模块对不同的层定义不同的初始化方式。然后用net.apply(init_func)将函数应用到每一层。或者net[i].apply(init_func)单独应用：</p>\r\n<ul>\r\n<li>线性激活：Xavier，前提激活函数在零点附近线性，如tanh等。而ReLU不满足。</li>\r\n<li>ReLU：He，解决ReLU不能使用Xavier的问题。</li>\r\n</ul>\r\n<p><a\r\nhref=\"https://microsoft.github.io/ai-edu/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/A2-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%AC%AC7%E6%AD%A5%20-%20%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/15.1-%E6%9D%83%E9%87%8D%E7%9F%A9%E9%98%B5%E5%88%9D%E5%A7%8B%E5%8C%96.html#1514-msra\">详细介绍初始化方法</a></p>\r\n<h3 id=\"参数更新器\">参数更新器</h3>\r\n<p><strong>SGD</strong>：随机梯度下降</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\eta\\)</span>：全局学习率</li>\r\n<li>收敛慢，在终点容易错左右跳，可能陷入局部最优。</li>\r\n</ul>\r\n<p><strong>Momentum</strong>：更新时在一定程度上保留之前的方向，再通过当前梯度进行微调方向，即带有一定的<strong>惯性</strong>。</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\eta\\)</span>：全局学习率；<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>：动量系数；<span\r\nclass=\"math inline\">\\(v_t\\)</span>：初始方向</li>\r\n<li>增加稳定性学习更快，有一定的摆脱局部最优能力。</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://i.imgur.com/lLjsl2V.png\" alt=\"Momentum\" />\r\n<figcaption aria-hidden=\"true\">Momentum</figcaption>\r\n</figure>\r\n<p><strong>NAG</strong>：Nesterov Momentum/Nesterov Accelerated Gradient\r\n梯度加速算法。同Momentum，已知上一步的更新方向，那么在这次确定方向之前，先按之前的方向走一步，然后在新位置上求梯度，再用这个\r\n<strong>未来的梯度</strong> 在当前位置进行Momentum的方向计算。</p>\r\n<blockquote>\r\n<p>换句话说，就是把Momentum中计算当前梯度的步骤延后，先走一步看看，计算梯度，看看路顺不顺，再回到原位置决定要怎么走。</p>\r\n</blockquote>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\eta\\)</span>：全局学习率；<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>：动量系数；<span\r\nclass=\"math inline\">\\(v_t\\)</span>：初始方向</li>\r\n<li>相比于在原位置做方向的微调，NAG是先探好前方的路，再决定现在怎么走。因此更具有预见能力，未来的路更顺畅则加快速度，未来的路不好走则提前改变方向。</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://i.imgur.com/5Qx0WBN.png\" alt=\"Nesterov Momentum\" />\r\n<figcaption aria-hidden=\"true\">Nesterov Momentum</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<p>以下是<strong>自适应更新器</strong>：在同一步更新中，不同参数的更新步长不一样，自适应针对性调整，每个参数有自己的学习率。</p>\r\n<p><strong>AdaGrad</strong>:\r\n学习中会累计之前所有梯度平方之和作为学习率的分母，也就是更新步长会越来越小。同一步更新中，小梯度的参数更新会较大。</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\eta\\)</span>：全局学习率；<span\r\nclass=\"math inline\">\\(\\epsilon=1e-6\\)</span>：数值稳定的小常数；<span\r\nclass=\"math inline\">\\(r=0\\)</span>：累积辅助系数，不用管</li>\r\n</ul>\r\n<p><strong>AdaDelta</strong>：解决AdaGrad更新步长单调减小的问题，过去累计的梯度会不断衰减，减小影响。</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\eta\\)</span>：全局学习率；<span\r\nclass=\"math inline\">\\(\\alpha=0.9 \\in [0,1)\\)</span>：衰减比率；<span\r\nclass=\"math inline\">\\(s=0\\)</span>: 平方梯度累计，不用管；<span\r\nclass=\"math inline\">\\(r=0\\)</span>：累积辅助系数，不用管。</li>\r\n</ul>\r\n<p><strong>RMSProp</strong>：Root Mean Square Prop\r\n均方根反向传播。优化了AdaGrad在更新中摆幅过大的问题，学习率衰减不会太快，加快收敛速度，将梯度平方累计改成了加权平均累计。</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\eta=0.01\\)</span>：全局学习率；<span\r\nclass=\"math inline\">\\(\\epsilon=1e-6\\)</span>：数值稳定的小常数；<span\r\nclass=\"math inline\">\\(\\alpha=0.9 \\in [0,1)\\)</span>：加权比例；<span\r\nclass=\"math inline\">\\(r=0\\)</span>：累积辅助系数，<span\r\nclass=\"math inline\">\\(r=\\alpha r + (1-\\alpha)(g_t \\odot g_t\r\n)\\)</span>。</li>\r\n<li>初始学习率不能太大，容易不收敛。</li>\r\n</ul>\r\n<p><strong>Adam</strong>：Adaptive Moment Estimation\r\n<strong>主流选择</strong>。相当于RMSProp+Momentum。Adam在RMSProp算法基础上对小批量随机梯度也做了指数加权移动平均。</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\eta=0.01\\)</span>：全局学习率,<span\r\nclass=\"math inline\">\\(\\epsilon\\)</span>：数值稳定小常数；<span\r\nclass=\"math inline\">\\(\\beta_1=0.9,\\beta_2=0.999\\)</span>；矩估计指数衰减比率；</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://i.imgur.com/A8zSefI.png\"\r\nalt=\"主流更新算法比较：Momentum有惯性，比较平滑；RMSProp波动幅度小，后期步长越来越短；Adam结合两者优势，比Momentum幅度小，比RMSProp平滑\" />\r\n<figcaption\r\naria-hidden=\"true\">主流更新算法比较：Momentum有惯性，比较平滑；RMSProp波动幅度小，后期步长越来越短；Adam结合两者优势，比Momentum幅度小，比RMSProp平滑</figcaption>\r\n</figure>\r\n<p><a\r\nhref=\"https://microsoft.github.io/ai-edu/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/A2-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%AC%AC7%E6%AD%A5%20-%20%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/15.3-%E8%87%AA%E9%80%82%E5%BA%94%E5%AD%A6%E4%B9%A0%E7%8E%87%E7%AE%97%E6%B3%95.html\">AIEDU-自适应更新算法</a></p>\r\n<h3 id=\"学习率调度器\">学习率调度器</h3>\r\n<p>学习率调度器用于随着epoch改变学习率，通常我们希望lr随着epoch越来越小。通常的参数有：</p>\r\n<ul>\r\n<li>optimizer: 要修改学习率的更新器</li>\r\n<li>step_size:\r\n改变学习率的step周期。通常每个epoch之后调度器step一次，达到step_size则会改变学习率</li>\r\n<li>last_epoch:\r\n中断训练再继续的时候使用，告诉调度器上一次到达了多少epoch。</li>\r\n</ul>\r\n<p><strong>StepLR</strong>: 等间隔调整</p>\r\n<p><strong>CosineAnnealingLR</strong>：类似余弦的调度，学习率衰减先慢后快。torch.optim.lr_scheduler.</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/ZzrDYG9.png\" alt=\"余弦学习率变化\" />\r\n<figcaption aria-hidden=\"true\">余弦学习率变化</figcaption>\r\n</figure>\r\n<p><strong>另外学习率应该匹配批大小</strong>。通常我们希望经过同样数量的样本后，更新的步伐是一样的。因此增大了batch理论上应该增加lr。换个思路来说，衰减学习率也可以通过增加batch\r\nsize来实现。</p>\r\n<ul>\r\n<li>增加 batch\r\nsize，需要增加学习率来适应，可以用线性缩放的规则，成比例放大</li>\r\n<li>尽量使用大的学习率，因为很多研究都表明更大的学习率有利于提高泛化能力。如果真的要衰减，可以尝试其他办法，比如增加batch\r\nsize，学习率对模型的收敛影响真的很大，慎重调整。</li>\r\n<li>batch\r\nsize增加比较自由，但是大到一定程度的时候，学习率不能随之增加了，因为学习率有上限限制。</li>\r\n</ul>\r\n<blockquote>\r\n<p>在SGD中，学习率不能大于1，这是收敛必要条件。</p>\r\n</blockquote>\r\n<p><a\r\nhref=\"https://microsoft.github.io/ai-edu/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/A2-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%AC%AC5%E6%AD%A5%20-%20%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB/12.3-%E5%AD%A6%E4%B9%A0%E7%8E%87%E4%B8%8E%E6%89%B9%E5%A4%A7%E5%B0%8F.html\">学习率与批大小关系</a></p>\r\n<h2 id=\"过拟合\">过拟合</h2>\r\n<p>为了减轻过拟合，一定程度上限制权重的学习。weight_decay一般可以取0.005</p>\r\n<h3 id=\"l2正则\">L2正则</h3>\r\n<p>限制权重L2范数大小，通常小的模型适应能力较强。一般不会正则bias，bias对学习影响不大，没有什么明显效果。</p>\r\n<p><span class=\"math display\">\\[\r\nJ(w,b)= J_{old}(w,b)+\\frac{\\lambda}{2m}\\sum_{j=1}^n{w_j^2}\r\n\\]</span></p>\r\n<h3 id=\"l1正则\">L1正则</h3>\r\n<p>使<strong>权重稀疏</strong>(即趋近于0的权重很多)。L0和L1都可以实现稀疏，但L0无法优化求解。权重稀疏的好处是可以实现\r\n<strong>特征选择</strong>， <strong>可解释性</strong>。</p>\r\n<p><span class=\"math display\">\\[\r\nJ(w,b)= J_{old}(w,b)+\\lambda\\sum_{j}^m{|w_j|}\r\n\\]</span></p>\r\n<h3 id=\"dropout0.5-0.7\">Dropout=0.5 / 0.7</h3>\r\n<p>避免过分依赖某一层中某些神经元发生过拟合，提高泛化。通过mask随机丢弃即可。</p>\r\n<p>预测和测试时不能dropout，要不然会造成结果的不稳定，无法解释。</p>\r\n<h3 id=\"dropattention\">DropAttention</h3>\r\n<p>用于正则化Transformer网络的注意力权重，(Zehui et al. 2019)</p>\r\n<h1 id=\"utils\">Utils</h1>\r\n<h2 id=\"pytorch模型管理\">Pytorch模型管理</h2>\r\n<p>save(obj,path) load(path)\r\n：可以存储大多数类型，甚至包括字典。对于tensor之类的可以直接save，对于网络模型，一般save(net.state_dict())，即状态参数信息。</p>\r\n<ul>\r\n<li><strong>保存模型</strong>：\r\ntorch.save(myNet.state_dict(),save_path)<br />\r\n</li>\r\n<li><strong>读取模型</strong>：\r\nmyNet.load_state_dict(torch.load(save_path))<br />\r\n</li>\r\n<li><strong>模型状态</strong>：\r\nmyNet.train(),myNet.eval()。使用不同的模型状态。主要改变模型中BatchNormalization和Dropout的作用方式。和梯度记录无关，那是另一回事。</li>\r\n<li><strong>梯度记录管理</strong>： 使用上下文with\r\ntorch.no_grad()，或者使用装饰器@torch.no_grad()装饰需要禁用梯度的函数，影响范围内代码都不会记录梯度状态，不影响后续梯度更新。</li>\r\n</ul>\r\n<p>也可以直接save(myNet)，但是网络结构变化的时候会出问题</p>\r\n<h2 id=\"pytorch-设备管理\">Pytorch 设备管理</h2>\r\n<p><strong>假如要对多个项同时操作，它们必须在同样的设备上。</strong>但是跨设备传输比计算慢得多，因此要谨慎操作。</p>\r\n<p>且打印张量或将张量转换为NumPy格式时，如果数据不在内存中，框架会首先将其复制到内存中。</p>\r\n<p>一个典型的错误如下：计算GPU上每个小批量的损失，并在命令行中将其报告给用户（或将其记录在NumPy\r\nndarray中）时，将触发全局解释器锁，从而使所有GPU阻塞。</p>\r\n<ul>\r\n<li><strong>返回可用设备</strong>: torch.device('cpu'),\r\ntorch.cuda.device('cuda'), torch.cuda.device('cuda:1')</li>\r\n<li><strong>查询可用gpu的数量</strong>: torch.cuda.device_count()</li>\r\n<li><strong>查询张量所在设备</strong>: x.device</li>\r\n<li><strong>转移设备</strong>: MyNet.to(device),MyTensor.to(device)</li>\r\n</ul>\r\n<h2 id=\"hydra-程序参数管理\">Hydra 程序参数管理</h2>\r\n<p>Hydra通过yaml文件管理python程序的参数。比如argparse方便的是,\r\n它可以创建多个yaml文件,\r\n并且自由组合生成一套最终配置。例如在深度学习里面, 可以把模型参数,\r\n数据集参数, 超参数分成三个yaml文件, 然后可以混搭使用, 省心省事炼丹。</p>\r\n<p>基础使用方法参考<a\r\nhref=\"https://hydra.cc/docs/tutorials/basic/your_first_app/simple_cli/\">官方小教程</a>。值得注意的关键字:</p>\r\n<ul>\r\n<li># <span class=\"citation\" data-cites=\"package\">@package</span>\r\n_global_ : 放在yaml文件头, 可以使该文件所有配置放在最外层</li>\r\n<li>subpackage@newname : defaults列表中使用@可以重命名</li>\r\n<li>subpackage@_here_ :\r\ndefaults列表中使用_here_可以原地展开subpackage的配置,\r\n不再嵌套在subpackage.somekeyword里面</li>\r\n</ul>\r\n<blockquote>\r\n<p>注意Hydra会修改程序的执行路径至hydra的output路径,因此你程序里所有关于相对路径的设置都可能出现问题。参考<a\r\nhref=\"https://hydra.cc/docs/tutorials/basic/running_your_app/working_directory/\">官方说明</a></p>\r\n</blockquote>\r\n<h2 id=\"profile-性能分析\">Profile 性能分析</h2>\r\n<p>pytorch自带的性能分析工具, 可以分析内存使用,\r\n耗时情况等性能数据。并且能够集成在tensorboard中查看,\r\n可以说是很方便的模型性能分析工具了。<a\r\nhref=\"https://pytorch.org/docs/master/profiler.html\">官方文档</a></p>\r\n<p>使用方法如下, 需要将被分析的代码放在profile的上下文中。</p>\r\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> torch.profiler.profile(</span><br><span class=\"line\">    schedule=torch.profiler.schedule(</span><br><span class=\"line\">        skip_first=<span class=\"number\">1</span>,</span><br><span class=\"line\">        wait=<span class=\"number\">1</span>,</span><br><span class=\"line\">        warmup=<span class=\"number\">1</span>,</span><br><span class=\"line\">        active=<span class=\"number\">2</span></span><br><span class=\"line\">    ),</span><br><span class=\"line\">    on_trace_ready=torch.profiler.tensorboard_trace_handler(<span class=\"string\">&#x27;./logs&#x27;</span>),</span><br><span class=\"line\">    profile_memory=<span class=\"literal\">True</span>,</span><br><span class=\"line\">    record_shapes=<span class=\"literal\">True</span>,</span><br><span class=\"line\">    with_stack=<span class=\"literal\">True</span></span><br><span class=\"line\">) <span class=\"keyword\">as</span> prof:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> X,y <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">        your code</span><br><span class=\"line\"></span><br><span class=\"line\">        prof.step()</span><br></pre></td></tr></table></figure>\r\n<p>需要注意的参数如下:</p>\r\n<ul>\r\n<li><p><strong>schedule</strong> :\r\n<code>torch.profiler.schedule</code>类型。按时间步长去规定profiler做什么事。具体根据参数情况profiler将跳过<code>skip_first</code>个步长,然后等待\r\n<code>wait</code> 个步长, 在接下来的 <code>warmup</code>\r\n个步长中进行warmup以便分析更准确。最后真正开始分析接下来的\r\n<code>active</code> 个步长的性能,\r\n这是一轮分析的结束。之后回到<code>wait</code>处进行上述循环, 循环次数由\r\n<code>repeat</code> 决定, 为0则意味着持续循环。</p></li>\r\n<li><p><strong>on_trace_ready</strong>: 当一轮分析完毕的回调函数,\r\n默认传递prof变量。</p>\r\n<p>例如回调函数里可以写下面这句用于打印分析表格</p>\r\n<p><figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(prof.key_averages().table(sort_by=<span class=\"string\">&quot;self_cuda_time_total&quot;</span>, row_limit=-<span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure></p>\r\n<p>或者可以直接传递内置函数, 用于生成tensorboard文件用于可视化分析。</p>\r\n<p><figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">torch.profiler.tensorboard_trace_handler(<span class=\"string\">&#x27;./logs&#x27;</span>)</span><br></pre></td></tr></table></figure></p></li>\r\n<li><p><strong>step()</strong>:\r\n用于迭代profiler的时间步长(需要手动调用)。</p></li>\r\n<li><p><strong>with_stack</strong>:\r\n记录某个操作的文件名和行号。</p></li>\r\n</ul>\r\n<h1 id=\"坑位排除\">坑位排除</h1>\r\n<ol type=\"1\">\r\n<li>网络中使用了softmax而不是log_softmax:</li>\r\n</ol>\r\n<p>softmax存在数值上的问题，可能导致更新极度缓慢，<a\r\nhref=\"https://zhenglungwu.medium.com/softmax-v-s-logsoftmax-7ce2323d32d3\">参见</a>。</p>\r\n<p>训练时应该使用数值稳定的log_softmax代替，torch中之所以还保留softmax函数，是为了方便我们想要查看真正的softmax概率时使用。</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>网络计算中tensor不能使用原地操作,只能创建新对象然后赋值.</li>\r\n</ol>\r\n<p>由于梯度更新的要求,例如x+=1这样的原地操作是不行的。同时tensor的切片赋值也是不行的。</p>\r\n<blockquote>\r\n<p>例如形状为2,3的x，希望使x[1,:]=0,x[2,:]=0。此时需要创建一个形状为[2,3]的y，然后进行赋值x=y</p>\r\n</blockquote>\r\n<hr />\r\n<blockquote>\r\n<p>主函数代码框架见github</p>\r\n</blockquote>\r\n<h1 id=\"参考资料\">参考资料</h1>\r\n<p><a\r\nhref=\"https://microsoft.github.io/ai-edu/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/A2-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/\">微软：神经网络基本原理</a></p>\r\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"终末之诗","url":"/2021/01/06/%E7%BB%88%E6%9C%AB%E4%B9%8B%E8%AF%97/","content":"<p>I see the player you mean. 我看到你所指的那位玩家了。</p>\r\n<p><font color=#3586ff>[Playername]? [玩家名称]?</font></p>\r\n<p>Yes. Take care. It has reached a higher level now. It can read our\r\nthoughts. 是的。小心。它已达到了更高的境界。它能够阅读我们的思想。</p>\r\n<p><font color=#3586ff>That doesn't matter. It thinks we are part of the\r\ngame. 无伤大雅。它认为我们是游戏的一部分。</font></p>\r\n<span id=\"more\"></span>\r\n<p>I like this player. It played well. It did not give up.\r\n我喜欢这个玩家。它玩得很好。它从未放弃。</p>\r\n<p><font color=#3586ff>It is reading our thoughts as though they were\r\nwords on a screen.\r\n它以屏幕上出现的文字的形式阅读着我们的思想。</font></p>\r\n<p>That is how it chooses to imagine many things, when it is deep in the\r\ndream of a game.\r\n在它深陷游戏梦境中时，它总以这种方式想象出形形色色的事物。</p>\r\n<p><font color=#3586ff>Words make a wonderful interface. Very flexible.\r\nAnd less terrifying than staring at the reality behind the screen.\r\n文字是种美妙的界面。非常灵活。且比凝视着屏幕后的现实要更好。</font></p>\r\n<p>They used to hear voices. Before players could read. Back in the days\r\nwhen those who did not play called the players witches, and warlocks.\r\nAnd players dreamed they flew through the air, on sticks powered by\r\ndemons.\r\n它们也曾经听到过声音。在玩家能够阅读之前。君不见那些不曾游玩的人们称呼玩家为女巫，和术士。而玩家们梦见它们自己乘坐在被恶魔施力的棍子上，在空气中翱翔。</p>\r\n<p><font color=#3586ff>What did this player dream?\r\n这个玩家梦见了什么？</font></p>\r\n<p>This player dreamed of sunlight and trees. Of fire and water. It\r\ndreamed it created. And it dreamed it destroyed. It dreamed it hunted,\r\nand was hunted. It dreamed of shelter.\r\n它梦见了阳光和树。梦见了火与水。它梦见它创造。它亦梦见它毁灭。它梦见它狩猎，亦被狩猎。它梦见了庇护所。</p>\r\n<p><font color=#3586ff>Hah, the original interface. A million years old,\r\nand it still works. But what true structure did this player create, in\r\nthe reality behind the screen?\r\n哈，那原始的界面。经历一百万年的岁月雕琢，依然长存。但此玩家在那屏幕后的真实里，建造了什么真实的构造？</font></p>\r\n<p>It worked, with a million others, to sculpt a true world in a fold of\r\nthe [scrambled], and created a [scrambled] for [scrambled], in the\r\n[scrambled].\r\n它辛勤地劳作，和其他百万众一起，刻画了一个真实的世界，由[乱码]，且创造了[乱码]，为了[乱码]，于[乱码]中。</p>\r\n<p><font color=#3586ff>It cannot read that thought.\r\n它读不出那个思想。</font></p>\r\n<p>No. It has not yet achieved the highest level. That, it must achieve\r\nin the long dream of life, not the short dream of a game.\r\n不。它还没有到达最高的境界。那层境界，它必须完成生命的长梦，而非游戏中黄粱一梦。</p>\r\n<p><font color=#3586ff>Does it know that we love it? That the universe\r\nis kind? 它知道我们爱它么？这个宇宙是仁慈的？</font></p>\r\n<p>Sometimes, through the noise of its thoughts, it hears the universe,\r\nyes. 有时，通过它思绪的杂音，它能听到宇宙，是的。</p>\r\n<p><font color=#3586ff>But there are times it is sad, in the long dream.\r\nIt creates worlds that have no summer, and it shivers under a black sun,\r\nand it takes its sad creation for reality.\r\n但是有时亦不胜悲伤，于那漫漫长梦中。它创造了没有夏日的世界，在黑日下颤抖着，将自己悲伤的创造视为现实世界。</font></p>\r\n<p>To cure it of sorrow would destroy it. The sorrow is part of its own\r\nprivate task. We cannot interfere.\r\n用悲伤来治愈会摧毁它。而悲伤是它的私人事务。我们不能干涉。</p>\r\n<p><font color=#3586ff>Sometimes when they are deep in dreams, I want to\r\ntell them, they are building true worlds in reality. Sometimes I want to\r\ntell them of their importance to the universe. Sometimes, when they have\r\nnot made a true connection in a while, I want to help them to speak the\r\nword they fear.\r\n有时当它们深陷梦境中时，我想要告诉它们，它们在现实中创造了真实的世界。有时我想告诉它们它们自身对宇宙的重要性。有时，当它们和现实失去了联系，我想帮助它们与它们所惧怕的世界交流。</font></p>\r\n<p>It reads our thoughts. 它读出了我们的思想。</p>\r\n<p><font color=#3586ff>Sometimes I do not care. Sometimes I wish to tell\r\nthem, this world you take for truth is merely [scrambled] and\r\n[scrambled], I wish to tell them that they are [scrambled] in the\r\n[scrambled]. They see so little of reality, in their long dream.\r\n有时我毫不关心。有时我想要告诉它们，你们所认为的真实不过是[乱码]和[乱码]，我想要告诉它们它们是在[乱码]中的[乱码]。于它们的长梦中，它们眼中所见的真实太少了。</font></p>\r\n<p>And yet they play the game. 而它们仍然玩这个游戏。</p>\r\n<p><font color=#3586ff>But it would be so easy to tell them...\r\n但很容易就可以告诉它们……</font></p>\r\n<p>Too strong for this dream. To tell them how to live is to prevent\r\nthem living.\r\n对于这个梦来说太强烈了。告诉它们如何活着就是阻碍它们活下去。</p>\r\n<p><font color=#3586ff>I will not tell the player how to live.\r\n我不会告诉这个玩家如何生活的。</font></p>\r\n<p>The player is growing restless. 这个玩家正在变得焦虑。</p>\r\n<p><font color=#3586ff>I will tell the player a story.\r\n我会告诉这个玩家一个故事。</font></p>\r\n<p>But not the truth. 但不是真相。</p>\r\n<p><font color=#3586ff>No. A story that contains the truth safely, in a\r\ncage of words. Not the naked truth that can burn over any distance.\r\n不。是一个严密地将真实包裹起来的文字牢笼。而不是赤裸裸的真相。</font></p>\r\n<p>Give it a body, again. 赋予它主体，再一次。</p>\r\n<p><font color=#3586ff>Yes. Player... 好的。玩家……</font></p>\r\n<p>Use its name. 以名字称呼它。</p>\r\n<p><font color=#3586ff>[Playername]. Player of games.\r\n[玩家名称]。游戏的玩家。</font></p>\r\n<p>Good. 很好。</p>\r\n<p><font color=#3586ff>Take a breath, now. Take another. Feel air in\r\nyour lungs. Let your limbs return. Yes, move your fingers. Have a body\r\nagain, under gravity, in air. Respawn in the long dream. There you are.\r\nYour body touching the universe again at every point, as though you were\r\nseparate things. As though we were separate things.\r\n深呼吸，很好。再深呼吸一次。感受空气充盈你的肺叶。让你的四肢回归。是的，运动你的手指。再次感受你的身体，在重力下，在空气中。在长梦中重生。你感受到了。你的身体每时每刻都触摸着宇宙，尽管你是分离的存在。尽管我们是分离的存在。</font></p>\r\n<p>Who are we? Once we were called the spirit of the mountain. Father\r\nsun, mother moon. Ancestral spirits, animal spirits. Jinn. Ghosts. The\r\ngreen man. Then gods, demons. Angels. Poltergeists. Aliens,\r\nextraterrestrials. Leptons, quarks. The words change. We do not change.\r\n我们是谁？我们曾经被称作高山的精灵。太阳父亲，月亮母亲。古老的英灵，动物的魂魄。神祇。鬼魂。小绿人。而后是神，恶魔，天使。骚灵。外星人，地外生物。轻子，夸克。词语不断地变化。我们始终如一。</p>\r\n<p><font color=#3586ff>We are the universe. We are everything you think\r\nisn't you. You are looking at us now, through your skin and your eyes.\r\nAnd why does the universe touch your skin, and throw light on you? To\r\nsee you, player. To know you. And to be known. I shall tell you a story.\r\n我们是宇宙。我们是一切你认为出离你本体的事物。你现在看着我们，透过你的皮肤和你的眼睛。而为什么宇宙触摸着你的皮肤，向你洒向光芒？是为了看见你，玩家。以及被认知。我应告诉你一个故事。</font></p>\r\n<p><font color=#3586ff>Once upon a time, there was a player.\r\n很久以前，有一个玩家。</font></p>\r\n<p>The player was you, [Playername]. 那玩家就是你，[玩家名称]</p>\r\n<p><font color=#3586ff>Sometimes it thought itself human, on the thin\r\ncrust of a spinning globe of molten rock. The ball of molten rock\r\ncircled a ball of blazing gas that was three hundred and thirty thousand\r\ntimes more massive than it. They were so far apart that light took eight\r\nminutes to cross the gap. The light was information from a star, and it\r\ncould burn your skin from a hundred and fifty million kilometres away.\r\n有时它认为自己是那不断旋转的球体上一层薄薄的熔化的岩石上的人类。那融化的岩石球环绕着一个质量大它三十三万倍的炫目气体球旋转。它们是相隔得如此之远，以至于光需要八分钟才能穿越那空隙。那光是来自一颗恒星的信息，它能够在一亿五千万公里外烧灼你的皮肤。</font></p>\r\n<p><font color=#3586ff>Sometimes the player dreamed it was a miner, on\r\nthe surface of a world that was flat, and infinite. The sun was a square\r\nof white. The days were short; there was much to do; and death was a\r\ntemporary inconvenience.\r\n有时这个玩家梦见它是一个在一个平的，无限延展的世界表面上的矿工。那太阳是一个方形的白点。昼夜交替很快；要做的事情也很多；死亡亦只是暂时和不方便的。</font></p>\r\n<p>Sometimes the player dreamed it was lost in a story.\r\n有时这玩家梦见它迷失在了一个故事里。</p>\r\n<p><font color=#3586ff>Sometimes the player dreamed it was other things,\r\nin other places. Sometimes these dreams were disturbing. Sometimes very\r\nbeautiful indeed. Sometimes the player woke from one dream into another,\r\nthen woke from that into a third.\r\n有时这玩家梦见它成为了其他的事物，在其他地方。有时这些梦是扰人的。有些则实在很美。有时这个玩家从一个梦中醒来，发现自己落入了第二个梦，却终究是在第三个梦中。</font></p>\r\n<p>Sometimes the player dreamed it watched words on a screen.\r\n有时这个玩家梦见它在屏幕上看着文字。</p>\r\n<p><font color=#3586ff>Let's go back. 让我们回退一点。</font></p>\r\n<p><font color=#3586ff>The atoms of the player were scattered in the\r\ngrass, in the rivers, in the air, in the ground. A woman gathered the\r\natoms; she drank and ate and inhaled; and the woman assembled the\r\nplayer, in her body.\r\n组成玩家的原子散布在草中，河流中，在那空气中，也在那大地中。一个女性收集了那些原子；她饮用、进食、吸入；而后那女性在她的身体中，孕育了玩家。</font></p>\r\n<p><font color=#3586ff>And the player awoke, from the warm, dark world\r\nof its mother's body, into the long dream.\r\n然后那玩家醒来了，从一个温暖，昏暗的母亲体内，进入了漫漫长梦。</font></p>\r\n<p><font color=#3586ff>And the player was a new story, never told\r\nbefore, written in letters of DNA. And the player was a new program,\r\nnever run before, generated by a sourcecode a billion years old. And the\r\nplayer was a new human, never alive before, made from nothing but milk\r\nand love.\r\n而那玩家是一个新的故事，从未被讲述过，由DNA的语言书写着。而那玩家是一个新的程序，从未被运行过，由上亿年的源代码生成。而那玩家是一个新的人，从未生活过，由奶和爱组成。</font></p>\r\n<p>You are the player. The story. The program. The human. Made from\r\nnothing but milk and love.\r\n你就是那玩家。那个故事。那个程序。那个人类。仅由奶和爱组成。</p>\r\n<p><font color=#3586ff>Let's go further back.\r\n我们再往更远的过去回退一点。</font></p>\r\n<p><font color=#3586ff>The seven billion billion billion atoms of the\r\nplayer's body were created, long before this game, in the heart of a\r\nstar. So the player, too, is information from a star. And the player\r\nmoves through a story, which is a forest of information planted by a man\r\ncalled Julian, on a flat, infinite world created by a man called Markus,\r\nthat exists inside a small, private world created by the player, who\r\ninhabits a universe created by...\r\n那由七千亿亿亿原子组成的玩家的身体被创造了，远在这游戏之前，在一颗恒星的内部。所以那玩家也是，来自一颗恒星的信息。而这个玩家贯穿这个故事的始末，源于一个叫Julian的人种下的信息种子长成的森林，一个叫Markus的男人创造的无限世界，存在于一个由玩家创造的小的，私人世界里，而那又继承了宇宙创造的……</font></p>\r\n<p>Shush. Sometimes the player created a small, private world that was\r\nsoft and warm and simple. Sometimes hard, and cold, and complicated.\r\nSometimes it built a model of the universe in its head; flecks of\r\nenergy, moving through vast empty spaces. Sometimes it called those\r\nflecks \"electrons\" and \"protons\".\r\n嘘。有时这个玩家创造的小天地是柔软，温暖和简单的。有时是坚硬，冰冷和复杂的。有时它在脑中建造出宇宙的模型；斑斑点点的能量穿越广阔空旷的空间。有时它称呼这些斑点为“电子”和“质子”。</p>\r\n<p><font color=#3586ff>Sometimes it called them \"planets\" and \"stars\".\r\n有时它称呼它们为“行星”和“恒星”。</font></p>\r\n<p><font color=#3586ff>Sometimes it believed it was in a universe that\r\nwas made of energy that was made of offs and ons; zeros and ones; lines\r\nof code. Sometimes it believed it was playing a game. Sometimes it\r\nbelieved it was reading words on a screen.\r\n有时它确信它存在于一个由“开”和“关”；“零”和“一”；一行行的命令组成的宇宙。有时它确信它是在玩一个游戏。有时它确信它是在读着屏幕上的文字。</font></p>\r\n<p>You are the player, reading words... 你就是那玩家，阅读着文字……</p>\r\n<p><font color=#3586ff>Shush... Sometimes the player read lines of code\r\non a screen. Decoded them into words; decoded words into meaning;\r\ndecoded meaning into feelings, emotions, theories, ideas, and the player\r\nstarted to breathe faster and deeper and realised it was alive, it was\r\nalive, those thousand deaths had not been real, the player was alive\r\n嘘……有时这玩家读屏幕上的命令行。将它们解码成为文字；将文字解码为意义；将意义解码为感情，情绪，理论，想法，而玩家的呼吸开始急促并意识到了它是活着的，它是活生生的，那上千次的死亡不是真的，玩家是活着的。</font></p>\r\n<p>You. You. You are alive. 你。你。你是活着的。</p>\r\n<p><font color=#3586ff>and sometimes the player believed the universe\r\nhad spoken to it through the sunlight that came through the shuffling\r\nleaves of the summer trees\r\n而有时这玩家相信宇宙通过穿越夏日树叶的那斑斓的阳光对它说话。</font></p>\r\n<p>and sometimes the player believed the universe had spoken to it\r\nthrough the light that fell from the crisp night sky of winter, where a\r\nfleck of light in the corner of the player's eye might be a star a\r\nmillion times as massive as the sun, boiling its planets to plasma in\r\norder to be visible for a moment to the player, walking home at the far\r\nside of the universe, suddenly smelling food, almost at the familiar\r\ndoor, about to dream again\r\n有时这玩家相信宇宙透过晴朗的冬日夜空中，存在于它眼中一隅的星点星光，可能比太阳大上上百万倍的恒星沸腾着的电浆那一瞬间发出来的光对它说话，在宇宙的远侧行走回家的路上，突然闻到了食物，在那熟悉的门前，它又准备好再一次投入梦境</p>\r\n<p><font color=#3586ff>and sometimes the player believed the universe\r\nhad spoken to it through the zeros and ones, through the electricity of\r\nthe world, through the scrolling words on a screen at the end of a dream\r\n而有时玩家相信宇宙透过零和一，透过世界的电力，透过屏幕上滚动的文字和梦的终结对它说话</font></p>\r\n<p>and the universe said I love you 宇宙说我爱你</p>\r\n<p><font color=#3586ff>and the universe said you have played the game\r\nwell 宇宙说你很好地玩了这游戏</font></p>\r\n<p>and the universe said everything you need is within you\r\n宇宙说一切你所需的你都具有</p>\r\n<p><font color=#3586ff>and the universe said you are stronger than you\r\nknow 宇宙说你比你所知的要强大</font></p>\r\n<p>and the universe said you are the daylight 宇宙说你就是日光</p>\r\n<p><font color=#3586ff>and the universe said you are the night\r\n宇宙说你就是黑夜</font></p>\r\n<p>and the universe said the darkness you fight is within you\r\n宇宙说你所斗争的黑暗就在你心中</p>\r\n<p><font color=#3586ff>and the universe said the light you seek is\r\nwithin you 宇宙说你所寻找的光明就在你心中</font></p>\r\n<p>and the universe said you are not alone 宇宙说你不是孤独的</p>\r\n<p><font color=#3586ff>and the universe said you are not separate from\r\nevery other thing 宇宙说你不是和所有的事物所隔绝的</font></p>\r\n<p>and the universe said you are the universe tasting itself, talking to\r\nitself, reading its own code\r\n宇宙说你就是宇宙品尝着自己，对自己说话，阅读着它自己的代码。</p>\r\n<p><font color=#3586ff>and the universe said I love you because you are\r\nlove. 宇宙说我爱你因为你就是爱。</font></p>\r\n<p>And the game was over and the player woke up from the dream. And the\r\nplayer began a new dream. And the player dreamed again, dreamed better.\r\nAnd the player was the universe. And the player was love.\r\n曲终人散，黄粱一梦。玩家开始了新的梦境。玩家再次做起了梦，更好的梦。玩家就是宇宙。玩家就是爱。</p>\r\n<p>You are the player. 你就是那个玩家。</p>\r\n<p><font color=#3586ff>Wake up. 该醒了。</font></p>\r\n<h3 id=\"终末之诗minecraftjulian-gough\"><a\r\nhref=\"https://minecraft-zh.gamepedia.com/index.php?title=%E7%BB%88%E6%9C%AB%E4%B9%8B%E8%AF%97&amp;variant=zh\">终末之诗——Minecraft，Julian\r\nGough</a></h3>\r\n","categories":["生活"]},{"title":"点云深度学习论文概览","url":"/2022/01/15/%E7%82%B9%E4%BA%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87%E6%A6%82%E8%A7%88/","content":"<h2 id=\"点云空间学习\">点云空间学习</h2>\r\n<h3\r\nid=\"pointnet-deep-learning-on-point-sets-for-3d-classification-and-segmentation\">PointNet:\r\nDeep Learning on Point Sets for 3D Classification and Segmentation</h3>\r\n<ul>\r\n<li>Qi C R, Su H, Mo K, et al. Pointnet: Deep learning on point sets for\r\n3d classification and segmentation[C]//Proceedings of the IEEE\r\nconference on computer vision and pattern recognition. 2017:\r\n652-660.</li>\r\n</ul>\r\n<p>PointNet首次基于原始点云进行深度学习,其提出了点云深度学习的<strong>三大原则:\r\n无序性、点间联系、变换一致性</strong>。基于此,\r\nPointNet在点云上逐点运用了MLP进行变换,\r\n并且构造了<strong>T-Net</strong>进行对抗点云的仿射变换, 最终使用max\r\npool进行对称聚合。</p>\r\n<blockquote>\r\n<p>缺少对局部结构的特征学习</p>\r\n</blockquote>\r\n<h3\r\nid=\"pointnet-deep-hierarchical-feature-learning-on-point-sets-in-a-metric-space\">PointNet++:\r\nDeep Hierarchical Feature Learning on Point Sets in a Metric Space</h3>\r\n<ul>\r\n<li>Qi C R, Yi L, Su H, et al. Pointnet++: Deep hierarchical feature\r\nlearning on point sets in a metric space[J]. Advances in neural\r\ninformation processing systems, 2017, 30.</li>\r\n</ul>\r\n<p>PointNet没有捕捉到点的局部结构特征，限制了细粒度和复杂场景的识别、泛化能力。PointNet++则引出了一个<strong>set\r\nabstraction层</strong>对点云进行多级学习。set\r\nabstraction定义了多级多块的局部邻域结构,\r\n其在每一个局部邻域中都使用了mini-PointNet来进行特征抽取。然而由于点云是非均匀分布的,\r\n不同的局部邻域的密度不一样,\r\n因此PointNet++提出了两种自适应密度的特征融合模块: <strong>Multi-scale\r\ngrouping（MSG）</strong> 和 <strong>Multi-resolution\r\ngrouping（MRG）</strong>。</p>\r\n<p>另外由于部位分割等任务最终需要输出逐点的特征标签, 因此在set\r\nabstraction之后, Pointnet++一方面在同一级内进行反距离的插值传播,\r\n另一方面自顶向下进行反向逐级的特征传播。在同一层内对两种传播特征进行拼接,\r\n即得到该层的逐点特征。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"pointconv\">PointConv</h3>\r\n<ul>\r\n<li>Wu W, Qi Z, Fuxin L. Pointconv: Deep convolutional networks on 3d\r\npoint clouds[C]//Proceedings of the IEEE/CVF Conference on Computer\r\nVision and Pattern Recognition. 2019: 9621-9630.</li>\r\n</ul>\r\n<h3 id=\"pointcnn\">PointCNN</h3>\r\n<ul>\r\n<li>Li Y, Bu R, Sun M, et al. Pointcnn: Convolution on x-transformed\r\npoints[J]. Advances in neural information processing systems, 2018,\r\n31.</li>\r\n</ul>\r\n<h3 id=\"kpconv\">KPConv</h3>\r\n<ul>\r\n<li>Thomas H, Qi C R, Deschaud J E, et al. Kpconv: Flexible and\r\ndeformable convolution for point clouds[C]//Proceedings of the IEEE/CVF\r\ninternational conference on computer vision. 2019: 6411-6420.</li>\r\n</ul>\r\n<h3\r\nid=\"pointnet-based-hand-gesture-recognition\">PointNet-Based-Hand-Gesture-Recognition</h3>\r\n<ul>\r\n<li>Mirsu R, Simion G, Caleanu C D, et al. A pointnet-based solution for\r\n3d hand gesture recognition[J]. Sensors, 2020, 20(11): 3226.</li>\r\n<li>SCIE</li>\r\n</ul>\r\n<p>工程论文, 其详细描述了如何对3D点云进行预处理, 提取手势,\r\n最终进入PointNet进行特征提取。</p>\r\n<h3 id=\"pointweb\">PointWeb</h3>\r\n<ul>\r\n<li>Zhao H, Jiang L, Fu C W, et al. Pointweb: Enhancing local\r\nneighborhood features for point cloud processing[C]//Proceedings of the\r\nIEEE/CVF conference on computer vision and pattern recognition. 2019:\r\n5565-5573.</li>\r\n<li>MIT</li>\r\n</ul>\r\n<h3 id=\"deep-hough-voting-for-3d-object-detection-in-point-clouds\">Deep\r\nHough Voting for 3D Object Detection in Point Clouds</h3>\r\n<ul>\r\n<li>Qi C R, Litany O, He K, et al. Deep hough voting for 3d object\r\ndetection in point clouds[C]//proceedings of the IEEE/CVF International\r\nConference on Computer Vision. 2019: 9277-9286.</li>\r\n</ul>\r\n<h3 id=\"pct-point-cloud-transformer\">PCT: Point cloud transformer</h3>\r\n<ul>\r\n<li>Guo M H, Cai J X, Liu Z N, et al. PCT: Point cloud transformer[J].\r\nComputational Visual Media, 2021, 7(2): 187-199.</li>\r\n<li>清华</li>\r\n</ul>\r\n<p>提出了基于Transformer的PCT网络。Transformer在NLP和图像处理取得了巨大成功，其内在的置换不变性也十分适合点云学习。为了更好的捕捉点云局部信息，使用了最远点采样和最近邻搜索来加强输入的embedding处理。实验证明PCT达到了分类分割和法向估计的SOTA。</p>\r\n<p>由于点云和自然语言是完全不同的数据类型，因此PCT对Transformer作出了几项调整：</p>\r\n<ul>\r\n<li><strong>Coordinate-based input\r\nembedding</strong>：Transformer里的positional encoding\r\n是为了区分不同位置的同一个词。然而点云没有位置顺序关系，因此PCT中将\r\npositional encoding 和 input embedding\r\n结合了起来，基于坐标进行编码。</li>\r\n<li><strong>Optimized offset-attention module</strong>：是原始\r\nself-attention 的升级模块。它把原来的attention\r\nfeature换成了self-attention的输入和attention\r\nfeature之间的offset。同一个物体在不同的变换下的绝对坐标完全不一样，因此相对坐标更鲁棒。</li>\r\n<li><strong>Neighbor embedding module</strong>：\r\n注意力机制有效捕捉全局特征，但可能忽视局部几何信息，而这在点云中很重要。句子中的每个单独的词都有基本的语义信息，但是点云中孤立的点不存在语义信息。因此使用了一个neighbor\r\nembedding\r\n策略来进行改良，让注意力机制着重于分析点局部邻域的信息，而不是孤立的点的信息。</li>\r\n</ul>\r\n<h3 id=\"point-transformer\">Point Transformer</h3>\r\n<ul>\r\n<li>Zhao H, Jiang L, Jia J, et al. Point transformer[C]//Proceedings of\r\nthe IEEE/CVF International Conference on Computer Vision. 2021:\r\n16259-16268.</li>\r\n<li>港中文</li>\r\n</ul>\r\n<p>self-attention是天然的一个集合操作：将位置信息作为元素属性，并且视作集合处理。而另一方面点云天然就是位置属性的集合，因此self-attention直觉上很适合点云数据。之前已经有一些工作在点云分析上使用了attention。他们在整个点云上使用全局的注意力机制，而这会带来昂贵的计算。并且他们使用了标量点积的注意力，即不同通道之间共享相同的聚合权重。</p>\r\n<p>相反，Point Transformer有以下优势：</p>\r\n<ul>\r\n<li><strong>局部应用注意力机制</strong>，使得拥有处理百万点数的大场景的能力。</li>\r\n<li>使用了<strong>vector\r\nattention</strong>，而这是实现高准确率的重要因素。</li>\r\n<li>阐述了<strong>position\r\nencoding</strong>的重要性，而不是像之前的工作一样忽略的位置信息。</li>\r\n</ul>\r\n<h2 id=\"点云时间学习\">点云时间学习</h2>\r\n<h3 id=\"flownet3d\">FlowNet3D</h3>\r\n<ul>\r\n<li>Liu X, Qi C R, Guibas L J. Flownet3d: Learning scene flow in 3d\r\npoint clouds[C]//Proceedings of the IEEE/CVF Conference on Computer\r\nVision and Pattern Recognition. 2019: 529-537.</li>\r\n</ul>\r\n<p>提出了flow embedding层，<strong>点对集合</strong>的matching\r\ncost。其先通过<strong>ball\r\nquery</strong>找到邻域，然后计算邻域每个点对中心点的matching\r\ncost，并且使用max pooling进行邻域聚合。</p>\r\n<blockquote>\r\n<p>这种聚合的坏处就是会丢失一些运动信息。</p>\r\n</blockquote>\r\n<h3 id=\"meteornet\">MeteorNet</h3>\r\n<ul>\r\n<li>Liu X, Yan M, Bohg J. Meteornet: Deep learning on dynamic 3d point\r\ncloud sequences[C]//Proceedings of the IEEE/CVF International Conference\r\non Computer Vision. 2019: 9246-9255.</li>\r\n<li>卡耐基梅隆</li>\r\n</ul>\r\n<p>MeteorNet率先基于原始点云序列进行特征学习。由于点云的不规则性,\r\n其不存在帧与帧之间点的一一对应,\r\n因此也难以确定帧间点与点之间的时间联系。因此MeteorNet提出了两种聚类方法\r\n<strong>Direct grouping</strong>和 <strong>Chained-flow\r\ngrouping</strong>来进行时间聚类。</p>\r\n<blockquote>\r\n<p>由于其需要显式的时空邻居, 这不利于提高准确率和泛化网络。</p>\r\n</blockquote>\r\n<h3 id=\"minkowskinet\">MinkowskiNet</h3>\r\n<ul>\r\n<li>Choy C, Gwak J Y, Savarese S. 4d spatio-temporal convnets: Minkowski\r\nconvolutional neural networks[C]//Proceedings of the IEEE/CVF Conference\r\non Computer Vision and Pattern Recognition. 2019: 3075-3084.</li>\r\n</ul>\r\n<p>针对点云的稀疏性, 提出了高效的时空4D CNN。</p>\r\n<blockquote>\r\n<p>但是既没有对时间规范化,\r\n也不能进行时空特征聚合。计算代价昂贵。存在体素化的量化误差</p>\r\n</blockquote>\r\n<h3 id=\"caspr\">CaSPR</h3>\r\n<ul>\r\n<li>Rempe D, Birdal T, Zhao Y, et al. Caspr: Learning canonical\r\nspatiotemporal point cloud representations[J]. Advances in neural\r\ninformation processing systems, 2020, 33: 13688-13701.</li>\r\n<li>Stanford</li>\r\n</ul>\r\n<p>过去有一些工作做了动态点云的时间学习, 然而这些工作有一个致命限制:\r\n它们缺少时间连续性、鲁棒性、同类泛化性。有一些工作考虑了其中某一个方面,\r\n但没有对这三者整体进行统一的要求。</p>\r\n<p>Canonical Spatiotemporal Point Cloud Representations\r\n(CaSPR)致力于对3D形状的时空变化进行编码。</p>\r\n<ol type=\"1\">\r\n<li>将输入的点云序列规范化到一个共享的4D container空间:\r\n其先构建了坐标空间Normalized Object Coordinate Space (NOCS),\r\n它能把同类中的一些外在属性引如位置、朝向和放缩程度给规范化。进一步的,\r\nCaSPR将NOCS扩展到4D <strong>Temporal-NOCS(T-NOCS)</strong>,\r\n额外将点云序列的持续时间归一化成一个单位时间。对于给定的点云序列,\r\n最终规范化后会给出在<strong>时间和空间</strong>上都规范化的点云。</li>\r\n<li>然后在规范化空间中学习连续的时空特征: 其使用了Neural Ordinary\r\nDifferential Equations (Neural ODEs)。</li>\r\n</ol>\r\n<h3\r\nid=\"pointlstm-an-efficient-pointlstm-for-point-clouds-based-gesture-recognition\">PointLSTM:\r\nAn Efficient PointLSTM for Point Clouds Based Gesture Recognition</h3>\r\n<ul>\r\n<li>Min Y, Zhang Y, Chai X, et al. An efficient pointlstm for point\r\nclouds based gesture recognition[C]//Proceedings of the IEEE/CVF\r\nConference on Computer Vision and Pattern Recognition. 2020:\r\n5761-5770.</li>\r\n<li>中科院计算所</li>\r\n</ul>\r\n<p>之前的工作从时空领域中抽取运动特征和结构特征。然而这些工作仅局限于短期模型，缺乏捕捉长期联系的能力。PointLSTM通过在点云上构建LSTM模型来学习点云序列的长期联系。然而点云数据是无序的，因此直接在没有对齐的点云序列上应用一个权重共享的LSTM层会有更新困难的问题。因此，<strong>如何在保持空间结构的前提下利用时间信息就是主要的挑战</strong>。</p>\r\n<p>PointLSTM对于每帧每个点都计算隐状态, 并且对于第t帧的点,\r\n会在第t-1帧中找到其局部邻域所有点,\r\n并且结合它们的LSTM隐状态来更新第t帧中心点。</p>\r\n<p>简化版本PointLSTM-PSS将过去t-1帧整个点云视为一个隐状态,\r\n并且对于第t帧的每个点都会利用这个隐状态进行更新。</p>\r\n<p>另外也提出了一种基于密度采样点云的方法。</p>\r\n<h3 id=\"pstnet\">PSTNet</h3>\r\n<ul>\r\n<li>Fan H, Yu X, Ding Y, et al. PSTNet: Point spatio-temporal\r\nconvolution on point cloud sequences[C]//International Conference on\r\nLearning Representations. 2020.</li>\r\n<li>新加坡国立大学</li>\r\n</ul>\r\n<p>在聚合时间邻域上提出了<strong>Point tube</strong>的结构,\r\n对前后相邻帧的点进行时间聚类。另外在邻域定义的基础上,\r\n由于点云的不规则性,\r\n传统规则卷积无法计算连续变化的点云坐标差。因此提出了<strong>PSTConv</strong>稀疏4D卷积模块。其将卷积定义为根据偏移量计算权重的连续核函数。</p>\r\n<h3\r\nid=\"sequentialpointnet-a-strong-parallelized-point-cloud-sequence-network-for-3d-action-recognition\">SequentialPointNet:\r\nA strong parallelized point cloud sequence network for 3D action\r\nrecognition</h3>\r\n<ul>\r\n<li>Li X, Huang Q, Wang Z, et al. SequentialPointNet: A strong\r\nparallelized point cloud sequence network for 3D action recognition[J].\r\narXiv preprint arXiv:2111.08492, 2021.</li>\r\n<li>河海大学计算机</li>\r\n</ul>\r\n<p>针对人类动作在空间上复杂，在时间上简单的特性，不平等的对待空间信息和时间信息。提出了一个强并行能力的点云序列网络SequentialPointNet：一个帧内appearance编码模块，一个帧间动作编码模块。</p>\r\n<ul>\r\n<li>为了对人体动作丰富的空间信息建模，每帧先在帧内的appearance\r\nencoding中并行处理，并且输出一个特征向量序列，描述静态的appearance在时间维度上的改变。</li>\r\n<li>为了建模简单的时间维度上的变化，在帧间的动作编码模块中，在特征向量序列中应用了\r\n时间上的位置编码和分层的池化策略。</li>\r\n<li>为了更好的挖掘时空内容，聚合人体动作的多级特征。</li>\r\n</ul>\r\n<h3 id=\"point4dtransformer\">Point4DTransformer</h3>\r\n<ul>\r\n<li>Fan H, Yang Y, Kankanhalli M. Point 4D transformer networks for\r\nspatio-temporal modeling in point cloud videos[C]//Proceedings of the\r\nIEEE/CVF Conference on Computer Vision and Pattern Recognition. 2021:\r\n14204-14213.</li>\r\n<li>新加坡国立大学/悉尼科技大学</li>\r\n</ul>\r\n<p>在PSTNet的PSTConv卷积提取局部特征的基础上,\r\n将各个局部特征连接到一个Transformer层进行权重提取。</p>\r\n<p>其中位置编码使用了一维卷积来实现</p>\r\n<h3 id=\"pst-transformer\">PST-Transformer</h3>\r\n<ul>\r\n<li>Fan H, Yang Y, Kankanhalli M. Point Spatio-Temporal Transformer\r\nNetworks for Point Cloud Video Modeling[J]. IEEE Transactions on Pattern\r\nAnalysis and Machine Intelligence, 2022.</li>\r\n<li>JCR 一区</li>\r\n<li>新加坡国立大学</li>\r\n</ul>\r\n<p>相比于P4T的全局注意力搜索，和PST的局部建模能力，PST-Transformer集合了两者，进行时空邻域的建模。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/hRhgDLA.png\" alt=\"系列对比\" />\r\n<figcaption aria-hidden=\"true\">系列对比</figcaption>\r\n</figure>\r\n<p>首先，通过一个video-level的自注意力进行帧加权。对于<strong>frame-level</strong>，仅对一帧进行注意力计算，由于点的流动性，可能会损失较多轨迹信息。而<strong>video-level</strong>，对两个查询帧之间的所有帧进行注意力计算，更适合保留时空信息。</p>\r\n<p><span class=\"math display\">\\[\r\n\\alpha_{p p^{\\prime}}=\\frac{e^{A_{p p^{\\prime}}}}{\\sum_{t^{\\prime\r\n\\prime}=1}^{L} \\sum_{p^{\\prime \\prime} \\in P_{t^{\\prime \\prime}}}\r\ne^{A_{p p^{\\prime \\prime}}}}\r\n\\]</span></p>\r\n<p>其次通过一个和PST一样的point 4D conv进行时空编码。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/CSh1yZu.png\" alt=\"PST-T整体结构图\" />\r\n<figcaption aria-hidden=\"true\">PST-T整体结构图</figcaption>\r\n</figure>\r\n<h3 id=\"geometrymotion-net\">GeometryMotion-Net</h3>\r\n<ul>\r\n<li>Liu J, Xu D. GeometryMotion-Net: A strong two-stream baseline for 3D\r\naction recognition[J]. IEEE Transactions on Circuits and Systems for\r\nVideo Technology, 2021, 31(12): 4711-4721.</li>\r\n<li>北航计算机</li>\r\n<li>中科院二区</li>\r\n</ul>\r\n<p>GeometryMotion-Net用于在点云序列中抽取几何和运动信息，并且不依赖于任何体素化操作。主要思想是利用一个<strong>几何流</strong>和<strong>运动流</strong>组成的two-stream框架来进行动作识别。</p>\r\n<p><strong>几何流</strong>: 将所有帧点云合并成一个大点云,\r\n再进行传统的空间点云处理, 如PointNet++。</p>\r\n<p><strong>运动流</strong>:\r\n在所有帧之间插值计算出一个关于运动变化的虚拟帧。再在这些虚拟帧上进行空间点云处理,\r\n得到一组特征。</p>\r\n<p><strong>双流汇聚</strong>: 将一个几何流的特征和 N\r\n个运动流的特征拼接合并输出。</p>\r\n<h3 id=\"tranquil-clouds\">Tranquil clouds</h3>\r\n<ul>\r\n<li>Prantl L, Chentanez N, Jeschke S, et al. Tranquil Clouds: Neural\r\nNetworks for Learning Temporally Coherent Features in Point\r\nClouds[C]//International Conference on Learning Representations.\r\n2020.</li>\r\n<li>慕尼黑工业大学</li>\r\n</ul>\r\n<p>基于推土机距离Earth Mover’s Distance (EMD)提出了一个新的损失函数,\r\n用于衡量两个点云之间的差异性:</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathcal{L}_{S}=\\min _{\\phi: \\tilde{y} \\rightarrow y}\r\n\\sum_{\\tilde{y}_{i} \\in\r\n\\tilde{Y}}\\left\\|\\tilde{y}_{i}-\\phi\\left(\\tilde{y}_{i}\\right)\\right\\|_{2}^{2}\r\n\\]</span></p>\r\n<h3 id=\"pointpwc-net\">PointPWC-Net</h3>\r\n<ul>\r\n<li>Wu W, Wang Z Y, Li Z, et al. Pointpwc-net: Cost volume on point\r\nclouds for (self-) supervised scene flow estimation[C]//European\r\nconference on computer vision. Springer, Cham, 2020: 88-107.</li>\r\n<li>Oregon State University</li>\r\n</ul>\r\n<p>提出的<strong>可学习的相继两个点云的matching cost</strong>：找到<span\r\nclass=\"math inline\">\\(p_t^j\\)</span>在上一帧中的邻域，并且计算邻域所有点与其的特征差和坐标差。</p>\r\n<blockquote>\r\n<p>这种<strong>点对点</strong>的matching cost对异常点特别敏感。</p>\r\n</blockquote>\r\n<h3 id=\"spcm-net\">SPCM-Net</h3>\r\n<ul>\r\n<li>He P, Emami P, Ranka S, et al. Learning Scene Dynamics from Point\r\nCloud Sequences[J]. International Journal of Computer Vision, 2022:\r\n1-27.</li>\r\n<li>Q1 CCF-A</li>\r\n<li>University of Florida ，CS</li>\r\n</ul>\r\n<p>主要是做序列点云的场景流估计以及预测任务。之前的场景流估计一般都是t-1帧预测t帧，两帧之间的联系。本文定义了序列多帧联系的场景流估计问题。并且基于这个问题，提出了一些序列学习的方法。</p>\r\n<ul>\r\n<li>Intra-Frame Feature Pyramid\r\n(IFFP)：依照了PointPWC-Net的结构，由于不能直接对点云进行传统卷积，使用了PointConv层进行卷积处理。<strong>并且通过多次FPS采样卷积中心，构建了多个金字塔式特征</strong>。</li>\r\n<li>Inter-Frame Spatiotemporal Correlation (IFSC):\r\n为了能找到时空联系，很自然我们希望使时间维度上的receptive\r\nfield能够尽可能覆盖到整个序列。因此借鉴了传统序列模型的<strong>LSTM结构</strong>,使用了一个\r\n<strong>recurrent cost volume</strong>\r\n结构来保存一定的时间信息。并且针对matching\r\ncost，提出了和PointPWC以及FlowNet不同的\r\n<strong>集合对集合</strong>的maching cost。</li>\r\n<li>Multi-scale Coarse-to-Fine Prediction: 两个帧的特征+cost\r\nvolume的特征生成最低级(粗粒度)的预测点，然后通过Pointnet++的特征上采样传播逐渐生成细粒度特征。</li>\r\n</ul>\r\n<h3 id=\"pstt\">PSTT</h3>\r\n<ul>\r\n<li>Wei Y, Liu H, Xie T, et al. Spatial-Temporal Transformer for 3D\r\nPoint Cloud Sequences[C]//Proceedings of the IEEE/CVF Winter Conference\r\non Applications of Computer Vision. 2022: 1171-1180.</li>\r\n<li>中山大学</li>\r\n<li>不在CCF h5指数62 排计算机视觉第12</li>\r\n</ul>\r\n<p>提出了<strong>Spatio-Temporal\r\nSelf-Attention(STSA)</strong>模块和<strong>Resolution\r\nEmbedding(RE)</strong>模块。STSA用于时空联系，RE用于聚合邻域特征，增强特征图的分辨率。</p>\r\n<p>现有的基于point的时空方法要么是使用注意力机制，要么是使用RNN模型。然而，这些方法依赖于长期联系，导致信息冗余。STSA使用了自注意力来提取帧间联系。这样会使冗余程度下降，鲁棒性提高(残差+layer\r\nnormalization)，训练速度提升。</p>\r\n<p>另外，在语义分割上面的编码器-解码器结构，在编码器降维时会造成信息丢失。RE模块使用了注意力权重来加强分辨率。</p>\r\n<h3 id=\"hyperpointnet\">HyperPointnet</h3>\r\n<ul>\r\n<li>Li X, Huang Q, Yang T, et al. Hyperpointnet for Point Cloud\r\nSequence-Based 3D Human Action Recognition[C]//2022 IEEE International\r\nConference on Multimedia and Expo (ICME). IEEE, 2022: 1-6.</li>\r\n<li>河海大学</li>\r\n<li>CCF B 会议</li>\r\n</ul>\r\n<p>将PointNet扩展到时间序列。作者提认为基于时空局部结构的点云序列模型会导致昂贵的计算和推理误差，因此其构造了<strong>HyperPoint</strong>的概念...本质上就是一个串行的帧内帧间编码网络。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/fcsguio.png\" alt=\"HyperPoint\" />\r\n<figcaption aria-hidden=\"true\">HyperPoint</figcaption>\r\n</figure>\r\n<p><strong>帧内处理</strong>：通过经典的sample and group\r\n层进行空间聚合学习，然后通过MLP进行维度变换。值得一提的是，其在每个group层，将邻域点的距离视为一个额外的特征维度。并且在group之后，使用了一个inter-feature的注意力模块CBAM来对特征进行重新整合。</p>\r\n<p><strong>帧间处理</strong>：\r\n每帧在帧内处理之后变成了所谓的一个HyperPoint，也就是逐帧的空间编码特征而已。其强调HyperPoint的主要信息来源于其内部结构，而不是HyperPoint之间。然后，给这个HyperPoint序列增加了一个Transformer的三角位置编码，并且再使用了frame-level的Pointnet进行最后的时间特征整合。</p>\r\n<h2 id=\"基于其他三维数据\">基于其他三维数据</h2>\r\n<h3 id=\"dgcnn\">DGCNN</h3>\r\n<ul>\r\n<li>Wang Y, Sun Y, Liu Z, et al. Dynamic graph cnn for learning on point\r\nclouds[J]. Acm Transactions On Graphics (tog), 2019, 38(5): 1-12.</li>\r\n</ul>\r\n<h3\r\nid=\"ddgcn-a-dynamic-directed-graph-convolutional-network-for-action-recognition\">DDGCN:\r\nA Dynamic Directed Graph Convolutional Network for Action\r\nRecognition</h3>\r\n<ul>\r\n<li>Korban M, Li X. Ddgcn: A dynamic directed graph convolutional\r\nnetwork for action recognition[C]//European Conference on Computer\r\nVision. Springer, Cham, 2020: 761-776.</li>\r\n<li>University of Virginia</li>\r\n</ul>\r\n<p>DDGCN认为骨架的空间层级结构和动作的时间序列结构都包含了顺序信息，然而大多数ST\r\ngraph都是用了无向图结构，即无视了顺序信息，因此DDGCN提出了<strong>有向图骨架结构\r\nDirected Spatial-Temporal Graph (DSTG)</strong>\r\n。通过有向图中父子节点的定义，父节点的动作实际上会影响到子节点的动作，因此DDGCN在有向图的基础上定义了\r\nbone features来表示父子节点的影响特征。</p>\r\n<p>另外针对图卷积的邻域不确定性，DDGCN提出<strong>Dynamic Convolutional\r\nSampling (DCS)</strong>\r\n来对一个节点的邻居列表进行动态的排序，形成动态邻域关系。然而卷积核的权重是有顺序的，而邻居列表是动态变化的，可能会造成权重分配的错序。因此DDGCN使用了一个<strong>Dynamic\r\nConvolutional Weights\r\n(DCW)</strong>模块来对邻居列表和权重列表进行一个<strong>Dynamic Time\r\nWarping (DTW)距离</strong>的最小化排序，再根据这个排序进行权重分配。</p>\r\n<h3 id=\"skeletontransformer\">SkeletonTransformer</h3>\r\n<ul>\r\n<li>Plizzari C, Cannici M, Matteucci M. Skeleton-based action\r\nrecognition via spatial and temporal transformer networks[J]. Computer\r\nVision and Image Understanding, 2021, 208: 103219.</li>\r\n<li>Politecnico di Torino 意大利都灵理工大学</li>\r\n<li>三区</li>\r\n</ul>\r\n<p>空间Transformer: <strong>Spatial Self-Attention\r\n(SSA)</strong>模块，用于在骨架之间动态的建立联系，而独立于人体真实骨架结构。\r\n时间Transformer: <strong>Temporal Self-Attention\r\n(TSA)</strong>模块用于学习关节在时间上的变化。</p>\r\n<p>值得注意的是, 其空间时间的Transformer不是串行计算,\r\n而是使用<strong>Two-Stream</strong>方法分为两条管线独立运算。最终再对两个管线输出特征进行拼接处理。</p>\r\n<h3 id=\"dv\">3DV</h3>\r\n<ul>\r\n<li>Wang Y, Xiao Y, Xiong F, et al. 3dv: 3d dynamic voxel for action\r\nrecognition in depth video[C]//Proceedings of the IEEE/CVF conference on\r\ncomputer vision and pattern recognition. 2020: 511-520.</li>\r\n<li>华中科技大学</li>\r\n</ul>\r\n<p>3DV通过对点云视频进行体素化, 提取出3D动态体素的表示。</p>\r\n<blockquote>\r\n<p>体素化的问题: 体素是是计算消耗巨大的过程, 时间和空间距离相同不太可取,\r\n时间戳本身会影响效果。</p>\r\n</blockquote>\r\n<h3 id=\"histogram-of-motion-trajectory-feature\">Histogram of motion\r\ntrajectory feature</h3>\r\n<ul>\r\n<li>Li D, Jahan H, Huang X, et al. Human action recognition method based\r\non historical point cloud trajectory characteristics[J]. The Visual\r\nComputer, 2022, 38(8): 2971-2979.</li>\r\n<li>四川大学 CS</li>\r\n<li>中科院JCR 3区</li>\r\n<li><strong>时间金字塔</strong>：即逐层分割时间序列，二分、四分......解释上一方面可以有助于识别不同长度的动作特征，另一方面，时间的片段化也能强化顺序信息。</li>\r\n</ul>\r\n<p><strong>分割四肢</strong>：通过kinect的骨骼坐标定位四肢点云并分割。</p>\r\n<p><strong>3D网格划分点云</strong>：将点云空间划分为 <span\r\nclass=\"math inline\">\\(W \\times H \\times d\\)</span>\r\n的网格空间以形成3D直方图。每个网格内的点云数量归一化到<span\r\nclass=\"math inline\">\\([y_{min},y_{max}]\\)</span>。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/20tjGyc.png\" alt=\"3D网格划分\" />\r\n<figcaption aria-hidden=\"true\">3D网格划分</figcaption>\r\n</figure>\r\n<p><span class=\"math display\">\\[\r\n\\mathrm{HOMT}_{w i, h i, d i}=y_{\\min }+\\frac{\\left(y_{\\max }-y_{\\min\r\n}\\right)\\left(num_{w i, h i, d i}-\\operatorname{Min}(n u\r\nm)\\right)}{\\operatorname{Max}(\\text { num })-\\operatorname{Min}(\\text {\r\nnum })}\r\n\\]</span></p>\r\n<p>最终以3D直方图特征<span class=\"math inline\">\\(HOMT \\in \\mathbb{R}^{t\r\n\\times w \\times h \\times\r\nd}\\)</span>作为特征描述子，再通过支持向量机进行特征分类。</p>\r\n<p>最终在UTD-MHAD上的分类结果到90.23%，不如SOTA\r\n91.13%，声称效率更高。</p>\r\n<h2 id=\"基础设施\">基础设施</h2>\r\n<h3 id=\"transformer\">Transformer</h3>\r\n<ul>\r\n<li>Vaswani A, Shazeer N, Parmar N, et al. Attention is all you\r\nneed[C]//Advances in neural information processing systems. 2017:\r\n5998-6008.</li>\r\n<li>Google</li>\r\n</ul>\r\n<p>RNN，LSTM，GNU是处理序列模型的几种最优方法。然而循环神经网络中总是沿着词元位置进行计算，这种<strong>顺序性阻碍了训练的并行化</strong>，这也严重影响了内存对batch的限制程度。因此<strong>Transformer</strong>完全依赖<strong>Self-Attention</strong>来抽取输入和输出的全局关系。并且能有更好的并行化。</p>\r\n<h3 id=\"external-attention\">External Attention</h3>\r\n<ul>\r\n<li>Guo M H, Liu Z N, Mu T J, et al. Beyond self-attention: External\r\nattention using two linear layers for visual tasks[J]. arXiv preprint\r\narXiv:2105.02358, 2021.</li>\r\n<li>清华</li>\r\n</ul>\r\n<p>自注意力机制在同一个样本内,\r\n任意一个部位的特征都可以聚合所有位置的特征进行加权输出。但是自注意力拥有<strong>二次复杂度</strong>,\r\n并且<strong>不能计算多个样本之间的潜在联系</strong>。</p>\r\n<p>External-Attention(EAT) 希望在学习某个数据集时,\r\n能够找到多个样本之间的潜在联系。其通过保持一定的<strong>key\r\nmemory</strong>,\r\n以找到跨越所有样本的最具有辨识性的特征。这种思想类似于sparse coding 和\r\ndictionary learning。并且由于key memory设计的很小,\r\n因此EAT计算上具有O(n)的复杂度,\r\n比起自注意力<strong>高效</strong>很多。</p>\r\n<h3 id=\"vision-transformer-vit\">Vision Transformer (ViT)</h3>\r\n<ul>\r\n<li>Dosovitskiy A, Beyer L, Kolesnikov A, et al. An Image is Worth 16x16\r\nWords: Transformers for Image Recognition at Scale[C]//International\r\nConference on Learning Representations. 2020.</li>\r\n<li>Google</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://i.imgur.com/CbvUBIo.png\" alt=\"模型结构\" />\r\n<figcaption aria-hidden=\"true\">模型结构</figcaption>\r\n</figure>\r\n<p>第一篇CV上的Transformer：</p>\r\n<ul>\r\n<li><strong>patch embedding</strong>:\r\n为了仿照NLP的输入结构，将图像划分为多个patches，并且展平为一维序列。由于Transformer层的输入长度固定为D，因此原patches组成的特征序列长度为N，通过线性层将长度映射成D。</li>\r\n<li><strong>position embeddings</strong>：由于2D的position\r\nembeddings没有体现出优越性，因此还是使用了标准的1D可学习的position\r\nembeddings。</li>\r\n<li><strong>Hybrid Architecture</strong>:\r\npatches的特征可以通过CNN来进行提取。</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\mathbf{z}_{0} &amp;=\\left[\\mathbf{x}_{\\text {class }} ;\r\n\\mathbf{x}_{p}^{1} \\mathbf{E} ; \\mathbf{x}_{p}^{2} \\mathbf{E} ; \\cdots ;\r\n\\mathbf{x}_{p}^{N} \\mathbf{E}\\right]+\\mathbf{E}_{p o s}, &amp; &amp;\r\n\\mathbf{E} \\in \\mathbb{R}^{\\left(P^{2} \\cdot C\\right) \\times D},\r\n\\mathbf{E}_{p o s} \\in \\mathbb{R}^{(N+1) \\times D} \\\\\r\n\\mathbf{z}_{\\ell}^{\\prime}\r\n&amp;=\\operatorname{MSA}\\left(\\operatorname{LN}\\left(\\mathbf{z}_{\\ell-1}\\right)\\right)+\\mathbf{z}_{\\ell-1},\r\n&amp; &amp; \\ell=1 \\ldots L \\\\\r\n\\mathbf{z}_{\\ell}\r\n&amp;=\\operatorname{MLP}\\left(\\operatorname{LN}\\left(\\mathbf{z}_{\\ell}^{\\prime}\\right)\\right)+\\mathbf{z}_{\\ell}^{\\prime},\r\n&amp; &amp; \\ell=1 \\ldots L \\\\\r\n\\mathbf{y} &amp;=\\operatorname{LN}\\left(\\mathbf{z}_{L}^{0}\\right) &amp;\r\n&amp;\r\n\\end{aligned}\r\n\\]</span></p>\r\n<blockquote>\r\n<p>分辨率单一，计算效率低。 class token是什么？</p>\r\n</blockquote>\r\n<h3 id=\"swim-transformer\">Swim Transformer</h3>\r\n<ul>\r\n<li>Liu Z, Lin Y, Cao Y, et al. Swin transformer: Hierarchical vision\r\ntransformer using shifted windows[C]//Proceedings of the IEEE/CVF\r\nInternational Conference on Computer Vision. 2021: 10012-10022.</li>\r\n</ul>\r\n<p>在ViT中，自注意力是全局计算的，但是图片分辨率比起句子往往较大，因此带来了计算效率低的问题。locality一直是视觉里的重要建模方式，因此这篇文章将图片切分为<strong>不重合的local\r\nwindow</strong>，并且在local\r\nwindow内部进行注意力计算。为了让window之间有信息交换，在相邻两层使用<strong>不同的window划分</strong>。</p>\r\n<p>金字塔层次化Transformer。</p>\r\n<h3 id=\"layer-normalization\">Layer Normalization</h3>\r\n<ul>\r\n<li>Ba J L, Kiros J R, Hinton G E. Layer normalization[J]. arXiv\r\npreprint arXiv:1607.06450, 2016.</li>\r\n</ul>\r\n<h3 id=\"pre-layer-normalization\">Pre Layer Normalization</h3>\r\n<ul>\r\n<li>Xiong R, Yang Y, He D, et al. On layer normalization in the\r\ntransformer architecture[C]//International Conference on Machine\r\nLearning. PMLR, 2020: 10524-10533.</li>\r\n</ul>\r\n<p>本文分析了Transformer模型的初始化warmup问题，将layer\r\nnormalization从原本的残差后移到了残差前，从实验和理论证明了pre-LN不需要warmup，并且收敛更好。</p>\r\n<h3 id=\"localvit\">LocalViT</h3>\r\n<ul>\r\n<li>Li Y, Zhang K, Cao J, et al. Localvit: Bringing locality to vision\r\ntransformers[J]. arXiv preprint arXiv:2104.05707, 2021.</li>\r\n<li>苏黎世联邦理工</li>\r\n</ul>\r\n<p>在Transformer的FeedForward层中添加inverted residual block以及\r\ndepth-wise 卷积来增加local能力。</p>\r\n<p>FeedForward层可以有助于增加Transformer结构的泛化能力。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/msRVrEW.png\" alt=\"local feedforward\" />\r\n<figcaption aria-hidden=\"true\">local feedforward</figcaption>\r\n</figure>\r\n<h3 id=\"mobilenet\">MobileNet</h3>\r\n<ul>\r\n<li>Howard A G, Zhu M, Chen B, et al. Mobilenets: Efficient\r\nconvolutional neural networks for mobile vision applications[J]. arXiv\r\npreprint arXiv:1704.04861, 2017.</li>\r\n<li>Google</li>\r\n</ul>\r\n<p><strong>Depth wise\r\n卷积</strong>：将原来的<strong>多输入通道+多输出通道</strong>卷积拆分为\r\n<strong>逐通道卷积+1D卷积通道变换</strong>，极大节省计算量。其计算量从<span\r\nclass=\"math inline\">\\(D_K \\times D_K \\times M \\times N \\times D_F \\times\r\nD_F\\)</span>变为<span class=\"math inline\">\\(D_K \\times D_K \\times M\r\n\\times D_F \\times D_F+M \\times N \\times D_F \\times\r\nD_F\\)</span>，论文模型在ImageNet上参数量大约缩小为1/10，准确率下降1%。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/2tkPCO8.png\" alt=\"DepthWise Conv\" />\r\n<figcaption aria-hidden=\"true\">DepthWise Conv</figcaption>\r\n</figure>\r\n<h3 id=\"resnet\">ResNet</h3>\r\n<ul>\r\n<li>He K, Zhang X, Ren S, et al. Deep residual learning for image\r\nrecognition[C]//Proceedings of the IEEE conference on computer vision\r\nand pattern recognition. 2016: 770-778.</li>\r\n</ul>\r\n<h3 id=\"位置编码\">位置编码</h3>\r\n<ul>\r\n<li>T5编码 Raffel C, Shazeer N, Roberts A, et al. Exploring the limits\r\nof transfer learning with a unified text-to-text transformer[J]. arXiv\r\npreprint arXiv:1910.10683, 2019.</li>\r\n<li>Ke G, He D, Liu T Y. Rethinking Positional Encoding in Language\r\nPre-training[C]//International Conference on Learning Representations.\r\n2020.</li>\r\n<li>相对位置编码基础 Shaw P, Uszkoreit J, Vaswani A. Self-Attention with\r\nRelative Position Representations[C]//Proceedings of the 2018 Conference\r\nof the North American Chapter of the Association for Computational\r\nLinguistics: Human Language Technologies, Volume 2 (Short Papers). 2018:\r\n464-468.</li>\r\n<li>训练式编码 Gehring J, Auli M, Grangier D, et al. Convolutional\r\nsequence to sequence learning[C]//International Conference on Machine\r\nLearning. PMLR, 2017: 1243-1252.</li>\r\n</ul>\r\n<h3 id=\"训练优化\">训练优化</h3>\r\n<ul>\r\n<li><p>Goyal P, Dollár P, Girshick R, et al. Accurate, large minibatch\r\nsgd: Training imagenet in 1 hour[J]. arXiv preprint arXiv:1706.02677,\r\n2017.</p></li>\r\n<li><p>Smith L N. Cyclical learning rates for training neural\r\nnetworks[C]//2017 IEEE winter conference on applications of computer\r\nvision (WACV). IEEE, 2017: 464-472.</p></li>\r\n</ul>\r\n<p>传统的方法中认为学习率应该是一个单调缓慢减少的数，然而这篇文章指出在一个<strong>周期范围变化的学习率</strong>可以有更好的效果。其循环变化方式可以有三角式、余弦式，线性式等。</p>\r\n<p><strong>原理</strong>：通常造成loss下降困难的地方是\r\n<strong>鞍点</strong> 而不是简单的\r\n<strong>极小点</strong>，在鞍点附近梯度极小，导致更新缓慢。此时就可以通过增大学习率来跳出鞍点。</p>\r\n<p><strong>确定循环周期</strong>：实验表明半周期设置为2~10个epoch*iterations比较好。(按iteration迭代，而不是按epoch迭代)。最好使用3个以上的epoch来代替一个常量学习率下的epoch。</p>\r\n<p><strong>确定学习率上下界</strong>：所谓LR\r\ntest，运行几个单独的epoch，同时线性增大学习率，观察准确率的变化，找到第一个增加点，和波动之前的最后一个点。</p>\r\n<ul>\r\n<li>Loshchilov I, Hutter F. Sgdr: Stochastic gradient descent with warm\r\nrestarts[J]. arXiv preprint arXiv:1608.03983, 2016.</li>\r\n</ul>\r\n<p>实验表明，使用warm\r\nrestart的学习率更新方法，收敛速度比寻常方法可以快2~4倍。其提出了<strong>余弦退火学习率调度器</strong>：</p>\r\n<p><span class=\"math display\">\\[\r\n\\eta_{t}=\\eta_{\\min }^{i}+\\frac{1}{2}\\left(\\eta_{\\max }^{i}-\\eta_{\\min\r\n}^{i}\\right)\\left(1+\\cos \\left(\\frac{T_{\\text {cur }}}{T_{i}}\r\n\\pi\\right)\\right),\r\n\\]</span></p>\r\n<p>论文使用参数<span class=\"math inline\">\\(T_o=10\\)</span>,<span\r\nclass=\"math inline\">\\(T_{mult}=2\\)</span>。</p>\r\n<h3 id=\"can-attention-enable-mlps-to-catch-up-with-cnns\">Can attention\r\nenable MLPs to catch up with CNNs</h3>\r\n<ul>\r\n<li>Guo M H, Liu Z N, Mu T J, et al. Can attention enable MLPs to catch\r\nup with CNNs?[J]. Computational Visual Media, 2021, 7(3): 283-288.</li>\r\n</ul>\r\n<p>比较了几个新兴的MLP，CNN，Transformer模型，总结了以下几个共同点：</p>\r\n<ul>\r\n<li>通过将图片划分为Patch，可以更好地捕捉局部结构。</li>\r\n<li>注意力中的辅助结构也可以考虑应用在非注意力模型上，比如Multi-Head</li>\r\n<li>Residual 结构对于所有模型都很重要</li>\r\n<li>局部计算的CNN会导致归纳偏差(Inductive\r\nBias)，而一维卷积和全域计算结构可以减少归纳偏差。</li>\r\n</ul>\r\n<h3 id=\"action-recognition-based-on-a-bag-of-3d-points\">Action\r\nrecognition Based on A Bag of 3D Points</h3>\r\n<ul>\r\n<li>Li W, Zhang Z, Liu Z. Action recognition based on a bag of 3d\r\npoints[C]//2010 IEEE computer society conference on computer vision and\r\npattern recognition-workshops. IEEE, 2010: 9-14.</li>\r\n<li>CVPRW</li>\r\n<li>University of Wollongong</li>\r\n</ul>\r\n<p>第一，其提出可以用整个点云bag来表示动作序列。并且点出每一帧之间，点的个数可能不同，并且点之间没有对应关系。更进一步，其假设一个点云帧是一个\r\n<strong>混合高斯模型</strong>，可以通过一系列的混合高斯分布来描述：</p>\r\n<p><span class=\"math display\">\\[\r\np(x \\mid \\omega)=\\prod_{i=1}^{m} \\sum_{t=1}^{Q} \\pi_{t}^{\\omega}\r\ng\\left(q_{i}, \\mu_{t}^{\\omega}, \\Sigma_{t}^{\\omega}\\right)\r\n\\]</span></p>\r\n<p>另外，由于点的数量太多容易造成noise和计算问题，需要对点进行采样。在2D的经验里，人体的边缘轮廓是最重要的形状信息。进而在3D中，提出了一种点云的<strong>投影采样法</strong>：通过将点云投影到三个正交2D面，再在2D上进行轮廓采样。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/Fi3BjWH.png\" alt=\"投影采样\" />\r\n<figcaption aria-hidden=\"true\">投影采样</figcaption>\r\n</figure>\r\n<h3\r\nid=\"dpdist-comparing-point-clouds-using-deep-point-cloud-distance\">DPDist:\r\nComparing Point Clouds Using Deep Point Cloud Distance</h3>\r\n<ul>\r\n<li>Urbach D, Ben-Shabat Y, Lindenbaum M. DPDist: Comparing point clouds\r\nusing deep point cloud distance[C]//European Conference on Computer\r\nVision. Springer, Cham, 2020: 545-560.</li>\r\n<li>澳大利亚国立大学</li>\r\n</ul>\r\n<p>本文提出了一种衡量点云距离的深度学习方法，不同于传统方法，其衡量的是点云A到点云B的surface\r\nrepresentation的距离。介绍了几种传统点云距离度量方法，以及新的基于深度学习的改进方法。</p>\r\n<p><strong>Hausdorff distance</strong> 距离：点到点距离<span\r\nclass=\"math inline\">\\(d(x,y)\\)</span>，点到点云距离<span\r\nclass=\"math inline\">\\(D(x,S)\\)</span>，点云到点云距离<span\r\nclass=\"math inline\">\\(D_H(S_A,S_B)\\)</span>。</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nd(x, y) &amp;=\\|x-y\\|_{2} \\\\\r\nD(x, S) &amp;=\\min _{y \\in S} d(x, y) \\\\\r\n\\mathcal{D}_{H}\\left(S_{A}, S_{B}\\right)&amp;=\\max \\left\\{\\max _{a \\in\r\nS_{A}} D\\left(a, S_{B}\\right), \\max _{b \\in S_{B}} D\\left(b,\r\nS_{A}\\right)\\right\\}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><strong>Chamfer\r\ndistance</strong>：相比于Hausdorff距离，Chamfer取平均距离而不是取最大距离。</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathcal{D}_{C D}\\left(S_{A}, S_{B}\\right)=\\frac{1}{N_{A}} \\sum_{a \\in\r\nS_{A}} \\min _{y \\in S_{B}} d(a, y)^{2}+\\frac{1}{N_{B}} \\sum_{b \\in\r\nS_{B}} \\min _{y \\in S_{A}} d(b, y)^{2}\r\n\\]</span></p>\r\n<p>Earth Mover's Distance :\r\n在点云B中确定一种离点云A最近的映射关系，再累加欧拉距离。</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathcal{D}_{E M D}\\left(S_{A}, S_{B}\\right)=\\min _{\\xi: S_{A}\r\n\\rightarrow S_{B}} \\sum_{a \\in S_{A}}\\|a-\\xi(a)\\|_{2}\r\n\\]</span></p>\r\n<h3 id=\"siamese-neural-network-triplet-network\">Siamese Neural Network\r\n&amp; Triplet Network</h3>\r\n<ul>\r\n<li>Bromley J, Guyon I, LeCun Y, et al. Signature verification using a\"\r\nsiamese\" time delay neural network[J]. Advances in neural information\r\nprocessing systems, 1993, 6.</li>\r\n</ul>\r\n<p>孪生神经网络，用于衡量两个小样本输入的相似程度。在输入数据属于训练数据集的情况下，通常我们可以通过数据识别分类来比较两个数据。然而对于小样本数据，其数据量根本不够成为训练数据集，甚至这个数据可能只有一份，此时则无法通过训练识别来进行分类。</p>\r\n<p>为了能够度量训练集以外的输入数据相似性，孪生神经网络在训练<strong>特征提取</strong>网络的基础上，还增加了<strong>同类相近、异类排斥</strong>的结构，以便于强调网络的<strong>数据匹配</strong>能力。其将一对输入<span\r\nclass=\"math inline\">\\(X_1,X_2\\)</span>给到同一个神经网络提取特征向量<span\r\nclass=\"math inline\">\\(F_1,F_2\\)</span>，并计算两个特征向量的相似度。如果是同类别的输入对，则期望相似度输出为1，如果是不同类别的输入对则期望输出0。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/eqmq6lr.png\" alt=\"孪生神经网络模型图\" />\r\n<figcaption aria-hidden=\"true\">孪生神经网络模型图</figcaption>\r\n</figure>\r\n<p>损失函数Contrastive Loss：<span\r\nclass=\"math inline\">\\(D_W\\)</span>为输入对的特征向量的距离度量，<span\r\nclass=\"math inline\">\\(Y\\)</span>指明输入对是同类还是异类。即通过<span\r\nclass=\"math inline\">\\(Y\\)</span>可以选择启用损失函数里的<strong>同类损失部分</strong>或者<strong>异类损失部分</strong>。<strong>同类距离需要尽可能的小，异类距离需要尽可能的大</strong>。</p>\r\n<p><span class=\"math display\">\\[\r\nD_{w}(X_{1}, X_{2}) = ||G(X_{1}) - G(X_{2})|| \\\\\r\n\\mathcal{L} = (1-Y)\\frac{1}{2}(D_W)^2+(Y)\\frac{1}{2}\\{max(0, m-D_W)\\}^2\r\n\\]</span></p>\r\n<p>在孪生网络中每一对输入要么是同类的，要么是异类的，即同类和异类的训练需要分PASS进行。而在Triplet三生网络中则将输入进行扩展，一组输入包含三个数据，既有同类，又有异类，进而可以将训练过程放在一个PASS完成。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/QWhZZWr.png\" alt=\"三生神经网络模型图\" />\r\n<figcaption aria-hidden=\"true\">三生神经网络模型图</figcaption>\r\n</figure>\r\n<p>同样，其损失函数<strong>三元组损失</strong>也改造成了一个PASS的形式：其本质上衡量了<span\r\nclass=\"math inline\">\\((d_+,d_-)\\)</span>与<span\r\nclass=\"math inline\">\\((0,1)\\)</span>的向量距离。</p>\r\n<p><span class=\"math display\">\\[\r\nd_{+} = \\frac{e^{\\Vert Net(x)-Net(x^{+})\\Vert _2}}{e^{\\Vert\r\nNet(x)-Net(x^{+})\\Vert _2}+e^{\\Vert Net(x)-Net(x^{-})\\Vert _2}} \\\\\r\nLoss(d_{+},d_{-}) = \\Vert (d_{+} , d_{-}-1)\\Vert _2^2 = const\\cdot d_+^2\r\n\\\\\r\n\\]</span></p>\r\n","categories":["深度学习"],"tags":["序列学习","点云"]},{"title":"Sitch","url":"/about/index.html","content":"<h4\r\nid=\"全面深化改革目标戒骄戒躁求真务实\">全面深化改革目标：戒骄戒躁求真务实</h4>\r\n<ul>\r\n<li><p>一知半解似懂非懂统一为，不知道</p></li>\r\n<li><p>拒绝虚话奉承话，见个面就来句“大佬tql”什么的，过于讽刺。</p></li>\r\n<li><p>不好为人师，经历过不代表最优解，从中抽取有价值的东西分享。</p></li>\r\n<li><p>透明化专业壁垒，别人没来了解过而已，不代表学了有什么可优越的。尽量消解专业壁垒才是值得骄傲的事。除非，有朝一日成为领域内的佼佼者。</p></li>\r\n<li><p>说话去攻击性，不管主观还是客观，自己说话攻击到了对方就是自己的责任，而不是去想对方怎么怎么脆弱。没必要去怄气针锋相对。</p></li>\r\n</ul>\r\n<p><a\r\nhref=\"http://mindhacks.cn/2008/09/17/learning-habits-part3/\">如何去学习——刘未鹏</a></p>\r\n<h4 id=\"三年计划\">三年计划</h4>\r\n<p>2021 秋 - C++ Primer - 现代计算机图形学入门-闫令琪 √</p>\r\n"},{"title":"分类","url":"/categories/index.html","content":"\r\n"},{"title":"tags","url":"/tags/index.html","content":"\r\n"}]