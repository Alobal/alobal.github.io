[{"title":"2020.8.22 随便写写","url":"/2020/08/22/2020-8-22%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/","content":"<p>是在 hexo 写的第一篇生活记录吧（大概也是几年来写的第一篇 hhhh</p>\r\n<p>随便写写看看能写出啥</p>\r\n<h2 id=\"博客的坑\">博客的坑</h2>\r\n<p>自从开始 Hexo\r\n搭建博客，不知道多少时间都拿去填了这该死的坑。一开始只是想着能跑起来就好，技术专业嘛，注重文本可读性，当个可以远程看的文本笔记就行。主题什么的不重要，字体什么的不重要，只要给我白底黑字，我能读能复习就\r\nok！！</p>\r\n<p>结果，网站能跑了，开始想想要不给搞个主题配置吧！直接默认风格也太寒颤了，好像隔壁\r\nNext 主题清新的就很和我胃口，装了。 (虽然 Next\r\n主题用的人比默认主题多多了，十个 Hexo 九个\r\nNext，剩下一个是学前端的自定义主题)</p>\r\n<p>博客多了看起来多麻烦，想想要不添加个分类和标签功能吧！嗯嗯都是为了方便找归档博客！诶诶隔壁博客还能放网易云背景音乐啊，带\r\nBGM\r\n看博客肯定很舒服我要了我要了！噢作为一个程序员，大家肯定能理解，别的不折腾，代码高亮主题肯定要折腾一下！！是用\r\nHighlightJS 呢，还是 prismJS 呢，还是 hexo-prism 插件呢！还是一贯的\r\nGoogle 信仰加持的 Google-code-prettify 呢！折腾了半天还出 BUG\r\n了，甚至不能改回正常的普普通通朴素高亮，重新安了一个 Next 主题 ...</p>\r\n<p><span id=\"more\"></span></p>\r\n<p>这次重新安装顺带把 Next 从 2020 8.0 版本换成了 7.8，毕竟 8.0\r\n实在没有教程带 ... 孩子们，虽然我是帮不了你们 8.0 了，但是 7.8\r\n的建站和自定义过程我写的很详细，有需求的话，最好远离网上的新瓶炒馊饭的博客，请看这里：</p>\r\n<ul>\r\n<li><a\r\nhref=\"https://alobal.github.io/Blog/2020/07/15/Github-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/\">GitHub+Hexo\r\n搭建博客</a></li>\r\n<li><a\r\nhref=\"https://alobal.github.io/Blog/2020/07/23/Next7-8-%E5%8A%9F%E8%83%BD%E6%80%A7%E9%85%8D%E7%BD%AE/\">Next7.8\r\n功能性配置</a></li>\r\n<li><a\r\nhref=\"https://alobal.github.io/Blog/2020/07/24/Next7-8-%E7%BE%8E%E5%8C%96%E6%80%A7%E9%85%8D%E7%BD%AE/\">Next7.8\r\n美化性配置</a></li>\r\n</ul>\r\n<blockquote>\r\n<p>　那些馊饭博客我能吐槽无数遍无数遍，虽然有参考价值，但是 2020 请拿出\r\n2020 的样子好吗。</p>\r\n</blockquote>\r\n<p>另外以前是在简书写博客笔记的，那些之前的博客肯定要搬过来的，要不然新建的\r\nHexo 多孤单！于是又折腾了一天的 <a\r\nhref=\"https://alobal.github.io/Blog/2020/07/16/%E7%AE%80%E4%B9%A6%E5%8D%9A%E5%AE%A2%E5%AF%BC%E5%85%A5hexo/\">简书博客导入\r\nHexo</a>...\r\n算是成功搬运了，只不过有些小问题，但也不打紧，过了过了，再折腾这玩意要疯了。</p>\r\n<p>虽然这些导入的博客时间全都设置在 2020.2.17 怪尴尬的 hhhhh\r\n我懒，不想一个一个改了，写个程序一天天递增设置也意义不大。<del>懒得写</del></p>\r\n<blockquote>\r\n<p>　？那你咋不会懒得写博客，每次折腾博客都是半天半天浪费了。——脑子不太对就开始写了。</p>\r\n</blockquote>\r\n<p>回到主线，BGM\r\n和代码高亮都折腾了，一切看起来都是适合读书的样子！....？</p>\r\n<ul>\r\n<li>一篇文章怎么能没有字数统计和阅读时长！看着自己码了多少字的博客多有成就感！搞！</li>\r\n<li>刚建站搜索引擎是没有收录的，看不到访客的博客失去了灵魂！百度分析和\r\nGoogle 收录，搞！</li>\r\n<li>喜欢安利 AVG\r\n的我，怎么能不搞点东西记录自己看过的玩过的东西呢！一开始用的是文本形式，记起一个写一个上去，但是看着看着觉得文本太枯燥了，要不要加个详情页链接？加个图片展示？（噢说到图片展示要不要做个相册页面\r\n.... 该死，被挖掘机传染了）最后搜着搜着发现可以导入豆瓣影评页面，搞 ...\r\n昨天晚上搞这玩意搞到凌晨。<del>其实是聊天为主</del></li>\r\n</ul>\r\n<p>豆瓣也是个大坑 ... 今天写日记前在豆瓣创了个号补了 45\r\n个电影动漫的\"看过+短评\"，算是把\"影片\"这一栏导入完毕了吧。结果刚想动手导\"游戏\"这一栏的之前在\r\nsteam 写的评测，但是 steam 评测是 steam-bbcode 格式，不是 markdown\r\n格式，更何况豆瓣游戏评价甚至连 markdown 也不支持 ...\r\n啊心累，在考虑单独开个分类，把每篇评测改造成一篇博客，还是缩减成几句话的短评写在豆瓣里.....然后纠结着发现又是一个浩大的工程！算了，先滚过来写了第一篇日记。</p>\r\n<blockquote>\r\n<p>　昨天晚上在我以为能装的功能都折腾完了之后，某个人提了一句，“会有人讨论吗？”...\r\n行行行，评论系统的坑我挖了。</p>\r\n</blockquote>\r\n<p>博客功能配置算是告一段落 ...\r\n中间还花了大笔时间去美化性自定义，标题怎么搞好看显眼，默认正文字体怎么感觉不够清新\r\n... 这个美化的坑虽然也埋葬了大笔时光，不过目前还算是满意了，归档！</p>\r\n<p>美化过程中搜到一段话，觉得写的很好哈哈哈哈哈，献给中英文混杂不留白的你：</p>\r\n<blockquote>\r\n<p>　打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在\r\n34\r\n岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。——<a\r\nhref=\"https://github.com/mzlogin/chinese-copywriting-guidelines\">mzlogin</a></p>\r\n</blockquote>\r\n","categories":["生活"]},{"title":"408错题集","url":"/2020/12/05/408%E9%94%99%E9%A2%98%E9%9B%86/","content":"<h2 id=\"数据结构\">数据结构</h2>\r\n<p>C语言标识符需要 字母 / 下划线 开头，不能数字开头</p>\r\n<p>中序和层序才能构成唯一的二叉树，先序和层序不能。</p>\r\n<p>完全二叉树的叶子节点不一定在最后一层，最后两层都可能。下(n/2)为最后的父节点。</p>\r\n<h3 id=\"查找\">查找</h3>\r\n<p>分块查找，块内取√n长度，ASL达到最小值。</p>\r\n<p>Hash表删除元素，不能简单地删除，而是标记为删除。因为在开放定址法里面，会影响到后面的元素查找。\r\nHash表平均失败长度是对mod出的位置算，不是对所有表的位置都算。</p>\r\n<p>B树支持随机查找，B+支持随机和顺序。注意基础的是随机查找，特有的是顺序查找。</p>\r\n<p><strong>折半查找判定树</strong>\r\n是一种平衡二叉排序树，判定树的结构和总节点数N一一对应。 高度H=下(log2\r\nn)+1=查找成功最多比较次数=查找失败最多比较次数 N节点建树方法： -\r\n先判断高度H，构建好H-1层的满二叉树 - 对于剩下的节点： -\r\nmid<strong>向下</strong>取整时，从根节点开始，按照<strong>先右后左</strong>的顺序判断往哪边挂新节点。对子树也是递归同样的规则判断。\r\n- mid<strong>向上</strong>取整时，<strong>先左后右</strong> -\r\n最后按照中值遍历的顺序填充节点值。\r\n&gt;向上取整和向下取整体现在树中就是哪侧会多一个节点。</p>\r\n<h3 id=\"排序\">排序</h3>\r\n<p>所有元素相等时的排序：简单选择排序是n^2, 基数排序是nd。</p>\r\n<p>插入排序，注意n趟之后是有n+1个元素有序。初始一个不算趟数。</p>\r\n<p>堆排序向下调整，先找出两个子节点中最厉害的那个，再换，递归继续向下。</p>\r\n<p>平衡二叉树[节点最少/层数最多]情况的递推：N1=1 N2=2\r\nNh=N(h-1)+N(h-2)+1</p>\r\n<p>排序序列原始状态只影响快排的效率，不影响趟数，事实上每一趟确定一个数的位置。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"计组\">计组</h2>\r\n<p>小心，CPI和时钟频率无关，只和执行速度有关</p>\r\n<p>RISC的体系结构并不等同于早期计算机的简单结构</p>\r\n<p>数据总线的位数一般等于机器字长，但也不绝对。大于的时候CPU可以分两次取数。</p>\r\n<p>翻译程序 -\r\n编译程序：将高级语言程序一次全部翻译成目标程序。每次执行只执行目标程序文件\r\n- 解释程序：将源程序每条语句翻译成机器目标代码，并立即执行。不产生文件。\r\n- 汇编程序：将汇编语言翻译成机器语言，和机器语言一一对应。</p>\r\n<h3 id=\"编码\">编码</h3>\r\n<p>不是所有十进制小数都可以用二进制表示，如0.3</p>\r\n<p><strong>浮点数</strong></p>\r\n<p>浮点数运算，阶码双符号位判断溢出，尾数双符号位决定正负。\r\n阶码上溢需要中断处理，阶码小于最小阶码即下溢，看作机器零处理。</p>\r\n<p>最简单的浮点数舍入处理方法是直接截断法。</p>\r\n<p>IEEE754浮点数乘法运算结果肯定不需要左规处理。左规是数往左移动，好让小数点前面有个1。因为754尾数必然≥1，尾数运算结果也必然≥1，显然不会需要左规。</p>\r\n<p>IEEE754\r\n阶码全1尾数全0是±∞，阶码全0尾数全0是±0。如果尾数此时不是0，则是NaN非规格数。</p>\r\n<h3 id=\"存储系统\">存储系统</h3>\r\n<p><strong>Cache</strong>\r\nCache不能作为指令地址码，一般都是主存单元作为地址码，系统自动在Cache中查找，Cache对程序员透明。\r\n指令地址码一般是 主存单元/数据寄存器。</p>\r\n<p>Cache每行位数：数据bit+Tag位+(LRU 1)+(修改位 1)+(有效位\r\n1)。注意不需要组号位，假如是组相联映射，主存地址结构中间几位是组号，但是Cache每行里面不需要装组号，多路分组是地址结构解析的事。</p>\r\n<p>Cache采用N路组相联映射：组内有N行，组数=数据区容量/每组容量</p>\r\n<p>Cache完全由硬件实现，且Cache透明。\r\n虚存由软硬件实现。虚存对系统程序员不透明，对应用程序员也透明。虚存大小≤内存+外存\r\nCache和TLB缺失都可以由硬件处理。</p>\r\n<p>对a[k]=a[k]+32;\r\n赋值也需要访问Cache，即需要访问两次Cache里的a[k]。</p>\r\n<p><strong>RAM</strong> RAM都是易失性存储器 SRAM 非破坏性读出，DRAM\r\n破坏性读出，。 SRAM 双稳态触发器，不需要再生，DRAM电容存储，需要再生。\r\nSRAM 更贵，功耗更大，集成度更低，速度更快。 DRAM\r\n地址复用，分两次送行列地址。</p>\r\n<p>高位交叉存储器也可能在一个存储周期内连续访问几个模块，只不过概率比较小...</p>\r\n<p>存取周期和存取时间是不同的概念，周期是连续两次操作的间隔，时间是一次操作的时间。周期＞时间。</p>\r\n<p><strong>分页管理和虚拟存储器</strong>\r\nTLB里存的是页表，访问完TLB还要访存访问页面。\r\n注意在统计TLB和主存访问次数的时候，缺页中断后，对原数据重新访问一次。</p>\r\n<p>分页存储解决的是不连续存储的问题，注意虚拟存储器的请求分页机制才是逻辑扩充容量。</p>\r\n<p>页面置换算法中，只有FIFO会出现Belady现象，队列类算法。\r\nLRU性能好，但需要寄存器和栈的硬件支持，是堆栈类算法。\r\nNRU=CLOCK，用较小的开销接近LRU性能。</p>\r\n<p>工作集窗口k是从当前时刻往前k个之内，是集合。不需要因为重复继续往前延伸。重复时工作集大小就小于k了。</p>\r\n<h3 id=\"指令系统\">指令系统</h3>\r\n<p>指令字长通常都是存储字长的整数k倍，k≥1。注意只说一样长是错误的。</p>\r\n<h3 id=\"cpu\">CPU</h3>\r\n<p>CPU数据通路由控制部件控制，因此数据通路内不包括控制部件。</p>\r\n<p>无论执行什么指令，CPU在指令周期首先是 取指，(PC)-&gt;MAR。</p>\r\n<p>CM控制存储器存储的是\r\n所有机器指令的微程序，也即所有微程序的所有微指令。\r\nCM容量=微指令数X微指令字长 注意水平型微指令字长 -\r\n操作控制字段，字段直接编码——互斥性微命令放在同一段进行编码，相容性微命令放在不同段。\r\n- 判断测试字段位数=外部条件数。比如外部条件3个，应该是3位，而不是2位。 -\r\n下地址字段位数N：即2^N≥所有微指令数。</p>\r\n<h3 id=\"总线\">总线</h3>\r\n<p>地址总线是单向的，数据、控制总线是双向的。</p>\r\n<p>异步定时方式适合速度差异较大的设备之间。完全依靠双方的握手信号来实行定时控制。</p>\r\n<h3 id=\"io\">IO</h3>\r\n<p>DMA中断只用来向CPU提出传输结束，可能报告数据错误，不会检查数据错误，不用来实现数据传送和申请总线。</p>\r\n<p>DMA中断请求可以在每个机器周期介乎，而普通中断需要在每条指令执行后。</p>\r\n<p>初始化中断向量表由操作系统完成，找中断向量由隐指令硬件完成。</p>\r\n<p>CPU通过IO指令控制通道。通道在通道程序执行结束产生IO中断向CPU报告。\r\n程序中断和通道都是软硬件结合的方式</p>\r\n<p>设备独立性=设备无关性=用户程序独立于具体物理设备=使用逻辑设备号\r\n设备驱动程序：与硬件直接相关，隐藏同类设备的设备控制器之间的差异。\r\n虚拟设备是指把一个物理设备变换成多个逻辑设备，但不是指把独占设备改成共享设备。</p>\r\n<h2 id=\"操作系统\">操作系统</h2>\r\n<p>微内核比起单一大内核效率更低，因为需要频繁切换核心态和用户态，开销大。</p>\r\n<p>从操作系统内核空间读数据或指令是静态的，不需要保护。</p>\r\n<h3 id=\"进程管理\">进程管理</h3>\r\n<p>线程共享进程的虚拟地址空间，但每个线程有自己的栈空间。\r\n子进程不共享父进程的虚拟地址空间，仅共享一部分资源。创建子进程时会分配相关资源。</p>\r\n<p>进程打开定时器是需要保护的操作，否则可能修改时间片。</p>\r\n<p>设备分配不会创建新进程，只是设置对应数据结构。</p>\r\n<p>死锁处理 -\r\n死锁避免：银行家算法，在进程执行过程中动态规避可能导致死锁的分配。 -\r\n死锁预防：从根本上破坏死锁条件，使死锁不可能成立。如限制进程申请资源的顺序，给资源编号分配。\r\n- 死锁检测：啥都不管，真死锁了检测到了，就强行处理掉...</p>\r\n<h3 id=\"内存管理\">内存管理</h3>\r\n<p>地址变换时，可能因缺页、地址越界、内存保护发生中断，不会发生内存溢出。</p>\r\n<h3 id=\"文件系统\">文件系统</h3>\r\n<p>Open()系统调用打开文件，读入文件的控制管理信息。文件内容是在打开之后，需要使用文件的时候，再读入。\r\nFAT表是在挂载文件系统的时候就读入到系统了。\r\n超级快是系统自举用，启动系统时读入。</p>\r\n<p>逻辑记录是对文件进行存取的基本单位。</p>\r\n<p>索引文件的表项装的是记录<strong>逻辑地址</strong>，不是物理地址，因为索引文件是逻辑结构。</p>\r\n<p>对文件访问权限的管理，通常由用户访问权限+文件属性限制，注意和用户优先级无关。</p>\r\n<p>直接存取是介于随机存取和顺序存取（磁带）之间的方式，直接存取存储器，例如磁盘，一般也可以顺序访问，但是比较低效。</p>\r\n<p>磁盘调度算法中，不会导致磁臂黏着的只有FCFS，考虑同一个磁道不停地申请。</p>\r\n<p>磁盘初始化：物理/低级格式化：扇区+校验码————柱面分磁盘区————逻辑格式化：文件系统+空闲盘块数据结构</p>\r\n<h2 id=\"计网\">计网</h2>\r\n<p>虚电路分为永久性虚电路和交换型虚电路，所以不是所有虚电路都会在会话结束释放链接。</p>\r\n<p>网络线路吞吐量=单位时间内通过的数据量=发送bit/(发送时延+往返时延)</p>\r\n<p>OSI 网络层两种方式，传输层仅面向连接。 TCP/IP\r\n网络层无连接，传输层两种方式。</p>\r\n<p>交换机和路由器的线路，即没有主机的线路，也算交换机分割的一个冲突域。</p>\r\n<p>按照对等层通信原则，IP分组的重组由网络层完成，而排序则由传输层完成。</p>\r\n<p>端到端是指进程端口到进程端口，即TCP/IP传输层。\r\n点到点是网络节点到网络节点，数据链路层。</p>\r\n<p>计算信道最高数据传输率的时候，注意看清给的是信道频率还是信道带宽。两个公式要求的W都是带宽。例如给频率3.5~3.9MHz，带宽=3.9-3.5=0.4MHz</p>\r\n<h3 id=\"数据链路层\">数据链路层</h3>\r\n<p>CSMA/CD 冲突时间=往返时间，最小帧长=最大帧碎片长</p>\r\n<p>以太网冲突时间=2τ=51.2μs 10Mb/s以太网最小帧长=10Mb/s X\r\n51.2μs=512bit=64B</p>\r\n<p>连续ARQ包括两种：GBN和SR选择重传</p>\r\n<p>以太网最小数据长度46B，因此封装的IP数据包总长度字段要≥46</p>\r\n<p><strong>无线局域网</strong>\r\nCTS和ACK确认帧的IFS都是SIFS。RTS之前有DIFS。 帧格式地址：RA(BSSID)+SA+DA\r\n= 目的地接入站地址+ 源地址 + 目的地址</p>\r\n<h3 id=\"网络层\">网络层</h3>\r\n<p>ARP请求是广播的，ARP响应是单播的。作为对比，DHCP是四个广播：DHCP发现，DHCP提供，DHCP请求，DHCP确认。</p>\r\n<p>路由表中配置到互联网的路由即一般默认路由项：目的IP 0.0.0.0 + 子网掩码\r\n0.0.0.0 + 下一跳IP + 接口</p>\r\n<h3 id=\"传输层\">传输层</h3>\r\n<p>TCP连接时，默认只有第一个序号是消耗的，第三次握手的序号也可以用作数据传送。</p>\r\n<p>注意IP分片需要是8B整数倍，偏移量=x/8B</p>\r\n<h3 id=\"应用层\">应用层</h3>\r\n<p>HTTP 服务器是80端口，客户端不确定。</p>\r\n<p>WWW高速缓存将最近的一些请求和响应暂存在本地磁盘中，可以有效降低WWW延迟。</p>\r\n","tags":["杂记"]},{"title":"Attention Is All You Need","url":"/2021/12/23/AttentionIsAllYouNeed/","content":"<ul>\r\n<li>Vaswani A, Shazeer N, Parmar N, et al. Attention is all you\r\nneed[C]//Advances in neural information processing systems. 2017:\r\n5998-6008.</li>\r\n<li>Google</li>\r\n</ul>\r\n<h1 id=\"introduction\">Introduction</h1>\r\n<p>大名鼎鼎的Transformer，仅依赖于注意力机制，完全不使用RNN和CNN的序列模型</p>\r\n<p>RNN，LSTM，GNU是处理序列模型的几种最优方法。然而循环神经网络中总是沿着词元位置进行计算，这种<strong>顺序性阻碍了训练的并行化</strong>，这也严重影响了内存对batch的限制程度。</p>\r\n<p>注意力机制也是成功的模型中必不可少的一部分，其可以考虑到模型中的依赖关系。<strong>大部分情况下注意力都和RNN捆绑在了一起</strong>。</p>\r\n<p><strong>Transformer</strong>，完全避开了RNN，并且完全依赖注意力机制来抽取输入和输出的全局关系。并且能有更好的并行化。</p>\r\n<p>相关工作：</p>\r\n<ul>\r\n<li>Self-Attention：提取序列不同位置联系的一种方式，可以计算出一个序列的表示形式。</li>\r\n<li>End-to-end memory\r\n：基于循环注意力机制，而不是序列循环网络，在语言建模任务上有优秀表现。</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<h1 id=\"model-architecture\">Model Architecture</h1>\r\n<p>大部分序列转换模型都是 <strong>编码器-解码器</strong>\r\n框架。其中编码器将输入序列从离散的符号表示映射到一个连续表示<span\r\nclass=\"math inline\">\\(z\\)</span>。得到<span\r\nclass=\"math inline\">\\(z\\)</span>之后，解码器逐时间步去生成输出序列<span\r\nclass=\"math inline\">\\((y_1,....,y_m)\\)</span>。Transformer也是在这个大框架之下：</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/mLvciTv.jpg\" alt=\"Model Architecture\" />\r\n<figcaption aria-hidden=\"true\">Model Architecture</figcaption>\r\n</figure>\r\n<p><strong>编码器-解码器</strong>：</p>\r\n<ol type=\"1\">\r\n<li>编码器：主要模块由两个子层<strong>Multi-head\r\nself-attention</strong>和<strong>position-wise\r\n全连接</strong>构成，并且每个子层都是用了一个残差连接。</li>\r\n<li>解码器：增加了一个Masked层，用于处理编码器的输出。同样每层都是用了残差连接设计。另外修改了self-attention层防止前面的元素受到后面的元素的影响。<strong>这样对位置i的预测仅能依赖于位置小于i的编码器输出。</strong></li>\r\n</ol>\r\n<h2 id=\"attention\">Attention</h2>\r\n<h3 id=\"scaled-dot-product-attention\">Scaled Dot-Product Attention</h3>\r\n<figure>\r\n<img src=\"https://i.imgur.com/GIL399v.png\" alt=\"放缩点积注意力\" />\r\n<figcaption aria-hidden=\"true\">放缩点积注意力</figcaption>\r\n</figure>\r\n<p>两种最常用的注意力评分函数是 加性注意力 和\r\n点积注意力。点积由于矩阵计算的优化，计算上更加效率。然而在大批量上加性注意力效果往往能够超越点积注意力。论文认为这是因为在大批量下，<strong>点积结果会数量级膨胀，导致softmax达到一个梯度极小的区域</strong>，因此为了解决这种现象，提出了<strong>放缩的点积注意力</strong>。</p>\r\n<p><span class=\"math display\">\\[\r\na(\\mathbf{q}, \\mathbf{k})=\\mathbf{q}^{\\top}\\mathbf{k}/\\sqrt{d}\r\n\\]</span></p>\r\n<p>其中<span\r\nclass=\"math inline\">\\(d\\)</span>为向量长度（显然query和key需要相同长度）。</p>\r\n<h3 id=\"multi-head-attention\">Multi-Head Attention</h3>\r\n<figure>\r\n<img src=\"https://i.imgur.com/Pg1hq7H.png\" alt=\"多头注意力\" />\r\n<figcaption aria-hidden=\"true\">多头注意力</figcaption>\r\n</figure>\r\n<p>相比于在数据上使用单一的一个注意力机制，Multi-Head\r\nAttention可以联合多种方式学到的不同信息。其<strong>通过<span\r\nclass=\"math inline\">\\(h\\)</span>个可学习的线性变换将query，key，value分别进行线性投影到<span\r\nclass=\"math inline\">\\(h\\)</span>个空间的<span\r\nclass=\"math inline\">\\(d_k,d_k,d_v\\)</span>维度</strong>。再在这<span\r\nclass=\"math inline\">\\(h\\)</span>种数据上并行使用注意力机制，最终每个空间都得到<span\r\nclass=\"math inline\">\\(d_v\\)</span>维的output\r\nvalues。将它们都连接起来，并且再进行一次投影，生成最终的values：</p>\r\n<p><span class=\"math display\">\\[\r\nMultiHead(Q,K,V)=Concat(h_1,...,h_h)W^O \\\\\r\nwhere \\ h_i=Attention(QW_i^Q,KW_I^K,VW_I^V)\r\n\\]</span></p>\r\n<p>实践中使用了8个head，每个维度都相应的除以8进行降维：<span\r\nclass=\"math inline\">\\(d_k=d_k=d_{model}/8=64\\)</span>。因为由于每个head都降维了，因此实际总计算花费和一个单一的注意力机制差不多。</p>\r\n<h3 id=\"模型中attention的使用\">模型中Attention的使用</h3>\r\n<ul>\r\n<li>编码器-解码器：query来自解码器的上一个输出，key和value来自编码器的输出。这使得解码器中每个位置都能与输入序列的所有位置产生联系，这基本上是经典的编码器解码器注意力机制。</li>\r\n<li>编码器中的self-attention层：key，value，query都来自编码器的上一个输出。这样编码器中的每个位置都能和之前所有位置产生联系。</li>\r\n<li>解码器中的self-attention层：同样，让解码器中的每个位置能和之前(包括自己)的所有位置产生联系。另外解码器中还需要避免使用后方的信息，因此在放缩点积注意力的softmax之前，设置了一个mask来掩盖掉当前位置对后方位置的连接。</li>\r\n</ul>\r\n<h2 id=\"position-wise-feed-forward-networks\">Position-wise Feed-Forward\r\nNetworks</h2>\r\n<p>在注意力层之后使用了一个共享参数的全连接层(两个线性层+ReLU)，对每个位置单独进行变换(它们参数一样)：</p>\r\n<p><span class=\"math display\">\\[\r\nFFN(X)=max(0,xW_1+b_1)W_2+b_2\r\n\\]</span></p>\r\n<h2 id=\"positional-encoding\">Positional Encoding</h2>\r\n<p>由于没有使用卷积和循环框架，想要使用位置信息，则需要在embeddings的基础上与一个\r\n<strong>Positional encodings</strong>相加：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{split}\\begin{aligned} p_{pos, 2i} &amp;=\r\n\\sin\\left(\\frac{pos}{10000^{2i/d}}\\right),\\\\p_{pos, 2i+1} &amp;=\r\n\\cos\\left(\\frac{pos}{10000^{2i/d}}\\right).\\end{aligned}\\end{split}\r\n\\]</span></p>\r\n<p>其中pos是编码的位置，i是编码目标维度(类似于embedding后的维度)。每个维度<span\r\nclass=\"math inline\">\\(i\\)</span>都对应一种正弦波，显然沿着维度升高，正弦波的频率单调降低，波长单调升高。因此也可以知道，对较低的维度，特征重合大，并且变换频率快。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/pGRZDCv.png\"\r\nalt=\"编码正弦波示意图。Col表示编码的不同维度，Row表示不同的位置。同一维度下的位置信息在同一条正弦波上。同一位置的不同维度(即不同正弦波)计算出不同的值。\" />\r\n<figcaption\r\naria-hidden=\"true\">编码正弦波示意图。Col表示编码的不同维度，Row表示不同的位置。同一维度下的位置信息在同一条正弦波上。同一位置的不同维度(即不同正弦波)计算出不同的值。</figcaption>\r\n</figure>\r\n<p>并且这种positional encoding可以很好表示相对位置。对于同样的维度<span\r\nclass=\"math inline\">\\(2i,2i+1\\)</span>上，位置 <span\r\nclass=\"math inline\">\\(pos+\\delta\\)</span> 和位置 <span\r\nclass=\"math inline\">\\(pos\\)</span>\r\n之间是线性变换的关系。即<strong>通过线性变换，就可以把<span\r\nclass=\"math inline\">\\((p_{i, 2j}, p_{i, 2j+1})\\)</span>投影到<span\r\nclass=\"math inline\">\\((p_{i+\\delta, 2i}, p_{i+\\delta,\r\n2i+1})\\)</span></strong>。证明如下：令<span\r\nclass=\"math inline\">\\(\\omega_j = 1/10000^{2j/d}\\)</span></p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{split}\\begin{aligned}\r\n&amp;\\begin{bmatrix} \\cos(\\delta \\omega_j) &amp; \\sin(\\delta \\omega_j)\r\n\\\\  -\\sin(\\delta \\omega_j) &amp; \\cos(\\delta \\omega_j) \\\\ \\end{bmatrix}\r\n\\begin{bmatrix} p_{i, 2j} \\\\  p_{i, 2j+1} \\\\ \\end{bmatrix}\\\\\r\n=&amp;\\begin{bmatrix} \\cos(\\delta \\omega_j) \\sin(i \\omega_j) +\r\n\\sin(\\delta \\omega_j) \\cos(i \\omega_j) \\\\  -\\sin(\\delta \\omega_j) \\sin(i\r\n\\omega_j) + \\cos(\\delta \\omega_j) \\cos(i \\omega_j) \\\\ \\end{bmatrix}\\\\\r\n=&amp;\\begin{bmatrix} \\sin\\left((i+\\delta) \\omega_j\\right)\r\n\\\\  \\cos\\left((i+\\delta) \\omega_j\\right) \\\\ \\end{bmatrix}\\\\\r\n=&amp;\r\n\\begin{bmatrix} p_{i+\\delta, 2j} \\\\  p_{i+\\delta, 2j+1} \\\\\r\n\\end{bmatrix},\r\n\\end{aligned}\\end{split}\r\n\\]</span></p>\r\n<p>另外，虽然这种编码和positional\r\nembeddings效果差不多，<strong>但是正弦编码可以生成比训练数据更长的序列。</strong>\r\n(因为是直接定义式，没有需要学习的参数)</p>\r\n<h1 id=\"self-attention-优势\">Self-Attention 优势</h1>\r\n<p>从三个方面进行性能分析：<strong>计算复杂度</strong>，<strong>可并行操作数</strong>，<strong>长距离依赖路径长度</strong>(路径越短，学习到长距离依赖更容易)</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/nnxHIIj.png\"\r\nalt=\"不同特征抽取方式的性能分析。n为序列长度，d为数据表示维度，k为核大小，r为邻域大小\" />\r\n<figcaption\r\naria-hidden=\"true\">不同特征抽取方式的性能分析。n为序列长度，d为数据表示维度，k为核大小，r为邻域大小</figcaption>\r\n</figure>\r\n<p>在<span\r\nclass=\"math inline\">\\(n&lt;d\\)</span>时，self-attention计算复杂度优于RNN，并且实际中<span\r\nclass=\"math inline\">\\(n&lt;d\\)</span>是大多数情况。针对特别大的<span\r\nclass=\"math inline\">\\(n\\)</span>的情况，self-attention需要被限制在一个<span\r\nclass=\"math inline\">\\(r\\)</span>的邻域之中，但是这增加了长距离依赖路径长度，论文尚未解决。</p>\r\n<p><span\r\nclass=\"math inline\">\\(k&lt;n\\)</span>的卷积层不能连接所有的元素，因此需要<span\r\nclass=\"math inline\">\\(O(n/k)\\)</span>层连续卷积，或者<span\r\nclass=\"math inline\">\\(O(\\log_k\r\nn)\\)</span>的空洞卷积，也会导致依赖路径的变长。</p>\r\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"C++函数","url":"/2020/08/17/C++%E5%87%BD%E6%95%B0/","content":"<h2 id=\"局部静态对象\">局部静态对象</h2>\r\n<p>有些时候，我们需要保留一些对象在函数体结束后依然使用，定义时使用<code>static</code>将其声明为静态类型，直到程序终止才销毁。</p>\r\n<blockquote>\r\n<p>虽然在函数外没有销毁，但是其仍然是局部变量，外部不可访问，只不过其内存也不释放。</p>\r\n</blockquote>\r\n<p>局部静态变量如果没有显式的初始化值，将执行<strong>值初始化</strong>，内置类型的值初始化为0。</p>\r\n<p>一个简单的例子，这个程序会输出 1~10 的数字。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">count_calls</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">size_t</span> num=<span class=\"number\">0</span>;</span><br><span class=\"line\">    num++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"built_in\">count_calls</span>()&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"指针变量传递\">指针变量传递</h2>\r\n<p>指针变量作为参数和普通变量作为参数一样，都是值传递。即形参和实参是两个不同的指针变量，两个指针自己的地址不一样，但是它们的值一样——即它们指向的地址是一样的。因此可以通过传递指针修改实参。</p>\r\n<h2 id=\"const-参数\">const 参数</h2>\r\n<p>实参传给形参会忽略掉<strong>顶层const</strong>，即从函数外部看函数，我们不知道这个函数的参数究竟有没有顶层const，也因此<strong>不能通过顶层const来重载函数</strong>。例如：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn1</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> i)</span></span>&#123;···&#125;     <span class=\"comment\">//忽略顶层 const</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn1</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;···&#125;           <span class=\"comment\">//错误，重复定义</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn2</span><span class=\"params\">( <span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> i)</span></span>&#123;···&#125;  <span class=\"comment\">//忽略顶层 const</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn2</span><span class=\"params\">(<span class=\"keyword\">int</span> * i)</span></span>&#123;···&#125;         <span class=\"comment\">//错误，重复定义</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn3</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * i)</span></span>&#123;···&#125;   <span class=\"comment\">//这是底层 const，不会造成重复定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn3</span><span class=\"params\">(<span class=\"keyword\">int</span> * i)</span></span>&#123;···&#125;         <span class=\"comment\">//正确</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn4</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;i)</span></span>&#123;···&#125;    <span class=\"comment\">//正确，也类似于底层const，const int 算作一种独立类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn4</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;i)</span></span>&#123;···&#125;          <span class=\"comment\">//int优先匹配int&amp;，其次匹配const int&amp;。 const int只能匹配const int&amp;</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>顶层可以理解为离变量最近的一层，顶层 const\r\n修饰指针本身的值，即指向哪一个地址不能被修改，底层 const\r\n修饰指针指向的对象的值不能被修改。</p>\r\n</blockquote>\r\n<p>形参初始化和变量初始化一样，关于 const\r\n的要求都是可<strong>降格兼容，不能升格</strong>。即如上<code>int</code>可用于初始化<code>const int</code>变量，<code>const int</code>不能初始化<code>int</code>变量。引用和指针层面也是类似，<code>cont int</code>引用可绑定到<code>int</code>对象，<code>int</code>引用不可绑定到<code>const int</code>对象。</p>\r\n<p><strong>尽量使用常量引用</strong>。使用常量引用可以避免拷贝数据，同时阻止非必要的修改操作。另一方面由于外部的\r\nconst 类型不能升格传参给非 const 形参，容易发生类型匹配错误。而外部的非\r\nconst 类型可以传给 const 形参，因此使用 const\r\n引用，也可以有效减少这种类型错误的情况。</p>\r\n<h2 id=\"数组形参\">数组形参</h2>\r\n<p>数组有两个特殊性质，影响我们对数组的传参操作：</p>\r\n<ul>\r\n<li>数组不能进行拷贝</li>\r\n<li>使用数组时相当于使用指针</li>\r\n</ul>\r\n<p>所以我们不能值传递数组，但是我们可以通过指针进行传递，如下三个等价的传递数组的函数，看起来不一样，其实都是形参都是\r\nconst int*，导致重复定义：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//会互相造成重复定义错误</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * a)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> a[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> a[<span class=\"number\">10</span>])</span></span>;<span class=\"comment\">//这里数组大小只是一个期望大小，有没有完全一样，和没有的会造成重复定义。</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>但是正如示例所述，只传递指针的话，我们不知道传进来的数组有多大，因此可以通过别的途径传递长度信息：</p>\r\n<ul>\r\n<li>加一个length变量\r\n<code>void fcn(const int a[],int length);//用另一个变量标记长度</code></li>\r\n<li>取得尾后迭代器\r\n<code>void fcn(const int *begin,const int * end)//标准库规范做法，传递尾后元素，进行尾后检测</code></li>\r\n</ul>\r\n<h3 id=\"多维数组\">多维数组</h3>\r\n<p>我们知道多维数组其实就是一维数组，只不过数组元素是新数组指针而已。多维数组即看作指针的指针进行传递。如下，首先明确传参的只是一个指针，指向首元素，这个指针的类型是首元素类型。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn</span><span class=\"params\">(<span class=\"keyword\">int</span> (* matrix)[<span class=\"number\">10</span>])</span></span>;   <span class=\"comment\">//matrix 是一个指针，指向首元素类型为 int[10]</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn</span><span class=\"params\">(<span class=\"keyword\">int</span> matrix[][<span class=\"number\">10</span>])</span></span>;     <span class=\"comment\">//等价形式，前面示例知道 matrix[] 其实也是看作指针。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn</span><span class=\"params\">(<span class=\"keyword\">int</span> * matrix[<span class=\"number\">10</span>])</span>      <span class=\"comment\">//错误，这是一个一维数组，数组元素类型是 int*</span></span></span><br></pre></td></tr></table></figure>\r\n<p>注意，虽然上述传递一维数组会忽略数组大小，但是<strong>第二维及以上的数组大小算作一种数据类型</strong>，需要严格对应:</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn</span><span class=\"params\">(<span class=\"keyword\">int</span> a[][<span class=\"number\">2</span>])</span> <span class=\"comment\">// == int (*a) [2]  , != int *a[2]</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> b[<span class=\"number\">2</span>][<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">fcn</span>(b);<span class=\"comment\">//错误，int (*)[4] 和 int(*)[2] 类型的形参不兼容。a指向int [2],b指向int[4]。</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>另外注意 int ** 和 int (*) [10] 不是同一个类型。</p>\r\n</blockquote>\r\n<h2 id=\"变长形参\">变长形参</h2>\r\n<p>有时候我们不确定要传递几个实参给函数，因此 C++提供了两种方法。</p>\r\n<h3 id=\"initializer_list\">Initializer_list</h3>\r\n<p>Initializer_list\r\n是一个很简单的列表容器，有点像python的<code>*args</code>。</p>\r\n<ul>\r\n<li>形参使用<code>initializer_list&lt;T&gt;</code>来接受列表参数</li>\r\n<li>实参使用初始化列表传参<code>&#123;T1,T2,T3&#125;</code></li>\r\n<li>函数体内则和其他容器一样访问。</li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">error_msg</span><span class=\"params\">(<span class=\"keyword\">int</span> count,initializer_list&lt;string&gt; msg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> arg =msg.<span class=\"built_in\">begin</span>();arg!=msg.<span class=\"built_in\">end</span>();++arg)</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">error_msg</span>(<span class=\"number\">217</span>,&#123;<span class=\"string\">&quot;Hello&quot;</span>,<span class=\"string\">&quot;,&quot;</span>,<span class=\"string\">&quot;World&quot;</span>,<span class=\"string\">&quot;!&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"省略符\">省略符</h3>\r\n<p>省略符是为了兼容 C 而设置的。通常<strong>不建议在 C\r\n之外使用</strong>。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(parm_list,...)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(...)</span></span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"返回值\">返回值</h2>\r\n<h3 id=\"返回数组指针\">返回数组指针</h3>\r\n<p>函数返回一个普通指针很简单，返回值 <code>type *</code>\r\n即可，但是返回一个指向数组的指针呢？正常声明数组指针变量是<code>type (*var)[size]</code>\r\n： var是一个指针，指向一个大小为size的数组，数组元素类型是type。</p>\r\n<p>那么函数返回同理：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">type</span> (* <span class=\"built_in\">func</span>(param...)) [size]</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"decltype返回\">decltype返回</h3>\r\n<p>如果已知返回的是什么变量的类型，可以使用decltype来推断返回类型：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">decltype</span>(somevar) * <span class=\"built_in\">func</span>(<span class=\"keyword\">int</span> i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    retrun &amp;somevar;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"尾置返回\">尾置返回</h3>\r\n<p>C++11更方便的尾置返回，在返回复杂的东西时显得很方便，例如返回数组指针：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> -&gt; <span class=\"title\">int</span><span class=\"params\">(*)</span> [size]</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"函数指针\">函数指针</h2>\r\n<p>和普通类型的指针<code>type *</code>一样，把函数看作一种类型，可以定义函数指针如下，并且可以将函数名赋值给该指针，然后当做函数一样使用：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">func</span> <span class=\"params\">(string,string)</span></span>;<span class=\"comment\">//原函数</span></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">bool</span></span> (*p) (string,string);<span class=\"comment\">//定义该函数的指针,注意括号，没有括号则是一个叫做p的函数。</span></span><br><span class=\"line\"><span class=\"comment\">//两种赋值方式等价</span></span><br><span class=\"line\">p=<span class=\"number\">0</span>; <span class=\"comment\">//0不指向任何函数</span></span><br><span class=\"line\">p=func;</span><br><span class=\"line\">p=&amp;func;</span><br><span class=\"line\"><span class=\"comment\">//两种调用方式等价</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> a=<span class=\"built_in\">p</span>(str1,str2);</span><br><span class=\"line\"><span class=\"keyword\">bool</span> b=(*p)(str1,str2);</span><br></pre></td></tr></table></figure>\r\n<p>拥有了指针，自然也能将函数指针作为 函数参数 和 函数返回值 使用。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//两种形参方式等价，自动将函数类型转为函数指针</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">bool</span> p(string,string))</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">bool</span> (*p)(string,string))</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//两种传参方式等价，自动将函数类型转为函数指针</span></span><br><span class=\"line\"><span class=\"built_in\">f</span>(func);</span><br><span class=\"line\"><span class=\"built_in\">f</span>(p);</span><br><span class=\"line\"><span class=\"comment\">//注意在作为返回值时，函数名不会自动转为函数指针</span></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">bool</span></span> (*<span class=\"built_in\">f</span>(<span class=\"keyword\">int</span> a)) (string,string); <span class=\"comment\">//f(int a)是一个函数，它返回一个指针，这个指针指向函数 bool func (string,string)。</span></span><br></pre></td></tr></table></figure>\r\n<p>显然上述的函数指针形式很繁琐，因此可以利用<code>typedef</code>和<code>decltype</code>等改名工具来简化：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//两种改名方式等价</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">bool</span> <span class=\"title\">f2</span><span class=\"params\">(string,string)</span></span>;<span class=\"comment\">//f2类型==func类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">decltype</span><span class=\"params\">(func)</span> f3</span>;     <span class=\"comment\">//f3类型==func类型</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> f4=<span class=\"built_in\"><span class=\"keyword\">bool</span></span> (string,string)  <span class=\"comment\">//f4类型==func类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\"><span class=\"keyword\">bool</span></span> (*p2)(string,string);  <span class=\"comment\">//p2类型==p类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">decltype</span><span class=\"params\">(func)</span> *p3</span>;         <span class=\"comment\">//p3类型==p类型</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> p4=<span class=\"built_in\"><span class=\"keyword\">bool</span></span> (*) (string,string)   <span class=\"comment\">//p4类型==p类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数指针作为参数。两种方式等价，因为函数类型自动转换为函数指针类型</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">f</span>(f3 afunc);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(p3 apoint)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//作为返回值时不等价。</span></span><br><span class=\"line\"><span class=\"function\">p3 <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>;<span class=\"comment\">//f(int a)是一个函数，返回p3类型，即指向func的函数指针类型。</span></span><br><span class=\"line\"><span class=\"function\">f3 <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>;<span class=\"comment\">//错误，不能将函数类型作为返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span> -&gt; <span class=\"title\">bool</span> <span class=\"params\">(*)</span> <span class=\"params\">(string,string)</span></span>;<span class=\"comment\">//后置返回语法</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p><strong>类型别名</strong> 不是\r\n<strong>变量名</strong>，上述代码没有创建一个f3变量或者一个p3变量，应当看作类型名去使用。</p>\r\n</blockquote>\r\n<h1 id=\"参考资料\">参考资料</h1>\r\n<p>C++ Primer 5 edition 中文版</p>\r\n","categories":["基础"],"tags":["cpp"]},{"title":"C++派生类构造函数初始化顺序问题","url":"/2020/05/15/C++%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/","content":"<p>众所周知，派生类构造时先会初始化构造基类，然后构造自身。</p>\r\n<h2 id=\"派生类私有成员-和-基类-同时初始化\">派生类私有成员 和 基类\r\n同时初始化</h2>\r\n<p>假如派生类的构造函数，初始化时显式初始化基类，同时显式初始化派生类成员，那么先后顺序是怎样的呢？\r\n测试背景：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"built_in\">base</span>(<span class=\"keyword\">int</span> i) :<span class=\"built_in\">x</span>(i) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispb</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">  cout &lt;&lt; <span class=\"string\">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; <span class=\"string\">&quot;base</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">derived</span> :</span> <span class=\"keyword\">public</span> base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"keyword\">int</span> a=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"built_in\">derived</span>(<span class=\"keyword\">int</span> i) :<span class=\"built_in\">a</span>(i), <span class=\"built_in\">base</span>(a) &#123;  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispd</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">  cout &lt;&lt; <span class=\"string\">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; <span class=\"string\">&quot;derived</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> <span class=\"function\">derived <span class=\"title\">obj</span><span class=\"params\">(<span class=\"number\">8</span>)</span></span>;</span><br><span class=\"line\"> base*p =&amp;obj;</span><br><span class=\"line\"> p-&gt;<span class=\"built_in\">dispb</span>();</span><br><span class=\"line\"> <span class=\"built_in\">system</span>(<span class=\"string\">&quot;PAUSE&quot;</span>);</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>如上，派生类Derived构造时，基类初始化base(a)，用了派生类私有成员a，同时a也被参数i初始化。此时因为基类初始化在a初始化之前，传给base（）的a是随机值。输出结果是：</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/8kIskTc.png\" alt=\"x!=i\" />\r\n<figcaption aria-hidden=\"true\">x!=i</figcaption>\r\n</figure>\r\n<p>所以我们可以知道，即使是初始化列表里，即使a的初始化排在前面，也一定是先初始化基类base，再调用派生类私有成员的初始化。</p>\r\n<blockquote>\r\n<p>想要正常构造，把base（a)改成base（i）即可。</p>\r\n</blockquote>\r\n<h2\r\nid=\"派生类初始化私有成员基类在函数体内构造\">派生类初始化私有成员，基类在函数体内构造</h2>\r\n<p><strong>假如派生类的构造函数是这样的</strong>：初始化私有成员，体内构造基类</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">derived</span>(<span class=\"keyword\">int</span> i) :<span class=\"built_in\">a</span>(i) &#123; <span class=\"built_in\">base</span>(i); &#125;</span><br></pre></td></tr></table></figure>\r\n<p>会提示类base不存在默认构造函数。</p>\r\n<p>我们可以得知，在派生类构造函数中，假如初始化了自己的变量成员，则会自动先调用基类构造，再对派生类的成员进行初始化，上例因为base没有无参数的默认构造函数所以报错。</p>\r\n<p><strong>假如基类有无参数的构造函数呢？</strong>讲道理会是先调用基类默认构造，再初始化a，再调用base(i)，是这样吗？增加一个无参数的基类构造函数：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">base</span>() &#123; cout &lt;&lt;<span class=\"string\">&quot;This is base()&quot;</span>&lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class=\"line\">.....</span><br><span class=\"line\"><span class=\"built_in\">derived</span>(<span class=\"keyword\">int</span> i) :<span class=\"built_in\">a</span>(i) &#123; <span class=\"built_in\">base</span>(i); &#125;</span><br></pre></td></tr></table></figure>\r\n<p>报错：形参 i 重定义——明明只声明了一次 i\r\n，怎么就重定义了呢？把a(i)删去？还是报错重定义</p>\r\n<p>——<a\r\nhref=\"https://segmentfault.com/q/1010000014553913\">搜了一下类似问题，发现题解</a>，对base（i)在里面的时候：“此时编译器会把它解析成变量声明，由此局部变量i与函数参数重名。根据语法，它可以被解释成函数式显式类型转换或者声明，存在二义性。标准约定将其解释成声明。”</p>\r\n<p><strong>这里面存在 声明 语句 定义 等根本性语法的规则定义=\r\n=</strong>具体了解得看其他详细资料，不过我们知道了报错是因为在 base(i)\r\n中，i被当成了新的局部变量，和外面的函数参数重定义冲突。</p>\r\n<p>i 冲突那我不用 i\r\n了，我用base（a)可以吧？a是被初始化的变量拿去赋值没问题吧？</p>\r\n<p>派生类构造函数改成：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">base</span>(<span class=\"keyword\">int</span> i) :<span class=\"built_in\">x</span>(i) &#123; cout &lt;&lt;<span class=\"string\">&quot;base(int i): &quot;</span>&lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class=\"line\"><span class=\"built_in\">base</span>() &#123; cout &lt;&lt;<span class=\"string\">&quot;This is base()&quot;</span>&lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"built_in\">derived</span>(<span class=\"keyword\">int</span> i)：<span class=\"built_in\">a</span>(i)&#123; cout &lt;&lt; <span class=\"string\">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl; <span class=\"built_in\">base</span>(a); &#125;</span><br></pre></td></tr></table></figure>\r\n<p>derived(8)运行，猜猜运行结果是什么？</p>\r\n<p>我们知道初始化a时，先会调用base（），然后初始化a，然后进入函数体内输出a值，然后a传参给base（int\r\ni），Really？</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/ZfXu4sR.png\" alt=\"运行结果\" />\r\n<figcaption aria-hidden=\"true\">运行结果</figcaption>\r\n</figure>\r\n","categories":["基础"]},{"title":"CaSPR","url":"/2022/03/06/CaSPR/","content":"<ul>\r\n<li>Rempe D, Birdal T, Zhao Y, et al. Caspr: Learning canonical\r\nspatiotemporal point cloud representations[J]. Advances in neural\r\ninformation processing systems, 2020, 33: 13688-13701.</li>\r\n<li>Stanford</li>\r\n</ul>\r\n<p>过去有一些工作做了动态点云的时间学习, 然而这些工作有一个致命限制:\r\n它们缺少时间连续性、鲁棒性、同类泛化性。有一些工作考虑了其中某一个方面,\r\n但没有对这三者整体进行统一的要求。</p>\r\n<p>Canonical Spatiotemporal Point Cloud Representations\r\n(CaSPR)致力于对3D形状的时空变化进行编码。</p>\r\n<ol type=\"1\">\r\n<li>将输入的点云序列规范化到一个共享的4D container空间:\r\n其先构建了坐标空间Normalized Object Coordinate Space (NOCS) [63],\r\n它能把同类中的一些外在属性引如位置、朝向和放缩程度给规范化。进一步的,\r\nCaSPR将NOCS扩展到4D <strong>Temporal-NOCS(T-NOCS)</strong>,\r\n额外将点云序列的持续时间归一化成一个单位时间。对于给定的点云序列,\r\n最终规范化后会给出在<strong>时间和空间</strong>上都规范化的点云。</li>\r\n<li>然后在规范化空间中学习连续的时空特征: 其使用了Neural Ordinary\r\nDifferential Equations (Neural ODEs) [9]。</li>\r\n</ol>\r\n<span id=\"more\"></span>\r\n<h1 id=\"规范化网络-tpointnet\">规范化网络 TPointNet++</h1>\r\n<p>在规范化的同时, 希望保留以下特性:</p>\r\n<ol type=\"1\">\r\n<li>避免时空邻域的搜索</li>\r\n<li>将时间视为和空间维度同等重要的一个维度</li>\r\n<li>将物体的时间特征加入到其局部结构的特征中</li>\r\n</ol>\r\n<figure>\r\n<img src=\"https://i.imgur.com/Kii5i5S.png\" alt=\"TPointNet\" />\r\n<figcaption aria-hidden=\"true\">TPointNet</figcaption>\r\n</figure>\r\n<p>其采用了双流的设计, 最终输出每个点的1600维embedding。</p>\r\n<ol type=\"1\">\r\n<li>PointNet: 将4D的点云序列(时间作为一个标签)视为一个整体,\r\n抽取出1024维的全局特征, 和64维的逐点特征。</li>\r\n<li>PointNet++: 对4D的每个点(不输入时间标签)计算局部结构特征,\r\n最终每个点输出512维特征。</li>\r\n</ol>\r\n<h1 id=\"后续求解使用-latent-ode-求解器-略\">后续求解使用 Latent ODE\r\n求解器 (略)</h1>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[9] Chen, T.Q., Rubanova, Y., Bettencourt, J., Duvenaud, D.K.: Neural\r\nordinary differential equations. In: Proceedings of the Advances in\r\nNeural Information Processing Systems (NeurIPS) (2018)</p>\r\n<p>[63] Sridhar, S., Rempe, D., Valentin, J., Bouaziz, S., Guibas, L.J.:\r\nMultiview aggregation for learning category-specific shape\r\nreconstruction. In: Proceedings of the Advances in Neural Information\r\nProcessing Systems (NeurIPS) (2019)</p>\r\n","categories":["深度学习"],"tags":["深度学习","点云"]},{"title":"C++构造函数初始化列表","url":"/2020/08/05/C++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/","content":"<h1 id=\"语法\">语法</h1>\r\n<p>在构造函数的（）之后，冒号开头，逗号分隔，括号传参，这一段就是初始化列表，随后是在{}里写构造函数内容。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Example</span>(argv):<span class=\"built_in\">a</span>(<span class=\"number\">1</span>),<span class=\"built_in\">b</span>(<span class=\"number\">2</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"初始化作用\">初始化作用</h1>\r\n<h2\r\nid=\"无法赋值的成员必须使用初始化列表进行初始化\">无法赋值的成员，必须使用初始化列表进行初始化</h2>\r\n<p>例如假设有个类成员，它本身是个没有默认构造函数的类。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CMember</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">CMember</span>(<span class=\"keyword\">int</span> x)&#123;···&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>我们都知道此时<code>CMember* pm=new CMember;</code>是错误的，必须调用有参数的构造函数。</p>\r\n<p>此时 CMember 是另一个类的成员时，我们怎么初始化呢？</p>\r\n<p><span id=\"more\"></span></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CMyClass</span> &#123;</span> </span><br><span class=\"line\">CMember m_member; </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>: </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">CMyClass</span>(); </span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//必须使用成员初始化列表 </span></span><br><span class=\"line\">CMyClass::<span class=\"built_in\">CMyClass</span>() : <span class=\"built_in\">m_member</span>(<span class=\"number\">2</span>) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">...</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\r\n<p>因为 m_member 不存在默认构造函数，所以不能在构造函数里\r\n默认初始化后再对其赋值，<strong>只能使用初始化列表的方式</strong>。</p>\r\n<p>常量对象和引用对象也是一样，只能被初始化。</p>\r\n<h2 id=\"效率相关\">效率相关</h2>\r\n<p>和上例类似，假如 CMember 存在默认构造函数呢？那我们是可以在 CMyClass\r\n函数体内对其赋值的。</p>\r\n<p>但是此时编译过程是————先调用 CMember\r\n的默认构造函数，再调用拷贝构造函数，即需两次函数运算。</p>\r\n<p>而假如是初始化列表，则直接调用相应的带参数的构造函数。</p>\r\n","categories":["基础"],"tags":["cpp"]},{"title":"ExternalAttention","url":"/2022/03/08/ExternalAttention/","content":"<ul>\r\n<li>Guo M H, Liu Z N, Mu T J, et al. Beyond self-attention: External\r\nattention using two linear layers for visual tasks[J]. arXiv preprint\r\narXiv:2105.02358, 2021.</li>\r\n<li>清华</li>\r\n</ul>\r\n<p>自注意力机制在同一个样本内,\r\n任意一个部位的特征都可以聚合所有位置的特征进行加权输出。但是自注意力拥有<strong>二次复杂度</strong>,\r\n并且<strong>不能计算多个样本之间的潜在联系</strong>。</p>\r\n<p>External-Attention(EAT) 希望在学习某个数据集时,\r\n能够找到多个样本之间的潜在联系。其通过保持一定的<strong>key\r\nmemory</strong>,\r\n以找到跨越所有样本的最具有辨识性的特征。这种思想类似于sparse coding 和\r\ndictionary learning。并且由于key memory设计的很小,\r\n因此EAT计算上具有O(n)的复杂度,\r\n比起自注意力<strong>高效</strong>很多。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/gVuVX87.png\" alt=\"external attention\" />\r\n<figcaption aria-hidden=\"true\">external attention</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h1 id=\"external-attention-eat\">External Attention (EAT)</h1>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nA&amp;=(\\alpha_{i,j})=Norm(FM_k^T)\\\\\r\nF_{out}&amp;=AM_v\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(F \\in \\mathbb{R}^{N \\times d}\\)</span>,\r\n其中<span class=\"math inline\">\\(M \\in \\mathbb{R}^{S \\times\r\nd}\\)</span>是一个独立于所有的输入特征进行学习的单元,即贯穿整个数据集的一个记忆模块,\r\n实践中使用了两个不同的单元 <span class=\"math inline\">\\(M_k\\)</span> 和\r\n<span class=\"math inline\">\\(M_v\\)</span> 来增强效果。<span\r\nclass=\"math inline\">\\(\\alpha_{i,j}\\)</span> 用于衡量第i个词元与<span\r\nclass=\"math inline\">\\(M\\)</span>中第j行记忆特征的关系。</p>\r\n<p><strong>Normalization</strong>: 在自注意力中attention\r\nmap是由余弦相似度的组成的一维向量,\r\n因此可以使用Softmax来进行权重归一化。EAT中假如把图像的每个像素看作一个词元,\r\n那么这个图像的attention map就是一个二维矩阵,\r\n因此使用了二维的softmax来进行归一化, 即double-normalization(2021,\r\nPCT):</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n(\\tilde{\\alpha})_{i, j} &amp;=F M_{k}^{T} \\\\\r\n\\hat{\\alpha}_{i, j} &amp;=\\exp \\left(\\tilde{\\alpha}_{i, j}\\right) /\r\n\\sum_{k} \\exp \\left(\\tilde{\\alpha}_{k, j}\\right) \\\\\r\n\\alpha_{i, j} &amp;=\\hat{\\alpha}_{i, j} / \\sum_{k} \\hat{\\alpha}_{i, k}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><strong>Multi-head</strong>:\r\n自注意力中常用多头机制来增强多视角的学习能力, 因此EAT中改造如下:</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nh_i&amp;=ExternalAttention(F_i,M_k,M_v) \\\\\r\nF_out&amp;=MultiHead(h,M_k,M_v) \\\\\r\n&amp;=Concat(h_1,...h_H)W_o\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(h_i\\)</span> 为每个头计算的注意力输出,\r\n<span class=\"math inline\">\\(W_o\\)</span>是用于使维度一致的线性层。<span\r\nclass=\"math inline\">\\(M\\)</span>为在多个头之间共享权重的memory单元。</p>\r\n<h1 id=\"效果\">效果</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/Uui5znz.png\" alt=\"Modelnet40\" />\r\n<figcaption aria-hidden=\"true\">Modelnet40</figcaption>\r\n</figure>\r\n","categories":["深度学习"],"tags":["深度学习","点云"]},{"title":"DDGCN","url":"/2021/12/30/DDGCN/","content":"<p>DDGCN: A Dynamic Directed Graph Convolutional Network for Action\r\nRecognition</p>\r\n<ul>\r\n<li>Korban M, Li X. Ddgcn: A dynamic directed graph convolutional\r\nnetwork for action recognition[C]//European Conference on Computer\r\nVision. Springer, Cham, 2020: 761-776.</li>\r\n<li>University of Virginia</li>\r\n</ul>\r\n<h1 id=\"introduction\">Introduction</h1>\r\n<p>之前的时空图网络(ST\r\ngraph)有着以下两点局限性：第一，人体骨架确实有时空联系性，但是这种联系在不同的人体动作下是不一样的。因此怎么有效地提取这种联系是困难的。传统的GCN卷积方法是静态的，无法描述动态时空结构。第二，骨架的空间层级结构和动作的时间序列结构都包含了顺序信息，然而大多数ST\r\ngraph都是用了无向图结构，即无视了顺序信息。</p>\r\n<p>DDGCN提出用于自适应学习时空关系和动作的时空顺序信息。</p>\r\n<ul>\r\n<li>Dynamic Convolutional Sampling (DCS)</li>\r\n<li>Dynamic Convolutional Weights (DCW)</li>\r\n<li>Directed Spatial-Temporal Graph (DSTG) Features</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<h2 id=\"related-work\">Related Work</h2>\r\n<p>Action recognition algorithms can be classi\fed based on data\r\nmodalities they run on. The majority of action recognition methods model\r\nactions on image sequence directly. Accordingly, they have developed\r\nvarious strategies based on handcrafted features [31, 26, 15],\r\nConvolutional Neural Network (CNN) [2, 9, 27], or Generative Adversarial\r\nNetwork (GAN) [14, 25, 29] to perform action recog- nition. However,\r\nusing only appearance modality such as RGB images has its limitations\r\nincluding high inference of background, high dimensional inputs, sen-\r\nsitivity to image transformations, and low expressive capability.</p>\r\n<h2 id=\"overview\">Overview</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/i9ofGUn.png\" alt=\"Overview\" />\r\n<figcaption aria-hidden=\"true\">Overview</figcaption>\r\n</figure>\r\n<p>对于输入的动作序列X，先构造出时空图<span\r\nclass=\"math inline\">\\(G_{ST}\\)</span>来构建时间关系。然后通过多个Dynamic\r\nDirected Convolutional (DDC)来抽取特征。</p>\r\n<h2 id=\"dynamic-convolutional-sampling-dcs\">Dynamic Convolutional\r\nSampling (DCS)</h2>\r\n<p>首先对于帧<span\r\nclass=\"math inline\">\\(G_0\\)</span>，DCS会尝试对每个点找出其邻居<span\r\nclass=\"math inline\">\\(p_i(B(v_i))\\)</span>(包含邻接点和非邻接相关点)：</p>\r\n<ol type=\"1\">\r\n<li>先用<span\r\nclass=\"math inline\">\\(G_0\\)</span>中的邻接点对邻居列表进行初始化，然后通过DCS来逐渐包含那些非邻接的相关点</li>\r\n<li>初始化邻域：创建一个有序的邻域点集<span\r\nclass=\"math inline\">\\(O_i\\)</span>：将所有节点按到<span\r\nclass=\"math inline\">\\(v_i\\)</span>的图距离排序存放，然后从<span\r\nclass=\"math inline\">\\(O_i\\)</span>中拿出前<span\r\nclass=\"math inline\">\\(r\\)</span>个节点作为这个点的邻域<span\r\nclass=\"math inline\">\\(p_i(B(v_i))\\)</span>。</li>\r\n<li>更新邻域<span class=\"math inline\">\\(p_i\\)</span>：通过学习一个index\r\nshift <span class=\"math inline\">\\(\\Delta p_i\\)</span>\r\n，相当于对邻域进行一个动态的排序，重新找前几个相关节点。</li>\r\n</ol>\r\n<p>最终在邻域上通过图卷积聚合生成特征：</p>\r\n<p><span class=\"math display\">\\[\r\nf_{S T}\\left(v_{i}\\right)=\\sum_{v_{j} \\in B\\left(v_{i}\\right)}\r\nw\\left(v_{i}\\right) \\cdot\\left(p_{i}\\left(v_{j}\\right)+\\Delta\r\np_{i}\\left(v_{j}\\right)\\right),\r\n\\]</span></p>\r\n<h2 id=\"dynamic-convolutional-weights-dcw\">Dynamic Convolutional Weights\r\n(DCW)</h2>\r\n<p>图像的卷积都是空间有序的，卷积核的权重学习也是按照同样的固定顺序。然而图像上卷积是无序的，且邻域数量不确定，因此DCW用于将图卷积自适应的有序化。</p>\r\n<p>给定卷积权重<span class=\"math inline\">\\(W=\\{w_i \\in\r\nR^3,i=1,...,r\\}\\)</span>，目标是将<span\r\nclass=\"math inline\">\\(w_i\\)</span>动态分配给相应的节点<span\r\nclass=\"math inline\">\\(v_i\\)</span>：计算一个 rx2 的矩阵<span\r\nclass=\"math inline\">\\(P_v=DTW_{path}(W,B(v))\\)</span>，其最小化<span\r\nclass=\"math inline\">\\(B(v)\\)</span>和排序后的<span\r\nclass=\"math inline\">\\(W\\)</span>的DTW距离。</p>\r\n<blockquote>\r\n<p>Dynamic Time Warping (DTW) [1] 动态时间规整算法:\r\n衡量两个时间序列的相似度的方法。因为表达同一个意义的两个序列，时间长度可能不一致。</p>\r\n</blockquote>\r\n<h2 id=\"directed-spatial-temporal-graph-dstg\">Directed Spatial-Temporal\r\nGraph (DSTG)</h2>\r\n<p><strong>有向空间图</strong>：从root开始广度优先搜索，生成骨架的有向图。在运动时，父节点的动作往往会影响子节点的动作，即子节点是关联于父节点的。可以将节点之间的边定义为bone，那么bone\r\nfeatures即<span\r\nclass=\"math inline\">\\(f_i^B=\\overrightarrow{v_{i-1}v_i}=f_{i-1}-f_i\\)</span>,其中<span\r\nclass=\"math inline\">\\(f_i\\)</span>表示节点<span\r\nclass=\"math inline\">\\(v_i\\)</span>的特征向量。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/VzzvInI.png\" alt=\"骨架图\" />\r\n<figcaption aria-hidden=\"true\">骨架图</figcaption>\r\n</figure>\r\n<p><strong>有向时间图</strong>：即将节点与其在上一帧对应节点连接起来。temporal\r\nfeatures <span\r\nclass=\"math inline\">\\(f_i^T=f_{i}^t-f_{i-1}^{t-1}\\)</span></p>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[1] Berndt, D.J., Cli\u000bord, J.: Using dynamic time warping to \fnd\r\npatterns in time series. In: KDD workshop. vol. 10, pp. 359{370.\r\nSeattle, WA (1994)</p>\r\n","categories":["深度学习"],"tags":["深度学习","序列学习"]},{"title":"C#细节","url":"/2023/05/09/Csharp%E7%BB%86%E8%8A%82/","content":"<h1 id=\"机制\">机制</h1>\r\n<h2 id=\"委托\">委托</h2>\r\n<p>委托类似于函数指针：</p>\r\n<figure class=\"highlight cs\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义委托类型 / 定义函数指针类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">MyDelegateType</span>(<span class=\"params\"><span class=\"built_in\">int</span> a</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//根据类型创建实例对象</span></span><br><span class=\"line\">MyDelegateType my_delegate_instance=<span class=\"keyword\">new</span> ();</span><br><span class=\"line\"><span class=\"comment\">//注册指向函数</span></span><br><span class=\"line\">my_delegate_instance+=Func1;</span><br><span class=\"line\">my_delegate_instance+=Func2;</span><br><span class=\"line\">my_delegate_instance+=Func3;</span><br><span class=\"line\"><span class=\"comment\">//删除函数</span></span><br><span class=\"line\">my_delegate_instance-=Func3;</span><br><span class=\"line\"><span class=\"comment\">//唤醒函数</span></span><br><span class=\"line\">my_delegate_instance.Invoke(int_variable);</span><br><span class=\"line\">my_delegate_instance(int_variable);</span><br></pre></td></tr></table></figure>\r\n<p>在我们定义委托类型时，本质上编译器会生成一个继承自标准库的类，如下所示。这个类实际上会形成一个委托的闭包，其会包含调用所需的所有信息，如调用实例、待调用方法的位置。</p>\r\n<figure class=\"highlight cs\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">MyDelegateType</span> :<span class=\"title\">System.MulticastDelegate</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//一些继承的重要字段</span></span><br><span class=\"line\">    <span class=\"keyword\">internal</span> Object _target;<span class=\"comment\">//当委托注册了实例方法时，这个字段会填充实例对象，以便调用实例方法。</span></span><br><span class=\"line\">    <span class=\"keyword\">internal</span> IntPtr _methodPtr;<span class=\"comment\">//指针，单播时使用，指向那个注册的方法。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object   _invocationList;<span class=\"comment\">//方法链，多播时使用，指向多个单播委托实例。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//唤醒操作</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Invoke</span>(<span class=\"params\"><span class=\"built_in\">int</span> a</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">//...其余字段和方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>对于单播委托，其会在<code>_methodPtr</code>中直接存储方法地址。然而正如上文所示，一个委托可以注册多个方法。实际上在注册多个方法后，C#会生成一个独立的委托实例，用来指向多个单播委托：</p>\r\n<span id=\"more\"></span>\r\n<figure>\r\n<img src=\"delegate.png\"\r\nalt=\"多播委托指向多个单播委托。每个单播委托才指向每个注册方法\" />\r\n<figcaption\r\naria-hidden=\"true\">多播委托指向多个单播委托。每个单播委托才指向每个注册方法</figcaption>\r\n</figure>\r\n<p>注意，<strong>每次</strong>注册方法<code>+=</code>，都会new一个新的多播实例，并且原有的多播实例会被废弃，等待垃圾回收。如上图中，如果再注册一个函数<code>Func3</code>，多播委托A会被丢弃，然后会新new一个多播委托B，并指向三个单播委托实例。</p>\r\n<p>另外在多播委托中，委托链的执行是顺序的，因此如果有一个抛出异常则会终止后续调用。</p>\r\n<h1 id=\"标准类型\">标准类型</h1>\r\n<p><a href=\"https://source.dot.net/\">源码链接</a></p>\r\n<h2 id=\"string\">string</h2>\r\n<p><strong>不可变</strong>的<strong>引用</strong>类型。注意字符串对象初始化之后就不会再修改，所有的修改操作都会new一个新的字符串对象，例如<code>str1+str2</code>。</p>\r\n<p>因此如果要构造变化的字符串，应该使用<code>System.Text.StringBuilder</code>。这是一个类似于<code>List&lt;char&gt;</code>的简单类，内部字段为<code>char[]</code>，其所有修改都是基于同一个对象的引用上。</p>\r\n<ul>\r\n<li>对于字面值字符串，编译器会不重复地写入到模块元数据中，以便复用，即<strong>字符串池</strong>。</li>\r\n<li>注意C#内char类型为2字节的Unicode码，而string的字节长度取决于你用的解码方式，例如默认UTF-8编码英文每字符1字节，中文每字符2字节。而UTF-16/Unicode编码内中英文都是每字符2字节。</li>\r\n<li>System.Object默认实现一个<code>ToString()</code>，返回当前对象的真实类型名称。</li>\r\n</ul>\r\n<h2 id=\"list\">List</h2>\r\n<p>底层为动态2倍扩容的数组。</p>\r\n<ul>\r\n<li>由于扩容会频繁new数组，因此尽量在初始化时给定好一个合适的大小，减少扩容。</li>\r\n<li>增删操作Insert和Remove底层都会使用Array.Copy进行数组移动，没有什么特别优化，因此每次增删复杂度为O(N)。</li>\r\n<li>ToArray会new一个新的数组返回，而不是直接获取内部数组，因此会造成额外的内存分配。</li>\r\n<li>Find为线性查找，Sort为快速排序。</li>\r\n</ul>\r\n<blockquote>\r\n<p>衍生: LinkedList 是双向链表。\r\nSortedList&lt;TKey,TValue&gt;通过拆分key和value两个数组来维持有序结构。\r\nQueue 数组 + 队头队尾指针维护而成的队列。</p>\r\n</blockquote>\r\n<h2 id=\"dictionary\">Dictionary</h2>\r\n<p>底层为<code>int[]? _buckets</code>和<code>Entry[] _entries</code>双数组的Hash结构，是旧的Hashtable的泛型版本。</p>\r\n<ul>\r\n<li><code>GetHashCode()</code>的默认实现：引用实例用<strong>内存地址当做Key</strong>计算Hash值，而值实例使用<strong>字段值来当做key</strong>。</li>\r\n<li>Hash值冲突时使用了拉链法解决。</li>\r\n<li>动态扩容与List类似，但是每次容量x2后会进一步选择一个贴近的素数。</li>\r\n<li>Remove只会重置目标条目，不会像List一样有数据移动。</li>\r\n<li>使用值作为Key比实例更快，因为不需要去计算内存地址。</li>\r\n</ul>\r\n<blockquote>\r\n<p>衍生： HashSet Value和Key合体的Dictionary。 SortedSet\r\n红黑树存储的有序HashSet。 SortedDictionary 红黑树存储的有序字典。</p>\r\n</blockquote>\r\n<h2 id=\"priorityqueue\">PriorityQueue</h2>\r\n<p>底层为数组表示的D叉最小堆\r\n<code>(TElement, TPriority)[] _nodes;</code></p>\r\n<ul>\r\n<li>插入时从底层往上冒泡插入 (和大学实现一样 hhh。</li>\r\n<li>删除时弹出堆顶，并由上往下逐层更新。</li>\r\n<li>仅.NET 6以上可用，像Unity内就用不了。</li>\r\n</ul>\r\n","categories":["基础"],"tags":["c#"]},{"title":"GeometryMotion-Net","url":"/2022/02/24/GeometryMotion-Net/","content":"<ul>\r\n<li>Liu J, Xu D. GeometryMotion-Net: A strong two-stream baseline for 3D\r\naction recognition[J]. IEEE Transactions on Circuits and Systems for\r\nVideo Technology, 2021, 31(12): 4711-4721.</li>\r\n<li>北航计算机</li>\r\n<li>中科院二区</li>\r\n</ul>\r\n<h1 id=\"introduction\">Introduction</h1>\r\n<p>一个比较相似的工作是3DV,其使用了PoinNet++抽取几何信息,再通过体素化抽取运动信息。然而体素化之类的过程是计算消耗巨大的,导致3DV本身很慢。GeometryMotion-Net则是用于在点云序列中抽取几何和运动信息，并且不依赖于任何体素化操作。主要思想是利用<strong>一个几何流和运动流组成的two-stream框架</strong>来进行动作识别。</p>\r\n<ol type=\"1\">\r\n<li>采样：帧采样之后，对帧内使用PointNet++类似的<strong>set\r\nabstraction</strong>(FPS, grouping, PointNet)进行下采样。</li>\r\n<li>几何流：用整个点云序列构造成一个空间整体。其从所有的帧中将点全部合并在一起，然后在每个点的局部邻域中抽取出特征。</li>\r\n<li>运动流：在相邻两帧之间生成两个虚拟的帧。对于帧内的一个点，首先生成其相对于前后相邻帧的offset特征，然后在offset特征的空间中抽取其局部邻域信息。</li>\r\n</ol>\r\n<figure>\r\n<img src=\"https://i.imgur.com/oNRJnkD.png\" alt=\"整体结构图\" />\r\n<figcaption aria-hidden=\"true\">整体结构图</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h1 id=\"采样和初始特征\">采样和初始特征</h1>\r\n<p>将序列划分为T个等分区间，并且训练时从每个区间内随机取一个帧，测试时则每个区间取固定一帧。</p>\r\n<p><strong>Baseline</strong>：有了帧之后，一种简单的思路即使用现有的点云空间学习方法（如PointNet和PointNet++）来对帧内进行全局的学习。并且最终将T帧的全局特征连接起来，作为最终的序列级别的特征。</p>\r\n<p>回到这篇文章，对于每个帧内，使用了PointNet++中的set\r\nabstraction操作来进行下采样出N个点，并且为这N个点计算出了初始特征（xyz\r\n拼接 C）。</p>\r\n<blockquote>\r\n<p>set abstraction：采样层+聚类层+miniPointNet层。</p>\r\n</blockquote>\r\n<h1 id=\"几何流\">几何流</h1>\r\n<p>对于输入的T帧点云，几何流将其整合为一个大的点云<span\r\nclass=\"math inline\">\\(P^{T*N \\times\r\n3+C}\\)</span>个点。对于大点云中的每个点，聚合其邻域范围特征作为自己的特征。具体做法是，首先搜索其k近邻<span\r\nclass=\"math inline\">\\(N_k(i)\\)</span>,并且对每个邻居构造一个差分特征，如下所示:</p>\r\n<p><span class=\"math display\">\\[\r\n\\tilde{f}_{j}=h_{1}\\left(\\left[f_{j}-f_{i}, f_{i}\\right]\\right), \\quad\r\n\\forall j \\in N_{k_{1}}(i)\\\\\r\ng_{i}=\\underset{j \\in N_{k_{1}}(i)}{\\mathbf{M A X}} \\tilde{f}_{j}\r\n\\]</span></p>\r\n<p>其中<span class=\"math inline\">\\(h_1\\)</span>是一个MLP块,<span\r\nclass=\"math inline\">\\(\\tilde{f}_{j}\\)</span>则是每个邻居的差分特征。之后再对整个邻域进行max-pooling操作，以聚合整个邻域的特征<span\r\nclass=\"math inline\">\\(g_i\\)</span>，其作为中心点的特征。</p>\r\n<p>更新了整个大点云之后，则在其上使用一个mini\r\nPointNet来抽取整个点云的全局特征<span\r\nclass=\"math inline\">\\(\\mathbf{G}\\)</span>，类似于平均图像的概念。</p>\r\n<h1 id=\"运动流\">运动流</h1>\r\n<p>点云中无法得知不同帧之间点的一一对应关系，而做点的运动估计和轨迹跟踪本身也是个困难且计算量大的任务。因此，这篇文章选择了对每一帧生成前后两个虚拟帧来找到运动关系。对于每一帧点云<span\r\nclass=\"math inline\">\\(P\\)</span>，其中点特征为<span\r\nclass=\"math inline\">\\(f_i : R^{3+C}\\)</span>。定义其邻域点云为<span\r\nclass=\"math inline\">\\(P^r\\)</span>，其中点特征为<span\r\nclass=\"math inline\">\\(f_j : R^{3+C}\\)</span>。</p>\r\n<p>为了学习点的运动变化信息，即需要构造一个在运动上的差分特征。因此对于原始帧内的点<span\r\nclass=\"math inline\">\\(p_i\\)</span>，在<span\r\nclass=\"math inline\">\\(P^r\\)</span>中使用PointNet++的方法找到k近邻，并且用类似于运动流的方法构造差分特征，如下所示：</p>\r\n<p><span class=\"math display\">\\[\r\n\\bar{f}_{j}=h_{2}\\left(\\left[\\hat{f}_{j}^{r}-\\hat{f}_{i}^{c},\r\n\\check{f}_{i}^{c}, \\check{f}_{j}^{r}\\right]\\right), \\quad \\forall j \\in\r\nN_{k_{2}}(i)\\\\\r\nm_{i}=\\underset{j \\in N_{k_{2}}(i)}{\\operatorname{MAX}} \\bar{f}_{j}\r\n\\]</span></p>\r\n<p>最终可以得到一个时间聚合点为<span\r\nclass=\"math inline\">\\(m_i\\)</span>，其组成了一个时间聚合点云<span\r\nclass=\"math inline\">\\(M\\)</span>。之后在其上同样使用mini\r\nPointNet来抽取这个运动点云的全局特征<span\r\nclass=\"math inline\">\\(\\mathbf{M}\\)</span>。</p>\r\n<p>因此在运动流的管线中，输入T帧点云，前一帧和后一帧都可以作为邻域点云，最终产生2(T-1)个时间聚合点云<span\r\nclass=\"math inline\">\\(M\\)</span>，抽取特征之后即可得到2(T-1)个双向运动特征。</p>\r\n<h1 id=\"双流汇聚\">双流汇聚</h1>\r\n<p>汇聚前的输入为一个几何全局特征，和2(T-1)个运动特征，简单的汇聚方法即对这些特征进行拼接，然后使用MLP进行降维处理，最终输出分类得分。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/XOLjSBv.png\" alt=\"NTU RGB+D 120结果\" />\r\n<figcaption aria-hidden=\"true\">NTU RGB+D 120结果</figcaption>\r\n</figure>\r\n","categories":["深度学习"],"tags":["深度学习","点云","序列学习"]},{"title":"Generative Adversarial Nets","url":"/2021/10/30/GAN/","content":"<p>一个生成模型G：学习到数据分布，使得D犯错概率最大<br />\r\n一个判别模型D：判别一个样本是来自真实数据还是G<br />\r\n存在一个特解，使得G可以涵盖住真实训练数据分布，D的判别概率始终是<span\r\nclass=\"math inline\">\\(\\frac{1}{2}\\)</span><br />\r\n对于MLP定义的G和D，可以使用反向传播训练整个系统，而不需要使用任何的马尔科夫链或者是展开的近似推理网络。</p>\r\n<h1 id=\"导论\">导论</h1>\r\n<p>迄今为止，大多数深度学习伟大的成功都是在判别模型上，将高维复杂的输入映射到一个类别标签。<br />\r\n而生成模型则有着很多的困难，如很难在极大似然估计和相关策略中进行概率计算，并且生成模型的上下文中难以利用分层线性单元的优势。</p>\r\n<p>本文提出了一个新的规避了这些困难的生成模型。</p>\r\n<p>GAN框架能够给很多模型和优化问题提供一种训练方法。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"对抗网络\">对抗网络</h1>\r\n<p>为了从数据 <span class=\"math inline\">\\(x\\)</span>\r\n上学习到生成器的分布 <span class=\"math inline\">\\(p_g\\)</span>\r\n，我们先给定一个先验输入噪声 <span\r\nclass=\"math inline\">\\(p_z(z)\\)</span><br />\r\n然后利用 <span class=\"math inline\">\\(G(z;\\theta_g)\\)</span>\r\n将z映射到数据空间，其中G是一个多层感知机。<br />\r\n再定义一个 <span class=\"math inline\">\\(D(x;\\theta_d)\\)</span>\r\n：计算x来自真实数据而不是生成器生成的分布<span\r\nclass=\"math inline\">\\(p_g\\)</span>的概率。</p>\r\n<p>训练D以最大化分类正确率，并且同时训练G以最小化<span\r\nclass=\"math inline\">\\(\\log(1-D(G(z)))\\)</span></p>\r\n<p>最终的评估函数：</p>\r\n<p><span class=\"math display\">\\[\r\n\\min _{G} \\max _{D} V(D, G)=\\mathbb{E}_{\\boldsymbol{x} \\sim p_{\\text\r\n{data }}(\\boldsymbol{x})}[\\log\r\nD(\\boldsymbol{x})]+\\mathbb{E}_{\\boldsymbol{z} \\sim\r\np_{\\boldsymbol{z}}(\\boldsymbol{z})}[\\log (1-D(G(\\boldsymbol{z})))]\r\n\\tag{1}\r\n\\]</span></p>\r\n<p>训练过程中，不会在一次训练循环里直接完成D的优化，那在有限数据集里会导致过拟合。因此，我们会在优化K次D和优化1次G中交替进行。只要G变化的足够缓慢，这将有助于保持D在它最优解的附近。</p>\r\n<p>这个策略类似于SML/PCD[2]中，为了避免样本在马尔科夫链中学习迭代时burning的方式。，</p>\r\n<p>实际上，公式(1)可能不能给G提供足够的梯度以供学习。在训练的初期，G效果很差，D可以轻易的分辨出数据的真假。此时\r\n<span class=\"math inline\">\\(\\log(1-D(G(z)))\\)</span>\r\n变得饱和：即接近极限了已经，变化很小。相比于训练G以最小化 <span\r\nclass=\"math inline\">\\(\\log(1-D(G(z)))\\)</span>\r\n，我们可以训练G以最大化<span\r\nclass=\"math inline\">\\(\\log(D(G(z)))\\)</span>\r\n，这个目标函数可以有相同的结果但是有更好的梯度。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/jxKCPer.png\"\r\nalt=\"GAN示意图：蓝线为判别器的认为的概率分布，黑点为真实数据的分布，绿线为生成器的分布。x线为真实数据域，z线为生成器采样数据域。箭头为z通过G映射到x。(b) 训练D后，D逼近真实数据分布。(c) 更新G，D的梯度引导G向真实分布靠近。(d) 足够训练的情况下，学习到的分布完全和训练分布一致，D(x)=0.5\" />\r\n<figcaption\r\naria-hidden=\"true\">GAN示意图：蓝线为判别器的认为的概率分布，黑点为真实数据的分布，绿线为生成器的分布。x线为真实数据域，z线为生成器采样数据域。箭头为z通过G映射到x。(b)\r\n训练D后，D逼近真实数据分布。(c) 更新G，D的梯度引导G向真实分布靠近。(d)\r\n足够训练的情况下，学习到的分布完全和训练分布一致，D(x)=0.5</figcaption>\r\n</figure>\r\n<h1 id=\"理论\">理论</h1>\r\n<p>生成器G隐式地定义了一个概率分布 <span class=\"math inline\">\\(p_g =\r\nG(z)\\)</span>——即从 <span class=\"math inline\">\\(z \\sim p_z\\)</span>\r\n中的采样结果。因此，我们希望训练算法在充分的环境下，可以最终收敛出一个不错的估计器来估计\r\n<span class=\"math inline\">\\(p_{data}\\)</span> 。</p>\r\n<p>接下来会证明这个minimax过程对于 $p_g = p_{data} $\r\n有一个全局最优解。然后会证明公式(1)可以通过训练算法来获得最优解。</p>\r\n<h2 id=\"训练算法\">训练算法</h2>\r\n<p>GAN的小批量随机梯度下降训练。<br />\r\nK：超参数，表明在判别器D上经过的step。</p>\r\n<p><strong>for</strong> number of training iterations\r\n<strong>do</strong></p>\r\n<ul>\r\n<li><p><strong>for</strong> <span class=\"math inline\">\\(k\\)</span> steps\r\n<strong>do</strong></p></li>\r\n<li><ol type=\"1\">\r\n<li>从先验噪声 <span class=\"math inline\">\\(p_{g}(z)\\)</span>\r\n中采样出m大小的小批量样本 <span class=\"math inline\">\\(\\left\\{z^{(1)},\r\n\\ldots, z^(m)\\right\\}\\)</span></li>\r\n</ol></li>\r\n<li><ol start=\"2\" type=\"1\">\r\n<li>从真实数据分布 <span class=\"math inline\">\\(p_{\\text {data\r\n}}(\\boldsymbol{x})\\)</span> 中采样出m大小的小批量样本 <span\r\nclass=\"math inline\">\\(\\left\\{\\boldsymbol{x}^{(1)}, \\ldots,\r\n\\boldsymbol{x}^{(m)}\\right\\}\\)</span></li>\r\n</ol></li>\r\n<li><ol start=\"3\" type=\"1\">\r\n<li>通过随机梯度下降更新判别器D：</li>\r\n</ol></li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\nabla_{\\theta_{d}} \\frac{1}{m} \\sum_{i=1}^{m}\\left[\\log\r\nD\\left(\\boldsymbol{x}^{(i)}\\right)+\\log\r\n\\left(1-D\\left(G\\left(z^{(i)}\\right)\\right)\\right)\\right]\r\n\\]</span></p>\r\n<ul>\r\n<li><p><strong>end <span class=\"math inline\">\\(k\\)</span>\r\nfor</strong></p></li>\r\n<li><p>从先验噪声 <span class=\"math inline\">\\(p_{g}(z)\\)</span>\r\n中采样出m大小的小批量样本 <span class=\"math inline\">\\(\\left\\{z^{(1)},\r\n\\ldots, z^(m)\\right\\}\\)</span></p></li>\r\n<li><p>通过随机梯度下降更新生成器G:</p></li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\nabla_{\\theta_{g}} \\frac{1}{m} \\sum_{i=1}^{m} \\log\r\n\\left(1-D\\left(G\\left(z^{(i)}\\right)\\right)\\right)\r\n\\]</span></p>\r\n<p><strong>end</strong> train iterations <strong>for</strong></p>\r\n<h2 id=\"证明-p_g-p_data-的全局最优解\">证明 <span\r\nclass=\"math inline\">\\(p_g = p_{data}\\)</span> 的全局最优解</h2>\r\n<h3 id=\"首先证明固定g时d的最优解为\">首先证明：固定G时，D的最优解为</h3>\r\n<p><span class=\"math display\">\\[\r\nD_{G}^{*}(x)=\\frac{p_{\\text {data }}(x)}{p_{\\text {data }}(x)+p_{g}(x)}\r\n\\]</span></p>\r\n<p>给定任何G，D，训练目标都是最大化 <span class=\"math inline\">\\(V(G,\r\nD)\\)</span> ：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nV(G, D) &amp;=\\mathbb{E}_{\\boldsymbol{x} \\sim p_{\\text {data\r\n}}(\\boldsymbol{x})}[\\log D(\\boldsymbol{x})]+\\mathbb{E}_{\\boldsymbol{z}\r\n\\sim p_{\\boldsymbol{z}}(\\boldsymbol{z})}[\\log (1-D(G(\\boldsymbol{z})))]\r\n\\\\\r\n期望展开&amp;=\\int_{\\boldsymbol{x}} p_{\\text {data }}(\\boldsymbol{x})\r\n\\log (D(\\boldsymbol{x})) d x+\\int_{\\boldsymbol{z}}\r\np_{\\boldsymbol{z}}(\\boldsymbol{z}) \\log (1-D(g(\\boldsymbol{z}))) d z \\\\\r\n换元z到x&amp;=\\int_{\\boldsymbol{x}} p_{\\text {data }}(\\boldsymbol{x})\r\n\\log (D(\\boldsymbol{x}))+p_{g}(\\boldsymbol{x}) \\log\r\n(1-D(\\boldsymbol{x})) d x\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>求积分最大值可以转化为求被积函数最大值：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nV(G,D)&amp;=\\int_{\\boldsymbol{x}} p_{\\text {data }}(\\boldsymbol{x}) \\log\r\n(D(\\boldsymbol{x}))+p_{g}(\\boldsymbol{x}) \\log (1-D(\\boldsymbol{x})) d x\r\n\\\\\r\n&amp;\\leq \\int_{\\boldsymbol{x}} \\max _{y} p_{\\text {data\r\n}}(\\boldsymbol{x}) \\log (y))+p_{g}(\\boldsymbol{x}) \\log (1-y) d x\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>并且因为固定G求D的最优，因此不涉及D的都可看作常数项即：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nf(D(x)) &amp;= p_{\\text {data }}(\\boldsymbol{x}) \\log\r\n(D(\\boldsymbol{x}))+p_{g}(\\boldsymbol{x}) \\log (1-D(\\boldsymbol{x})) \\\\\r\n&amp;= a \\log D + b \\log (1-D) \\\\\r\n即 f(y) &amp;= a \\log y + b \\log (1-y)\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>其中 $ a,b (0,1) $ 。为了求最优解，对该式计算 <span\r\nclass=\"math inline\">\\(y\\)</span> 的一阶导可得 <span\r\nclass=\"math inline\">\\(y=\\frac{a}{a+b}\\)</span>，继续求该位置的二阶导可得：</p>\r\n<p><span class=\"math display\">\\[\r\nf^{\\prime\r\n\\prime}\\left(\\frac{a}{a+b}\\right)=-\\frac{a}{\\left(\\frac{a}{a+b}\\right)^{2}}-\\frac{b}{1-\\left(\\frac{a}{a+b}\\right)^{2}}&lt;0\r\n\\]</span></p>\r\n<p>因此最优D为：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nD_{G}^{*}(x)&amp;=\\frac{p_{\\text {data }}(x)}{p_{\\text {data\r\n}}(x)+p_{g}(x)} \\\\\r\nP_G=P_{data}时，&amp;= \\frac{1}{2}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<h3 id=\"定理1cg-当且仅当-p_g-p_data-时取得全局最小值--log4\">定理1：<span\r\nclass=\"math inline\">\\(C(G)\\)</span> 当且仅当 <span\r\nclass=\"math inline\">\\(p_g = p_{data}\\)</span> 时取得全局最小值\r\n-log4</h3>\r\n<p>证明：</p>\r\n<p>结合公式(1)和$ D $的最优解，可知 $ C(G) $ 有如下表达式 ：</p>\r\n$$\r\n<span class=\"math display\">\\[\\begin{aligned}\r\nC(G)&amp;=\\int_{x} p_{\\text {data }}(x) \\log \\left(\\frac{p_{\\text {data\r\n}}(x)}{p_{G}(x)+p_{\\text {data }}(x)}\\right)+p_{G}(x) \\log\r\n\\left(\\frac{p_{G}(x)}{p_{G}(x)+p_{\\text {data }}(x)}\\right) \\mathrm{d} x\r\n\\\\\r\n\r\np_g = p_{data} 时 , C(G) &amp;=- log 4\r\n\\end{aligned}\\]</span>\r\n<p>$$</p>\r\n<p>为了检查这个 -log4 是不是最优值，构造方程：</p>\r\n$$\r\n<span class=\"math display\">\\[\\begin{aligned}\r\nC(G) &amp;=\\int_{x}(\\log 2-\\log 2) p_{\\text {data }}(x)+p_{\\text {data\r\n}}(x) \\log \\left(\\frac{p_{\\text {data }}(x)}{p_{G}(x)+p_{\\text {data\r\n}}(x)}\\right) \\\\\r\n&amp;+(\\log 2-\\log 2) p_{G}(x)+p_{G}(x) \\log\r\n\\left(\\frac{p_{G}(x)}{p_{G}(x)+p_{\\text {data }}(x)}\\right) \\mathrm{d} x\r\n\\\\\r\n\\\\\r\n&amp;=-\\log 2 \\int_{x} p_{G}(x)+p_{data}(x) \\mathrm{d} x +\\int_{x}\r\np_{data}(x)\\left(\\log 2+\\log \\left(\\frac{p_{data}(x)}{p_{G}(x)+p_{\\text\r\n{data }}(x)}\\right)\\right) \\\\\r\n&amp;+p_{G}(x)\\left(\\log 2+\\log\r\n\\left(\\frac{p_{G}(x)}{p_{G}(x)+p_{data}(x)}\\right)\\right) \\mathrm{d} x\r\n\\\\\r\n\\\\\r\n\r\nC(G)&amp;=-\\log 4+\\int_{x} p_{\\text {data }}(x) \\log\r\n\\left(\\frac{p_{\\text {data }}(x)}{\\left(p_{G}(x)+p_{\\text {data\r\n}}(x)\\right) / 2}\\right) \\mathrm{d} x \\\\\r\n&amp;+\\int_{x} p_{G}(x) \\log\r\n\\left(\\frac{p_{G}(x)}{\\left(p_{G}(x)+p_{\\text {data }}(x)\\right) /\r\n2}\\right) \\mathrm{d} x\r\n\r\n\\end{aligned}\\]</span>\r\n<p>$$</p>\r\n<p>后面两个积分式即是KL散度（一种衡量分布差异的方法）：</p>\r\n<blockquote>\r\n<p>KL散度为非负值，具有非对称性，且KL散度为0当且仅当两个离散分布处处相同。</p>\r\n<p><span class=\"math display\">\\[\r\nD_{\\mathrm{KL}}(P \\| Q)=\\mathbb{E}_{\\mathrm{x} \\sim P}\\left[\\log\r\n\\frac{P(x)}{Q(x)}\\right]=\\mathbb{E}_{\\mathrm{x} \\sim P}[\\log P(x)-\\log\r\nQ(x)]\r\n\\]</span></p>\r\n</blockquote>\r\n<p><span class=\"math display\">\\[\r\nC(G)=-\\log 4+K L\\left(p_{\\text {data }} \\mid \\frac{p_{\\text {data\r\n}}+p_{G}}{2}\\right)+K L\\left(p_{G} \\mid \\frac{p_{\\text {data\r\n}}+p_{G}}{2}\\right)\r\n\\]</span></p>\r\n<p>由于KL散度的非负性质，我们可以得到-log4即为<span\r\nclass=\"math inline\">\\(C(G)\\)</span>的全局最小值。进一步需要证明 <span\r\nclass=\"math inline\">\\(p_G=p_{data}\\)</span> 是取值的唯一点。</p>\r\n<p>因为KL散度是非对称的，因此构造两个相反的KL散度相加，它们的和就是对称项，即可以表示为JS散度：</p>\r\n<p><span class=\"math display\">\\[\r\nJSD(P \\| Q) = \\frac{1}{2}KL(P \\|(P+Q)/2) +\\frac{1}{2}KL(Q \\|(P+Q)/2)\r\n\\]</span></p>\r\n<p>因此 <span class=\"math inline\">\\(C(G)\\)</span> 可表示为：</p>\r\n<p><span class=\"math display\">\\[\r\nC(G)=-\\log 4 +2 JSD(p_{data}|p_G)\r\n\\]</span></p>\r\n<p>根据JS散度非负，且只有 $p_G=p_{data} 时 , JSD=0 $。\r\n综上所述，得证。</p>\r\n<h1 id=\"实验效果\">实验效果</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/JyLtCdO.png\" alt=\"MINIST\" />\r\n<figcaption aria-hidden=\"true\">MINIST</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/OOvavFd.png\" alt=\"TFD\" />\r\n<figcaption aria-hidden=\"true\">TFD</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/AA8kLIS.png\" alt=\"CIFAR-10 全连接\" />\r\n<figcaption aria-hidden=\"true\">CIFAR-10 全连接</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/IweITKm.png\"\r\nalt=\"CIFAR-10 卷积D和逆卷积G\" />\r\n<figcaption aria-hidden=\"true\">CIFAR-10 卷积D和逆卷积G</figcaption>\r\n</figure>\r\n<h1 id=\"优缺点\">优缺点</h1>\r\n<p>缺点：</p>\r\n<ol type=\"1\">\r\n<li>对 <span class=\"math inline\">\\(p_g (x)\\)</span>\r\n没有显式的表达。</li>\r\n<li>G不能在更新D之前训练过多，要不然会发生模型崩溃问题。</li>\r\n</ol>\r\n<blockquote>\r\n<p>模型崩溃Mode collapse 是指 GAN\r\n生成的样本单一。当G发现一种样本可以欺骗到D时，就只会生成那一种mode的样本。判别网络最后会判别来自该\r\nmode 的样本是假的。最后，生成网络 G 会简单地锁定到另一个\r\nmode。该循环会无限进行，就会限制生成样本的多样性</p>\r\n</blockquote>\r\n<p>优点：</p>\r\n<ol type=\"1\">\r\n<li>只需要反向传播，不需要马尔科夫链，不需要推理网络</li>\r\n<li>多种多样的模型可以结合在GAN的框架中。</li>\r\n<li>不会直接使用真实数据样本去更新G，而是只能通过判别器的梯度引导。换句话说，生成器不会直接copy原始输入。</li>\r\n</ol>\r\n<h1 id=\"other\">Other</h1>\r\n<p>为什么要distribution？<br />\r\n为了同样的输入能够产生不同的输出</p>\r\n<p>JS散度的问题?<br />\r\n如果两个分布完全不重叠，JS散度值始终是 log 2，改进有Wasserstein\r\ndistance...</p>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[1]Goodfellow I, Pouget-Abadie J, Mirza M, et al. Generative\r\nadversarial nets[J]. Advances in neural information processing systems,\r\n2014, 27.</p>\r\n<p>[2]Younes, L. (1999). On the convergence of Markovian stochastic\r\nalgorithms with rapidly decreasing ergodicity rates. Stochastics and\r\nStochastic Reports, 65(3), 177–228.</p>\r\n<p>[3]GAN完整理论推导与实现, 机器之心, <a\r\nhref=\"https://www.jiqizhixin.com/articles/2017-10-1-1\"\r\nclass=\"uri\">https://www.jiqizhixin.com/articles/2017-10-1-1</a></p>\r\n","categories":["深度学习"]},{"title":"Github+Hexo 搭建博客","url":"/2020/07/15/Github-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","content":"<h1 id=\"github-pages-hexo-博客搭建\">github Pages + Hexo 博客搭建</h1>\r\n<p>前置知识：git 使用，github 建库</p>\r\n<blockquote>\r\n<p>注意GitHub仓库最好建的是username.github.io仓库，这样GitHub Pages\r\n才能获得一级域名。而二级域名在进行某些扩展时有问题。可以去搜一下关于github\r\npages两种域名的区别。</p>\r\n</blockquote>\r\n<h2 id=\"安装环境\">安装环境</h2>\r\n<h3 id=\"安装-node.js\">安装 node.JS</h3>\r\n<p><a\r\nhref=\"https://nodejs.org/en/download/\">官网下载安装程序，默认安装即可</a></p>\r\n<p>命令行运行<code>node -v</code> <code>npm -v</code>检查安装效果</p>\r\n<h3 id=\"安装-hexo\">安装 hexo</h3>\r\n<p>注意以下命令推荐使用字符支持良好的命令行，最好给管理员权限。我使用的是\r\ngit bash。</p>\r\n<blockquote>\r\n<p>可以使用 cmd，但我遇到了中文问题。</p>\r\n<p>powershell 运行会提示 “在此系统上禁止运行脚本”， 管理员权限下输入\r\n<code>set-executionpolicy remotesigned</code>\r\n更改安全策略，允许运行脚本。</p>\r\n</blockquote>\r\n<p>运行<code>npm install -g hexo-cli</code>进行安装,再运行<code>hexo -v</code>检查安装效果，有版本信息即安装成功</p>\r\n<h2 id=\"配置项目\">配置项目</h2>\r\n<h3 id=\"初始化\">初始化</h3>\r\n<p>安装成功后自己创建一个项目文件夹，命令行切换到文件夹路径进行以下初始化：</p>\r\n<p>运行<code>hexo init</code>初始化</p>\r\n<h3 id=\"本地测试\">本地测试</h3>\r\n<p>运行以下命令部署默认网页进行测试：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">hexo</span> <span class=\"string\">new</span> <span class=\"string\">test_my_site</span> <span class=\"comment\">#创建新 test_my_site 的 markdown 文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">hexo</span> <span class=\"string\">g</span>                <span class=\"comment\"># 从 md 文件生成 html 文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">hexo</span> <span class=\"string\">s</span>                <span class=\"comment\"># 部署本地服务器</span></span><br></pre></td></tr></table></figure>\r\n<p>观察到命令行在持续运行时，则可打开浏览器输入本地服务器地址（默认是<code>localhost:4000</code>）访问试试看。</p>\r\n<h3 id=\"部署到网络\">部署到网络</h3>\r\n<p>在文件夹根路径下面，找到_config.yml，打开修改</p>\r\n<p>最后一段为：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">repo:</span> <span class=\"string\">仓库的完整路径，推荐使用</span> <span class=\"string\">ssh</span> <span class=\"string\">路径，这样可以有</span> <span class=\"string\">ssh</span> <span class=\"string\">免密登录。例如我的</span> <span class=\"string\">git@github.com:Alobal/alobal.github.io.git</span></span><br><span class=\"line\"><span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\r\n<p>URL 小段为：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># URL</span></span><br><span class=\"line\"><span class=\"comment\">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"string\">访问网址，例如</span> <span class=\"string\">https://alobal.github.io/</span></span><br><span class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">仓库名，例如</span> <span class=\"string\">/</span></span><br></pre></td></tr></table></figure>\r\n<p>保存关闭该文件</p>\r\n<p>安装 hexo 的 git\r\n部署插件<code>npm install hexo-deployer-git --save</code></p>\r\n<p>运行以下命令进行发布到网络</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">hexo</span> <span class=\"string\">clean</span></span><br><span class=\"line\"><span class=\"string\">hexo</span> <span class=\"string\">g</span></span><br><span class=\"line\"><span class=\"string\">hexo</span> <span class=\"string\">d</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>在 hexo d 部署到 GitHub 时可能要求 GitHub 账号密码。</p>\r\n</blockquote>\r\n<p>出现<code>Branch 'master' set up to track remote branch 'master' from 'https:..</code>大概就恭喜你成功了。此时可以在\r\ngithub 仓库看到 hexo\r\n提交的文件。以及能通过访问网址查看你刚才发布的默认博客。</p>\r\n<h2 id=\"选一个你喜欢的主题\">选一个你喜欢的主题</h2>\r\n<h3 id=\"下载主题\">下载主题</h3>\r\n<p><a href=\"https://hexo.io/themes/\">hexo 主题库</a></p>\r\n<p>挑选一个合适的主题，比如很常见的 Next，复制 git\r\n地址，在本地博客项目根目录下，命令行输入进行 git clone</p>\r\n<p>例如<code>git clone https://github.com/next-theme/hexo-theme-next themes/next</code></p>\r\n<blockquote>\r\n<p>如果使用 next 主题请注意， next 主题在 2020 之前是 theme-next\r\n项目，2020 版本是 next-theme 项目，配置字段有点不同，根据需要选择。19\r\n版本网上教程比较健全了。</p>\r\n</blockquote>\r\n<h3 id=\"配置主题\">配置主题</h3>\r\n<p>打开 _config.yml，修改 theme 字段：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Extensions</span></span><br><span class=\"line\"><span class=\"comment\">## Plugins: https://hexo.io/plugins/</span></span><br><span class=\"line\"><span class=\"comment\">## Themes: https://hexo.io/themes/</span></span><br><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">主题名，例如</span> <span class=\"string\">next</span></span><br></pre></td></tr></table></figure>\r\n<p>其中主题也有自己的配置文件，项目名/themes/主题名/_config.yml，可以根据需要进行修改。比如\r\nnext\r\n主题配置文件中，可以在四种风格中选一种，选一个取消注释就好了。想预览效果可以去找\r\nnext 官方文档。</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Schemes</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Muse</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Mist</span></span><br><span class=\"line\"><span class=\"attr\">scheme:</span> <span class=\"string\">Pisces</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>\r\n<p>输入<code>hexo g;hexo d</code>\r\n重新生成网页并发布出去，可以自己偷偷欣赏欣赏。</p>\r\n<blockquote>\r\n<p>如果没看到生效，可能是因为浏览器缓存，关掉浏览器重新打开，或者\r\nCtrl+F5 强制刷新。</p>\r\n</blockquote>\r\n<h2 id=\"helloblog\">hello，blog</h2>\r\n<p>让我们试着发布第一篇博客。项目路径下，命令行输入<code>hexo n 博客名</code>\r\n, 可以在 项目名/source/_posts/ 下面找到新建的 markdown\r\n文件。打开文件可以发现有预置的文件头，暂时不用管，后续要添加<strong>分类</strong>和<strong>标签</strong>功能的时候可以写一写。在文件头之后，即<code>------</code>下面写入你的\r\nmarkdown 格式内容即可。</p>\r\n<p>关于 markdown 怎么书写，可以看我的 <a\r\nhref=\"https://alobal.github.io/Blog/2020/07/17/MarkDown%E7%AE%80%E6%B4%81%E6%89%8B%E5%86%8C/\">markdown\r\n简洁手册</a>。</p>\r\n<h2 id=\"参考\">参考</h2>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/26625249\">知乎经典贴</a></p>\r\n<h2 id=\"错误汇总\">错误汇总</h2>\r\n<h3 id=\"can-not-find-module-xxx\">can not find module xxx</h3>\r\n<p>命令行<code>npm install</code> 安装所有依赖包完事。</p>\r\n<h3 id=\"没有启用代码高亮\">没有启用代码高亮</h3>\r\n<p>根目录 config 里，修改配置如下：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">highlight:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">line_number:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">auto_detect:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">tab_replace:</span> <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">  <span class=\"attr\">wrap:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">hljs:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\r\n<p>next 主题配置里，选择自己要的高亮样式：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">codeblock:</span></span><br><span class=\"line\">  <span class=\"comment\"># Code Highlight theme</span></span><br><span class=\"line\">  <span class=\"comment\"># All available themes: https://theme-next.js.org/highlight/</span></span><br><span class=\"line\">  <span class=\"attr\">theme:</span></span><br><span class=\"line\">    <span class=\"attr\">light:</span>  <span class=\"string\">tomorrow-night-blue</span></span><br><span class=\"line\">    <span class=\"attr\">dark:</span>  <span class=\"string\">tomorrow-night-blue</span></span><br><span class=\"line\">  <span class=\"attr\">prism:</span></span><br><span class=\"line\">    <span class=\"attr\">light:</span> <span class=\"string\">tomorrow-night-blue</span></span><br><span class=\"line\">    <span class=\"attr\">dark:</span> <span class=\"string\">tomorrow-night-blue</span></span><br><span class=\"line\">  <span class=\"comment\"># Add copy button on codeblock</span></span><br><span class=\"line\">  <span class=\"attr\">copy_button:</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"comment\"># Available values: default | flat | mac</span></span><br><span class=\"line\">    <span class=\"attr\">style:</span></span><br></pre></td></tr></table></figure>\r\n","categories":["工具"],"tags":["博客"]},{"title":"Hexo Github+Coding 双线部署(已废弃,Coding已不支持免费部署)","url":"/2020/08/27/Hexo-Github-Codin%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2/","content":"<h2 id=\"起因\">起因</h2>\r\n<p>本来在【关于】页挂了个终末之诗，觉得写得很好想分享出去看看。</p>\r\n<p>结果别说看了，别人打开 GitHub 部署的静态网页完全就是\r\n404！用久了传送门都忘掉了 GitHub 是带墙的 ... 只能保存了个没有样式的\r\nhtml 发过去。</p>\r\n<blockquote>\r\n<p>一开始还以为是个别连不上，因为我自己裸连虽然慢了点也能上。后来发现好像是因为上海的网墙矮一点？？之前在上海也是能裸连\r\nR6 服务器，回江西那是完全登不上的那种。</p>\r\n</blockquote>\r\n<p>所以想着再在国内代码托管平台部署一个了。毕竟虽然没有人看，但偶尔想分享的时候也太不方便了=\r\n=</p>\r\n<h2 id=\"配置\">配置</h2>\r\n<p>单独配置其中任何一个平台的话，在前面的博客里写的很详细了，默认已经配置好了\r\nGitHub 哈，介绍一些双线部署的小问题。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"hexo-_config.yml-配置\">hexo _config.yml 配置</h3>\r\n<p>这里主要注意 deploy 字段：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">仓库地址</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">仓库地址</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">master</span> </span><br></pre></td></tr></table></figure>\r\n<p>要同时往两个仓库部署，需要用<code>-</code>号语法。同时请注意严格遵守缩进规则。</p>\r\n<h3 id=\"coding-配置\">Coding 配置</h3>\r\n<p>注意 Coding 新建一个仓库后，默认是没有打开部署服务的。因此要去\r\n<code>项目设置-&gt;项目与成员-&gt;功能开关-&gt;持续部署</code>这里开启静态页面相关功能。</p>\r\n<p>之后可以在仓库的<strong>持续部署</strong>下找到静态网站功能了。去网站设置里保存一下相关设置即可，最好能打开强制\r\nHTTPS。</p>\r\n<blockquote>\r\n<p>至于其他博客说的什么仓库名项目名网站名要和用户名一样，我是没感觉到有必要性\r\n... 毕竟名字至少肯定不影响\r\npush，而静态网页的地址最后都是被分配\".com\"网址，也想不出和名字有啥关系。</p>\r\n</blockquote>\r\n<h3 id=\"github-和-coding-的路由区别\">GitHub 和 Coding 的路由区别</h3>\r\n<p>如果之前在 GitHub\r\n随便创个普通仓库部署的静态网页，这时候就会出现问题。我后来才知道，GitHub\r\nPages 分<strong>个人主页</strong>和<strong>项目主页</strong>：</p>\r\n<ul>\r\n<li>个人主页 user.github.io</li>\r\n<li>项目主页 user.github.io/xxxx</li>\r\n</ul>\r\n<p>普通仓库的 GitHub Pages 是项目主页，因此网址是次级网址，再加上之前在\r\nhexo 配置的<code>root</code>相关字段，hexo 加载资源什么的都是以 “/xxxx”\r\n为根目录去查找的。</p>\r\n<p>然而 Coding 给的是一级域名，此时部署到 Coding\r\n的页面也是会以“/xxxx”为根目录进行加载资源，显然就会出错了，直接体现就是\r\nmain.css 无法加载，F12 调试看可以发现是 main.css 的路径错误。</p>\r\n<p>然而在没有自定义域名的情况下，两边都不允许更换主次级域名，这时候发现GitHub有分<em>个人主页</em>这个东西\r\n...</p>\r\n<h3 id=\"github-个人主页-顶级网址\">GitHub 个人主页 顶级网址</h3>\r\n<p>普通的仓库名建出来的都是项目主页，是次级网址。GitHub有两个仓库名比较特殊：</p>\r\n<ul>\r\n<li>user 这个是彩蛋仓库，它的readme.md会显示在GitHub个人资料页</li>\r\n<li>user.github.io 这个是我们要的，顶级网址仓库。</li>\r\n</ul>\r\n<p>创建名为<code>user.github.io</code>的仓库，user\r\n是账户名，比如我需要的仓库名就是 alobal.github.io</p>\r\n<p>此时去开启GitHub Pages 可以发现域名就是 user.github.io\r\n了，重新调整hexo对GitHub的相关部署即可。</p>\r\n<blockquote>\r\n<p>记得hexo _config.yml 中设置 <code>root: /</code>。</p>\r\n</blockquote>\r\n<h3 id=\"成功部署\">成功部署</h3>\r\n<p>调整相关配置和仓库后，可以轻松验证两边都配置成功了。当然，如果你删了GitHub的旧仓库，假如以前有页间引用的绝对路径链接..此时都会失效。自己酌情考虑要不要清空吧。</p>\r\n<p>另外hexo _config.yml中有一个 url\r\n字段，设置的是网页访问网址，而且好像只能设置一个，但又没影响双线不同网址的部署，不知道有什么用=\r\n=可能是作为一种可选引用变量吧</p>\r\n","categories":["工具"],"tags":["博客"]},{"title":"How to Read a Paper","url":"/2021/09/26/How-to-Read-a-Paper/","content":"<h2 id=\"确定阅读目标\">确定阅读目标</h2>\r\n<ol type=\"1\">\r\n<li>能够重述给听众</li>\r\n<li>跟踪领域前沿技术</li>\r\n<li>调研一个新的领域</li>\r\n</ol>\r\n<p>根据自己的阅读目的调整自己的阅读深度。</p>\r\n<h2 id=\"三步走方法\">三步走方法</h2>\r\n<p>不要每一篇论文都从开始硬读到结尾，而是分段为三步走。每一步建立在上一步的基础之上，并且需要完成这一步应有的目标。</p>\r\n<p>第一步：了解论文总体的idea\r\n第二步：掌握论文的大致内容，但不需要在乎细节。 第三步：深度理解论文</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"第一步\">第一步</h3>\r\n<p>第一步用来快速浏览整篇论文，对论文有一个大体的认识，花费5~10分钟：</p>\r\n<ol type=\"1\">\r\n<li>仔细阅读<strong>标题，摘要，导论</strong>。</li>\r\n<li>阅读每一章节以及子节的<strong>引论</strong>，其他的不需要读。</li>\r\n<li>浏览一下<strong>数学</strong>性的内容，了解论文潜在的的理论基础。</li>\r\n<li>阅读<strong>结论</strong>。</li>\r\n<li>瞥一眼<strong>参考文献</strong>，在心里去掉那些你已经读过的。</li>\r\n</ol>\r\n<p>第一步做完之后，需要对一下五个问题有一个想法：</p>\r\n<ol type=\"1\">\r\n<li>分类：\r\n这篇论文是什么类型的？一项研究的原型？一个现有系统的分析？</li>\r\n<li>关联：和其他哪些论文有所联系？需要用到哪些理论基础来分析问题？</li>\r\n<li>正确性：论文的假设是否可以被证实？</li>\r\n<li>贡献点：论文的主要贡献点是什么？</li>\r\n<li>写作：这篇论文写作水平好吗？</li>\r\n</ol>\r\n<p>过了这些问题，已经足够让你判断论文是否值得继续阅读：不感兴趣、看不太懂、领域无关、正确性不够的论文，不用再看。</p>\r\n<p>同样，自己写作时也是如此。章节要连贯，内容概要要清晰明确，让人能够在浏览中掌握论文的要旨和亮点。用一个精心挑选的图表来总结全文是一种很棒的方法。</p>\r\n<h3 id=\"第二步\">第二步</h3>\r\n<p>第二步需要更用心地去看全文，但不需要在乎细节（例如证明过程什么的），花费大约一个小时。\r\n此时，可以在留白处写下注释笔记，记录要点，以及一些不懂的术语和问题。</p>\r\n<ol type=\"1\">\r\n<li>仔细看论文的<strong>图表插图</strong>。轴和标签是否标注正确？结论是否有误差范围？这些普遍的错误可以很好地区分优秀工作和粗制滥造。</li>\r\n<li>标记未读的相关<strong>参考文献</strong>，以便于进一步了解该论文的背景。</li>\r\n</ol>\r\n<p>第二步做完，需要能够掌握论文内容，并且能够带着支撑性的理论向别人概述文章主旨。这种深度的阅读适合于你感兴趣的，但不一定是你研究方向的论文。</p>\r\n<p>有可能这时候你还是没看懂这篇论文。这时候可以选择先把论文放一放，在过一会（例如读完相关材料）之后再回去读一读。或者先就这样，继续我们的第三步深度阅读。</p>\r\n<h3 id=\"第三步\">第三步</h3>\r\n<p>第三步是为了想要完整地理解一篇论文。在这一步里，努力尝试去复现/复推这篇论文：和作者基于同样的假设，重新去实现相关工作。然后比较自己实现的版本和论文版本，你会很容易地发现作者的创新点、设想、以及隐藏的错误。</p>\r\n<p>这一步需要特别注意每一个细节之处。我们需要理解论文中的每一个推导和假设，最终，我们可以把其中的知识和技术点加入到我们的知识库中。因此，我们也应该据此记下我们未来要做的工作。</p>\r\n<p>这一步可能要花上数个小时，最后我们应该有能力从记忆中完全把论文结构复现出来，并且对其优缺点了如指掌。</p>\r\n<h2 id=\"文献调研\">文献调研</h2>\r\n<p>踏入一个不熟悉的领域，怎么去选择要阅读的论文呢？</p>\r\n<ol type=\"1\">\r\n<li>利用学术搜索引擎（Google Scholar /\r\nCiteSeer）查找三到五篇近期的高引论文。对每篇论文过一次第一步，掌握对相关工作的一个感觉。然后看看它们的<strong>相关工作</strong>章节，以便找到近期进展的一些概述。直到找到<strong>survey综述论文</strong>。</li>\r\n<li>如果没找到，在参考文献里找一些多次引用的作者和论文。看看这些作者近期工作是在哪出版的，这样可以找到领域内的<strong>顶级会议</strong>。</li>\r\n<li>在这些会议上浏览他们近期的进展，配合上之前搜集的几篇论文，这就构成了调研的文集。可以在其中进行第二步的阅读。特别注意这些文章的<strong>共同引用论文</strong>。</li>\r\n</ol>\r\n<h2 id=\"参考文献\">参考文献</h2>\r\n<p>《How to Read a Paper》, S. Keshav David R. Cheriton School of\r\nComputer Science, University of Waterloo Waterloo, ON, Canada,August 2,\r\n2013,keshav@uwaterloo.ca</p>\r\n","categories":["工具"]},{"title":"KMP 字符串模式匹配","url":"/2020/09/11/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/","content":"<p>字符串模式匹配——给定两个字符串，主串 haystack，模式串 needle。在\r\nhaystack 中查找 needle 出现的首字符位置。</p>\r\n<blockquote>\r\n<p>示例：</p>\r\n<p>输入：haystack=\"hello\",needle=\"ll\" 输出：2</p>\r\n<p>\"ll\" 在“hello”中出现的首字符位置是第三个字符，下标是 2</p>\r\n</blockquote>\r\n<h3 id=\"暴力的简单匹配\">暴力的简单匹配</h3>\r\n<p>思想是，在 haystack 的每个位置，都检查一遍是不是 needle\r\n的首字符，即后续能不能和 needle 匹配上。</p>\r\n<p>使用两层循环很简单，时间复杂度是 O(len_h*len_n)，显然过于复杂。</p>\r\n<h2 id=\"简单匹配的优化方向\">简单匹配的优化方向</h2>\r\n<p>既然要优化，我们肯定要知道原来的算法到底在哪里浪费了性能。可以看下面的例子：</p>\r\n<blockquote>\r\n<p>haystack=\"abcabcabe\" needle=\"abcabe\"</p>\r\n</blockquote>\r\n<p>跟着简单匹配的思路，以 haystack[0]\r\n为起点，然后主串模式串同时向后移动并匹配每一位，我们可以发现最终匹配会停留在：</p>\r\n<ul>\r\n<li>abcab<code>c</code>abe</li>\r\n<li>abcab<code>e</code></li>\r\n</ul>\r\n<p>即 c 和 e 匹配失败，那么简单匹配会退出这轮子循环，再以 haystack[1]\r\n进行匹配。</p>\r\n<p>此时以人的思维去看，以 b 或 c 为起点肯定匹配不成功，相反\r\nabc<code>ab</code>cabe 和<code>ab</code>cabe 是显然可以匹配到的。</p>\r\n<p>而且从遍历的角度来看，主串已经走到了\r\nhaystack[5]，相当于我们已经获取了前 6 位字符的信息了，我们已经知道前 6\r\n位是什么字符了，再从 haystack[1]\r\n开始的话就相当于刚见过人家长啥样就忘了，没有利用到已知信息，这就是问题所在。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"失败返回的有效信息\">失败返回的有效信息</h3>\r\n<p>匹配在 e 处失败，整理一下这次匹配获得的信息： -\r\n主串从匹配起点到失败点，必然是\r\nabcab，要不然肯定在前面就失败了，不会在第六位失败。</p>\r\n<p>更普遍一点，在模式串 needle[i] 位失败，那么主串 haystack\r\n在失败点前面必然有 needle[0~i-1] 的所有字符。而因为 needle\r\n是固定不变的，所以不管 i=1，2，3，4，5 ...\r\n主串从匹配起始点到匹配失败点间的字符，都肯定是固定的。</p>\r\n<p>这就是匹配失败告诉我们的教训。</p>\r\n<h3 id=\"利用失败信息\">利用失败信息</h3>\r\n<p>例如匹配情况如下： - xxxxxx abcab<code>d</code> xxxxxx -\r\nabcab<code>e</code></p>\r\n<p>我们甚至不需要知道主串长什么样，只要模式串在 e\r\n处失败，我们就可以闭眼预测——主串失败点前面肯定是 abcab 。</p>\r\n<p>既然我们已经能预测到有 abcab\r\n了，那么我们能做点什么呢？当然能啊，对面都明牌了，我们事先安排好最优匹配策略不就完事。</p>\r\n<p>上例中已知 abcab<code>d</code> ，那人眼显然看出来了——a\r\n开始的匹配失败了，b、c 开头的显然不行，abc<code>ab</code>d 的 ab\r\n恰好直接对上模式串前两位 ab，那我们接下来干嘛呢？当然直接从 ab\r\n的位置接后着匹配 d 和 c： - xxxxxxxx abc<code>ab</code>d xxxxx -\r\n<code>ab</code>cabe</p>\r\n<blockquote>\r\n<p>此时可以发现，主串遍历指针在 d 处失败，直接再从 d 开始，不需要回退到\r\nb ，这是 KMP 的最大优点。</p>\r\n</blockquote>\r\n<p>通过我们事先的预测可以发现，不管主串长什么旮旯样，只要匹配在\r\nabcab<code>e</code>处失败，那么下一个匹配一定可以直接从<code>ab</code>cabe\r\n开始，不需要主串回退遍历。甚至不仅没回退，还在主串不同的情况下，模式串直接免掉了几位的匹配。</p>\r\n<p>假如失败在第 1 位、第 2 位、... 第 i\r\n位呢？显然前面说过，在哪一位匹配失败后，前面都有固定的字符串，我们都可以做好事先预测。</p>\r\n<blockquote>\r\n<p>例 1： - xxxxx abca<code>d</code> xxxx - abca<code>b</code>e\r\n此时我们知道前面是 abca，观察可知接下来的最优方案是直接以 needle[0]\r\n对上主串的第二个 a。</p>\r\n<p>例 2：</p>\r\n<ul>\r\n<li>xxxxx abac<code>d</code> xxxxx</li>\r\n<li>abac<code>e</code> 此时我们知道前面是 abac，但即使 needle[0]\r\n对上了主串失败区间的第二个 a，也必然会失败，因为后面是 c 和 b\r\n的必然不匹配，我们也没必要去尝试了。</li>\r\n</ul>\r\n</blockquote>\r\n<p>通过例 2 我们知道，匹配失败后我们拿 needle\r\n的头部去主串中找一个地方对上，但对上的时候必须有这样一个结构：<strong>模式串前缀\r\naxx 刚好对上主串失败区间的后缀 axx</strong>，这样的匹配才可能成功。</p>\r\n<h3 id=\"怎么事先预测\">怎么事先预测</h3>\r\n<p>现在我们的目标是怎么让程序去做事先预测，只要做好了事先预测，那么每次失败之后的下一步该怎么做就知道了。</p>\r\n<p>我们还知道，失败后可能成功的匹配只有\r\n<strong>模式串前缀=失败区间后缀</strong>，而失败区间又是模式串自己的子串，因此就是<strong>模式串\r\n0~i 的子串的前后缀相同</strong>，i 为模式串的任意位置。</p>\r\n<p>具体来说，在模式串 i 位失败，假如模式串前缀 [0~k-1] 和 0~i 的后缀\r\n[i-k~i-1] 有 k\r\n位相同，那么直接拿前缀去匹配后缀在主串中的位置就可以了。</p>\r\n<p>即：<strong>主串指针不动，前缀有 k-1 位匹配好了，模式串指针跳转到\r\nneedle[k] 继续匹配</strong>。</p>\r\n<blockquote>\r\n<p>在这个例子中： - xxxxxxxx abc<code>ab</code>d xxxxx -\r\n<code>ab</code>cabe</p>\r\n<p>模式串在 e 失败，则指针跳转到下标 2 的位置，以 needle[2] 去匹配 d</p>\r\n</blockquote>\r\n<h3 id=\"创建失效数组\">创建失效数组</h3>\r\n<p>所以我们可以创建一个<strong>失效数组</strong>，第 i 位存储模式串在第\r\ni 位失败后，模式串指针应当跳转到的位置。</p>\r\n<p>而且因为模式串固定，失败后的跳转位置也固定，做好了一个失效数组就可以在任意主串匹配中使用。</p>\r\n<p>所以我们的最终问题在于，检测每个失败区间 0~i 中是否有前后缀相同的 k\r\n位，并据此设定失败后的模式串指针跳转到 needle[k]。</p>\r\n<p>当然找到前后缀相同的 k 位，其实也就是前后缀的模式匹配问题。 &gt;...\r\n嗯，也是模式匹配。 &gt;KMP 让我惊叹地点在于，为了构造 KMP\r\n的失效数组，也用到了 KMP 自身的思想 ...</p>\r\n<p>前后缀计算的主要思想如下： - 前后缀的匹配有动态规划特性，0~i+1\r\n的前后缀，直接和 0~i 的前后缀相关联。例如对于 i 位以前的 0~i-1 有 k\r\n位成功匹配的前后缀：</p>\r\n<pre><code>- 假如 needle[k]==needle[i]，即前后缀可继续累加，0\\~i 则有了 k+1 位前后缀。\r\n\r\n- needle[k]!= needle[i]，相当于此时前后缀 i k 位匹配失败，相当于 0\\~k 的子串作为模式串 needle，去模式匹配后缀的子串，结果在 k 位失败了，按照我们之前失败跳转的思想，这里 k 自然进行跳转到对应位置 lost[k]。</code></pre>\r\n<blockquote>\r\n<p>注意 0~i 的有效前后缀 k 位，是为第 i+1 位的失败服务的，而不是为第 i\r\n位。换句话说，计算出了 0~i 位有 k 位有效的前后缀，那么进行 i++，然后把 k\r\n填入 lost[i]。</p>\r\n</blockquote>\r\n<p>构造失效数组代码，逐句详细注释： <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">GetLost</span><span class=\"params\">(string&amp; needle)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;   </span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">lost</span><span class=\"params\">(needle.size(),<span class=\"number\">0</span>)</span></span>;<span class=\"comment\">//构造等长失效数组，初始值 0</span></span><br><span class=\"line\">    <span class=\"comment\">//KMP</span></span><br><span class=\"line\"></span><br><span class=\"line\">    lost[<span class=\"number\">0</span>]=<span class=\"number\">-1</span>;<span class=\"comment\">//在 0 位失败肯定没法跳跃，-1 表示退出子循环。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k=<span class=\"number\">-1</span>;<span class=\"comment\">//跳跃位置，也即匹配前缀的下一位</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;<span class=\"comment\">//尾部</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;needle.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//前缀还空着或 i k 位相同，即目前为止前后缀仍相同，可以继续累加匹配的前后缀长度。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k==<span class=\"number\">-1</span> || needle[i]==needle[k])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//因为前后缀都是相对于 i 位之前的，在 0~i-1 的有效前后缀，其实是下一位，i 位跳转需要用到的，所以 i++，k++。</span></span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//设定在 i 位失败的跳转位置</span></span><br><span class=\"line\">            <span class=\"comment\">//i k 位不同，则就是跳转到 k。假如 i k 位相同，你说 i 失败了，k 必然也会失败，有啥意义呢，所以跳转到 k 跳转的位置。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(needle[i]!=needle[k])</span><br><span class=\"line\">                lost[i]=k;</span><br><span class=\"line\">            <span class=\"keyword\">else</span><span class=\"comment\">//</span></span><br><span class=\"line\">                lost[i]=lost[k];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//此时前后缀 i k 位匹配失败，相当于 0~k 的子串作为模式串 needle，去模式匹配后缀的子串，结果在 k 位失败了，按照我们之前失败跳转的思想，这里 k 自然进行跳转 ... KMP 内置 KMP 嗯</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>   </span><br><span class=\"line\">            k=lost[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lost;<span class=\"comment\">//完成失效数组</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\r\n<h3 id=\"利用失效数组进行模式匹配\">利用失效数组进行模式匹配</h3>\r\n<p>失效数组有了，每次失败后将模式串指针进行对应跳转即可，此时的模式匹配已经十分简单。</p>\r\n<p>匹配代码，这里只做了一次位置查找，简单修改可以查找出所有位置：\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(string&amp; haystack, string&amp; needle)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">int</span> x=<span class=\"number\">0</span>;<span class=\"comment\">//主串指针</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> y=<span class=\"number\">0</span>;<span class=\"comment\">//模式串指针</span></span><br><span class=\"line\">    vector&lt;<span class=\"keyword\">int</span>&gt; lost=<span class=\"built_in\">GetLost</span>(needle);<span class=\"comment\">//失效数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//模式串匹配</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x&lt;haystack.<span class=\"built_in\">size</span>() &amp;&amp; y&lt;<span class=\"built_in\"><span class=\"keyword\">int</span></span>(needle.<span class=\"built_in\">size</span>())) <span class=\"comment\">//注意这里 int 化！！！！！！很容易出意外的 bug，因为 size 返回值是 unsigned int</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(y==<span class=\"number\">-1</span> ||haystack[x]==needle[y])<span class=\"comment\">//匹配成功，或刚开始</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//当前位没问题，到下一位</span></span><br><span class=\"line\">            x++;</span><br><span class=\"line\">            y++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span><span class=\"comment\">//匹配在 y 失败，跳转到 lost[y]</span></span><br><span class=\"line\">        y=lost[y];</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(y==needle.<span class=\"built_in\">size</span>())<span class=\"comment\">//是模式串完全匹配成功退出循环的，x-y 即首字符位置</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x-y;</span><br><span class=\"line\">    <span class=\"keyword\">else</span><span class=\"comment\">//匹配失败退出循环的</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\r\n","categories":["算法"]},{"title":"LeetCode-No-10","url":"/2020/02/17/LeetCode-No-10/","content":"<h1 id=\"正则表达式匹配\"><a\r\nhref=\"https://leetcode-cn.com/problems/regular-expression-matching\">正则表达式匹配</a></h1>\r\n<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持\r\n'.' 和 '*' 的正则表达式匹配。</p>\r\n<p>'.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素\r\n所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>\r\n<p>说明:</p>\r\n<p>s 可能为空，且只包含从 a-z 的小写字母。\r\np 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例 1:</p>\r\n<p>输入: s = \"aa\" p = \"a\" 输出: false 解释: \"a\" 无法匹配 \"aa\"\r\n整个字符串。</p>\r\n<p>示例 2:</p>\r\n<p>输入: s = \"aa\" p = \"a<em>\" 输出: true 解释: 因为 '</em>'\r\n代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是\r\n'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。</p>\r\n<p>示例 3:</p>\r\n<p>输入: s = \"ab\" p = \".<em>\" 输出: true 解释: \".</em>\"\r\n表示可匹配零个或多个（'*'）任意字符（'.'）。</p>\r\n<p>示例 4:</p>\r\n<p>输入: s = \"aab\" p = \"c<em>a</em>b\" 输出: true 解释: 因为 '*'\r\n表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串\r\n\"aab\"。</p>\r\n<p>示例 5:</p>\r\n<p>输入: s = \"mississippi\" p = \"mis<em>is</em>p*.\" 输出: false</p>\r\n<h1 id=\"解题分析\">解题分析</h1>\r\n<h2 id=\"条件特性\">条件特性</h2>\r\n<ul>\r\n<li>首先可知\".\" 和对应字符的匹配都很容易处理,关键要处理好这个\" * \".</li>\r\n<li>\" * \"带来的变化有,\r\n使前一个字符匹配N次,<strong>N可为0</strong>,也就是说也可以忽略前一个字符.\r\n#### 错误思路\r\n~~由于我一开始没有注意到N可以为0,就采用了一个逐字符匹配的方法,假如遇到一个字符后面有\"<em>\",如果匹配错误则直接返回,匹配正确则维持pi不变,这样一步步推过去,在最后若两个字符串都到了结尾,则成功.后来提交错误后有针对性的修修补补浪费了很长时间,并且发现这种解法下再怎么改也不能AC,最终还是推盘重做T-T~~\r\n## 解题思路\r\n每一次带\"</em>\"的字符处,都会有两种可能的情况,要么匹配这个字符,要么不匹配这个字符.\r\n我们在测试一种情况发现不行之后,需要再退回测试另一种情况下的匹配.因此可以想到可以使用递归返回.</li>\r\n</ul>\r\n<h3 id=\"递归体设置\">递归体设置</h3>\r\n<p>1.若pi+1处为\" * \",则分情况处理 1.1.\r\n如果pi处可正确匹配,则分两个递归,一个是pi匹配1次,一个是pi匹配0次. 1.2.\r\n如果pi处不能匹配,则以pi匹配0次向后递归处理 1.3. 考虑特殊情况,s已经被带\"\r\n*\r\n\"字符匹配完,s为空,p还有至少两个字符存在,则p向后推进两个字符再和已经空的字符进行递归匹配.</p>\r\n<p>2.若pi处为\".\"或可匹配字符,则正常匹配成功,s和p都往后推进1个字符.</p>\r\n<p>3.若pi处为无法匹配字符,return false ### 递归出口\r\n因为我们的递归体若能成功匹配,则S在最底层的递归中,必定是一个空串 -\r\n此时<strong>若p为空串</strong>,则s和p恰好完全匹配成功,return true -\r\n<strong>若p不为空</strong>,则s肯定是被带\" *\r\n\"字符消化掉了,因此参考上面的递归体条件,进入下一次递归中p的带\"<em>\"字符被删掉,此时再进行出口判断.如果p仍不为空,即可return\r\nfalse. 注意p不为空时,有两种情况,并且后一种情况是前一种情况的递归结果\r\n因此<strong>不能简单的直接根据plength!=0直接返回false</strong>.\r\n要<strong>先判断p是否有字符</strong>,若有字符并且是带\" </em>\r\n\"字符,则是可匹配范围内的情况,需递归推两个字符进一步判断.\r\n若p有字符并且不是带\"*\"字符,则是无法正确匹配的情况,return false.</p>\r\n<h1 id=\"初版通过代码\">初版通过代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isMatch</span><span class=\"params\">(string s, string p)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> si = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> pi = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> slength = s.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> plength = p.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (slength != <span class=\"number\">0</span> &amp;&amp; plength == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (slength == <span class=\"number\">0</span> &amp;&amp; plength == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (p[pi + <span class=\"number\">1</span>] == <span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (slength == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">isMatch</span>(s.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>), p.<span class=\"built_in\">substr</span>(pi + <span class=\"number\">2</span>, plength - pi - <span class=\"number\">2</span>));</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(p[pi] == <span class=\"string\">&#x27;.&#x27;</span> || p[pi] == s[si])</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//pi匹配1次s前进p不变  pi匹配0次s不变p前进2</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">isMatch</span>(s.<span class=\"built_in\">substr</span>(si + <span class=\"number\">1</span>, slength - si - <span class=\"number\">1</span>), p.<span class=\"built_in\">substr</span>(pi, plength - pi)) || <span class=\"built_in\">isMatch</span>(s.<span class=\"built_in\">substr</span>(si, slength - si), p.<span class=\"built_in\">substr</span>(pi + <span class=\"number\">2</span>, plength - pi - <span class=\"number\">2</span>));</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">isMatch</span>(s.<span class=\"built_in\">substr</span>(si, slength - si), p.<span class=\"built_in\">substr</span>(pi + <span class=\"number\">2</span>, plength - pi - <span class=\"number\">2</span>));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (slength == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p[pi] == <span class=\"string\">&#x27;.&#x27;</span> || p[pi] == s[si])</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">isMatch</span>(s.<span class=\"built_in\">substr</span>(si + <span class=\"number\">1</span>, slength - si - <span class=\"number\">1</span>), p.<span class=\"built_in\">substr</span>(pi + <span class=\"number\">1</span>, plength - pi - <span class=\"number\">1</span>));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>624 ms</li>\r\n<li>16.4 MB</li>\r\n<li>Cpp 虽然已经AC了,时间空间上还是很笨拙的,日后找时间探索优化解法.\r\n-------------\r\n动态规划，以dp[i][j]为状态标志位，为1表示s的前i个字符和p的前j个字符可以匹配。\r\n注意dp[0][0]==1表示空字符串时可以匹配。 <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//两层for循环</span><br><span class=\"line\">for(i)</span><br><span class=\"line\">  for(j)</span><br></pre></td></tr></table></figure>\r\n通过判断当前字符匹配情况，加上前面的子串情况进行累积动态规划，最终达到dp[slength][plength]的值。</li>\r\n</ul>\r\n<h2\r\nid=\"理解了思路但实战这道题还是有细节方面思路不清继续挖坑\">理解了思路，但实战这道题还是有细节方面思路不清，继续挖坑。</h2>\r\n","categories":["算法"]},{"title":"LeetCode-No-1","url":"/2020/02/17/LeetCode-No-1/","content":"<h1 id=\"两数之和\"><a\r\nhref=\"https://leetcode-cn.com/problems/two-sum\">两数之和</a></h1>\r\n<p>给定一个整数数组 <code>nums</code> 和一个目标值\r\n<code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。\r\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>\r\n<p>示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] =\r\n2 + 7 = 9 所以返回 [0, 1]</p>\r\n<h3 id=\"解决思路\">1.解决思路</h3>\r\n<p><strong>暴力遍历</strong>，我们需要找出两个数满足一个数值和的需求，我首先想到的就是通过遍历尝试，简单暴力。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"keyword\">int</span> twoSum(vector&lt;<span class=\"keyword\">int</span>&amp; nums, <span class=\"keyword\">int</span> target) </span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=0;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j=0;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=0;i&lt;nums.size()-1;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j=i+1;j&lt;nums.size();j++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[i]+nums[j]==target)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    result.push_back(i);</span><br><span class=\"line\">                    result.push_back(j);</span><br><span class=\"line\">                    j=nums.size();</span><br><span class=\"line\">                    i=j-1;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>通过</li>\r\n<li>472 ms</li>\r\n<li>9.2 MB</li>\r\n<li>Cpp</li>\r\n</ul>\r\n<h3 id=\"优化思路\">2.优化思路</h3>\r\n<p>显然暴力解法最容易想但效率也大量浪费在了无谓的二层循环中，直接导致了O(n^2)的复杂度。\r\n<strong>细化需求</strong>，当我们找到一个数，本来是要在二层循环中尝试找到可以组合的数，我们已知数值寻找位置，因此可以考虑到使用<strong>map哈希表</strong>来构造数据结构,使用\r\n<strong>空间换时间</strong>。 哈希表查找复杂度为O(1)</p>\r\n<p><strong><em>两遍哈希表</em></strong>，我们把数组遍历存入map中，消耗O(n)，然后再对每一个数进行遍历，每次只要在map中寻找其对应的数值是否存在即可，总时间复杂度为2O(n)。\r\n<strong><em>一遍哈希表</em></strong>\r\n：在存入map时即对对应的匹配数进行查找，优化复杂度至O(n)。</p>\r\n<h3 id=\"最终实现代码\">3.最终实现代码</h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"keyword\">int</span> twoSum(vector&lt;<span class=\"keyword\">int</span>&amp; nums, <span class=\"keyword\">int</span> target) </span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        map&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span> store;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=0;i&lt;nums.size();i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(store.count(target-nums[i])0)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                result=vector&lt;<span class=\"keyword\">int</span>(&#123;store[target-nums[i]],i&#125;);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            store.insert(map&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>::value_type(nums[i],i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>通过</li>\r\n<li>20 ms</li>\r\n<li>10.1 MB</li>\r\n<li>Cpp</li>\r\n</ul>\r\n","categories":["算法"]},{"title":"LeetCode No.136","url":"/2020/08/20/LeetCode-No-136/","content":"<h1 id=\"只出现一次的数字\"><a\r\nhref=\"https://leetcode-cn.com/problems/single-number\">只出现一次的数字</a></h1>\r\n<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>\r\n<p>说明：</p>\r\n<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>\r\n<p>示例 1:</p>\r\n<p>输入：[2,2,1] 输出：1</p>\r\n<p>示例 2:</p>\r\n<p>输入：[4,1,2,1,2] 输出：4</p>\r\n<h1 id=\"算法思想\">算法思想</h1>\r\n<p>老规矩找到问题给出的性质——目标元素只出现一次，剩余元素出现<strong>两次</strong>。</p>\r\n<p>不多不少，正好两次。显然这是一个主要的突破口。</p>\r\n<p>两次很容易让我们想到，假如非目标元素两两揍一顿互相抵消就好了。什么方式可以让相同的数抵消，不同的数保留呢？</p>\r\n<h3 id=\"数位的异或运算\">数位的异或运算</h3>\r\n<p>位的角度来看：1^1=0 0^0=0 1<sup>0=0</sup>1=1</p>\r\n<p>即相同的位会清空，不相同的位会保留。</p>\r\n<p>并且多位运算时：1<sup>1</sup>0=1<sup>(1</sup>0)=(1<sup>0)</sup>1=0</p>\r\n<p>易知位的异或运算具有结合律和交换律——即运算顺序不影响运算结果</p>\r\n<h3 id=\"数的异或\">数的异或</h3>\r\n<p>从数位异或中可以看出，偶数次的 1 或者 0 运算后都是\r\n0，在数的层面上也是一样，出现偶数次的数两两运算后也为 0。而 0\r\n和任何数异或等于数本身。</p>\r\n<p>因此对整个数组进行异或运算，相当于最后剩个 0\r\n和目标元素异或，结果就是目标值。</p>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//异或运算 相同的数异或归 0 且异或具有交换律</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> result=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> num :nums)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result^=num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-11","url":"/2020/02/17/LeetCode-No-11/","content":"<h1 id=\"盛最多水的容器\"><a\r\nhref=\"https://leetcode-cn.com/problems/container-with-most-water\">盛最多水的容器</a></h1>\r\n<p>给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai)\r\n。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i,\r\n0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>\r\n<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>\r\n<p>图中垂直线代表输入数组\r\n[1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>\r\n<p> <img\r\nsrc=\"https://upload-images.jianshu.io/upload_images/19387483-4f82d6d77b0bc922.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"\r\nalt=\"image.png\" /></p>\r\n<p>示例:</p>\r\n<p>输入: [1,8,6,2,5,4,8,3,7] 输出: 49</p>\r\n<h1 id=\"解题分析\">解题分析</h1>\r\n<ul>\r\n<li>双循环暴力法是人类本能,就不侃了,直接放上辣眼睛的效率结果</li>\r\n</ul>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>通过情况</th>\r\n<th>时间</th>\r\n<th>内存</th>\r\n<th>语言</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>通过</td>\r\n<td>2436 ms</td>\r\n<td>9.8 MB</td>\r\n<td>Cpp</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<ul>\r\n<li><strong>正解</strong>: 双指针向内收缩法.即一指针在头部,一指针在尾部,\r\n而收缩时面积由两端之短决定,我们要找到更大的面积,则必定要改变两端之短,所以每次将短的那边往里收缩,遍历O(n).</li>\r\n<li><strong>正确性</strong>: S=min(ai,aj)\r\n<em>(j-i),假如大的那一边往里收缩则S=min(bi,bj)</em> (j-i-1).\r\n则min(bi,bj)要么是比收缩前最小值还小的值,要么是收缩前的最小值,所以S必定变小.\r\n因此双指针移动大的一端时,得到的S2&lt;=S1,肯定不是正确方向,所以可以省略掉这一系列的遍历,即只移动每对中小的那一端即可,省下O(n)的遍历不需要尝试,最终的遍历效率是O(n).</li>\r\n</ul>\r\n<h1 id=\"解题代码\">解题代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&amp; height)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;   <span class=\"comment\">//双指针 思考正确性</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j=height.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> Area;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> MaxArea=<span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> minvalue=<span class=\"built_in\">min</span>(height[i],height[j]);</span><br><span class=\"line\">            Area=minvalue*(j-i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(AreaMaxArea)</span><br><span class=\"line\">                MaxArea=Area;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(height[i]==minvalue)</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> MaxArea;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-15-","url":"/2020/02/17/LeetCode-No-15-/","content":"<h1 id=\"三数之和\"><a\r\nhref=\"https://leetcode-cn.com/problems/3sum\">三数之和</a></h1>\r\n<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素\r\na，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>\r\n<p>注意：答案中不可以包含重复的三元组。</p>\r\n<p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>\r\n<p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2]]</p>\r\n<h1 id=\"思路分析\">思路分析</h1>\r\n<ul>\r\n<li><p>暴力O(n3) 这样做还不如不做kj</p></li>\r\n<li><p>联想<strong>两数之和</strong>那道题，可以采用map哈希来查找需要的值，但由于要先确定两个数之和，才能知道需要的值，所以有时间O(n2)+空间O(n)。</p></li>\r\n<li><p><strong>牺牲O(Nlog\r\nN)对数组sort，排序之后找数即可用双指针头尾同步进行</strong></p></li>\r\n<li><p>我的做法是，对于a&lt;=b&lt;=c，a+b+c=0，先确定b为<code>center</code>，然后对于center的每一次循环中，都让a,c分别从首尾开始，根据<code>sum=a+b+c</code>与0相比，判断是要a++还是c--。\r\n这里要注意人为考虑特殊情况，<strong>注意剪枝</strong>，否则像{0,0,0,0,0,0,0,0,0,0,0}会没意义的算很多遍。另外在每个center的内循环中，显然假如<strong>最小值大于0</strong>，或者<strong>最大值小于0</strong>，是不可能和为0，可以剪枝。</p></li>\r\n<li><p>另外，当数组中有重复数字时，会重复进行循环匹配，因此我额外使用了一个<code>set</code>。</p></li>\r\n<li><p><code>if(sum==0)</code>之后，额外加一个<code>if(set.count(vector)==0)</code>来判断是否已经有了相同的组合被存储了，如果没有，则<code>set</code>和<code>result</code>同时存储这个新组合，set中存储是为了对之后判重。</p></li>\r\n</ul>\r\n<h1 id=\"解题代码\">解题代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"keyword\">int</span> threeSum(vector&lt;<span class=\"keyword\">int</span>&amp; nums) </span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span> result;</span><br><span class=\"line\">        set&lt;vector&lt;<span class=\"keyword\">int</span> resultset;</span><br><span class=\"line\">        //剪枝</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.size() &lt;= 2)</span><br><span class=\"line\">   <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        </span><br><span class=\"line\">  sort(nums.begin(), nums.end());</span><br><span class=\"line\">        </span><br><span class=\"line\">        //不剪枝会被0吓死=.=</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nums[0]=0 ||nums[nums.size()-1]&lt;=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (nums[0] == 0 &amp;&amp;nums[nums.size()-1]==0)</span><br><span class=\"line\">    result.push_back(&#123; 0,0,0 &#125;);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> center;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(center=0;center&lt;nums.size();center++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            i=0;</span><br><span class=\"line\">            j=nums.size()-1;</span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i!=center &amp;&amp;j!=center)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[i]0 || nums[j]&lt;0)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">int</span> sum=nums[i]+nums[center]+nums[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(sum==0)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    vector&lt;<span class=\"keyword\">int</span> temp =&#123;nums[i],nums[center],nums[j]&#125;;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(resultset.count(temp)==0)</span><br><span class=\"line\">                    &#123;   </span><br><span class=\"line\">                        result.push_back(temp);</span><br><span class=\"line\">                        resultset.insert(temp);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                    j--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum&lt;0)</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum0)</span><br><span class=\"line\">                    j--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<table style=\"width:10%;\">\r\n<colgroup>\r\n<col style=\"width: 9%\" />\r\n</colgroup>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>执行用时 : 424 ms, 在所有 C++ 提交中击败了5.01%的用户 内存消耗 :24.3\r\nMB, 在所有 C++ 提交中击败了7.53%的用户</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>虽然好像剪枝也做了，但好像效率依然不够高，不知道是不是额外加了个set的问题\r\n看别人的题解，<strong>不以b以a为外循环可以避免重复</strong>，也就不需要set，但没懂是为什么。\r\n挖个坑，搞懂了再回来看看。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n","categories":["算法"]},{"title":"LeetCode-No-16","url":"/2020/02/17/LeetCode-No-16/","content":"<h1 id=\"最接近的三数之和\"><a\r\nhref=\"https://leetcode-cn.com/problems/3sum-closest\">最接近的三数之和</a></h1>\r\n<p>给定一个包括 n 个整数的数组 nums 和\r\n一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>\r\n<p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</p>\r\n<p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p>\r\n<h1 id=\"解题思路\">解题思路</h1>\r\n<ul>\r\n<li>一开始我想分解问题，确定一个数，找最接近的两个数，其中找两个数的过程也是通过确定一个数，找最接近的最后一个数。解题不难，但复杂度很高。</li>\r\n<li>又是一个逼近问题，做了几道现在应该领悟到了<strong>双指针逼近</strong>的方法是一个很好的寻找逼近值的策略。</li>\r\n</ul>\r\n<h3 id=\"算法主体\">算法主体</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">while(i&lt;j)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if(sum&lt;target)</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">  else if(sumtarget)</span><br><span class=\"line\">    j--;</span><br><span class=\"line\">  else if(sum==target)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>算法简单，但实现细节需要考虑，并不是出口附近的sum就一定是最接近的sum。</li>\r\n</ul>\r\n<p>假如简单的取上面这个粗糙的循环，对于实例([-101,-100,0,2,3,4,5,6,7,8,9,10],-99)。当i从-100移到0之后，j一直减到i期间的sum都没有i=-100处的sum良好，但却会作为出口给人最优的错觉。</p>\r\n<p>错误经验：最优解也并不是取最后一次i变动的sum和最后一次j变动的sum，因为可能变i变j再变i反复变化，然而最优解其实一直停留在第一个变i之前。</p>\r\n<ul>\r\n<li>我自己的解决办法是把所有的sum都存储起来，最后统一遍历找出最优解，但显然这样需要花一点点时间。</li>\r\n</ul>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">threeSumClosest</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&amp; nums, <span class=\"keyword\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> result;</span><br><span class=\"line\">  <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">  vector&lt;<span class=\"keyword\">int</span> sums;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> sum;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> resultdistance = INT_MAX;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (a = 0; a &lt; nums.size() - 2; a++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   b = a + 1;</span><br><span class=\"line\">   c = nums.size() - 1;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">while</span> (b &lt; c)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">    sum = nums[a] + nums[b] + nums[c];</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    sums.push_back(sum);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sum &lt; target)</span><br><span class=\"line\">     b++;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum  target)</span><br><span class=\"line\">     c--;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=0;i&lt;sums.size();i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(abs(target - sums[i]) &lt; resultdistance)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     result = sums[i];</span><br><span class=\"line\">     resultdistance = abs(target - result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<hr />\r\n<p>不存储所有结果，直接在每个sum之后与result比较，效率比存储的高了4ms。</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>提交结果</th>\r\n<th>执行用时</th>\r\n<th>内存消耗</th>\r\n<th>语言</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>2019.9.15</td>\r\n<td>通过</td>\r\n<td>12 ms</td>\r\n<td>8.7 MB</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>2019.9.11</td>\r\n<td>通过</td>\r\n<td>16 ms</td>\r\n<td>12.9 MB</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>8ms可能是做不到了，量级上应该一样。</p>\r\n","categories":["算法"]},{"title":"LeetCode-No-22","url":"/2020/02/17/LeetCode-No-22/","content":"<h1 id=\"括号生成\"><a\r\nhref=\"https://leetcode-cn.com/problems/generate-parentheses\">括号生成</a></h1>\r\n<p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>\r\n<p>例如，给出 n = 3，生成结果为：</p>\r\n<p>[ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]</p>\r\n<h1 id=\"题解分析\">题解分析</h1>\r\n<ul>\r\n<li><p>一开始我想创建一个2n的string数组\r\n因为string（包括子串）第一个空位一定会是' ( ' 因此我的算法思路是\r\n第一位肯定是' ( ' 不变，然后在剩下的length-1空位中遍历选一处插入')'\r\n然后递归进入子串插入，也是子串第一位 '( ' 不变，遍历剩下的空位一次次插入\r\n')' ，直到递归完成括号串。\r\n这种算法不能避免重复，而且我在创建动态长度的字符串这里就失败了=。=\r\n但没看到相似的思路，因此写下来说不定以后能够优化一下。</p></li>\r\n<li><h3 id=\"标准思路\">标准思路</h3></li>\r\n</ul>\r\n<p>递归对每一位进行检测，如果' ( '数量少，则这一位插入' (\r\n'进入递归，否则插入' ）'进行递归，直到填满。</p>\r\n<p>因为这种方法会遍历完所有'（'可能的位置，进而能够确定括号串，因此不会重复也不会遗漏。</p>\r\n<ul>\r\n<li><h3 id=\"递归法代码\">递归法代码</h3></li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;string generateParenthesis(<span class=\"keyword\">int</span> n)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vector&lt;string result;</span><br><span class=\"line\">       </span><br><span class=\"line\">        Recursion(n,&quot;&quot;,0,0,result);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">void</span>  Recursion(<span class=\"keyword\">int</span> n,string temp,<span class=\"keyword\">int</span> left ,<span class=\"keyword\">int</span> right,vector&lt;string&amp; result)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(temp.size()== 2*n)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result.push_back(temp);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left&lt;n)</span><br><span class=\"line\">            Recursion(n,temp+&#x27;(&#x27;,left+1,right,result);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(right&lt;left)</span><br><span class=\"line\">            Recursion(n,temp+&#x27;)&#x27;,left,right+1,result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>提交时间</th>\r\n<th>提交结果</th>\r\n<th>执行用时</th>\r\n<th>内存消耗</th>\r\n<th>语言</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>2 天前</td>\r\n<td>通过</td>\r\n<td>20 ms</td>\r\n<td>17 MB</td>\r\n<td>Cpp</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<ul>\r\n<li><h3 id=\"动态规划\">动态规划</h3></li>\r\n</ul>\r\n<p>因为递归法效率还没有极致，因此看了看题解大神的解法，发现了一位用动态规划的人才。\r\n给上链接 ：</p>\r\n<h3 id=\"闭合数的合理解释-jerry-peng\"><a\r\nhref=\"%5Bhttps://leetcode-cn.com/problems/generate-parentheses/solution/bi-he-shu-de-he-li-jie-shi-by-jerry-peng/%5D(https://leetcode-cn.com/problems/generate-parentheses/solution/bi-he-shu-de-he-li-jie-shi-by-jerry-peng/)\">闭合数的合理解释-Jerry\r\nPeng</a></h3>\r\n<ul>\r\n<li><p>算法分析 对于每个n对括号的括号串S[n] 都可以划分为两个部分\r\n<code>S[n] = '(' + S[c] + ')' + S[n-c-1];</code>\r\n第一对括号里面带着c长度的子问题， 右边剩下部分n-c-1长度的子问题\r\n<strong>自底向上，存储子问题结果，逐步合并到n长度的问题</strong>。\r\n因为要找到所有可能结果，因此c的取值需要遍历所有可能。</p></li>\r\n<li><h3 id=\"动态规划代码\">动态规划代码</h3></li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;string generateParenthesis(<span class=\"keyword\">int</span> n)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       map&lt;<span class=\"keyword\">int</span>,vector&lt;string resultmap;</span><br><span class=\"line\">        resultmap[0].push_back(&quot;&quot;);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=1;i&lt;=n;i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=0;j&lt;i;j++)</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(string left: resultmap[j])</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(string right: resultmap[i-j-1])</span><br><span class=\"line\">                    resultmap[i].push_back(&quot;(&quot;+left+&quot;)&quot;+right);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> resultmap[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>提交时间</th>\r\n<th>提交结果</th>\r\n<th>执行用时</th>\r\n<th>内存消耗</th>\r\n<th>语言</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>2 天前</td>\r\n<td>通过</td>\r\n<td>12 ms</td>\r\n<td>9.6 MB</td>\r\n<td>Cpp</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<hr />\r\n<p><strong>有想过为什么不直接分为left 和 right\r\n两个部分，一定要套个括号</strong> 　——假如只分两半left 和\r\nright，那在求解S[n]遍历的时候肯定要遍历到S[n]自身，因此需要先固定好一对括号，这样遍历会停止在S[n-1]的子问题，然后合并出待解的S[n]问题。</p>\r\n","categories":["算法"]},{"title":"LeetCode No.221","url":"/2020/07/31/LeetCode-No-221/","content":"<h1 id=\"最大正方形\"><a\r\nhref=\"https://leetcode-cn.com/problems/maximal-square\">最大正方形</a></h1>\r\n<p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1\r\n的最大正方形，并返回其面积。</p>\r\n<p>示例:</p>\r\n<p>输入:</p>\r\n<p>1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0</p>\r\n<p>输出: 4</p>\r\n<h1 id=\"算法思想\">算法思想</h1>\r\n<p>大正方形必然是由小正方形迭代上来的。因此这题是个明显的动态规划题，但是我们怎么去确定状态转移方程呢？</p>\r\n<h3 id=\"状态转移方程的理解\">状态转移方程的理解</h3>\r\n<p>首先我们确定，正方形是从左上往右下进行延展(其他延展方向也行)。</p>\r\n<h5\r\nid=\"我们什么时候可以延展这个正方形呢\">我们什么时候可以延展这个正方形呢？</h5>\r\n<p>首先新找到的点肯定得是\r\n<code>1</code>，要不然不可能构成正方形。以matrix[i][j]位为1，我们可以得到示例如下：\r\na a a x a a a x a a a x x x x 1</p>\r\n<p>因为是正方形，所以假如 [i][j]位要构成新的正方形，那必然是从左上角的 a\r\n区域延展下来的。</p>\r\n<p>但是即使 a\r\n区域是正方形，[i][j]位是1，就一定形成新正方形吗？并没有</p>\r\n<p>当我们把正方形延展到[i][j]位时，其实[i]行和[j]列对应边也都扩展进去了，也就是上例的\r\nx 区域，也要是1才能延展构成新正方形。</p>\r\n<h5\r\nid=\"即我们现在知道延展正方形受限于哪些环境\">即我们现在知道延展正方形受限于哪些环境</h5>\r\n<ul>\r\n<li><p>左上角的 a 区域的正方形有多大，新正方形则是边长++</p></li>\r\n<li><p>x 区域，从[i][j]分别往左和往上走，能提供的最大边长。</p>\r\n<p>如下，虽然 a\r\n区域是边长3的正方形，本来想要以[i][j]为新顶点扩展成边长4的正方形，但是由于新的两条边长度只有1，满足不了边长4的正方形的要求。</p>\r\n<p>因此[i][j]只能构成边长2的正方形。</p></li>\r\n</ul>\r\n<p>受限于 x 区域新边长的延展 1 1 1 0 1 1 1 0 1 1 1 1 0 0 1 1</p>\r\n<h5 id=\"得出状态转移方程\">得出状态转移方程</h5>\r\n<p>因此总结一下状态转移方程：</p>\r\n<p><code>[i][j]位的正方形边长=min( [i-1][j-1]的正方形边长，新的两边边长 ) + 1</code></p>\r\n<p>伪代码即\r\n<code>dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1</code></p>\r\n<p>其中dp[i][j]表示[i][j]位作为左下角时，形成正方形的边长。</p>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maximalSquare</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">char</span>&amp; matrix)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//动态规划，如何理解dp的递归式</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> width=matrix.<span class=\"built_in\">size</span>();<span class=\"keyword\">if</span>(width==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length=matrix[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();<span class=\"keyword\">if</span>(length==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span> dp(width+1,vector(length+1,0));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result=0;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=0;i&lt;width;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=0;j&lt;length;j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(matrix[i][j]==&#x27;1&#x27;)</span><br><span class=\"line\">                    dp[i+1][j+1]=min(min(dp[i][j],dp[i][j+1]),dp[i+1][j])+1;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    dp[i+1][j+1]=0;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(dp[i+1][j+1]result)</span><br><span class=\"line\">                    result=dp[i+1][j+1];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result*result;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"],"tags":["动态规划"]},{"title":"LeetCode-No-23","url":"/2020/02/17/LeetCode-No-23/","content":"<h1 id=\"合并k个链表\"><a\r\nhref=\"https://leetcode-cn.com/problems/merge-k-sorted-lists\">合并K个链表</a></h1>\r\n<p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>\r\n<p>示例:</p>\r\n<p>输入: [ 　1-4-5,   　1-3-4,   　2-6] 输出: 1-1-2-3-4-4-5-6</p>\r\n<h1 id=\"解题分析\">解题分析</h1>\r\n<ul>\r\n<li><p>因为之前做过2个排序链表的合并，所以这里主要想法是两两归并。\r\n两个链表合并：双指针判断对应节点大小，依次插入新链表，若一个链表用尽，则在result链表后接上另一个链表即可。</p></li>\r\n<li><p>归并其实也有讲究，我一开始直接用的是顺序归并<code>result=mergeTwoLists(result,temp)</code>，其实浪费了很多效率，把不必要的排序比较一遍又一遍的做。</p></li>\r\n<li><p>如下方题解代码，使用了折半归并（直观描述词）。每次合并<code>List i =mergeTwoLists(List i,List i+halflength)</code>.\r\n直到长度为1即完成。</p></li>\r\n</ul>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * struct ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode *next;</span><br><span class=\"line\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class=\"line\"> * &#125;;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    ListNode* mergeKLists(vector&lt;ListNode*&amp; lists) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ListNode* result=NULL;</span><br><span class=\"line\">        int length=lists.size();</span><br><span class=\"line\">        if(length==0)</span><br><span class=\"line\">            return NULL;</span><br><span class=\"line\">        while(length1)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            int temp=(length+1)/2;</span><br><span class=\"line\">            for(int i=0;i&lt;length/2;i++)</span><br><span class=\"line\">                lists[i]=mergeTwoLists(lists[i],lists[i+temp]);</span><br><span class=\"line\">            </span><br><span class=\"line\">            length=temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        return lists[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    ListNode result(0);</span><br><span class=\"line\">    ListNode* another = &amp;result;</span><br><span class=\"line\"></span><br><span class=\"line\">    while (l1 != NULL &amp;&amp; l2 != NULL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">     if (l1-val &lt;= l2-val)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">      another-next = l1;</span><br><span class=\"line\">      l1 = l1-next;  </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     else</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">      another-next = l2;</span><br><span class=\"line\">      l2 = l2-next;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">              </span><br><span class=\"line\">              another = another-next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">                   </span><br><span class=\"line\">          another-next=(l1==NULL)?l2:l1;</span><br><span class=\"line\">    return (&amp;result)-next;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode No.264","url":"/2021/03/03/LeetCode-No-264/","content":"<h1 id=\"丑数ii\"><a\r\nhref=\"https://leetcode-cn.com/problems/ugly-number-ii\">丑数II</a></h1>\r\n<p>编写一个程序，找出第 n 个丑数。</p>\r\n<p>丑数就是质因数只包含 2, 3, 5 的正整数。</p>\r\n<p>示例:</p>\r\n<p>输入: n = 10 输出: 12 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10\r\n个丑数。</p>\r\n<p>说明:  </p>\r\n<p>1 是丑数。 n 不超过1690。</p>\r\n<h1 id=\"算法思想\">算法思想</h1>\r\n<p>显而易见，我们要找分解式为 2 3 5\r\n构成的数。也容易想到，<strong>后面的丑数必然是由前面的丑数乘 2 3 5\r\n得到的</strong>。</p>\r\n<p>但是从前往后顺序计算乘积，并且顺序存放的话，例如<code>2*5  3*3</code>。可以看出先后顺序错位了，10先存放，而9后存放。</p>\r\n<p>因此要取计算的所有乘积的最小值,\r\n这个最小值必然是从小到大的下一个ugly，解决了存放的错位问题。</p>\r\n<h3 id=\"但是对哪些乘积取最小值呢\">但是对哪些乘积取最小值呢？</h3>\r\n<p>前面的数都计算一遍乘积的话计算量太大</p>\r\n<p>想一下，假如有 2*3， 那么对所有x2,x*3必然没有2*3小，因此对 3\r\n这个因子，只需要计算它和2的乘积即可。后面的肯定不是我们要找的最小乘积。</p>\r\n<p>因此，其实只要<strong>为每个因子找到当前最小的乘数即可</strong>。</p>\r\n<h3\r\nid=\"怎么确定每个因子的当前最小乘数呢\">怎么确定每个因子的当前最小乘数呢？</h3>\r\n<p>要找当前最小的，首先要确定这个因子的候选乘数有哪些，然后在里面找最小的。</p>\r\n<h4 id=\"哪些是候选乘数\">哪些是候选乘数？</h4>\r\n<p>我们找当前最小乘数是为了找出下一个最小的丑数。假如要生成所有丑数的话，每个因子都必然要遍历去乘每一个数。</p>\r\n<p>换句话说，对这个因子，所有数都是要乘的，跑不了的，即所有没乘过的数，都是它的候选乘数。</p>\r\n<h4 id=\"最小的候选乘数\">最小的候选乘数</h4>\r\n<p>既然所有数都要乘，而我们的数又是从小到大排列的，那么从前往后，第一个没有乘过的就是当前最小乘数。</p>\r\n<p>代码角度来看，即当前乘数为nums[i]，每乘一次，即i++,准备乘下一个数即可。</p>\r\n<h1 id=\"解题代码\">解题代码</h1>\r\n<p>注意我们有三个因子，因此需要用三个指针对三个因子维护他们的最小乘数。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">nthUglyNumber</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//动态规划，后面的数必然是前面的数乘 2 3 5得到</span></span><br><span class=\"line\">        <span class=\"comment\">//但是顺序进行的话 2*5  3*3 ，可以看出大小顺序不能保证，因此要取几个乘积的最小值,这个最小值必然是从小到大的下一个ugly</span></span><br><span class=\"line\">        <span class=\"comment\">//但是对哪些乘积取最小值呢？前面的数都计算一遍的话计算量太大。</span></span><br><span class=\"line\">        <span class=\"comment\">//想一下，假如有 2*3， 那么对所有x2,x*3必然没有2*3小，因此对 3 这个乘积，其实只要找到最小的乘数即可，其他乘积也是一样</span></span><br><span class=\"line\">        <span class=\"comment\">//怎么确定每个乘积的最小乘数呢？显然每个乘积都要乘每个数，那么从前往后找没乘过的 就是当前最小乘数</span></span><br><span class=\"line\"></span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span> nums(n,0);</span><br><span class=\"line\">        nums[0]=1;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p2=0,p3=0,p5=0;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=1;i&lt;n;i++)//除1外 生成n-1个丑数</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ugly_i=min(min(nums[p2]*2,nums[p3]*3),nums[p5]*5);//取当前乘积最小值</span><br><span class=\"line\">            nums[i]=ugly_i;</span><br><span class=\"line\">            //判断用的是哪个乘积，它的最小乘数要变了，注意重复的也算</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ugly_i==nums[p2]*2) p2++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ugly_i==nums[p3]*3) p3++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ugly_i==nums[p5]*5) p5++;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[n-1];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"],"tags":["动态规划"]},{"title":"LeetCode-No-28-(KMP)","url":"/2020/02/17/LeetCode-No-28-(KMP)/","content":"<h1 id=\"实现-strstr-函数\"><a\r\nhref=\"https://leetcode-cn.com/problems/implement-strstr\">实现 strStr() 函数</a></h1>\r\n<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack\r\n字符串中找出 needle 字符串出现的第一个位置\r\n(从0开始)。如果不存在，则返回  -1。</p>\r\n<p>示例 1:</p>\r\n<p>输入: haystack = \"hello\", needle = \"ll\" 输出: 2</p>\r\n<p>示例 2:</p>\r\n<p>输入: haystack = \"aaaaa\", needle = \"bba\" 输出: -1</p>\r\n<p>说明:\r\n当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\r\n对于本题而言，当 needle 是空字符串时我们应当返回 0\r\n。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>\r\n<blockquote>\r\n<p>显然这题主要目标是在主串中找到一个模式串，而我在数据结构课中有学到<strong>KMP</strong>算法，因此我首选题解就是<strong>实现KMP</strong>。</p>\r\n</blockquote>\r\n<h2 id=\"kmp-主要思想不回退的主串查找位有效利用失败信息\">KMP\r\n（主要思想：<strong>不回退的主串查找位，有效利用失败信息</strong>）</h2>\r\n<h3 id=\"暴力法存在的问题\">暴力法存在的问题</h3>\r\n<p>主串abcdabcdabce，模式串abcdabce. 标志位 i，j</p>\r\n<p>我们可以知道第一次匹配会在abcdabc<code>d</code>abce，abcdabc<code>e</code>处失败\r\n在暴力法中，失败后 i ++，j=0，从i=1，j=0 处再次开始一轮匹配。\r\n即主串明明匹配到了第8位，失败后却还要回退到第二位开始新的匹配，无疑浪费了很多时间。</p>\r\n<h3 id=\"失败返回的有效信息\">失败返回的有效信息</h3>\r\n<p>模式串在 e 处失败，可以带给我们什么有效信息：</p>\r\n<ol type=\"1\">\r\n<li>主串前面有<code>abcdabc</code></li>\r\n<li>主串这一位不为<code>e</code></li>\r\n</ol>\r\n<h3 id=\"利用返回的有效信息\">利用返回的有效信息</h3>\r\n<p>已经已知主串有了这七个字符，按人的思维去分析的话，可以知道主串前四位<code>abcd</code>都没必要去做新的匹配模式串的循环了，因为一定会失败，而5\r\n~ 7位<code>abc</code>虽然是在匹配模式串的5 ~\r\n7位匹配出来的，但是却也可以匹配模式串的前三位。因为这些都是已知信息，所以我们可以直接当失败处abcd<code>abc</code>d已经匹配了模式串的<code>abc</code>，只需要拿<code>d</code>去匹配<code>d</code>即可。</p>\r\n<p>相当于不仅没回退，还可以在当前位置上直接跳过模式串前三位进行后续匹配。</p>\r\n<p>而把上面的思路写成逻辑，我们就需要分析其产生的原因条件，以及导出的结果</p>\r\n<p><strong>为什么恰巧可以跳过呢</strong>？让我们来看一下跳过时的环境条件</p>\r\n<ol type=\"1\">\r\n<li>失败前的倒数几位，刚好可以拿去匹配正数前几位，因此相当于匹配好了前几位</li>\r\n<li>这种在某一位失败之后能否产生跳跃的信息，只和模式串本身有关，和主串无关，因为我们是用失败的倒数几位去匹配前几位，全是模式串自己。</li>\r\n</ol>\r\n<p>因此我们可以找到跳过的思路，对于匹配失败时：</p>\r\n<ol type=\"1\">\r\n<li>假如模式串在这个字符之前的倒数几位能和整数几位匹配，那就直接略过，i\r\n不变，j 跳到整数几位的后一位接着匹配</li>\r\n<li>假如不能形成这种前后缀的匹配，则直接让 i\r\n++，在下一位开始全新的匹配</li>\r\n</ol>\r\n<blockquote>\r\n<p>i 不用回到这次匹配的开头再i++，假如回到开头再 i++\r\n，我们的目标是当前匹配失败了，主串字符串匹配区间右移一位是不是能匹配成功。然而这种匹配成功的条件必须是<strong>区间右移后，和移动前的重叠区域字符相同。即在重叠区域内，pat[i+1]==pat[i]</strong>。用人话翻译就是，只有str=aaaaax\r\npat=aaaax这种前部分字符只有一个的情况才有移动区间匹配成功的可能。然而我们可以从实例中看到，这种字符串情况也包含在跳过的思路中，也恰好满足跳过的条件，甚至不用回移不用使j=0开始匹配，只需要接着从跳到的\r\nj 处匹配就解决了这个情况。</p>\r\n</blockquote>\r\n<h3 id=\"创造跳跃数组\">创造跳跃数组</h3>\r\n<p>我们知道，KMP主要算法就是在失败时，通过跳跃到恰当的位置接着匹配。\r\n而这个恰当的位置 k\r\n满足：k之前的所有k位，即前缀，和失败处的倒数k位，即后缀，恰好相同，此时失败即可跳到k处。</p>\r\n<p><strong>所以我们要解决的就是，在开始查找模式串之前，先对模式串每一位\r\nj 进行前后缀检测，存在满足的前后缀即可令 jump[j]=k\r\n存储在该处失败可跳跃到的位置。不存在则存入 -1 作为标志即可</strong></p>\r\n<p>因为跳跃位置只与模式串本身有关，因此事先处理好一次即可对任何主串复用。</p>\r\n<p>当然检测前后缀也不是一个简单的事，KMP中构造跳跃数组的过程中也是用了KMP自己.......作为学习者只能对创造者表示敬佩，这里用伪代码描述一下。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">因为在<span class=\"number\">0</span>位失败肯定没法跳跃，令jump[<span class=\"number\">0</span>]=<span class=\"number\">-1</span> </span><br><span class=\"line\">设置好跳跃定位标志 k=<span class=\"number\">-1</span></span><br><span class=\"line\">对模式串每一位 i</span><br><span class=\"line\">    假如 i  k 位相同，或者k==<span class=\"number\">-1</span></span><br><span class=\"line\">      即看作前后缀目前为止相同</span><br><span class=\"line\">      i, k 到下一位</span><br><span class=\"line\">      对于已经处理好前后缀之后的下一位，只需把跳跃信息给它即可</span><br><span class=\"line\">          假如下一位与跳跃位不同</span><br><span class=\"line\">              把已经处理好的k作为它的跳跃位即可，jump[i]=k</span><br><span class=\"line\">          假如下一位与跳跃位相同</span><br><span class=\"line\">              （比如在a失败，跳到的地方还是a，那就没有再比一次的必要了）</span><br><span class=\"line\">              把跳跃位的跳跃位作为它的跳跃位hhh jump[i]=jump[k]</span><br><span class=\"line\">   假如 i k 位不同 （他们的跳跃信息已经被处理好了）</span><br><span class=\"line\">      （内用KMP，即相当于后缀作为主串，前缀作为模式串，此时匹配失败了，前缀跳到跳跃位接着匹配）</span><br><span class=\"line\">      k=jump[k]</span><br><span class=\"line\">      </span><br></pre></td></tr></table></figure>\r\n<p>处理好跳跃数组（失效数组）之后，即可按数组的跳跃信息进行利用匹配.匹配过程看下方代码即可，并不难:</p>\r\n<h1 id=\"kmp解题代码\">KMP解题代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(string haystack, string needle)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;   </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(needle==<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//KMP</span></span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">int</span> jump[needle.<span class=\"built_in\">size</span>()];</span><br><span class=\"line\">        jump[<span class=\"number\">0</span>]=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> k=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//创建失效数组  abcabcd</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;needle.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(k==<span class=\"number\">-1</span> || needle[i]==needle[k])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                k++;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(needle[i]!=needle[k])</span><br><span class=\"line\">                    jump[i]=k;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    jump[i]=jump[k];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>    <span class=\"comment\">//内置kmp</span></span><br><span class=\"line\">                k=jump[k];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> x=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(x&lt;haystack.<span class=\"built_in\">size</span>() &amp;&amp; y&lt;<span class=\"built_in\"><span class=\"keyword\">int</span></span>(needle.<span class=\"built_in\">size</span>())) <span class=\"comment\">//注意这里int化！！！！！！看bug看了好久，size返回值是unsignedint</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(y==<span class=\"number\">-1</span> ||haystack[x]==needle[y])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                x++;</span><br><span class=\"line\">                y++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">               y=jump[y];</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(y==needle.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x-y;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-3","url":"/2020/02/17/LeetCode-No-3/","content":"<h1 id=\"无重复字符的最长子串\"><a\r\nhref=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters\">无重复字符的最长子串</a></h1>\r\n<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\r\n示例 1: 输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是\r\n\"abc\"，所以其长度为 3。</p>\r\n<p>示例 2: 输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是\r\n\"b\"，所以其长度为 1。</p>\r\n<p>示例 3: 输入: \"pwwkew\" 输出: 3 解释:\r\n因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\r\n请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。</p>\r\n<h2 id=\"解题思路\">解题思路</h2>\r\n<p>　这题也是思路比较直接的一题,分析以下几点需求:</p>\r\n<ol type=\"1\">\r\n<li><p>判断重复字符\r\n用int构造一个<strong><em>hash表</em></strong>进行判断即可,注意字符总数,数组空间可以开大一点\r\n(数组初始化的时候没有想到更好的优化效率方案).</p></li>\r\n<li><p>子串检测\r\n数据结构课上有学过kmp算法,因此容易联想到这里为了最佳效率,也应采用<strong><em>窗口移动</em></strong>的算法.</p></li>\r\n<li><p>后事处理\r\n移动窗口之后,由于窗口之外的字符的位置信息还保留在表内,因此需要进行处理\r\n直接思路是使用一个滞后的位置符<code>behind</code>进行遍历清除即可\r\n优化思路:\r\n可以通过判断滞留的位置是否处于现有检测窗口之前,如果是则无视,不需要遍历处理,<strong>空间换时间</strong></p></li>\r\n</ol>\r\n<h2 id=\"最终代码\">最终代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(string s)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;   </span><br><span class=\"line\">        <span class=\"keyword\">int</span> flag[<span class=\"number\">127</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">127</span>;i++)</span><br><span class=\"line\">            flag[i]=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result=<span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> max=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> start=<span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;s.<span class=\"built_in\">length</span>();i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            temp=<span class=\"built_in\">getNO</span>(s[i]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag[temp]&lt;start)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result++;</span><br><span class=\"line\">                flag[temp]=i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(result=max)</span><br><span class=\"line\">                    max=result;</span><br><span class=\"line\">                </span><br><span class=\"line\">                start=flag[temp]+<span class=\"number\">1</span>;</span><br><span class=\"line\">                result=i-flag[temp];</span><br><span class=\"line\">                flag[temp]=i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(result=max)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getNO</span><span class=\"params\">(<span class=\"keyword\">char</span> originchar)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> originchar-<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-31","url":"/2020/02/17/LeetCode-No-31/","content":"<h1 id=\"下一个排列\"><a\r\nhref=\"https://leetcode-cn.com/problems/next-permutation\">下一个排列</a></h1>\r\n<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>\r\n<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\r\n必须原地修改，只允许使用额外常数空间。</p>\r\n<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。 1,2,3 → 1,3,2\r\n3,2,1 → 1,2,3 1,1,5 → 1,5,1</p>\r\n<h1 id=\"思路分析\">思路分析</h1>\r\n<h3 id=\"是否存在更大的排列\">①是否存在更大的排列</h3>\r\n<h5 id=\"更大的排列\">更大的排列</h5>\r\n<p>考虑最大的字典序排列: 降序排列 <strong>[1,2,3]</strong> →\r\n<strong>[3,2,1]</strong> 对于 <strong>[3,2,1]</strong>\r\n序列,已经是最大字典序了</p>\r\n<p>假如序列存在一个更大的排列,那它必然不是降序排列\r\n因此判断是否存在下一个排列的条件就是\r\n<strong>顺序遍历数组,判断是否完全降序</strong></p>\r\n<h3 id=\"找到下一个排列\">②找到下一个排列</h3>\r\n<p>首先对于<strong>[1,2,3,4,5,6]</strong>,假如我们要人工找到下一个排列,我们知道要把倒数两位调换一下<strong>[1,2,3,4,6,5]</strong>,这样值的变动最小,字典序大小变动也最小.</p>\r\n<h5\r\nid=\"为什么最后两位调换之后字典序会变大呢\">为什么最后两位调换之后字典序会变大呢?</h5>\r\n<p>我们可以发现一个本质: <strong>它们是升序的,\r\n升序排列那么必然就存在可以调换成降序的操作空间</strong>,因此可以改动升序关系的任意两位来获取一个更大的字典序\r\n如 <strong>[1,2,5,4,3,6]</strong></p>\r\n<h5\r\nid=\"知道了获得更大序的方法接下来我们要确定什么操作能得到最小的更大序下一个更大的序列\">知道了获得更大序的方法,接下来我们要确定什么操作能得到最小的更大序(下一个更大的序列)</h5>\r\n<p>其实字典序类似于数的大小关系. 比如<strong>[1,2,3]</strong> →\r\n<strong>[2,1,3][1.3.2]</strong></p>\r\n<p>所以为了找到最小的更大序列,我们操作的<strong>升序数对</strong>要尽可能的小.所以目标就变成了:</p>\r\n<h5 id=\"找到最靠后的一对升序数对\">找到最靠后的一对升序数对</h5>\r\n<p><strong>[9,8,3,6,5,4]</strong>→<strong>[9,8,4,3,5,6]</strong>\r\n最靠后的/最小的 升序数对是\r\n[3,4],初步调换后是<strong>[9,8,4,6,5,3]</strong>\r\n显然这个结果还不太对.</p>\r\n<p>找到了最小的升序数对只是保证了在一步操作的范围内,我们增加的值是最小的.\r\n换句话说,其实再多加几步操作才能保证是下一个序列. 来看看我们还差些什么\r\n<strong>[9,8,4,6,5,3]</strong> →<strong>[9,8,4,3,5,6]</strong> ,\r\n4的后面原本是降序,被整理成了升序</p>\r\n<p>首先在我们的算法里,我们从后往前找一个升序的\"峰值\"\r\n换句话说,我们在找到\"\"峰值\"\"之前,也即从末尾到\"峰值\"\",必然是降序的,也就是局部最大的序列.\r\n因此我们调换了一对最小的升序对,整个序列在\"\"峰值\"\"之前已经是最小的了,\r\n但在调换位置之后的局部仍然是降序,即现在的序是<strong>前半段最小+后半段最大</strong>,\r\n因此<strong>将\"\"峰值\"\"往后调整成升序,即后半段最小</strong>即可构成\"最小+最小\"的下一个排列.</p>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">nextPermutation</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&amp; nums)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.<span class=\"built_in\">size</span>()&lt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextid=nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> currentid=nextid<span class=\"number\">-1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(currentid=<span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[nextid]nums[currentid])</span><br><span class=\"line\">            &#123;   </span><br><span class=\"line\">                <span class=\"comment\">//从后往前，找到第一组 升序对</span></span><br><span class=\"line\">               flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            nextid--;</span><br><span class=\"line\">            currentid--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag==<span class=\"number\">1</span>)<span class=\"comment\">//存在下一个更大排列</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                <span class=\"comment\">//交换生成新排列</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(nextid+<span class=\"number\">1</span>&lt;nums.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[nextid+<span class=\"number\">1</span>]nums[currentid] )</span><br><span class=\"line\">                    nextid++;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">tempswap</span>(nums[currentid],nums[nextid]);</span><br><span class=\"line\">            <span class=\"comment\">//currentid右边必然是降序</span></span><br><span class=\"line\">            <span class=\"comment\">//将currentid右边升序处理</span></span><br><span class=\"line\">            nextid=nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(currentid+<span class=\"number\">1</span>&lt;nextid)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">tempswap</span>(nums[nextid],nums[currentid+<span class=\"number\">1</span>]);</span><br><span class=\"line\">                nextid--;</span><br><span class=\"line\">                currentid++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;   <span class=\"comment\">//不存在，则倒序</span></span><br><span class=\"line\">            nextid=nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">            currentid=<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(currentid&lt;nextid)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">tempswap</span>(nums[nextid],nums[currentid]);</span><br><span class=\"line\">                nextid--;</span><br><span class=\"line\">                currentid++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tempswap</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp; a,<span class=\"keyword\">int</span>&amp; b)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp=b;</span><br><span class=\"line\">            b=a;</span><br><span class=\"line\">            a=temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-32","url":"/2020/02/17/LeetCode-No-32/","content":"<h1 id=\"最长有效括号\"><a\r\nhref=\"https://leetcode-cn.com/problems/longest-valid-parentheses\">最长有效括号</a></h1>\r\n<p>给定一个只包含 '(' 和\r\n')' 的字符串，找出最长的包含有效括号的子串的长度。</p>\r\n<p>示例 1:</p>\r\n<p>输入: \"(()\" 输出: 2 解释: 最长有效括号子串为 \"()\"</p>\r\n<p>示例 2:</p>\r\n<p>输入: \")()())\" 输出: 4 解释: 最长有效括号子串为 \"()()\"</p>\r\n<h1 id=\"思路分析\">思路分析</h1>\r\n<h5 id=\"错误思路规避\">错误思路规避</h5>\r\n<p>刚看到括号对, 第一反应就是栈操作的括号匹配,\r\n认为只要匹配到匹配失败的时候记录这条括号串的长度, 在遍历完整个串之后,\r\n通过最大值筛选就获得了最长有效括号长度.\r\n<strong>然而事实证明困难题没有那么憨憨</strong> 对于\"( ) ( (\r\n)\"显然简单的匹配栈会把这个长度定为4,实际上只有2 ##### 问题出在哪呢?\r\n<strong>( )</strong> ((((((((( <strong>( )</strong>\r\n在两个正常括号中间的压栈操作不会终止长度的累积\r\n当然也不能粗暴的终止,毕竟也有( ) ( ( ( ( ) ) ) ) ) 的情况</p>\r\n<h1 id=\"改良方法\">改良方法</h1>\r\n<p>参考了题解大神的思路之后, 明白了单纯压char型 ' (\r\n'入栈是一种很憨憨的行为...... 同样是压栈匹配,\r\n人家压的下标.....<strong>消耗一样,却额外带来了位置信息</strong></p>\r\n<p>匹配时括号对会产生一个位置差, 而对于这个差内部肯定是合法的括号串. (\r\n~~~~~~~) 假如是非法串, 要么是 ( 多了,那匹配时会匹配内部多的 (\r\n,而不是外部那个. 要么是 ) 多了, 那肯定已经把栈清空了,\r\n外围也不会有匹配括号.</p>\r\n<p>每次匹配成功会通过位置差得到一个当前长度信息<code>length=i-stack.top()</code>\r\n<strong>注意这里的top是已经匹配pop出一个(\r\n之后,再取的top,此时的top为目前合法字符串的开始位置的前一个</strong>\r\n假如top和pop为同一个,对于 ((())) 的嵌套形式是没问题的, 但对于连串形式如:\r\n例如 ( ( ) ( ) ( ) ( ) <strong>( )</strong> ) )\r\nstring[9]和string[10]匹配了,目前合法长度肯定不是10-9=1...实际上是10-0=10</p>\r\n<p><strong>也因为这个i-top的方法,我们需要在最开始的栈底压入一个-1,\r\n代表字符串开头</strong> 针对 ( ) ( ) ( ) 的情况, 最后一个右括号pop完,\r\n不压入一个-1你让人家减谁去算长度....</p>\r\n<p>顺带一提原方法错误的案例 再看( ) ( ( ), 原方法因为是只要不匹配失败,\r\n每过一位都会长度++,因此产生错误结果 4 而利用位置信息差算长度的方法,\r\n只会算出两个长度为2 的括号对 ,最大也就是2.</p>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<p>算法比较简单, 但分析细节还是比较令人舒适的~ <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(string s)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;   </span><br><span class=\"line\">        <span class=\"keyword\">int</span> result=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        stack&lt;<span class=\"keyword\">int</span> left;</span><br><span class=\"line\">        left.push(-1);//压入字符串头，以防（）（）（）（）情况</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;s.size())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i]==&#x27;(&#x27;)   //左括号 下标 入栈</span><br><span class=\"line\">                left.push(i);</span><br><span class=\"line\">            <span class=\"keyword\">else</span>    //右括号消除一个左括号，并用下标差计算长度</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                left.pop();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(left.empty()!=<span class=\"literal\">true</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(i-left.top()result)</span><br><span class=\"line\">                        result=i-left.top();  </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    left.push(i);</span><br><span class=\"line\">                  </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n","categories":["算法"]},{"title":"LeetCode-No-4-","url":"/2020/02/17/LeetCode-No-4-/","content":"<h1 id=\"寻找两个有序数组的中位数\"><a\r\nhref=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays\">寻找两个有序数组的中位数</a></h1>\r\n<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。\r\n请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m +\r\nn))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3]\r\nnums2 = [2] 则中位数是 2.0</p>\r\n<p>示例 2: nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5</p>\r\n<h2 id=\"思路分析\">思路分析</h2>\r\n<p><strong>首先</strong>, 题目有 log\r\n时间复杂度限制，不能重组数组暴力解决</p>\r\n<p><strong>已知</strong>,\r\n两数组有序不为空，找到中位数的难点在于怎么把两个数组的数一起考虑</p>\r\n<p><strong>目标</strong>,\r\n中位数定义：将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。所以我们其实是找一个方法，把两个数组同时划分成两块，左边块的所有数都比右边块的所有数要小。\r\n若分割后左边有 k 个数，此时划分的边界有 LMax1,LMax2,RMin1,RMin2：</p>\r\n<ul>\r\n<li>Max(LMax1,LMax2) 必然是第 k 个数</li>\r\n<li>Min(RMin1,RMin2) 必然是第 k+1 个数</li>\r\n</ul>\r\n<p>即我们可以定位到第 k 个数，中位数的序号 k\r\n也可通过数组长度得到。因此，我们需要：</p>\r\n<p><strong>两个数组同时分割成有大小关系的两块，左块总共有 k 个数，k\r\n为中位数序号，此时中位数要么是第 k 个，要么是第 k 个和第 k+1\r\n个，都可以在边界找到</strong></p>\r\n<h2 id=\"题解分析-链接原高赞题解\"><a\r\nhref=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/\">题解分析</a>\r\n（链接原高赞题解）</h2>\r\n<h3 id=\"分割主体思路\">分割主体思路</h3>\r\n<p>要把两数组同时分割成两块，先看单一数组的内部。因为数组是有序的，所以假如在中间一割，同一数组的左边肯定小于右边。</p>\r\n<p>为了达到我们两个数组整体分割的目标，我们还需要满足对一个数组都有，分割的左边最大值小于另一个数组的右边最小值，这样左边的整体必然就会小于右边的整体。</p>\r\n<p>另外注意切割后要满足左大块总共有 k 个数。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://upload-images.jianshu.io/upload_images/19387483-5f138dbbe56bdd7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"\r\nalt=\"题解示意图，来自 LeetCode 扁扁熊\" />\r\n<figcaption aria-hidden=\"true\">题解示意图，来自 LeetCode\r\n扁扁熊</figcaption>\r\n</figure>\r\n<h3 id=\"边界数赋值\">边界数赋值</h3>\r\n<p>假如分割点恰巧在有数的位置 C, 为方便比较大小，LMax=RMin=L[C],\r\n即中位数同时分给两边。</p>\r\n<p>假如分割点在两数之间，即 LMax 和 RMin 即分属两边。</p>\r\n<h3 id=\"假想放大数组\">假想放大数组</h3>\r\n<p>因为无法用整数下标表示描述在两数之间的位置，但实际存在这种分割情况。\r\n所以我们不妨将每个数组<strong>放缩成 2m+1 的长度</strong>,\r\n即给两数之间也加入一个标识位置。 例如 [1,2,3] 假想放缩成 [#\r\n,1,#,2,#,3,#],</p>\r\n<p>此时：<strong>数的实际位置=假想位置/2</strong>，\r\n<strong>两数之间的假想位置=数的假想位置+-1</strong>。</p>\r\n<p>设放大后对一个数组切割的假想下标（虚位）为 C。 此时无论 C\r\n是<strong>数的虚位</strong>还是<strong>空的虚位</strong>, 都满足\r\nLMax=L[(C-1)/2] RMin=L[C/2],\r\n注意放缩产生的虚位是假想的，因此访问时要转换回实位</p>\r\n<p>例如对于 [# ,1,#,2,#,3,#] 2 的原下标是 1, 假想下标是 3, 3/2=1\r\n若此时以，C=3 为切割位置，即切在点上，则\r\nLMax=L[(C-1)/2]=L[1]=2,RMin=L[C/2]=L[1]=2 若以 C=4\r\n为分割处，即切在空上，LMax=L[1]=2,RMin=L[2]=3.</p>\r\n<p><strong>放大数组后，切点切空都可以用同一个式子正确给 LMax 和 RMin\r\n赋值</strong></p>\r\n<h3 id=\"左块确保有-k-个数\">左块确保有 k 个数</h3>\r\n<p>因为放大后数组总长度是 2m+2n+2，所以中位数在是 第 m+n+1 数和第 m+n+2\r\n数相加的平均值。</p>\r\n<p>因此有 <code>k=m+n+1</code>，且 <code>C2=m+n-C1</code>。</p>\r\n<p>真实数组序号从 0 开始，所以 C1+C2=k-1, 左块才有 k 个数，<strong>不是\r\nC1+C2=m+n+1</strong>。</p>\r\n<h3 id=\"切割终止条件\">切割终止条件</h3>\r\n<p>好，现在我们随便怎么切，都能确保左边是 k\r\n个数。但是注意为了维护左块所有数一定小于右块所有数，我们需要有<code>LMax&lt;=RMin</code></p>\r\n<h3 id=\"处理边界情况\">处理边界情况</h3>\r\n<p>切割时切割点可能在数组最左边或者最右边，此时直观上理解可知，切最左边的时候，LMax=无穷小，切最右边的时候\r\nRMin=无穷大</p>\r\n<h3 id=\"切割点遍历方式\">切割点遍历方式</h3>\r\n<p>切割点选择方式确定后，我们要逐步逼近正确的切割点\r\n类似于查找算法，此时可用二分法进行逼近，满足效率 O(log).</p>\r\n<h2 id=\"最终代码\">最终代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> &lt;vector        <span class=\"comment\">//注意头文件的加入，否则 INT_MIN 之类的可能无法使用</span></span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> &lt;stdio.h</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&amp; nums1, vector&lt;<span class=\"keyword\">int</span>&amp; nums2)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> length1=nums1.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length2=nums2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(length1length2)        <span class=\"comment\">//节省效率，以最短的数组为主切割 C1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">findMedianSortedArrays</span>(nums2,nums1);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> LMax1;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> LMax2;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> RMin1;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> RMin2;</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">int</span> k=length1+length2;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c1;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c2;<span class=\"comment\">//切割点</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> lo=<span class=\"number\">0</span>;<span class=\"comment\">//二分逼近变量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> hi=length1*<span class=\"number\">2</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//二分确定切割点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(lo&lt;=hi)  <span class=\"comment\">//写 LMax1RMin2 || LMax2RMin1 为什么不可以</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//计算切割点，保持了左边都是 k 个数</span></span><br><span class=\"line\">            c1=(lo+hi)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            c2=k-c1;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//计算四个边界值</span></span><br><span class=\"line\">           (c1==<span class=\"number\">0</span>) ? LMax1=INT_MIN : LMax1=nums1[(c1<span class=\"number\">-1</span>)/<span class=\"number\">2</span>];</span><br><span class=\"line\">            (c1==<span class=\"number\">2</span>*length1) ? RMin1=INT_MAX : RMin1=nums1[c1/<span class=\"number\">2</span>];</span><br><span class=\"line\">             (c2==<span class=\"number\">0</span>) ? LMax2=INT_MIN : LMax2=nums2[(c2<span class=\"number\">-1</span>)/<span class=\"number\">2</span>];</span><br><span class=\"line\">            (c2==<span class=\"number\">2</span>*length2) ? RMin2=INT_MAX : RMin2=nums2[c2/<span class=\"number\">2</span>];</span><br><span class=\"line\">            </span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(LMax1RMin2)<span class=\"comment\">//左上大于右下，左下显然小于右下，切多了，hi 降低</span></span><br><span class=\"line\">                hi=c1<span class=\"number\">-1</span>;          </span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(LMax2RMin1)<span class=\"comment\">//左下大于右上，左上显然小于右上，少了。lo 升高</span></span><br><span class=\"line\">                lo=c1+<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>       <span class=\"comment\">//左上小于右上右下，左下小于右上右下，目标条件。</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> LMax,RMin;</span><br><span class=\"line\">        LMax=(LMax1LMax2)?LMax1:LMax2;</span><br><span class=\"line\">        RMin=(RMin1&lt;RMin2)?RMin1:RMin2;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (LMax+RMin)/<span class=\"number\">2.0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<hr />\r\n<p>这个题目细节比较复杂，代码相对来说挺清晰简洁。</p>\r\n","categories":["算法"]},{"title":"LeetCode-No-43","url":"/2020/02/17/LeetCode-No-43/","content":"<h1 id=\"字符串相乘\"><a\r\nhref=\"https://leetcode-cn.com/problems/multiply-strings\">字符串相乘</a></h1>\r\n<p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>\r\n<p>示例 1:</p>\r\n<p>输入: num1 = \"2\", num2 = \"3\" 输出: \"6\"</p>\r\n<p>示例 2:</p>\r\n<p>输入: num1 = \"123\", num2 = \"456\" 输出: \"56088\"</p>\r\n<p>说明：</p>\r\n<p>num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1\r\n和 num2 均不以零开头，除非是数字 0 本身。\r\n不能使用任何标准库的大数类型（比如\r\nBigInteger）或直接将输入转换为整数来处理。</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<p>//1 2 3 num1 //4 5 6 num2 //7 3 8+6 1 5 * 10+..... reverseresult</p>\r\n<h2 id=\"竖式暴力模拟\">1. 竖式暴力模拟</h2>\r\n<p>因为现实竖式乘法是从右到左落位,\r\n程序从左到右方便一些,所以运算过程中是反向存储的乘法结果,最后需要翻转.</p>\r\n<p>当然这个可以优化</p>\r\n<h4\r\nid=\"整数相乘直接思维是按竖式相乘-显而易见两次循环外层num2内层num1\">1.1\r\n整数相乘直接思维是按竖式相乘, 显而易见两次循环,外层num2,内层num1</h4>\r\n<h4 id=\"对num2的最后一位乘num1一遍currentresult保存这遍的结果\">1.2\r\n对num2的最后一位,乘num1一遍,currentresult保存这遍的结果</h4>\r\n<h4 id=\"result累加上currentresult-加法也有点麻烦-还得写个加法函数\">1.3\r\nresult累加上currentresult, (加法也有点麻烦, 还得写个加法函数</h4>\r\n<h4 id=\"因为最后一位乘过了就没用了num2.pop_back\">1.4\r\n因为最后一位乘过了就没用了,num2.pop_back()</h4>\r\n<h4\r\nid=\"注意乘完一个数-下一个currentresult要向左移一位即x10尾部添0-而我们又是反向存储所以需要在currentresult头部加i个0-ipop次数\">1.5\r\n注意乘完一个数, 下一个currentresult要向左移一位,即X10尾部添0,\r\n而我们又是反向存储,所以需要在currentresult头部加i个\"0\", i=pop次数</h4>\r\n<h4 id=\"num2所有数都用过了即num2结束循环\">1.6\r\nnum2所有数都用过了即num2=\"\",结束循环</h4>\r\n<h4 id=\"考虑一些收尾工作进位有没有多-要不要连续进位\">1.7\r\n考虑一些收尾工作,进位有没有多, 要不要连续进位</h4>\r\n<h4 id=\"将累加结果result反转-得到真实结果\">1.8 将累加结果result反转,\r\n得到真实结果</h4>\r\n<p>可以看到暴力法虽然思路直接,但是需要处理的东西也不少,而且时间空间效率都不理想,\r\n权当一个编码锻炼.</p>\r\n<h2 id=\"暴力代码\">暴力代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"function\">string <span class=\"title\">multiply</span><span class=\"params\">(string num1, string num2)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num1 == <span class=\"string\">&quot;0&quot;</span> || num2 == <span class=\"string\">&quot;0&quot;</span>)</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  string result;</span><br><span class=\"line\">  string tempresult;</span><br><span class=\"line\">  string zerostring;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> cflag = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (num2 != <span class=\"string\">&quot;&quot;</span>)<span class=\"comment\">//num1对num2每个数逐个相乘,每次result=result+currentresult*10</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (i = num1.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i = <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">    tempresult.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;0&#x27;</span> + ((num1[i] - <span class=\"string\">&#x27;0&#x27;</span>)*(num2.<span class=\"built_in\">back</span>() - <span class=\"string\">&#x27;0&#x27;</span>) + cflag) % <span class=\"number\">10</span>);</span><br><span class=\"line\">    cflag = ((num1[i] - <span class=\"string\">&#x27;0&#x27;</span>)*(num2.<span class=\"built_in\">back</span>() - <span class=\"string\">&#x27;0&#x27;</span>) + cflag) / <span class=\"number\">10</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">//乘到最后一个数还剩下cflag</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (cflag  <span class=\"number\">0</span>)</span><br><span class=\"line\">    tempresult.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;0&#x27;</span> + cflag);</span><br><span class=\"line\">   <span class=\"comment\">//用零串移位</span></span><br><span class=\"line\">   tempresult = zerostring + tempresult;</span><br><span class=\"line\">   <span class=\"comment\">//相加上下两个字符串</span></span><br><span class=\"line\">   <span class=\"built_in\">ADDstring</span>(result, tempresult);</span><br><span class=\"line\">   <span class=\"comment\">//乘完num2的一个数num2把用过的数pop</span></span><br><span class=\"line\">   num2.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">   <span class=\"comment\">//临时数据清空</span></span><br><span class=\"line\">   tempresult.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">   zerostring += <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\">   cflag = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//1 2 3</span></span><br><span class=\"line\">  <span class=\"comment\">//4 5 6</span></span><br><span class=\"line\">  <span class=\"comment\">//7 3 8+6 1 5 * 10</span></span><br><span class=\"line\">  string reverseresult;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = result.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; j = <span class=\"number\">0</span>; j--)</span><br><span class=\"line\">   reverseresult.<span class=\"built_in\">push_back</span>(result[j]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> reverseresult;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ADDstring</span><span class=\"params\">(string&amp; up, string&amp; down)</span><span class=\"comment\">//up和down字符串数值相加,结果存在up里,仅适用倒序存储</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> cflag = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">//result接在up上面</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (j &lt; down.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (j &lt; up.<span class=\"built_in\">size</span>())<span class=\"comment\">//up[j]存在</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">    temp = (up[j] - <span class=\"string\">&#x27;0&#x27;</span>) + (down[j] - <span class=\"string\">&#x27;0&#x27;</span>) + cflag;</span><br><span class=\"line\">    up[j] = (temp) % <span class=\"number\">10</span> + <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">    cflag = (temp) / <span class=\"number\">10</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span><span class=\"comment\">//up[j]不存在</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">    up.<span class=\"built_in\">push_back</span>(((down[j] - <span class=\"string\">&#x27;0&#x27;</span>) + cflag) % <span class=\"number\">10</span> + <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">    cflag = ((down[j] - <span class=\"string\">&#x27;0&#x27;</span>) + cflag) / <span class=\"number\">10</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   j++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (cflag != <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (j &lt; up.<span class=\"built_in\">size</span>())<span class=\"comment\">//up[j]存在</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">    temp = (up[j] - <span class=\"string\">&#x27;0&#x27;</span>) + cflag;</span><br><span class=\"line\">    up[j] = (temp) % <span class=\"number\">10</span> + <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">    cflag = (temp) / <span class=\"number\">10</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span><span class=\"comment\">//up[j]不存在</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">    up.<span class=\"built_in\">push_back</span>(cflag % <span class=\"number\">10</span> + <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">    cflag = cflag / <span class=\"number\">10</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"优化思路每一位数的乘法运算对result影响分析\">2.\r\n优化思路——每一位数的乘法运算对result影响分析</h2>\r\n<p>//1 2 3 num1[i] //为示范简单,这里序号从右往左编码,程序中需要转换 //4\r\n5 6 num2[j] //例如num1[0]和num2[0]相乘 : 3X6=18\r\n肯定影响到了result[0+0],有进位则会影响到result[0+0+1],\r\nresult其他的值则肯定不会改变</p>\r\n<h4\r\nid=\"优化分析-在竖式中从右向左编码-两个数num1i-num2j相乘-则只会影响到resultij-resultij1两位的结果\">2.1\r\n优化分析: 在竖式中,从右向左编码, 两个数num1[i], num2[j]相乘,\r\n则只会影响到result[i+j] , result[i+j+1]两位的结果</h4>\r\n<h4\r\nid=\"因此我们不需要临时存储的容器currentresult-只需要在-result中修改受影响的两位即可\">2.2\r\n因此我们不需要临时存储的容器currentresult, 只需要在\r\nresult中修改受影响的两位即可</h4>\r\n<h4\r\nid=\"另外num2.pop_back虽然符合直觉习惯但显然我们可以通过移动下标来代替反复的pop\">2.3\r\n另外num2.pop_back虽然符合直觉习惯,但显然我们可以通过移动下标来代替反复的pop</h4>\r\n<p>事实证明对于一些修改字符串的操作还是小心为慎,\r\n虽然pop这个操作看起来只需要剪掉尾巴就好, 应该耗时影响不大 ,\r\n<strong>但事实上我卡在80%就是因为它!!!!</strong>, 优化掉后直接97%=\r\n=.</p>\r\n<h4\r\nid=\"反转问题-同上可知-乘法最远也就影响到resultlength1length21.-即result长度已知-因此可以反向填充result即可避免最后还得反转\">2.4\r\n反转问题: 同上可知, 乘法最远也就影响到result[length1+length2+1].\r\n即result长度已知, 因此可以反向填充result即可避免最后还得反转</h4>\r\n<p>暴力法时因为不清楚result到底会有多长, 所以不能反向填充.</p>\r\n<h4 id=\"另外还有一些小细节思考\">2.5 另外还有一些小细节思考</h4>\r\n<h4 id=\"比如连续进位有没有问题\">比如连续进位有没有问题</h4>\r\n<h4 id=\"循环结束需不需要有收尾整理\">循环结束需不需要有收尾整理</h4>\r\n<h4\r\nid=\"我们现在result里填充了length1length21的-0-方便我们后续反向填充和累加-但是result0是最后一位进位的结果-假如最后没有进位呢\">我们现在result里填充了[length1+length2+1]的\r\n'0' 方便我们后续反向填充和累加, 但是result[0]是最后一位进位的结果,\r\n假如最后没有进位呢?</h4>\r\n<h1 id=\"优化代码-超越97时间86内存\">优化代码, 超越97%时间,86%内存</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"function\">string <span class=\"title\">multiply</span><span class=\"params\">(string num1, string num2)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num1 == <span class=\"string\">&quot;0&quot;</span> || num2 == <span class=\"string\">&quot;0&quot;</span>)</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">           </span><br><span class=\"line\">  string result;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> totallength=num1.<span class=\"built_in\">size</span>()+num2.<span class=\"built_in\">size</span>();<span class=\"comment\">//result最大可能长度</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> cflag =<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp=<span class=\"number\">0</span>;<span class=\"comment\">//i+j位和存储器</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;totallength;i++)<span class=\"comment\">//初始化填充</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//反向填充,可以不需要在最后reverse,....好像对效率影响不大</span></span><br><span class=\"line\">        <span class=\"comment\">//把num2.pop()删掉了,终于从8ms提到了4ms......</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (j&lt;num2.<span class=\"built_in\">size</span>())<span class=\"comment\">//num1[i]Xnum2[j] 只影响result的[i+j]和[i+j+1],因此相比暴力相加,可以优化中间步骤</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (i = num1.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i = <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">   &#123;   <span class=\"comment\">//因为要改变i+j位,所以先计算出i+j+1位,(程序用的i和注释i不是一个)</span></span><br><span class=\"line\">                temp=(result[totallength<span class=\"number\">-1</span>-((num1.<span class=\"built_in\">size</span>()-i<span class=\"number\">-1</span>)+j)]-<span class=\"string\">&#x27;0&#x27;</span>)+ (num1[i] - <span class=\"string\">&#x27;0&#x27;</span>)*(num2[num2.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>-j] - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">                <span class=\"comment\">//连续进位怎么办?临时存储?循环清理干净?</span></span><br><span class=\"line\">                <span class=\"comment\">//临时存储试试</span></span><br><span class=\"line\">                result[totallength<span class=\"number\">-1</span>-((num1.<span class=\"built_in\">size</span>()-i<span class=\"number\">-1</span>)+j+<span class=\"number\">1</span>)]+=temp/<span class=\"number\">10</span>;</span><br><span class=\"line\">    result[totallength<span class=\"number\">-1</span>-((num1.<span class=\"built_in\">size</span>()-i<span class=\"number\">-1</span>)+j)]=<span class=\"string\">&#x27;0&#x27;</span>+temp%<span class=\"number\">10</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            j++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">        <span class=\"comment\">//不需要检查最后一位要不要进位</span></span><br><span class=\"line\">       </span><br><span class=\"line\">  <span class=\"comment\">//1 2 3</span></span><br><span class=\"line\">  <span class=\"comment\">//4 5 6</span></span><br><span class=\"line\">  <span class=\"comment\">//7 3 8+6 1 5 * 10</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//跳过头部的0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(result[<span class=\"number\">0</span>]!=<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> result.<span class=\"built_in\">substr</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<hr />\r\n<p>string.pop_back()真的卡了我好久, 左优化右优化, 去头部0的方法换了又换,\r\n就是卡在80% .......谨慎考虑库函数的效率.</p>\r\n","categories":["算法"]},{"title":"LeetCode-No-44","url":"/2020/02/17/LeetCode-No-44/","content":"<h1 id=\"通配符匹配\"><a\r\nhref=\"https://leetcode-cn.com/problems/wildcard-matching\">通配符匹配</a></h1>\r\n<p>------类似No.10的正则匹配</p>\r\n<p>给定一个字符串 (s) 和一个字符模式 (p)\r\n，实现一个支持 '?' 和 '*' 的通配符匹配。</p>\r\n<p>'?' 可以匹配任何单个字符。 '*' 可以匹配任意字符串（包括空字符串）。\r\n两个字符串完全匹配才算匹配成功。</p>\r\n<p>说明:</p>\r\n<p>s 可能为空，且只包含从 a-z 的小写字母。\r\np 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<p>和正则一样, 重点在于 * 的任意位匹配</p>\r\n<ol type=\"1\">\r\n<li><p>假如是一个没有 * 的串匹配,\r\n我们只要碰到一个匹配失败即可结束</p></li>\r\n<li><p>有了 <em>的情况,</em>\r\n可以用来干什么呢?-----帮你把匹配失败的地方干掉</p></li>\r\n<li><p>因此其实我们可以先正常逐个精确匹配, 遇到 * 可以记录下来,\r\n以便帮助后面</p></li>\r\n<li><p>当在某一位精确匹配失败时, 我们回去找 <em>的帮助,\r\n如果之前没有</em> , 帮不了, 匹配失败</p></li>\r\n<li><p>假如之前有 <em>,即需让</em>往后匹配来避免这个失败位, 但是因为*\r\n每向后扩展一位, 原本的精确匹配顺序全都挪动了一位,\r\n此时我们不知道是不是能匹配成功</p></li>\r\n<li><p>因此 <em>帮忙的时候,</em> 只向后扩展一位试试,\r\n此时是一个未知的匹配状态, 我们需要在 * 的边缘重新开始精确匹配,\r\n再失败了就重复 6 即可</p></li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isMatch</span><span class=\"params\">(string s, string p)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//i,j指示当前匹配位置,iflag,jflag指示*号匹配位置</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> slength=s.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> plength=p.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> iflag=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> jflag=<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//匹配到*之后的匹配中, 如果准确匹配,则进入了第一个if,失败则</span></span><br><span class=\"line\">        <span class=\"comment\">//  是* 则先保存现场, 在之后的匹配中如果失败则需要*来救场</span></span><br><span class=\"line\">        <span class=\"comment\">//  不是* ,则看之前有没有*,有可以用来救场,尝试增加*解决掉的位数,再继续试试</span></span><br><span class=\"line\">        <span class=\"comment\">// 没有*救场 , 那可以自闭了.over</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//循环内每次都确保当前匹配成功</span></span><br><span class=\"line\">        <span class=\"comment\">//注意j&lt;plength的处理,j==plength时,仍然要继续尝试用*解决的,不能无脑return false.</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;slength)</span><br><span class=\"line\">        &#123;   </span><br><span class=\"line\">            <span class=\"comment\">//准确匹配成功</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j&lt;plength &amp;&amp; (s[i]==p[j] || p[j]==<span class=\"string\">&#x27;?&#x27;</span>))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//匹配到*</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j&lt;plength &amp;&amp; p[j]==<span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                iflag=i;</span><br><span class=\"line\">                jflag=j;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//p中*用掉了,j去下一位. s[i]因为 *可能用于匹配空串,所以暂时不移动</span></span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//准确匹配失败,但是进入下面的elseif内则说明之前有*,这时候就需要增加*匹配的一位 来尝试解决掉不能准确匹配的东西.</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(jflag!=<span class=\"number\">-1</span>)</span><br><span class=\"line\">            &#123;   </span><br><span class=\"line\">                <span class=\"comment\">//*匹配到原iflag走不通,尝试匹配到iflag++位置,再次开始匹配</span></span><br><span class=\"line\">                i=++iflag;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//p因为是用*去匹配的,所以p下一个要匹配的位是*下一位,jflag+1</span></span><br><span class=\"line\">                j=jflag+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//连*都不能帮忙解决,s可以走了</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//注意考虑s匹配完了,p剩余*则还能成功</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&lt;plength)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p[j]==<span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> j==plength;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-45","url":"/2020/02/17/LeetCode-No-45/","content":"<h1 id=\"跳跃游戏\"><a\r\nhref=\"https://leetcode-cn.com/problems/jump-game-ii\">跳跃游戏</a></h1>\r\n<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>\r\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\r\n<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>\r\n<p>示例:</p>\r\n<p>输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。  \r\n从下标为 0 跳到下标为 1\r\n的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p>\r\n<p>说明:</p>\r\n<p>假设你总是可以到达数组的最后一个位置。</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<h3 id=\"假如不考虑最少次数-贪心法\">1. 假如不考虑最少次数, 贪心法</h3>\r\n<h4 id=\"逐位扩展可跳最大距离-只要够到了末尾就好.\">----\r\n逐位扩展可跳最大距离, 只要够到了末尾就好.</h4>\r\n<h4\r\nid=\"假如扩展的时候-最大距离到不了这个位-则不能从这个位扩展-即断路了.\">----\r\n假如扩展的时候, 最大距离到不了这个位, 则不能从这个位扩展, 即断路了.</h4>\r\n<h3 id=\"加上了最少次数要求\">2. 加上了最少次数要求</h3>\r\n<h4 id=\"什么情况会多次数-就是之前的一次能跳到的-跳了几次.\">----\r\n什么情况会多次数? 就是之前的一次能跳到的, 跳了几次.</h4>\r\n<h4\r\nid=\"那么怎么知道之前能不能跳到呢-记录能跳到的最大距离-只有到达最大距离-才算一次次数.-当然到末端也算一次.\">----\r\n那么怎么知道之前能不能跳到呢? 记录能跳到的最大距离, 只有到达最大距离,\r\n才算一次次数. 当然到末端也算一次.</h4>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jump</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//参考题解大神思路: i每到达前一个max,完成一次跳跃</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> end = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxend = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">\t    &#123;   <span class=\"comment\">//i每到达前一个max,完成一次跳跃</span></span><br><span class=\"line\">\t\t    maxend = <span class=\"built_in\">max</span>(nums[i] + i, maxend);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == end)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                end = maxend;</span><br><span class=\"line\">                sum++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-46-47","url":"/2020/02/17/LeetCode-No-46-47/","content":"<h1 id=\"全排列\"><a\r\nhref=\"https://leetcode-cn.com/problems/permutations\">全排列</a></h1>\r\n<p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p>\r\n<p>示例:</p>\r\n<p>输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2],\r\n[3,2,1]]</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<h3\r\nid=\"递归-顺着手工思路从后往前逐步交换.-固定前面的后面的全排列即可.\">1.\r\n递归, 顺着手工思路,从后往前逐步交换. 固定前面的+后面的全排列即可.</h3>\r\n<h3\r\nid=\"用一个for循环表示该位与后面每一位交换-包括交换自己-等于不交换的情况-然后用递归表达后面的全排列.\">2.\r\n用一个for循环表示该位与后面每一位交换, (包括交换自己, 等于不交换的情况),\r\n然后用递归表达后面的全排列.</h3>\r\n<p>注意递归出来后要把之前换的换回来, 要不然 [1 2 3 ] 换成 [2 1 3],\r\n递归到第二层 1 3 又会换成[2 3 1], 这已经不是全排列了, 是在顺序交换.\r\n容易出错</p>\r\n<h3 id=\"全排列ii-存在重复数字-要筛选掉重复的排列\">3. 全排列II\r\n存在重复数字, 要筛选掉重复的排列</h3>\r\n<h4\r\nid=\"为什么会有重复序列呢-因为-i-交换了-j-递归出来后-接下来i又碰到一个-j-.-两次交换递归下去的结果一模一样-所以会重复-.\">----为什么会有重复序列呢?\r\n因为 i 交换了 j, 递归出来后, 接下来i又碰到一个 j .\r\n两次交换递归下去的结果一模一样 , 所以会重复 .</h4>\r\n<h4\r\nid=\"因此对每个j-我们要查重它是不是在i-j之间-即已经交换过j值-查重通过了才能继续递归-否则跳过.\">----\r\n因此对每个j 我们要查重它是不是在i-j之间 (即已经交换过j值)\r\n,查重通过了才能继续递归, 否则跳过.</h4>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"keyword\">int</span> permuteUnique(vector&lt;<span class=\"keyword\">int</span>&amp; nums) </span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span> result;</span><br><span class=\"line\">        backtrace(nums,result,0);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">void</span> backtrace(vector&lt;<span class=\"keyword\">int</span>&amp;nums,vector&lt;vector&lt;<span class=\"keyword\">int</span>&amp;result,<span class=\"keyword\">int</span> i)</span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i==nums.size()-1)</span><br><span class=\"line\">            result.push_back(nums);</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i;j&lt;nums.size();j++)</span><br><span class=\"line\">        &#123;   </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i==j)//不需要交换的递归</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                backtrace(nums,result,i+1);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;     </span><br><span class=\"line\">            //检查要交换的这个,在已经交换过的里面,有没有相同的,有就不交换了</span><br><span class=\"line\">            <span class=\"keyword\">int</span> k;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(k=j-1;k=i;k--)</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[k]==nums[j])</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(k!=i-1)//查重没通过,跳过这个数</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            //正常交换递归</span><br><span class=\"line\">            swap(nums[i],nums[j]);</span><br><span class=\"line\">            backtrace(nums,result,i+1);</span><br><span class=\"line\">            swap(nums[i],nums[j]);  //换回来？</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\">void</span> swap(<span class=\"keyword\">int</span>&amp; a,<span class=\"keyword\">int</span>&amp;b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp=a;</span><br><span class=\"line\">        a=b;</span><br><span class=\"line\">        b=temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-46","url":"/2020/02/17/LeetCode-No-46/","content":"<h1 id=\"全排列\"><a\r\nhref=\"https://leetcode-cn.com/problems/permutations\">全排列</a></h1>\r\n<p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p>\r\n<p>示例:</p>\r\n<p>输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2],\r\n[3,2,1]]</p>\r\n<h1 id=\"思路分析\">思路分析</h1>\r\n<ul>\r\n<li><p>由排列特性我们的直觉思路是, 首先固定第一个数, 然后排列后面的数\r\n,同时后面的排列也是这种<strong>固定+排序</strong>的思路进行.\r\n因此很显然可以想到是一种递归回溯的算法.</p></li>\r\n<li><p>递归到字符串尾很简单,\r\n但需要注意的是怎么得到其他的组合情况.</p></li>\r\n</ul>\r\n<p><del>我首先设想的是进行一种遍历, 首先确定第一个数,\r\n然后选取未被排列过的剩下的数, 逐一形成n!个排列组合,\r\n但好像没想到简便的方法实现</del></p>\r\n<p>参考题解后得知, 想要不同的排列组合, 本质在于数的顺序不同,\r\n因此我们只要将数进行交换, 然后递归到底输出交换后的组合即可.</p>\r\n<h1 id=\"解答代码\">解答代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"keyword\">int</span> permute(vector&lt;<span class=\"keyword\">int</span>&amp; nums) </span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span> result;</span><br><span class=\"line\">        backtrace(nums,result,0);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">void</span> backtrace(vector&lt;<span class=\"keyword\">int</span>&amp;nums,vector&lt;vector&lt;<span class=\"keyword\">int</span>&amp;result,<span class=\"keyword\">int</span> i)</span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i==nums.size()-1)</span><br><span class=\"line\">            result.push_back(nums);</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i;j&lt;nums.size();j++)  //逐一尝试与后面的数的交换组合</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            swap(nums[i],nums[j]);//交换</span><br><span class=\"line\">            backtrace(nums,result,i+1);//然后输出交换后的串</span><br><span class=\"line\">            swap(nums[i],nums[j]);  //记得换回来保持原状, 否则换到最后会重复  比如ABC- CBA-ABC </span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\">void</span> swap(<span class=\"keyword\">int</span>&amp; a,<span class=\"keyword\">int</span>&amp;b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp=a;</span><br><span class=\"line\">        a=b;</span><br><span class=\"line\">        b=temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-48-矩阵圈圈类型","url":"/2020/02/17/LeetCode-No-48-%E7%9F%A9%E9%98%B5%E5%9C%88%E5%9C%88%E7%B1%BB%E5%9E%8B/","content":"<h1 id=\"旋转矩阵\"><a\r\nhref=\"https://leetcode-cn.com/problems/rotate-image\">旋转矩阵</a></h1>\r\n<p>给定一个 n × n 的二维矩阵表示一个图像。</p>\r\n<p>将图像顺时针旋转 90 度。</p>\r\n<p>说明：</p>\r\n<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>\r\n<p>示例 1:</p>\r\n<p>给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],</p>\r\n<p>原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3]]</p>\r\n<p>示例 2:</p>\r\n<p>给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7],\r\n[15,14,12,16]],</p>\r\n<p>原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6,\r\n8, 9], [16, 7,10,11]]</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>矩阵圈圈式问题主要在于怎么确定问题需要的 圈。例如旋转矩阵这个问题,\r\n看似旋转, 实际上是一圈圈的边界互换, 上边界换到右边界, 以此类推。</p>\r\n<p>那么其实只要我们找到四个边界, 然后以边界去for遍历就好了。遍历完一圈\r\n,收缩上下左右边界, 继续遍历, 直到边界重合。</p>\r\n<table>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>之后的顺时针遍历问题也是一样, 以边界为中心去做遍历.不断收缩边界,\r\n注意单行单列的圈 需要做避免重复处理, 旋转问题这里不需要, 因为是n x\r\nn.</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 id=\"题解代码\">题解代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">int</span>&amp; matrix)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;       </span><br><span class=\"line\">            <span class=\"comment\">//确定四个边界,因为是nxn其实可以两个数就够了,但是为了可读性用四个数</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> left=<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> top=<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> right=matrix[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> bottom=matrix.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(left&lt;right)<span class=\"comment\">//每次旋转外围四边,旋转完缩小外围定义</span></span><br><span class=\"line\">            &#123;   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;right-left;i++)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//上到右</span></span><br><span class=\"line\">                    temp=matrix[top+i][right];</span><br><span class=\"line\">                    matrix[top+i][right]=matrix[top][left+i];</span><br><span class=\"line\">                    <span class=\"comment\">//左到上</span></span><br><span class=\"line\">                    matrix[top][left+i]=matrix[bottom-i][left];</span><br><span class=\"line\">                    <span class=\"comment\">//下到左</span></span><br><span class=\"line\">                    matrix[bottom-i][left]=matrix[bottom][right-i];</span><br><span class=\"line\">                    <span class=\"comment\">//右到下</span></span><br><span class=\"line\">                    matrix[bottom][right-i]=temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                left++;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">                top++;</span><br><span class=\"line\">                bottom--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-49","url":"/2020/02/17/LeetCode-No-49/","content":"<h1 id=\"字母异位分词\"><a\r\nhref=\"https://leetcode-cn.com/problems/group-anagrams\">字母异位分词</a></h1>\r\n<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>\r\n<p>示例:</p>\r\n<p>输入: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], 输出: [\r\n[\"ate\",\"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"]] 说明：</p>\r\n<p>所有输入均为小写字母。 不考虑答案输出的顺序。</p>\r\n<h1 id=\"题解分析\">题解分析</h1>\r\n<h3 id=\"怎么判断是不是异位分词呢-想想异位分词具有什么特点\">1.\r\n怎么判断是不是异位分词呢? 想想异位分词具有什么特点?</h3>\r\n<h3 id=\"异位分词中-字母出现次数相同-字母顺序不同\">---- 异位分词中,\r\n字母出现次数相同, 字母顺序不同</h3>\r\n<h3 id=\"因此我们可以-排序后观察-26字母次数统计-进行比较.\">----\r\n因此我们可以 排序后观察 / 26字母次数统计 进行比较.</h3>\r\n<h3\r\nid=\"当然注意别做一类扫一遍-用个字典自动分类就可以了.\">当然注意别做一类扫一遍,\r\n用个字典自动分类就可以了.</h3>\r\n<h1 id=\"题解代码----排序字典\">题解代码----排序+字典</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;string groupAnagrams(vector&lt;string&amp; strs) </span><br><span class=\"line\">    &#123;   //加字典的排序</span><br><span class=\"line\">        vector&lt;vector&lt;string result;</span><br><span class=\"line\">        unordered_map&lt;string, vector&lt;string hashmap;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(string s : strs)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            string temp = s;</span><br><span class=\"line\">            sort(temp.begin(), temp.end());</span><br><span class=\"line\">            hashmap[temp].push_back(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i : hashmap)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result.push_back(i.second);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-50","url":"/2020/02/17/LeetCode-No-50/","content":"<h1 id=\"powxn\"><a\r\nhref=\"https://leetcode-cn.com/problems/powx-n\">pow(x,n)</a></h1>\r\n<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>\r\n<p>示例 1:</p>\r\n<p>输入: 2.00000, 10 输出: 1024.00000</p>\r\n<p>示例 2:</p>\r\n<p>输入: 2.10000, 3 输出: 9.26100</p>\r\n<p>示例 3:</p>\r\n<p>输入: 2.00000, -2 输出: 0.25000 解释: 2-2 = 1/22 = 1/4 = 0.25\r\n说明:</p>\r\n<p>-100.0 &lt; x &lt; 100.0 n 是 32\r\n位有符号整数，其数值范围是 [−231, 231 − 1] 。</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<h3 id=\"数学思路-快速幂算法\">数学思路, 快速幂算法</h3>\r\n<h4\r\nid=\"因为xn可以分解成xn2-xn2-所以可以把n二分下去-变成logn的快速幂算法\">----因为x<sup>n</sup>可以分解成x<sup>n/2</sup>\r\n* x<sup>n/2</sup>, 所以可以把n二分下去 变成logN的快速幂算法</h4>\r\n<h4 id=\"另外注意-数值越界-奇偶的二分的区别\">另外注意: 数值越界,\r\n奇偶的二分的区别</h4>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">myPow</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">int</span> n)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;   <span class=\"comment\">//????通不过45,90啊</span></span><br><span class=\"line\">        <span class=\"comment\">//只有奇偶递归的话,数值变大了就有问题</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==INT_MIN)<span class=\"comment\">//注意-n 和 n 的越界范围不一样</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>/(<span class=\"built_in\">myPow</span>(x,INT_MAX)*x);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>/<span class=\"built_in\">myPow</span>(x,-n);</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1.0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n==<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">double</span> half=<span class=\"built_in\">myPow</span>(x,n/<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n%<span class=\"number\">2</span>==<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> half*half;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"comment\">//(n%2!=0)</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> half*half*x;            </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-5","url":"/2020/02/17/LeetCode-No-5/","content":"<h1 id=\"最长回文子串\"><a\r\nhref=\"https://leetcode-cn.com/problems/longest-palindromic-substring\">最长回文子串</a></h1>\r\n<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为\r\n1000。 示例 1： 输入: \"babad\" 输出: \"bab\" 注意: \"aba\"\r\n也是一个有效答案。</p>\r\n<p>示例 2： 输入: \"cbbd\" 输出: \"bb\"</p>\r\n<h2 id=\"仿no.4切入\">仿No.4切入</h2>\r\n<ul>\r\n<li>回文序列本质上还是一个切割问题</li>\r\n<li>以切割点为起始,逐步比较两边是否相等即可判断回文.</li>\r\n<li>注意切割处可以是数, 也可以是两数之间</li>\r\n</ul>\r\n<h2 id=\"求解代码\">求解代码</h2>\r\n<p>题目思路较为简单,直接放出一遍撸过的代码. <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\">string <span class=\"title\">longestPalindrome</span><span class=\"params\">(string s)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tstring result;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> center;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> left;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> right;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s.<span class=\"built_in\">length</span>() == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//参考题4扩展</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//[1,2,3] [1,# ,2,#,3]</span></span><br><span class=\"line\">\t\t <span class=\"comment\">//[2,1,1,2] [2,# ,1,#,1,#,2]</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (center = <span class=\"number\">0</span>; center &lt; <span class=\"number\">2</span>*s.<span class=\"built_in\">length</span>()<span class=\"number\">-1</span>; center++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tleft = center / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\tright = (center + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (left &lt; <span class=\"number\">0</span> || right = s.<span class=\"built_in\">length</span>() || s[left] != s[right])</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tleft++;</span><br><span class=\"line\">\t\t\t\t\tright--;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tleft--;</span><br><span class=\"line\">\t\t\t\tright++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (right - left + <span class=\"number\">1</span>  result.<span class=\"built_in\">length</span>())</span><br><span class=\"line\">\t\t\t\tresult.<span class=\"built_in\">assign</span>(s, left, right - left + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n----------------- ## 错误思路反省 #### 1.<strong>条件定义错误</strong>\r\n简单的将回文定义为 一个数在中间,两边相等 的序列,\r\n实际上回文序列最中间可能是<strong>空</strong>而不是<strong>数</strong>.\r\n#### 2.<strong>边界特殊情况考虑不周</strong>\r\n比如空字符串,比如没想到\"aaaaa\"这种字符串,\r\n当然使用扩展分割的算法时这些情况都可以求解,\r\n只不过如果自己能早点注意到这些特殊情况,就不需要绕弯子 ,\r\n可以直接上来就撸分割了. #### 3. <strong>自行测试</strong>\r\n自己在提交给OJ之前,应该自己尽量想出各种各样的测试样例,\r\n不能写出什么就随便丢上去跑,\r\n只有自己用心测试了之后才会发现自己的初始算法有那么多的错误.</p>\r\n","categories":["算法"]},{"title":"LeetCode-No-51&No-52","url":"/2020/02/17/LeetCode-No-51-52/","content":"<h1 id=\"n皇后\"><a\r\nhref=\"https://leetcode-cn.com/problems/n-queens\">N皇后</a></h1>\r\n<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n\r\n的棋盘上，并且使皇后彼此之间不能相互攻击。 <img\r\nsrc=\"https://upload-images.jianshu.io/upload_images/19387483-fd574c97962d8a50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"\r\nalt=\"N皇后示例-LeetCode\" /> 上图为 8 皇后问题的一种解法。 给定一个整数\r\nn，返回所有不同的 n 皇后问题的解决方案。</p>\r\n<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和\r\n'.' 分别代表了皇后和空位。</p>\r\n<p>示例:</p>\r\n<p>输入: 4 输出: [ [\".Q..\", // 解法 1 \"...Q\", \"Q...\", \"..Q.\"],] 解释: 4\r\n皇后问题存在两个不同的解法。</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<ul>\r\n<li><h4\r\nid=\"主要思路和数独类一样回溯遍历\">主要思路和数独类一样，回溯遍历</h4></li>\r\n<li><h4\r\nid=\"放置特性行列对角线不同\">放置特性：行、列、对角线不同</h4></li>\r\n<li><h4\r\nid=\"需要注意怎么判断皇后在当前位置是否可放置呢使用状态表判断三个数组构成\">需要注意怎么判断皇后在当前位置是否可放置呢？——使用状态表判断，三个数组构成</h4></li>\r\n</ul>\r\n<ol type=\"1\">\r\n<li>行列不同很简单，以行遍历为例，因为一行放了一个就到下一行，所以行不可能重复。</li>\r\n<li>列检查，遍历每行的时候，检查<strong>列状态表</strong>，这列未被使用才可。<code>bool colFlag[n]</code></li>\r\n<li>检查主对角线，主对角线特征是<strong>行列差</strong>相同即是同一个主对角线，行列差范围在[-n+1,n-1]，因为索引有负，进行一个+n的偏移处理。<code>diagonal[2*n]</code></li>\r\n<li>检查次对角线，特征是<strong>行列和</strong>相同，范围在[0,2n-2]。<code>SubDiagonal[2*n]</code></li>\r\n<li>检查通过才可放置，同时后续假如要撤销记得收拾好记录表。</li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;string solveNQueens(<span class=\"keyword\">int</span> n) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;string result;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> First=0;//第一行的Q位置</span><br><span class=\"line\">       </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(First&lt;n)//第一个Q的位置代表尝试轮次,第一行超过最后一格则所有遍历结束</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //初始化棋盘</span><br><span class=\"line\">            vector&lt;string tempReuslt;</span><br><span class=\"line\">            string tempString(n,&#x27;.&#x27;);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=0;i&lt;n;i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                tempReuslt.push_back(tempString);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //列使用情况,<span class=\"literal\">false</span>代表没用过</span><br><span class=\"line\">            <span class=\"keyword\">bool</span> colFlag[n];</span><br><span class=\"line\">            <span class=\"keyword\">bool</span> diagonal[2*n];//对角线使用情况</span><br><span class=\"line\">            <span class=\"keyword\">bool</span> SubDiagonal[2*n];//次对角线使用情况</span><br><span class=\"line\">            memset(colFlag,0,<span class=\"keyword\">sizeof</span>(colFlag));</span><br><span class=\"line\">            memset(diagonal,0,<span class=\"keyword\">sizeof</span>(diagonal));</span><br><span class=\"line\">            memset(SubDiagonal,0,<span class=\"keyword\">sizeof</span>(SubDiagonal));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            //第一个Q在First位置</span><br><span class=\"line\">            tempReuslt[0][First]=&#x27;Q&#x27;;</span><br><span class=\"line\">            colFlag[First]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">            diagonal[0-First+n]=<span class=\"literal\">true</span>;//偏移n,因为行减列可能是负数</span><br><span class=\"line\">            SubDiagonal[First]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> count=1;</span><br><span class=\"line\">            backTrace(result,tempReuslt,count,colFlag,n,diagonal,SubDiagonal);</span><br><span class=\"line\"></span><br><span class=\"line\">            First++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> backTrace(vector&lt;vector&lt;string&amp; result,vector&lt;string&amp;tempReuslt,<span class=\"keyword\">int</span>&amp; count,<span class=\"keyword\">bool</span>* colFlag,<span class=\"keyword\">int</span>&amp; n,<span class=\"keyword\">bool</span>* diagonal,<span class=\"keyword\">bool</span>* SubDiagonal)</span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        //找齐了</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(count==n)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result.push_back(tempReuslt);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;//填入第count个数</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=0;i&lt;n;i++)</span><br><span class=\"line\">        &#123;   </span><br><span class=\"line\">            //检查列,对角线,次对角线</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((colFlag[i]==<span class=\"literal\">true</span> || (diagonal[count-i+n]==<span class=\"literal\">true</span>) || SubDiagonal[count+i]==<span class=\"literal\">true</span>)==<span class=\"literal\">false</span>)</span><br><span class=\"line\">            &#123;  </span><br><span class=\"line\">                //填入一个数</span><br><span class=\"line\">                tempReuslt[count][i]=&#x27;Q&#x27;;</span><br><span class=\"line\">                colFlag[i]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                diagonal[count-i+n]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                SubDiagonal[count+i]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\"></span><br><span class=\"line\">                //找下一个数</span><br><span class=\"line\">                backTrace(result,tempReuslt,count,colFlag,n,diagonal,SubDiagonal);</span><br><span class=\"line\"></span><br><span class=\"line\">                //重置当前数</span><br><span class=\"line\">                count--;</span><br><span class=\"line\">                tempReuslt[count][i]=&#x27;.&#x27;;</span><br><span class=\"line\">                colFlag[i]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">                diagonal[count-i+n]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">                SubDiagonal[count+i]=<span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-53","url":"/2020/02/17/LeetCode-No-53/","content":"<h1 id=\"最大子序和\"><a\r\nhref=\"https://leetcode-cn.com/problems/maximum-subarray\">最大子序和</a></h1>\r\n<p>给定一个整数数组\r\nnums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\r\n<p>示例:</p>\r\n<p>输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1]\r\n的和最大，为 6。 进阶:</p>\r\n<p>如果你已经实现复杂度为 O(n)\r\n的解法，尝试使用更为精妙的分治法求解。</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<h5\r\nid=\"一开始我是想着尝试双指针往中间收缩只要收缩能增加和那就保留当前状态但不知道怎么描述收缩停止条件\">1.\r\n一开始我是想着，尝试双指针往中间收缩，只要收缩能增加和，那就保留当前状态，但不知道怎么描述收缩停止条件。</h5>\r\n<h5 id=\"动态规划当累积到第i个数时有两种情况\">2.\r\n动态规划，当累积到第i个数时,有两种情况:</h5>\r\n<p>2.1 吃掉之前的sum,变得更大 2.2 之前的sum为负,要它干嘛,不吃,自立门户\r\n#####\r\n所以很简单，只需要判断前面的sum是否有价值就行了，因为是不能跳跃的，没价值你只能丢弃这个包袱，不能挑几项走。</p>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&amp; nums)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;   </span><br><span class=\"line\">        <span class=\"comment\">//想着两边双指针逼近收缩,不过不知道怎么确定收缩停止条件,暂时搁置</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//动态规划</span></span><br><span class=\"line\">        <span class=\"comment\">//当累积到第i个数时,有两种情况:</span></span><br><span class=\"line\">        <span class=\"comment\">//1.吃掉之前的sum,变得更大</span></span><br><span class=\"line\">        <span class=\"comment\">//2.之前的sum为负,要它干嘛,不吃,自立门户</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum=nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxResult=nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> L=nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;L;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum0)</span><br><span class=\"line\">                sum+=nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                sum=nums[i];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(summaxResult)</span><br><span class=\"line\">                maxResult=sum;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxResult;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-56-&-No-57","url":"/2020/02/17/LeetCode-No-56-No-57/","content":"<h1\r\nid=\"合并区间-插入区间httpsleetcode-cn.comproblemsmerge-intervals\">(合并区间\r\n|| 插入区间)[https://leetcode-cn.com/problems/merge-intervals]</h1>\r\n<p>给出一个区间的集合，请合并所有重叠的区间。</p>\r\n<p>示例 1:</p>\r\n<p>输入: [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释:\r\n区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p>\r\n<p>示例 2:</p>\r\n<p>输入: [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5]\r\n可被视为重叠区间。</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<h3 id=\"合并区间\">合并区间</h3>\r\n<ol type=\"1\">\r\n<li>[a,b] [c,d]合并条件：b=c &amp;&amp; a&lt;=d\r\n此时区间存在重复区段，可以合并</li>\r\n<li>由于原区间序列是乱序，你合并了前两个，产生合并结果temp，但你不知道temp还可以和后续的什么合并，所以又需要遍历一遍，不现实。</li>\r\n<li>因此我们先按区间左边界进行排序，这样temp只需要考虑是否还要合并紧挨着的下一个即可。\r\n### 插入区间</li>\r\n<li>首先需要找到插入位置，即左边界 介于 前一个和后一个的左边界\r\n中间。</li>\r\n<li>插入之后的收尾工作 插入时会不会和前一个发生和合并？\r\n因为是按左边界顺序，因此<strong>往前只可能合并一个</strong>\r\n但是不知道新区间的右边界延伸到了哪里，因此对<strong>后续区间都要检查一遍是否需要合并</strong></li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<h3 id=\"合并区间-1\">合并区间</h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"keyword\">int</span> merge(vector&lt;vector&lt;<span class=\"keyword\">int</span>&amp; intervals) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> Len=intervals.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Len==0)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        </span><br><span class=\"line\">        sort(intervals.begin(),intervals.end(),cmp);</span><br><span class=\"line\">        result.push_back(intervals[0]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=1;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;Len)</span><br><span class=\"line\">        &#123;    //可连接 [1,3] [2,4]</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(intervals[i][0]&lt;=result.back()[1])</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(intervals[i][1]result.back()[1])</span><br><span class=\"line\">                    result.back()[1]=intervals[i][1];</span><br><span class=\"line\">                <span class=\"keyword\">else</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>//不可连接 </span><br><span class=\"line\">                result.push_back(intervals[i]);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> cmp(vector&lt;<span class=\"keyword\">int</span>&amp; a,vector&lt;<span class=\"keyword\">int</span>&amp; b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a[0]&lt;b[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"插入区间\">插入区间</h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"keyword\">int</span> insert(vector&lt;vector&lt;<span class=\"keyword\">int</span>&amp; intervals, vector&lt;<span class=\"keyword\">int</span>&amp; newInterval) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=0;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> Len=intervals.size();</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> IsInsert=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;Len)</span><br><span class=\"line\">        &#123;   //找到插入的位置</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(intervals[i][1]&lt;newInterval[0])</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i==Len)//插在末尾之后</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            intervals.push_back(newInterval);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> intervals;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=0;j&lt;i;j++)//无需检查的项直接插入</span><br><span class=\"line\">            result.push_back(intervals[j]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(intervals[i][0]&lt;=newInterval[1])//可以合并</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            intervals[i][0]=min(intervals[i][0],newInterval[0]);</span><br><span class=\"line\">            intervals[i][1]=max(intervals[i][1],newInterval[1]);</span><br><span class=\"line\">            result.push_back(intervals[i]);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>//插入 而不是合并</span><br><span class=\"line\">            result.push_back(newInterval);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;Len)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //插入项往后 每一项都要检查是否要往前合并,直到不用合并</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(intervals[i][0]&lt;=result.back()[1])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(result.back()[1]&lt;intervals[i][1])</span><br><span class=\"line\">                    result.back()[1]=intervals[i][1];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //出来的i往后是无法合并的项</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;Len)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result.push_back(intervals[i]);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-60","url":"/2020/02/17/LeetCode-No-60/","content":"<h1 id=\"第k个排列\"><a\r\nhref=\"https://leetcode-cn.com/problems/permutation-sequence\">第K个排列</a></h1>\r\n<p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p>\r\n<p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时,\r\n所有排列如下：</p>\r\n<p>\"123\" \"132\" \"213\" \"231\" \"312\" \"321\" 给定 n\r\n和 k，返回第 k 个排列。</p>\r\n<p>说明：</p>\r\n<p>给定 n 的范围是 [1, 9]。 给定 k 的范围是[1,  n!]。</p>\r\n<p>示例 1:</p>\r\n<p>输入: n = 3, k = 3 输出: \"213\"</p>\r\n<p>示例 2:</p>\r\n<p>输入: n = 4, k = 9 输出: \"2314\"</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<ol type=\"1\">\r\n<li><p>我一开始想到的是全排列的函数的复用，我能找到全排列难道我找不到第k个排列？但我发现全排列那里并没有按序排列，因此不可复用..</p></li>\r\n<li><p>可以复用 下一个排列\r\n的函数，毕竟一直找找到第K个就好，效率较低，没尝试。</p></li>\r\n<li><p>数学计算。全排列每个位置的每个数其实是有数学特征的。比如对 1 2\r\n3</p>\r\n<p>3.1 <strong>首位情况</strong>：\r\n肯定先是1在首位两次，然后是2首位2次，然后是3首位两次。</p>\r\n<p>3.2\r\n<strong>次位情况</strong>：除掉首位数字，剩下的数字在nums[]中，同样也是先nums[0]作为次位，出现\r\n<strong>尾部排列次数</strong> 次，然后是nums[1]...依次类推。</p>\r\n<p>综上：即我们知道每位的次数情况，比如 1 2\r\n3中，我们要找第5个排列，因为首位1在前两个， 首位2 在3 4 个，因此\r\n第5个排列必然是首位3。 再看次位，第5个排列，除去 1 2\r\n首位的四个，我们要找的是3首位的第一个，依次类推即可。\r\n即我们可以直接计算出每一位应该是什么数字。然后组成result即可。</p></li>\r\n<li><p>细节</p>\r\n<p>4.1 当前位\r\n每个数字出现次数，由尾部的全排列次数决定，而全排列是n！，因此最好能预置个阶乘结果数组。</p>\r\n<p>4.2 k/fac[n-1] 向上取整得i，此时该位应该是\r\nnums里的第i个数（下标i-1），同时对nums删除这个数。</p>\r\n<p>4.3 n==1 时，nums只剩一个数，直接连上并返回。</p></li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">getPermutation</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;   </span><br><span class=\"line\">        <span class=\"comment\">//题解数组</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> vector&lt;<span class=\"keyword\">int</span> fac = &#123;0,1,2,6,24,120,720,5040,40320,362880,3628800&#125;;</span><br><span class=\"line\">        string result(n,&#x27;0&#x27;);</span><br><span class=\"line\">        string nums(n,&#x27;0&#x27;);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=0;i&lt;n;i++)</span><br><span class=\"line\">            nums[i]=&#x27;1&#x27;+i;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=0;n0;i++)</span><br><span class=\"line\">        &#123;   </span><br><span class=\"line\">            <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> left=0;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n=2) //计算每个首位有多少个排列,跳过这些排列</span><br><span class=\"line\">            &#123;   </span><br><span class=\"line\">                left=fac[n-1];</span><br><span class=\"line\">                a=k/left;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(k%left!=0)</span><br><span class=\"line\">                    a++;</span><br><span class=\"line\">                result[i]=nums[a-1];</span><br><span class=\"line\">                k-=(a-1)*left;</span><br><span class=\"line\">                nums.erase(a-1,1);</span><br><span class=\"line\">                n--;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> //只剩一个数,直接修改返回</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result[i]=nums[0];</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;   </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-61","url":"/2020/02/17/LeetCode-No-61/","content":"<h1 id=\"旋转链表\"><a\r\nhref=\"https://leetcode-cn.com/problems/rotate-list\">旋转链表</a></h1>\r\n<p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p>\r\n<p>示例 1:</p>\r\n<p>输入: 1-2-3-4-5-NULL, k = 2 输出: 4-5-1-2-3-NULL 解释: 向右旋转 1 步:\r\n5-1-2-3-4-NULL 向右旋转 2 步: 4-5-1-2-3-NULL</p>\r\n<p>示例 2:</p>\r\n<p>输入: 0-1-2-NULL, k = 4 输出: 2-0-1-NULL 解释: 向右旋转 1 步:\r\n2-0-1-NULL 向右旋转 2 步: 1-2-0-NULL 向右旋转 3 步: 0-1-2-NULL 向右旋转\r\n4 步: 2-0-1-NULL</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<h5 id=\"直观移位每个节点向右移动k位\">1.\r\n直观移位——每个节点向右移动K位</h5>\r\n<p>遍历每个节点，都后向计算出该位置的新节点，即向左找K位，然后赋值过来。思路很简单。\r\n（前向计算也是可以的，甚至更利于想出优化的第二步） #####\r\n注意细节：一个是移动出了链头，要转到链尾继续移动。 #####\r\n然而链表头并没有指向链尾的指针，因此怎么从链头转到链尾呢？\r\n一个很傻的方法是把链表数值做成vector...然后在vector中找相应的数值，然后赋给当前位置...\r\n很傻，浪费空间时间= = ##### 2.\r\n我们的目标是从链头转到链尾，然而链头唯一的跳转指针next又必须连着链表，所以不太好修改头指针。但是链尾的next是空的，我们是不是可以利于一下呢？\r\n再看前向计算，每个节点向右移动K位，找到正确位置然后赋值，问题也在于怎么从链尾转移到链头。\r\n##### 3.\r\n因此我们可以把链尾连向链头，即tail-next=head，此时找位置的问题就不存在了，可以开开心心对每个节点遍历。\r\n##### 4.\r\n遍历移动完想想，移完虽然AC了，但好像憨憨的？链表顺序还是原来的样子，对链尾连着链头的循环链表来讲，移完看起来只不过是head从原节点，往前走了几步，然后停了下来选了一个新位置当head。\r\n例如 1-2-3-4-5，k=2\r\n遍历移动==》4-5-1-2-3，即head往前走了K步，停在了4的位置，然后以4为链头往后即是新链表。\r\n##### 5.\r\n因此我们不需要遍历移动每个节点，首先我们找到链尾，然后知道链尾往前K个（包括链尾本身）即是新head，找到新head时，把head前一个的next置为NULL，断开循环链表即是所需链表。\r\n当然，我们在链尾的时候同样不能往前走，因此往前找K个即相当于往后找L-K+1个（不包括链尾）。\r\n你可能会想既然是从链尾向后找L-K+1个，那不是相当于从最初的head过去找L-K个吗？</p>\r\n<p>但是没有先遍历到链尾，把链尾链头连接起来的话，我们是没有循环链表的，即使一开始从head找出新head，我们还是得再遍历到链尾，连上链头，再把新链头和新链尾断开=\r\n=\r\n当然直接从head开始找，可以沿途把新链尾和原链头都存储下来，然后遍历到链尾的时候，该连的连该断的断即可=\r\n=。</p>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * struct ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode *next;</span><br><span class=\"line\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class=\"line\"> * &#125;;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    ListNode* rotateRight(ListNode* head, int k) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ListNode* i=head;</span><br><span class=\"line\">        int L=0;</span><br><span class=\"line\">        if(head==NULL)</span><br><span class=\"line\">            return head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        while(i-next!=NULL)//找链尾</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            i=i-next;</span><br><span class=\"line\">            L++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        L++;</span><br><span class=\"line\"></span><br><span class=\"line\">        i-next=head;//首尾相连</span><br><span class=\"line\">        //缩小k</span><br><span class=\"line\">        k%=L;</span><br><span class=\"line\">        int j=0;</span><br><span class=\"line\">        //从末尾起移动L-k到达 i , i-next是新头</span><br><span class=\"line\">        k=L-k;</span><br><span class=\"line\"></span><br><span class=\"line\">        while(j&lt;k)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            i=i-next;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        head=i-next;</span><br><span class=\"line\">        i-next=NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">       </span><br><span class=\"line\"></span><br><span class=\"line\">       return head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-62-&-No-63-&-No-64","url":"/2020/02/17/LeetCode-No-62-64/","content":"<h1 id=\"不同路径-i-ii\"><a\r\nhref=\"https://leetcode-cn.com/problems/unique-paths-ii\">不同路径 I &amp;\r\nII</a></h1>\r\n<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start”\r\n）。</p>\r\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>\r\n<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\r\n<img\r\nsrc=\"https://upload-images.jianshu.io/upload_images/19387483-b32c8851464ff850.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"\r\nalt=\"示例\" /></p>\r\n<p>网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n\r\n的值均不超过 100。</p>\r\n<p>示例 1:</p>\r\n<p>输入: [   [0,0,0],   [0,1,0],   [0,0,0]] 输出: 2 解释: 3x3\r\n网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1.\r\n向右 - 向右 - 向下 - 向下 2. 向下 - 向下 - 向右 - 向右</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<h3 id=\"对没有障碍物的情况\">对没有障碍物的情况</h3>\r\n<ol type=\"1\">\r\n<li>小学数学思想：走到终点总共需要的操作是 m-1个向下 和\r\nn-1个向右，那么即是一个组合数问题，在总共m-1+n-1的操作步中，选取m-1个操作步放置向下操作，剩下的放向右操作。<span\r\nclass=\"math display\">\\[C_{m+n-2}^{m-1}\\]</span></li>\r\n</ol>\r\n<p>2.当然，组合数是一个阶乘运算，不太理想。再用编程思想去想，直观上是一个深度遍历，或者说回溯遍历的问题。即尝试每种可能的走路方案，走到终点则计数+1。\r\n3.说到回溯，大概率我们可以想想能不能换成动态规划？ ### 动态规划 1.\r\n首先这显然是一个依赖子问题解决的问题。考虑位置[i][j]，有两种方式可以到达这，一种是从[i-1][j]向下，一种是[i][j-1]向右。即[i][j]位置解，即依赖于上\r\n和 左 两个位置的解。</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>考虑dp[i][j]为到达[i][j]位置的总方法数，那么假如[i-1][j]能往下，则dp[i][j]+=dp[i-1][j]，同理对dp[i][j-1]。</li>\r\n<li>动态规划主体已经清晰了，再可以进一步优化空间细节。\r\n我们是按行遍历列，而每行开头的dp[i][0]仅依赖于dp[i-1][0]，即每行开头的dp可由列方向上的第一个生成。\r\n而每行的除开头外任意一个，在行方向上又仅依赖于前一个dp[i][j-1]。换句话说，我们至始至终在行方向上只需要一个O（1）的存储空间，保留行前一个的dp结果即可。\r\n<strong>即我们只需要一个O（n）的一行大小的列dp组，一个常数大小的行dp存储数即可。</strong></li>\r\n<li>注意细节，dp数组要用long类型= =int会炸</li>\r\n</ol>\r\n<h3\r\nid=\"no.64给每个位置加了权值要求走到右下角的权值累计和最小\">No.64给每个位置加了权值，要求走到右下角的权值累计和最小</h3>\r\n<ol type=\"1\">\r\n<li>同样也是动态规划，到任意一位置的最小权值，必然是由[i-1][j] 和\r\n[i][j-1]的最小值发展而来，以此类推。</li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uniquePathsWithObstacles</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">int</span>&amp; obstacleGrid)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//动态规划</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> m=obstacleGrid.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n=obstacleGrid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">long</span> temp[n];<span class=\"comment\">//注意要用long 有样例爆int....</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(obstacleGrid[<span class=\"number\">0</span>][<span class=\"number\">0</span>]!=<span class=\"number\">1</span>)</span><br><span class=\"line\">            temp[<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;n;i++)<span class=\"comment\">//首行处理</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(obstacleGrid[<span class=\"number\">0</span>][i]!=<span class=\"number\">1</span>)</span><br><span class=\"line\">                temp[i]=temp[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                temp[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> row=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(;row&lt;m;row++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(obstacleGrid[row][<span class=\"number\">0</span>]==<span class=\"number\">1</span>)<span class=\"comment\">//首列障碍物处理</span></span><br><span class=\"line\">                temp[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;n;i++)</span><br><span class=\"line\">            &#123;   </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(obstacleGrid[row][i]==<span class=\"number\">1</span>)</span><br><span class=\"line\">                    temp[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    temp[i]+=temp[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> temp[n<span class=\"number\">-1</span>];    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-65","url":"/2020/02/17/LeetCode-No-65/","content":"<h1 id=\"有效数字\"><a\r\nhref=\"https://leetcode-cn.com/problems/valid-number\">有效数字</a></h1>\r\n<p>验证给定的字符串是否可以解释为十进制数字。</p>\r\n<p>例如:</p>\r\n<p>\"0\" = true \" 0.1 \" = true \"abc\" = false \"1 a\" = false \"2e10\" = true \"\r\n-90e3   \" = true \" 1e\" = false \"e3\" = false \" 6e-1\" = true \"\r\n99e2.5 \" = false \"53.5e93\" = true \" --6 \" = false \"-+3\" = false\r\n\"95a54e53\" = false</p>\r\n<p>说明: 我们有意将问题陈述地比较模糊。在实现代码之前，你应当事先思考所有可能的情况。这里给出一份可能存在于有效十进制数字中的字符列表：</p>\r\n<p>数字 0-9 指数 - \"e\" 正/负号 - \"+\"/\"-\" 小数点 - \".\"\r\n当然，在输入中，这些字符的上下文也很重要。</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<ol type=\"1\">\r\n<li><p>这题我感觉是一种代码实现问题，考查考虑问题是否全面？\r\n没有什么特别的算法思想，想清楚判定数字的流程，然后一路判断下来即可。但是要实现你原计划的流程，还是要好好打理一下自己的代码。</p></li>\r\n<li><p><strong>字符特征</strong> ： 2.1\r\n可能包含”0~9“，”e“，”.“，“+”，“-”，” “。 2.2 ”e”\r\n允许出现的次数？还要考虑“e”后是否允许出现”.\" ，\r\n”+“，”-“？是否允许作为开头结尾？前面是否一定要有数字？ 2.3 “.\"\r\n允许出现的次数？ ”.\" 后是否允许出现 “e\" , \"+ \" ,\"-\r\n\"？是否允许作为开头结尾 ？前面是否一定要有数字？ 2.4 ”+“\r\n，”-“，最多出现两次，一次在幂，一次在指数，且一定位于其他符号之前，且不能作为结尾\r\n2.5 ”0~9“ ，”0“是否允许在幂 或者 指数 或者 小数部分\r\n的首部，是否允许”0“结尾的小数部分。 2.6 ” “，只能作为开头结尾。 2.7\r\n整个数，必须要有数字出现。</p></li>\r\n<li><p><strong>判断流程</strong> 3.1 数前空格清除 3.2 首位判断+ -\r\n号，然后进入幂部分/整数部分 3.3 正常判断数字，遇到 ”.\" 进入小数部分，“e”\r\n进入指数部分，其余false。 3.4.1\r\n小数部分，标记小数点已经用过，不能再出现，其余照常。 3.4.2\r\n指数部分，检查e前是否有数字，”+“\r\n”-“可以再用，重置”+-“的标志位，小数点不能用了，小数点标志位置false，当然e也不能再用了。继续照常检查数字。\r\n3.5 检查到” “，”\r\n“只能作为末尾出现，因此直接跳出主体循环，进入尾部判断环节。 3.6\r\n数的结尾检查，不能是”e\", \"+ \" \"-\" ，但可以是“ . ”。\r\n3.7尾部清洗，一路检查是否是“ ”，遇到个不是的则false。 3.8\r\n检查全部通过，但它也要有数字才可能是数！return HasNum；</p></li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isNumber</span><span class=\"params\">(string s)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;   <span class=\"comment\">//0开头结尾 true</span></span><br><span class=\"line\">        <span class=\"comment\">//多个e  false</span></span><br><span class=\"line\">        <span class=\"comment\">//e左右两边要有数 </span></span><br><span class=\"line\">        <span class=\"comment\">//指数不能为小数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> UsedSign=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> UsedCom=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> UsedExp=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> HasNum=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//首部空格清除</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;s.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i]!=<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//首位判断符号位</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&lt;s.<span class=\"built_in\">size</span>() &amp;&amp; (s[i]==<span class=\"string\">&#x27;+&#x27;</span> || s[i]==<span class=\"string\">&#x27;-&#x27;</span>) )<span class=\"comment\">//符号</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            UsedSign=<span class=\"literal\">true</span>;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//主体判断</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(;i&lt;s.<span class=\"built_in\">size</span>();i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i]=<span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; s[i]&lt;=<span class=\"string\">&#x27;9&#x27;</span>)</span><br><span class=\"line\">            &#123;   </span><br><span class=\"line\">                HasNum=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;+&#x27;</span> || s[i]==<span class=\"string\">&#x27;-&#x27;</span>)<span class=\"comment\">//主要用来判断指数的符号</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(UsedSign==<span class=\"literal\">false</span> &amp;&amp; s[i<span class=\"number\">-1</span>]==<span class=\"string\">&#x27;e&#x27;</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    UsedSign=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;.&#x27;</span>)<span class=\"comment\">//小数点</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(UsedCom==<span class=\"literal\">false</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    UsedCom=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;e&#x27;</span>)<span class=\"comment\">//指数符号</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(UsedExp==<span class=\"literal\">false</span> &amp;&amp; HasNum==<span class=\"literal\">true</span>) <span class=\"comment\">//e前需有数字</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    UsedExp=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                    UsedSign=<span class=\"literal\">false</span>;<span class=\"comment\">//重置符号状态位,指数也可以带符号</span></span><br><span class=\"line\">                    UsedCom=<span class=\"literal\">true</span>;<span class=\"comment\">//指数不能是小数</span></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27; &#x27;</span>) <span class=\"comment\">//尾部空格</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i<span class=\"number\">-1</span>]==<span class=\"string\">&#x27;e&#x27;</span> ||s[i<span class=\"number\">-1</span>]==<span class=\"string\">&#x27;+&#x27;</span> || s[i<span class=\"number\">-1</span>]==<span class=\"string\">&#x27;-&#x27;</span>)<span class=\"comment\">//e + -结尾 不行</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;s.<span class=\"built_in\">size</span>())<span class=\"comment\">//尾部空格清除</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i]!=<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> HasNum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-68","url":"/2020/02/17/LeetCode-No-68/","content":"<h1 id=\"文本左右对齐\"><a\r\nhref=\"https://leetcode-cn.com/problems/text-justification\">文本左右对齐</a></h1>\r\n<p>给定一个单词数组和一个长度 maxWidth，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。</p>\r\n<p>你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 '\r\n' 填充，使得每行恰好有 maxWidth 个字符。</p>\r\n<p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p>\r\n<p>文本的最后一行应为左对齐，且单词之间不插入额外的空格。</p>\r\n<p>说明:</p>\r\n<p>单词是指由非空格字符组成的字符序列。 每个单词的长度大于\r\n0，小于等于 maxWidth。 输入单词数组 words 至少包含一个单词。 示例:</p>\r\n<p>输入: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\",\r\n\"justification.\"] maxWidth = 16 输出: [    \"This    is    an\",  \r\n \"example  of text\",    \"justification.  \"] 示例 2:</p>\r\n<p>输入: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\r\nmaxWidth = 16 输出: [   \"What   must   be\",   \"acknowledgment  \",  \r\n\"shall be        \"] 解释: 注意最后一行的格式应为 \"shall be \" 而不是\r\n\"shall be\",   因为最后一行应为左对齐，而不是左右两端对齐。<br />\r\n第二行同样为左对齐，这是因为这行只包含一个单词。 示例 3:</p>\r\n<p>输入: words =\r\n[\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\r\n  \"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]\r\nmaxWidth = 20 输出: [   \"Science  is  what we\", \"understand      well\",\r\n  \"enough to explain to\",   \"a  computer.  Art is\",   \"everything  else\r\n we\",   \"do                  \"]</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<ol type=\"1\">\r\n<li>也是没有突出思路的困难题....考验代码实现细节的功底。 ####\r\n进入每行一轮的循环：</li>\r\n<li>计算每行能最多放多少个单词，贪心尝试，能放多少放多少= = <strong>2.1\r\n注意每个单词后面要留个位置给空格</strong> <strong>2.2\r\n同时记得保存个末行标志位，以便后续末行特殊处理</strong> <strong>2.3\r\n这里用到了两个指针，一个指向起始单词，一个探索结束单词</strong></li>\r\n<li>计算每行的所需空格数，用vector存储每空应该有多少个空格，注意空格多了先在左边填，因此可以实现类似个抽屉原理，先把能平均分的部分分了，然后多的从前往后填。\r\n<strong>3.1\r\n注意最后一个单词后面没有空格，计算每空空格数时可以先排除它，前面的空格全分完了，在vector后面push_back(0)即可</strong>\r\n<strong>3.2\r\n注意该行一个单词的时候需要特殊处理，把所有空格都填在vector[0]即可。</strong></li>\r\n<li>末行特殊处理，末行单词间空格数固定为1，最后一个单词之后的空格数为所有剩余空格。</li>\r\n<li>循环填入单词，填一个单词+vector[i]数量的空格。</li>\r\n<li>填入该行结果</li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;string fullJustify(vector&lt;string&amp; words, <span class=\"keyword\">int</span> maxWidth) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vector&lt;string  result;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> wordsFlag=0;//处理到的最远的单词</span><br><span class=\"line\">        <span class=\"keyword\">int</span> StartFlag=0;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> SpaceNum=0;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> wordsNum=0;//每行单词数</span><br><span class=\"line\">        <span class=\"keyword\">int</span> CurrentLength=0;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> isLast=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span> spaces;//存储每行每处的空格数</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(wordsFlag&lt;words.size())//行循环</span><br><span class=\"line\">        &#123;   </span><br><span class=\"line\">            StartFlag=wordsFlag;</span><br><span class=\"line\">            wordsNum=0;</span><br><span class=\"line\">            CurrentLength=0;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(CurrentLength&lt;maxWidth)//判断一行最多能放几个单词</span><br><span class=\"line\">            &#123;   </span><br><span class=\"line\">                CurrentLength+=words[wordsFlag].size();</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(CurrentLength+wordsNummaxWidth)//超过了 退掉最后一次</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    CurrentLength-=words[wordsFlag].size();</span><br><span class=\"line\">                    // wordsFlag--; wordsFlag 停在下一行第一个</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                wordsNum++;</span><br><span class=\"line\">                wordsFlag++;</span><br><span class=\"line\"></span><br><span class=\"line\">                //末行判定</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(wordsFlag=words.size())</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    isLast=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            //计算所需空格数</span><br><span class=\"line\">            SpaceNum=maxWidth-CurrentLength;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(wordsNum1)//1判断，wordsNum-1=0时不能当除数</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                 spaces= vector&lt;<span class=\"keyword\">int</span>(wordsNum-1,SpaceNum/(wordsNum-1));//space有wordsNum-1处，每处平均有SpaceNum/(wordsNum-1)个</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = 0; j &lt; SpaceNum%(wordsNum-1); ++j)//多的从前往后填，填多少是多少，保证左边的空格大于等于右边的</span><br><span class=\"line\">                        spaces[j] += 1;</span><br><span class=\"line\">                spaces.push_back(0);//最后一个数不要空格</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                spaces= vector&lt;<span class=\"keyword\">int</span>(1,SpaceNum);</span><br><span class=\"line\"></span><br><span class=\"line\">            //末行处理</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isLast==<span class=\"literal\">true</span> &amp;&amp; wordsNum1)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> j= 0;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (; j &lt;wordsNum-1; j++)</span><br><span class=\"line\">                    spaces[j]=1;//末行每处空都只有一个空格，最后是剩余空格，也是服了= =</span><br><span class=\"line\">                spaces[j]=SpaceNum-(wordsNum-1);//剩余空格</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">            string temp;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j=0;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(StartFlag&lt;wordsFlag)</span><br><span class=\"line\">            &#123;   </span><br><span class=\"line\">                //填充单词</span><br><span class=\"line\">                temp+=words[StartFlag];//填词</span><br><span class=\"line\">                //填充空格</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=0;i&lt;spaces[j];i++)//填空格</span><br><span class=\"line\">                    temp.push_back(&#x27; &#x27;);</span><br><span class=\"line\">                StartFlag++;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            result.push_back(temp);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-69-（牛顿迭代法）","url":"/2020/02/17/LeetCode-No-69-%EF%BC%88%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89/","content":"<h1 id=\"x的平方根\"><a\r\nhref=\"https://leetcode-cn.com/problems/sqrtx\">x的平方根</a></h1>\r\n<p>实现 int sqrt(int x) 函数。</p>\r\n<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>\r\n<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>\r\n<p>示例 1:</p>\r\n<p>输入: 4 输出: 2</p>\r\n<p>示例 2:</p>\r\n<p>输入: 8 输出: 2 说明: 8 的平方根是 2.82842...,  \r\n由于返回类型是整数，小数部分将被舍去。</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<ol type=\"1\">\r\n<li>首先直接计算平方根不太现实，所以这是一个在有序的1~x中查找出平方根的问题。</li>\r\n<li>查找有序整数中的特定值，正常思路即<strong>二分查找</strong>，实现也简单。</li>\r\n<li><strong>递归缩小求解：</strong> <span\r\nclass=\"math display\">\\[\\sqrt{x}=2*\\sqrt{\frac{x}{4}}\\]</span>\r\n因此可以递归找到易解的小x，然后再回溯整合到原x。\r\n注意为什么选择2作为系数进行递归呢？\r\n——x缩小和放大2的倍数，可以通过位操作实现，效率极高。</li>\r\n</ol>\r\n<p>递归式为：<code>mySqrt(x)=mySqrt(x2)&lt;&lt;1</code> 4.\r\n针对这个计算平方根的特定问题，有 <strong>牛顿迭代法</strong>：\r\n<strong>牛顿法</strong>（英语：Newton's\r\nmethod）又称为<strong>牛顿-拉弗森方法</strong>（英语：Newton-Raphson\r\nmethod），它是一种在实数域和复数域上近似求解方程的方法。方法使用函数<span\r\nclass=\"math inline\">\\(f(x)\\)</span>\r\n的泰勒级数的前面几项来寻找方程的根。</p>\r\n<p><span\r\nclass=\"math display\">\\[x_{k+1}=\frac{1}{2}[x_k+\frac{x}{x_k}]\\]</span>\r\n根据精度要求，<span class=\"math inline\">\\(x_k\\)</span>和<span\r\nclass=\"math inline\">\\(x_{k+1}\\)</span>收敛后差距小于1即可返回结果。</p>\r\n<p><strong>迭代求解示意</strong>：<img\r\nsrc=\"https://upload-images.jianshu.io/upload_images/19387483-cf905b78f3551337.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"\r\nalt=\"迭代示意图，图源 (https://leetcode-cn.com/problems/sqrtx/solution/niu-dun-die-dai-fa-by-loafer/)\" /></p>\r\n<p>如上图所示，想求<span\r\nclass=\"math inline\">\\(\\sqrt{a}\\)</span>，图示a=2\r\n先随便取xi=4，然后找到过(xi,yi)的切线，且<span\r\nclass=\"math inline\">\\(f(x)=x^2-a\\)</span>的导数是<span\r\nclass=\"math inline\">\\(2x\\)</span> 即切线方程<span\r\nclass=\"math inline\">\\(f(x)-(x_i^2-a)=2x_i(x-xi)\\)</span>\r\n显而易见这个切线与x轴的交点得$x_{i+1}=\frac\r\n{2x_i<sup>2-(x_i</sup>2-a)}{2x_i}= \frac{1}{2} (x_i+\frac{a}{x_i}) $\r\n即得<span class=\"math inline\">\\(x_{i+1}\\)</span>比<span\r\nclass=\"math inline\">\\(x_{i}\\)</span>更接近解<span\r\nclass=\"math inline\">\\(\\sqrt{a}\\)</span>。</p>\r\n<h1 id=\"牛顿迭代题解代码\">牛顿迭代题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mySqrt</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//牛顿迭代</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x&lt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">        <span class=\"comment\">//注意long类型</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> last=x/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> cur =(last+x/last)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"built_in\">abs</span>(last-cur)=<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;   </span><br><span class=\"line\">            last=cur;</span><br><span class=\"line\">            cur=(cur +x/ cur) / <span class=\"number\">2.0</span> ;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur&lt;=x/cur)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-72","url":"/2020/02/17/LeetCode-No-72/","content":"<h1 id=\"编辑距离\"><a\r\nhref=\"https://leetcode-cn.com/problems/edit-distance\">编辑距离</a></h1>\r\n<p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2\r\n所使用的最少操作数 。</p>\r\n<p>你可以对一个单词进行如下三种操作：</p>\r\n<p>插入一个字符 删除一个字符 替换一个字符 示例 1:</p>\r\n<p>输入: word1 = \"horse\", word2 = \"ros\" 输出: 3 解释: horse - rorse (将\r\n'h' 替换为 'r') rorse - rose (删除 'r') rose - ros (删除 'e')</p>\r\n<p>示例 2:</p>\r\n<p>输入: word1 = \"intention\", word2 = \"execution\" 输出: 5 解释:\r\nintention - inention (删除 't') inention - enention (将 'i' 替换为 'e')\r\nenention - exention (将 'n' 替换为 'x') exention - exection (将 'n'\r\n替换为 'c') exection - execution (插入 'u')</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<ol type=\"1\">\r\n<li>和字符串匹配之类的差不多，都是\r\n<strong>动态规划</strong>，观察子问题状态，考虑转移状态</li>\r\n<li>动态规划 dp[i][j]状态</li>\r\n<li><strong>对比dp[i-1][j]状态时</strong>，只需要把i代表的字母删除即可回到dp[i-1][j]</li>\r\n<li><strong>对比dp[i][j-1]状态</strong>，因为[i][j-1]代表word1 i位 和\r\nword2 j-1 位匹配，因此word2还多个j位没有匹配到，对word1增加操作即可</li>\r\n<li><strong>对比dp[i-1][j-1]状态</strong>，双方都多出个第i位和第j位，如果这两个相等，则和dp[i-1][j-1]一样，不相等，则需要一次替换操作。</li>\r\n</ol>\r\n<h1 id=\"dp题解代码\">dp题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minDistance</span><span class=\"params\">(string word1, string word2)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//动态规划  dp[i][j]状态</span></span><br><span class=\"line\">        <span class=\"comment\">//对比dp[i-1][j]状态时，只需要把i代表的字母删除即可回到dp[i-1][j]</span></span><br><span class=\"line\">        <span class=\"comment\">//对比dp[i][j-1]状态，因为[i][j-1]代表word1 i位 和 word2 j-1 位匹配，因此word2还多个j位没有匹配到，对word1增加操作即可</span></span><br><span class=\"line\">        <span class=\"comment\">//对比dp[i-1][j-1]状态，双方都多出个第i位和第j位，如果这两个相等，则和dp[i-1][j-1]一样，不相等，则需要一次替换操作。</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> dp[word1.<span class=\"built_in\">size</span>()+<span class=\"number\">1</span>][word2.<span class=\"built_in\">size</span>()+<span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=word1.<span class=\"built_in\">size</span>();i++)</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>]=i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=word2.<span class=\"built_in\">size</span>();i++)</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i]=i;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=word1.<span class=\"built_in\">size</span>();i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j=<span class=\"number\">1</span>;j&lt;=word2.<span class=\"built_in\">size</span>();j++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(word1[i<span class=\"number\">-1</span>]==word2[j<span class=\"number\">-1</span>])</span><br><span class=\"line\">                    dp[i][j]=<span class=\"number\">1</span>+<span class=\"built_in\">min</span>( <span class=\"built_in\">min</span>(dp[i<span class=\"number\">-1</span>][j],dp[i][j<span class=\"number\">-1</span>]),dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]<span class=\"number\">-1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    dp[i][j]=<span class=\"number\">1</span>+<span class=\"built_in\">min</span>( <span class=\"built_in\">min</span>(dp[i<span class=\"number\">-1</span>][j],dp[i][j<span class=\"number\">-1</span>]),dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[word1.<span class=\"built_in\">size</span>()][word2.<span class=\"built_in\">size</span>()];                    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-75","url":"/2020/02/17/LeetCode-No-75/","content":"<h1 id=\"颜色分类\"><a\r\nhref=\"https://leetcode-cn.com/problems/sort-colors/\">颜色分类</a></h1>\r\n<p>给定一个包含红色、白色和蓝色，一共 <em>n </em>个元素的数组，<strong><a\r\nhref=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\">原地</a></strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>\r\n<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>\r\n<p><strong>示例:</strong></p>\r\n输入:** [2,0,2,1,1,0] <strong>输出:</strong> [0,0,1,1,2,2]\r\n</pre\r\n\r\n**进阶：**\r\n\r\n*   一个直观的解决方案是使用计数排序的两趟扫描算法。\r\n    首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。\r\n*   你能想出一个仅使用常数空间的一趟扫描算法吗？\r\n\r\n# 题目分析\r\n1. 相同元素相邻，换句话说即分区存放，一个颜色一个区域，但因为这里颜色使用0 ，1，2表示，即对一个012的无序序列进行排序，变成000...111....2222的顺序。\r\n正常排序算法都适用，只不过这里注意仅有三种可能的顺序值，可以有特殊做法。\r\n2. 对于一个元素，我们将他分区时，肯定是插在区域的末尾，换句话说，我们只要保留每个区域的末尾下标，插入的时候交换过去就可以了。\r\n三个区域，其实我们只要确定了两个区域即可确定第三个区域，因为0区域在最左边，2区域在最右边，方便程序定位，因此取0 2 的末尾指针保留下来。\r\n3. 确定了双指针确定区域，那么怎么进行遍历处理呢？确定了分类移动的位置，即cur遍历每一位的数值，分类处理遇到0放左边，遇到2放右边，02放好了，则1的区域也放好了。\r\n\r\n#####     针对cur的分类处理：\r\n1. 是0，则和0的flag ，left交换值，同时left++。此时cur获取的是之前的left交换过来的值。我们知道我们换过去的处理好了，那么这个换过来的还需要处理吗？目前还不知道，先看2的情况的处理。\r\n\r\n2.  是2，则和2的flag，right交换，同时right--。同样，此时cur获取了交换过来的值，由于这个值必然是在cur右边（因为它是原right，即cur的右边界），则cur肯定没有遍历过这个值。\r\n同时因为它在cur右边，它也不可能是交换过去的，因为交换过去的值肯定都在0 2 区域里了。\r\n因此这个值是野生的，所以cur在此停留，继续处理这个交换过来的值。\r\n\r\n3. 是1，因为我们把0 2 排序好，1的区域自然就出来了，因此1直接不处理，过就好了\r\n\r\n4. 那么看看0的情况交换过来的值？首先这个值的位置关系，即原left是在cur左边还是右边呢？\r\n\r\n    **只有当left会在cur右边时**，left指向的才可能是cur没处理过的，但此时cur在left内部？那cur就是把一个0换到了外边，把一个乱序的换进了0的内部，内鬼毫无意义。\r\n\r\n      **当left在cur左边时，即left指向的必定经过了cur的洗礼**，而且它必不是原来在后面被换到前面的，因为交换的肯定在left内部去了。所以它原值就是在那，且经过处理不用动，因此从left换到现在的cur之后，也是同样的处理，也不用动它，cur++拜拜嘞。\r\n\r\n5. 当cur遇到right，即到达2的边界，则说明不需要处理了，结束。\r\n\r\n# 题解代码\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sortColors</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&amp; nums)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right=nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cur=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur&lt;=right)</span><br><span class=\"line\">        &#123;   </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[cur]==<span class=\"number\">0</span>)<span class=\"comment\">//这个数字是0，移动0区域内，</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(nums[cur],nums[left]);</span><br><span class=\"line\">                <span class=\"comment\">//假如curleft，left交换过来的值肯定已经被处理过了，但是处理时产生交换，原left指向的，一定是不用处理的吗？</span></span><br><span class=\"line\">                <span class=\"comment\">//jeromememory：准确的说 cur 如果 与 p0 不是指向同一个索引，那 cur 指向的索引值如果发生交换，那交换过来的一定是 1（原因是只有当遍历过的节点有1，p0 和 cur 才不会同步），而 如果索引是 1 刚好也就不用有任何操作，所以可以直接++。</span></span><br><span class=\"line\">                <span class=\"comment\">//假如cur==left==0，没啥好说的，下一个</span></span><br><span class=\"line\">                <span class=\"comment\">//假如cur&lt;left, 可能吗？cur++的机会 = left++的机会</span></span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[cur]==<span class=\"number\">2</span>)<span class=\"comment\">//这个数字是2，移到2区域内</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(nums[cur],nums[right]);</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">                <span class=\"comment\">//交换过来的值，是右边过来的，cur没处理过，因此还需要对这个位置处理，--抵消++，位置不变</span></span><br><span class=\"line\">                cur--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-84","url":"/2020/02/17/LeetCode-No-84/","content":"<h1 id=\"最大矩形\"><a\r\nhref=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram\">最大矩形</a></h1>\r\n<p>给定 n\r\n个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1\r\n。</p>\r\n<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。 <img\r\nsrc=\"https://upload-images.jianshu.io/upload_images/19387483-c76a635ea91ad61e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"\r\nalt=\"LeetCode图\" /></p>\r\n<p>以上是柱状图的示例，其中每个柱子的宽度为\r\n1，给定的高度为 [2,1,5,6,2,3]。 <img\r\nsrc=\"https://upload-images.jianshu.io/upload_images/19387483-4198f8b5095d233b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"\r\nalt=\"LeetCode图\" /></p>\r\n<p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p>\r\n<p> </p>\r\n<p>示例: 输入: [2,1,5,6,2,3] 输出: 10</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<ol type=\"1\">\r\n<li><p>想要知道最大矩形，肯定先要知道每根柱子怎么形成矩形的</p></li>\r\n<li><p>对柱子 i，高度为 hi，以i为中心往两边扩展，只要碰到的柱子高度\r\nHj=hi，那么形成的矩形必然是以 hi 为高构造。</p></li>\r\n<li><p>假如 Hj&lt;hi，那么这个矩形的高就是新的 Hj，而这个 Hj\r\n构造的矩形必然会出现在以柱子 j\r\n为中心扩展的时候，所以不必考虑降低现在的高度。</p></li>\r\n<li><p>所以对柱子 i\r\n的扩展，往左右两边找，碰到矮的停下来，确定两边边界，边界高度\r\nHj=hi，这个即是这个 i 自己能做出来的最大矩形。\r\n可以双重循环扫描，但不是重点，这里学习题解大神的栈思路。 #\r\n题解分析：栈保留边界</p></li>\r\n<li><p>首先有一层主循环遍历所有柱子，从左到右，当前柱子为 i。</p></li>\r\n<li><p>我们目的是要找i的两个边界，因为是从左到右扫描，即我们可以顺手找到\r\ni 的右边界。只要扫描时碰到比 i 矮的就知道这个是右边界了。</p></li>\r\n<li><p>但是碰到比 i 高或者相等的柱子 j 怎么办呢？j 不会是 i 的边界\r\n，但我们也要找 j 的边界。因此我们要把未处理的 i 和 j 都留下来。</p></li>\r\n<li><p>而继续往后找的时候， i 的右边界x 必然是 j 的右边界或者之外\r\n（hi&lt;=hj) 。 <strong>因此对于下一个柱子 x：</strong> 4.1\r\n假如我们先判断 x 是不是 i 的边界，假如它是，它也不一定就是 j 的右边界\r\n，我们还得用 x 和 j 比较一次。假如它不是，它也不一定就不是 j\r\n的右边界，还是得 x j 比较一次，<strong>所以先判定 i\r\n的边界很鸡肋</strong>。 4.2 假如先判断 x 是不是更高的 j\r\n的右边界，假如它不是，那么肯定也不是 i\r\n的边界，假如它是，那么可以继续判定是不是更矮的 i 的右边界。</p></li>\r\n<li><p>因此，我们的扫描过程是这样的，<strong>从左到右</strong>，且保留的柱子<strong>高度递增</strong>（因为只要更高的才会保留，否则是作为右边界判定）。\r\n且判定的顺序是高的在前，低的在后，即<strong>新的在前，旧的在后</strong>，因此<strong>保留柱子的数据结构是：栈</strong>。\r\n因此遇到一个新柱子，与栈顶比较，更高则继续压栈。更低则是栈顶的右边界，然后栈顶出栈，判定是不是下一个栈顶的右边界。</p></li>\r\n<li><p>右边界解决了，我们还需要确定每个柱子 i 的左边界，左边界肯定在左边\r\n， 并且左边界也要比 i 矮，而我们的栈又是高度递增的=\r\n=+显然，我们可以利用出栈过程。 在栈顶确定了右边界，然后出栈的时候： 6.1\r\n下面的那个柱子高度大于【栈顶右边界高度Hr】，那么这个柱子不是左边界，而可以组成这个矩形（因为有右边界后，矩形最低高度是Hr，只要高于Hr，都是）我们继续出栈寻找即可。\r\n6.2 即一直出栈，直到出了个高度小于等于【栈顶右边界高度Hr】的柱子 x\r\n，那么 x 就是上面这个矩形的左边界。\r\n出栈到边界了怎么办？在数组开头预备一个0作为栈底标志位结束出栈。\r\n同样压栈到边界了怎么办？在数组结尾预备一个0作为启动出栈的标志位。</p></li>\r\n<li><p>此时 i 的左右边界都能找到，高度为 i ，计算面积。</p></li>\r\n</ol>\r\n<h4\r\nid=\"总之精髓在于出栈过程从栈顶的右边界一直出栈到满足的左边界中间这些柱子形成当前最大矩形\">总之精髓在于出栈过程，从栈顶的右边界，一直出栈到满足的左边界，中间这些柱子形成当前最大矩形。</h4>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">largestRectangleArea</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&amp; heights)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//题解学习</span></span><br><span class=\"line\">        std::stack&lt;<span class=\"keyword\">int</span> Lefts;</span><br><span class=\"line\">        heights.insert(heights.begin(),0);//补0作为边界判断</span><br><span class=\"line\">        heights.insert(heights.end(),0);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result=0;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=0;i&lt;heights.size();i++)</span><br><span class=\"line\">        &#123;   </span><br><span class=\"line\">            //栈单调递增，当碰到一个i 比栈顶矮，则它必是栈顶的右边界</span><br><span class=\"line\">            //再逐渐出栈，每次出栈循环，都是栈顶作为中心，而栈单调递增，栈顶下面一个更矮的必是栈顶的左边界，左右边界确定，则栈顶位置能形成的矩阵面积可计算完毕。</span><br><span class=\"line\">            //直到栈顶比 i 还矮，那 i 就不能作为右边界了 ，栈顶此时的右边界也找不到，则 i 入栈待命当左边界，然后<span class=\"keyword\">for</span>下一轮</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(Lefts.empty()!=<span class=\"literal\">true</span> &amp;&amp; heights[Lefts.top()]heights[i])//找到比栈顶矮的柱子，即栈顶柱子的右边界</span><br><span class=\"line\">            &#123;     </span><br><span class=\"line\">                temp=Lefts.top();</span><br><span class=\"line\">                Lefts.pop();</span><br><span class=\"line\">                result = max(result, (i - Lefts.top()-1)*heights[temp]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Lefts.push(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-86","url":"/2020/02/17/LeetCode-No-86/","content":"<h1 id=\"分隔链表\"><a\r\nhref=\"https://leetcode-cn.com/problems/partition-list/\">分隔链表</a></h1>\r\n<p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x\r\n的节点都在大于或等于 x 的节点之前。</p>\r\n<p>你应当保留两个分区中每个节点的初始相对位置。</p>\r\n<p>示例:</p>\r\n<p>输入: head = 1-4-3-2-5-2, x = 3 输出: 1-2-2-4-3-5</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<ol type=\"1\">\r\n<li>直接思路是第一次遍历找到中间节点，并且划分为左右两边，然后再重新遍历链表元素，按大小分类到两边去。</li>\r\n<li>但这样要来回遍历链表，还要不停的交换节点很麻烦，换个<strong>逆向思路：既然是一个链表分成两个区域，不就相当于两个链表合成一个区域</strong></li>\r\n<li>因此，即构造两个链表，遍历原链表元素，分类接在两个链表上。</li>\r\n<li>遍历结束合成两个链表。</li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">partition</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> x)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;   </span><br><span class=\"line\">        <span class=\"comment\">//逆向想问题，既然分成了两段，那也可以是两段连成了一段</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\">ListNode <span class=\"title\">lefthead</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        ListNode* left=&amp;lefthead;</span><br><span class=\"line\">        <span class=\"function\">ListNode <span class=\"title\">righthead</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        ListNode* right=&amp;righthead;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(head!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(head-val&lt;x)</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">               left-next=head;</span><br><span class=\"line\">               left=left-next;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">else</span></span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">               right-next=head;</span><br><span class=\"line\">               right=right-next;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           head=head-next;</span><br><span class=\"line\"></span><br><span class=\"line\">          </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        right-next=<span class=\"literal\">NULL</span>;<span class=\"comment\">//注意赋值null，否则下面的链表连接会无限循环超时</span></span><br><span class=\"line\">        left-next=righthead.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lefthead.next;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode-No-92","url":"/2020/02/17/LeetCode-No-92/","content":"<h1 id=\"反转链表\"><a\r\nhref=\"https://leetcode-cn.com/problems/reverse-linked-list-ii\">反转链表</a></h1>\r\n<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>\r\n<p>说明: 1 ≤ m ≤ n ≤ 链表长度。</p>\r\n<p>示例:</p>\r\n<p>输入: 1-2-3-4-5-NULL, m = 2, n = 4 输出: 1-4-3-2-5-NULL</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<ol type=\"1\">\r\n<li>反转一段区域，首先肯定想到是一个一个反转 比如2-3-4 先3插前面去 3-2-4\r\n，然后4插前面去 4-3-2</li>\r\n<li>怎么移过去呢？观察这个局部链表，可以知道我们每次把要处理的插入到链表头即可。</li>\r\n<li>因此保留一个pre指向反转区域头部，例如示例中是1</li>\r\n<li>遍历反转区域元素current，令temp=current-next保存下位，处理好current的前后指向关系，然后把temp插入到链表头，即pre-next即可。</li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * struct ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode *next;</span><br><span class=\"line\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class=\"line\"> * &#125;;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    ListNode* reverseBetween(ListNode* head, int m, int n) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int count=1;</span><br><span class=\"line\">        ListNode* temp;</span><br><span class=\"line\">        ListNode* current;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode First(0);</span><br><span class=\"line\">        First.next=head;</span><br><span class=\"line\">        ListNode* pre=&amp;First;</span><br><span class=\"line\">        while(count&lt;m)//pre停在原第m-1个数</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            pre=pre-next;</span><br><span class=\"line\">            count++;   </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current=pre-next;//current指向当前处理数</span><br><span class=\"line\">        </span><br><span class=\"line\">        while(count&lt;n)//count计数位，每次将current-next插入到pre-next，相当于利用pre做了个栈，[1,2,3,4,5]为例 current=2 pre=1</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            temp=current-next;//保留current后节点，temp=3</span><br><span class=\"line\">            current-next=temp-next;//2-next=4</span><br><span class=\"line\">            temp-next=pre-next;//逆转temp和current的前后关系。3-next=2</span><br><span class=\"line\">            pre-next=temp;//更新pre的后节点，1-next=3</span><br><span class=\"line\">            //current</span><br><span class=\"line\">            count++;//完成[1,3,2,4,5]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return First.next;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"]},{"title":"LeetCode_剑指Offer No.39","url":"/2020/07/20/LeetCode-%E5%89%91%E6%8C%87Offer-No-39/","content":"<h1 id=\"求数组中的众数\"><a\r\nhref=\"https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof\">求数组中的众数</a></h1>\r\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\r\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\r\n<p>示例 1:</p>\r\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2] 输出: 2</p>\r\n<p>限制：</p>\r\n<p>1 &lt;= 数组长度 &lt;= 50000</p>\r\n<h1 id=\"题目分析\">题目分析</h1>\r\n<p>题目关键词：<strong>出现次数</strong>，即我们很容易想到对次数进行统计然后查找的暴力方式，当然，没有介绍的必要。</p>\r\n<p>另一个关键词：<strong>超过一半</strong>，超过一半的性质能带给我们什么优势？暴力法没有顾及到，下面介绍的<strong>抵消法</strong>/<strong>摩尔投票法</strong>则利用了这一性质进行提速。</p>\r\n<p>再仔细思考题目性质：</p>\r\n<p><strong>核心性质</strong>————寻找众数，众数次数超过一半————众数次数 -\r\n所有其他数字加起来出现的次数 0</p>\r\n<ol type=\"1\">\r\n<li><p>我们可以拿出一个 众数，和 一个非众数\r\n匹配抵消。<strong>两两抵消</strong>后，最终剩下的肯定是众数。</p></li>\r\n<li><p>假设当前数是a，碰到下一个不同的数b，a和b抵消后，不管a b\r\n和众数是什么关系。之后的数组中依然有性质————众数次数 -\r\n所有其他数字加起来出现的次数 0\r\n，即a和b的抵消不影响我们在后续数组中找众数。</p></li>\r\n<li><p>即我们可以按序把两两不相同的数抵消，相同的数累计起来去抵消后续不同的数。并且后续的数组中依然可以继续抵消。</p></li>\r\n<li><p>这样即可递归下去，最终遍历完整个数组，把所有数抵消了一遍，我们得到剩下的数<code>remain=众数</code>。</p></li>\r\n</ol>\r\n<h1 id=\"算法流程\">算法流程</h1>\r\n<ol type=\"1\">\r\n<li><p>取第一个数作为当前<code>remain</code></p></li>\r\n<li><p>遍历到下一个数</p>\r\n<ul>\r\n<li>假如不同，则两两抵消，由上面分析可知，不影响后面数组中最后留下的是众数。</li>\r\n<li>假如相同，则在<code>count</code>中累计起来，后面可以抵消更多的不同的数。</li>\r\n</ul></li>\r\n<li><p>遍历完一整遍数组，全部抵消完毕，则最后<code>remain</code>保持为抵消后多余出来的众数</p></li>\r\n</ol>\r\n<h1 id=\"题解代码\">题解代码</h1>\r\n<p>抵消法做法很简单，值得注意的是理解算法的正确性，为什么这样做是对的。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&amp; nums)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//抵消思路，因为次数超过一半————众数次数 - 所有其他数字加起来出现的次数 0 ,</span></span><br><span class=\"line\">        <span class=\"comment\">//即取 众数一次 抵消 非众数一次 最终剩下来的就是众数</span></span><br><span class=\"line\">        <span class=\"comment\">//即 假设a是众数，碰到下个数不是a， 那么这两个数抵消，剩下的数组里依然有 众数次数 - 所有其他数字加起来出现的次数 0</span></span><br><span class=\"line\">        <span class=\"comment\">//最终全部抵消后，多余的是众数。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> remain;<span class=\"comment\">//最后剩下的肯定是全数组的众数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count=<span class=\"number\">0</span>;<span class=\"comment\">//记录当前假设的众数的次数 用于抵消</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> length=nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;length;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count==<span class=\"number\">0</span>)<span class=\"comment\">//更新假设对象</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                remain=nums[i];</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[i]!=remain)<span class=\"comment\">//两两抵消</span></span><br><span class=\"line\">                count--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span><span class=\"comment\">//相同数，count++</span></span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> remain;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法"],"tags":["分治"]},{"title":"MarkDown简洁手册","url":"/2020/07/17/MarkDown%E7%AE%80%E6%B4%81%E6%89%8B%E5%86%8C/","content":"<h1 id=\"first-title-一级标题-markdown示例\">First title 一级标题\r\nMarkDown示例</h1>\r\n<p><code># First title 一级标题  MarkDown示例</code></p>\r\n<h2 id=\"second-title-二级标题\">Second title 二级标题</h2>\r\n<p><code>## Second title 二级标题</code></p>\r\n<h3 id=\"third-title-三级标题\">Third title 三级标题</h3>\r\n<p><code>### Third title 三级标题</code></p>\r\n<h4 id=\"fourth-四级标题\">Fourth 四级标题</h4>\r\n<p><code>#### Fourth 四级标题</code></p>\r\n<h5 id=\"fifth-五级标题-下面是分割线\">Fifth 五级标题 下面是分割线</h5>\r\n<p><code>##### Fifth 五级标题 下面是分割线</code></p>\r\n<hr />\r\n<p><code>---</code></p>\r\n<h2 id=\"正文书写\">1. 正文书写</h2>\r\n<p><code>## 1. 正文书写</code></p>\r\n<p>标准正文示例.</p>\r\n<p><code>标准正文示例.</code></p>\r\n<p><strong>粗体示例</strong></p>\r\n<p><code>**粗体示例**</code></p>\r\n<p><em>斜体示例</em></p>\r\n<p><code>*斜体示例*</code></p>\r\n<p><strong><em>粗斜体示例</em></strong></p>\r\n<p><code>***粗斜体示例***</code></p>\r\n<blockquote>\r\n<p>引用示例</p>\r\n<blockquote>\r\n<p>嵌套引用示例</p>\r\n</blockquote>\r\n<p>引用示例</p>\r\n</blockquote>\r\n<figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;引用示例</span><br><span class=\"line\"><span class=\"quote\">&gt;</span></span><br><span class=\"line\"><span class=\"quote\">&gt;&gt;嵌套引用示例</span></span><br><span class=\"line\"><span class=\"quote\">&gt;</span></span><br><span class=\"line\"><span class=\"quote\">&gt;引用示例</span></span><br></pre></td></tr></table></figure>\r\n<ol type=\"1\">\r\n<li><p>有序列表示例1</p>\r\n<p>1.1. 嵌套多级列表1.1</p>\r\n<p>1.2. 嵌套多级列表1.2</p>\r\n<ul>\r\n<li>有序列表嵌套无序列表</li>\r\n</ul></li>\r\n<li><p>有序列表示例2</p>\r\n<p>2.1. 嵌套多级列表2.1</p>\r\n<p>2.2. 嵌套多级列表2.2</p></li>\r\n</ol>\r\n<figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">1.</span> 有序列表示例1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"code\">    1.1. 嵌套多级列表1.1</span></span><br><span class=\"line\"><span class=\"code\"></span></span><br><span class=\"line\"><span class=\"code\">    1.2. 嵌套多级列表1.2</span></span><br><span class=\"line\"><span class=\"code\">    </span></span><br><span class=\"line\"><span class=\"code\">    - 有序列表嵌套无序列表</span></span><br><span class=\"line\"><span class=\"code\"></span></span><br><span class=\"line\"><span class=\"bullet\">2.</span> 有序列表示例2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"code\">    2.1. 嵌套多级列表2.1</span></span><br><span class=\"line\"><span class=\"code\"></span></span><br><span class=\"line\"><span class=\"code\">    2.2. 嵌套多级列表2.2</span></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li><p>无序列表示例1</p></li>\r\n<li><p>无序列表示例2</p></li>\r\n<li><ul>\r\n<li>嵌套无序列表2.1</li>\r\n</ul></li>\r\n<li><ol type=\"1\">\r\n<li>无序嵌套有序</li>\r\n</ol></li>\r\n<li><ol start=\"2\" type=\"1\">\r\n<li>无序嵌套有序</li>\r\n</ol></li>\r\n</ul>\r\n<figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> 无序列表示例1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">-</span> 无序列表示例2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">-</span> - 嵌套无序列表2.1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">-</span> 1. 无序嵌套有序</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">-</span> 2. 无序嵌套有序</span><br></pre></td></tr></table></figure>\r\n<hr />\r\n<h2 id=\"资源插入\">2. 资源插入</h2>\r\n<ol type=\"1\">\r\n<li>代码段插入示例<code>for day in time</code></li>\r\n</ol>\r\n<p><code>1. 代码段插入示例 ``for day in time``</code></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>代码块插入示例:</li>\r\n</ol>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码块示例 第一个```后加代码名即可进行语法识别</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;std;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"code\">```C++</span></span><br><span class=\"line\"><span class=\"code\">//代码块示例 第一个```</span>后加代码名即可进行语法识别</span><br><span class=\"line\"><span class=\"section\">#include <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">iostream</span>&gt;</span></span></span></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"code\">    cout&lt;&lt;std;</span></span><br><span class=\"line\"><span class=\"code\">&#125;</span></span><br><span class=\"line\"><span class=\"code\">```</span></span><br></pre></td></tr></table></figure>\r\n<ol start=\"3\" type=\"1\">\r\n<li><a href=\"www.lianjie.com\">链接插入示例</a></li>\r\n</ol>\r\n<p><code>3. [链接插入示例](www.lianjie.com)</code></p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>图片插入示例:</li>\r\n</ol>\r\n<figure>\r\n<img src=\"https://i.imgur.com/sVc8zeN.png\" alt=\"这里是图片注释\" />\r\n<figcaption aria-hidden=\"true\">这里是图片注释</figcaption>\r\n</figure>\r\n<figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\">![<span class=\"string\">这里是图片注释</span>](<span class=\"link\">https://i.imgur.com/sVc8zeN.png</span>)</span><br></pre></td></tr></table></figure>\r\n","categories":["工具"],"tags":["MarkDown","写作"]},{"title":"Hexo+Next7.8 美化性配置","url":"/2020/07/24/Next7-8-%E7%BE%8E%E5%8C%96%E6%80%A7%E9%85%8D%E7%BD%AE/","content":"<h1 id=\"前情提要\">前情提要</h1>\r\n<ul>\r\n<li>Next 7.8.0</li>\r\n<li>hexo 4.2.1</li>\r\n<li>npm 6.14.5</li>\r\n<li>Next 配置文件指 项目根目录/themes/next/_config.yml</li>\r\n<li>项目配置文件指 项目根目录/_config.yml</li>\r\n<li>注意在配置文件中配置字段时，请严格控制缩进</li>\r\n<li>安装命令没特别说明都在 项目根目录 下进行</li>\r\n</ul>\r\n<p><strong>以下所有配置都建立在 7.8\r\n版本的基础之上实现的，保新保质，绝对不是复制偷搬那些祖传博客。</strong></p>\r\n<blockquote>\r\n<p>^_^ 友情建议：进行较大更改之前，先通过如 <code>git</code>\r\n等方式进行保存。并且更改后为了避免样式不刷新，尽量先<code>hexo clean</code>清除样式。生成后最好先在本地<code>hexo s</code>部署。确认没有千疮百孔再推到线上吧。</p>\r\n</blockquote>\r\n<h1 id=\"美化性配置\">美化性配置</h1>\r\n<p>虽然功能有了，但没人想要自己的博客完全单调扁平，虽然 next\r\n的设计已经清新的挺舒服了，但人总有自定义的需求嘛。</p>\r\n<p>修改途径有两种：</p>\r\n<ul>\r\n<li><p>custom style\r\n文件，覆盖单点样式，一般用于进行几个小地方的自定义等</p></li>\r\n<li><p>custom variable\r\n文件，修改变量，变量会被其他样式引用到，因此一般修改都是整体性的，一般用于修改文章宽度，文章颜色等整体性的样式。\r\n&gt;注意我在 variable\r\n配置时发现，这里颜色字段只支持十六进制表示法，不支持 rgb 表示。</p></li>\r\n</ul>\r\n<p>以下样式修改大多是在 styles 和 variables 两个文件中进行。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"next-样式结构\">Next 样式结构</h2>\r\n<p>以<strong>主题</strong>目录为根目录，主要关注\r\n<code>./source/css</code> 目录，偶尔需要 <code>./layout</code>\r\n目录，结构如下：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">NEXT</span><br><span class=\"line\">├─layout  布局相关，swig 文件，html 标记语言及嵌套语言，对新手比较难改。</span><br><span class=\"line\">│  ├─_macro</span><br><span class=\"line\">│  ├─_partials</span><br><span class=\"line\">│  ├─_scripts</span><br><span class=\"line\">│  └─_third-party</span><br><span class=\"line\">│    </span><br><span class=\"line\">│─source  资源相关</span><br><span class=\"line\">    ├─css css 样式相关</span><br><span class=\"line\">    │  ├─_common 公共部分，一般是些公共小组件的样式，什么 back 2 top 按钮</span><br><span class=\"line\">    │  │  ├─components 组件部分</span><br><span class=\"line\">    │  │  |    </span><br><span class=\"line\">    │  │  ├─outline  框架部分</span><br><span class=\"line\">    │  │  │  ├─footer  脚注</span><br><span class=\"line\">    │  │  │  ├─header  头部，菜单栏，github 彩带，书签等</span><br><span class=\"line\">    │  │  │  └─sidebar 侧栏，导航栏相关，站点概况区域相关</span><br><span class=\"line\">    │  │  |    </span><br><span class=\"line\">    │  │  └─scaffolding</span><br><span class=\"line\">    │  │      ├─highlight</span><br><span class=\"line\">    │  │      └─tags</span><br><span class=\"line\">    │  │      </span><br><span class=\"line\">    │  ├─_schemes 主题样式方案，四大主题的样式，内部调用了 variables 的值</span><br><span class=\"line\">    │  │  ├─Gemini 因此一般修改下面的_variables 的变量值就可以。</span><br><span class=\"line\">    │  │  ├─Mist</span><br><span class=\"line\">    │  │  ├─Muse</span><br><span class=\"line\">    │  │  └─Pisces</span><br><span class=\"line\">    │  │     </span><br><span class=\"line\">    │  └─_variables 以变量形式存储的 css 属性值，宽度，颜色，等全局性属性都在这里</span><br><span class=\"line\">    │  │  ├─base.styl 全局配置，下面四个为各样式对全局配置的覆盖字段</span><br><span class=\"line\">    │  │  ├─Gemini.styl</span><br><span class=\"line\">    │  │  ├─Mist.styl</span><br><span class=\"line\">    │  │  ├─Muse.styl</span><br><span class=\"line\">    │  │  └─Pisces.styl</span><br></pre></td></tr></table></figure>\r\n<p>variables\r\n里配置字段非常多，基本假如修改的只是属性值的话，都可以在这里找到 ...\r\n什么文章显示宽度、文章背景颜色，链接色 ...\r\n详细有什么字段建议自己去摸一摸\r\n<code>base.styl</code>文件，变量名都很有可读性，实在看不懂自己可以修改看看变化。</p>\r\n<p>variables\r\n取值优先级：<code>custom variables 文件 &gt; 主题 .styl 文件 &gt; base.styl 全局配置</code>。</p>\r\n<p>一般我们需要修改覆盖什么变量，即针对性的将赋值写在 custom variables\r\n文件中即可。</p>\r\n<blockquote>\r\n<p>Windows 输出树形目录技巧：命令行输入 <code>tree /?</code> ，即可查阅\r\ntree 命令的相关用法，照着用即可，生成的树形结构即可复制出来。</p>\r\n</blockquote>\r\n<h2 id=\"创建-custom-文件\">创建 custom 文件</h2>\r\n<p>在 next\r\n配置文件中，找到下面这段，然后把需要的自定义字段取消注释，这里我们想要自定义\r\nstyle 和\r\nvariable，因此取消注释这两个字段，之后可以在路径文件中写入你想要<strong>覆盖</strong>的样式。</p>\r\n<p>**注意默认路径是 hexo 项目根目录下的\r\nsource/_data/styles.styl**，取消注释后按路径自己创建那个文件。</p>\r\n<p><strong>再次强调，不是 next 主题目录为根的路径。</strong></p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Define custom file paths.</span></span><br><span class=\"line\"><span class=\"comment\"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span></span><br><span class=\"line\"><span class=\"attr\">custom_file_path:</span></span><br><span class=\"line\">  <span class=\"comment\">#head: source/_data/head.swig</span></span><br><span class=\"line\">  <span class=\"comment\">#header: source/_data/header.swig</span></span><br><span class=\"line\">  <span class=\"comment\">#sidebar: source/_data/sidebar.swig</span></span><br><span class=\"line\">  <span class=\"comment\">#postMeta: source/_data/post-meta.swig</span></span><br><span class=\"line\">  <span class=\"comment\">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class=\"line\">  <span class=\"comment\">#footer: source/_data/footer.swig</span></span><br><span class=\"line\">  <span class=\"comment\">#bodyEnd: source/_data/body-end.swig</span></span><br><span class=\"line\">  <span class=\"attr\">variable:</span> <span class=\"string\">source/_data/variables.styl</span></span><br><span class=\"line\">  <span class=\"comment\">#mixin: source/_data/mixins.styl</span></span><br><span class=\"line\">  <span class=\"attr\">style:</span> <span class=\"string\">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"调试样式方法\">调试样式方法</h2>\r\n<p>虽然能够自定义覆盖样式，但是 css\r\n配色总是要试试的嘛，怎么调试出自己喜欢的配色再添加到文件里呢？</p>\r\n<p>chrome\r\n打开博客网站，右键你想要更改的元素，例如正文背景，在右键菜单中点【检查】，可以看到如图的调试台，右边则是相应的元素样式。如图：\r\n<img\r\nsrc=\"https://wx1.sinaimg.cn/mw1024/b8e57787gy1ggtuquyezgj20wn0di0v3.jpg\"\r\nalt=\"主要找右边的样式表\" />\r\n比如这里我就把正文背景从原来的纯白，修改为了带点暖黄的护眼色。\r\n然后把更改的这段复制到 styles.styl 即可，如下：</p>\r\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">//正文背景护眼色</span><br><span class=\"line\"><span class=\"selector-pseudo\">:root</span> &#123;</span><br><span class=\"line\">    --<span class=\"selector-tag\">body</span>-bg-<span class=\"attribute\">color</span>: <span class=\"number\">#f9dbb6</span>47;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>重新生成文章即可，其他浏览器调试应该也是同理。</p>\r\n<p>样式修改花样就太多了 ...\r\n整个页面每个地方每个角落都能修改，具体每个想法怎么修改我肯定是覆盖不了的，一般通过浏览器调试找到相应的属性值修改就行。</p>\r\n<p>因此下面通过几个简单的修改作为示例好了。</p>\r\n<h2 id=\"字体配置\">字体配置</h2>\r\n<p>在 next/_config.yml 里，找到 font 字段，一般配置 global\r\n全局字体就行。</p>\r\n<p>字体 CDN 默认是 google 的，可以去里面挑自己喜欢的字体，在 family\r\n字段配置即可。</p>\r\n<p>个人是比较喜欢思源宋体的。</p>\r\n<p>示例如下：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">font:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Uri of fonts host, e.g. https://fonts.googleapis.com (Default).</span></span><br><span class=\"line\">  <span class=\"attr\">host:</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Font options:</span></span><br><span class=\"line\">  <span class=\"comment\"># `external: true` will load this font family from `host` above.</span></span><br><span class=\"line\">  <span class=\"comment\"># `family: Times New Roman`. Without any quotes.</span></span><br><span class=\"line\">  <span class=\"comment\"># `size: x.x`. Use `em` as unit. Default: 1 (16px)</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Global font settings used for all elements inside &lt;body&gt;.</span></span><br><span class=\"line\">  <span class=\"attr\">global:</span></span><br><span class=\"line\">    <span class=\"attr\">external:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">family:</span> <span class=\"string\">Noto</span> <span class=\"string\">Serif</span> <span class=\"string\">SC</span></span><br><span class=\"line\">    <span class=\"attr\">size:</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"标题阴影美化\">标题阴影美化</h2>\r\n<p>标题虽然可以通过字体大小区分，但是光秃秃的几个字在全文里还是有比较混杂的感觉，即不方便分割上下文，也不凸显标题本身。</p>\r\n<p>因此考虑添加阴影来增强标题感。</p>\r\n<p>在 styles 中添加字段如下，具体颜色和大小参数自己配吧。</p>\r\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.post-body</span> <span class=\"selector-tag\">h1</span>, <span class=\"selector-class\">.post-body</span> <span class=\"selector-tag\">h2</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">box-shadow</span>: inset <span class=\"number\">0</span> -<span class=\"number\">0.6em</span> <span class=\"number\">0</span> <span class=\"number\">#ffeb88</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"单句代码悬浮突出美化\">单句代码悬浮突出美化</h2>\r\n<p>单句代码无论用什么颜色修改感觉都差点意思，要么是太过鲜艳，在频繁的地方看的挺烦，要么是太过暗淡，又不够突出明显。</p>\r\n<p>因此搬运了悬浮贴的 css 样式。</p>\r\n<p>单句代码和代码块都在<code>code</code>类下面，因此最好加个<code>p</code>类限制为仅单句代码。</p>\r\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span> <span class=\"selector-tag\">code</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">1em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>: <span class=\"number\">1.5rem</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#333</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-weight</span>: bold;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ebc65a</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0.2em</span> <span class=\"number\">0.2em</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">#ebc65a</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0.1em</span> <span class=\"number\">0.4em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> <span class=\"number\">0.4em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>: bottom;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"修改文章页面宽度\">修改文章页面宽度</h2>\r\n<p>在<code>next\\source\\css\\_variables</code>中找到对应子主题文件的如下字段：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$content-desktop              = &#x27;calc(100% - %s)&#x27; % unit($content-desktop-padding / 2, &#x27;px&#x27;);</span><br><span class=\"line\">$content-desktop-large        = 900px;</span><br><span class=\"line\">$content-desktop-largest      = 61%;</span><br></pre></td></tr></table></figure>\r\n<p>如果子主题文件没有，可以去<code>base.styl</code>里找。</p>\r\n<p>或者自己在子主题文件里添加这个字段。</p>\r\n<p>至于相应的值就自己调试成自己舒服的了。</p>\r\n<blockquote>\r\n<p>小提示：<code>hexo s</code>部署在本地后，可以直接修改这些 styl\r\n文件，刷新页面即生效，不需要中断本地服务器。</p>\r\n</blockquote>\r\n<h2 id=\"修改文章背景色及透明度\">修改文章背景色及透明度</h2>\r\n<p>在<code>next\\source\\css\\_variables</code>中找到对应子主题文件的如下字段：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$content-bg-color             =#ffffffc2;</span><br></pre></td></tr></table></figure>\r\n<p>如果子主题文件没有，可以去<code>base.styl</code>里找。</p>\r\n<p>或者自己在子主题文件里添加这个字段。</p>\r\n<p>值也自己调咯，推荐透明度在 0.9 左右。</p>\r\n<h2 id=\"hightlight代码配色\">hightlight代码配色</h2>\r\n<p>觉得 next 的几款 highlight\r\n都不太搭白底网站，于是摸了一遍发现<code>themes\\next\\source\\css\\_common\\scaffolding\\highlight\\</code>路径下的文件存储着几套主题的配色，可以自己改一套喜欢的了。</p>\r\n<h1 id=\"参考美化\">参考美化</h1>\r\n<p><a\r\nhref=\"https://www.randomyang.top/2019/01/27/pixels%E5%B9%B6%E4%B8%8D%E7%AE%80%E5%8D%95/\">randomyang\r\n的 paper 设计</a></p>\r\n<p><a href=\"https://co5.me/\">co5=Shioko 个人博客</a></p>\r\n<p><a href=\"https://qianling.pw/\">千灵</a></p>\r\n","categories":["工具"],"tags":["博客"]},{"title":"MeteorNet","url":"/2022/01/03/MeteorNet/","content":"<ul>\r\n<li>Liu X, Yan M, Bohg J. Meteornet: Deep learning on dynamic 3d point\r\ncloud sequences[C]//Proceedings of the IEEE/CVF International Conference\r\non Computer Vision. 2019: 9246-9255.</li>\r\n<li>Carnegie Mellon University</li>\r\n</ul>\r\n<h2 id=\"meteor-module\">Meteor Module</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/RgsZUHy.png\"\r\nalt=\"MeteorNet应用架构：左：Meteor模块将不同帧的点先混合起来，然后统一输出特征。右：先分别抽取特征，再通过Meteor模块进行时间特征抽取。\" />\r\n<figcaption\r\naria-hidden=\"true\">MeteorNet应用架构：左：Meteor模块将不同帧的点先混合起来，然后统一输出特征。右：先分别抽取特征，再通过Meteor模块进行时间特征抽取。</figcaption>\r\n</figure>\r\n<h3 id=\"聚类方法\">聚类方法</h3>\r\n<figure>\r\n<img src=\"https://i.imgur.com/iPVSfJv.png\"\r\nalt=\"(a)dircet grouping (b) Chained-flow grouping\" />\r\n<figcaption aria-hidden=\"true\">(a)dircet grouping (b) Chained-flow\r\ngrouping</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<p><strong>Direct grouping</strong>：主要灵感源于\r\n<strong>时间过得越久，物体能移动的最大距离就越远。</strong>\r\n因此对于邻域半径，也可以随着时间增加而增加。</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathcal{N}_{d}\\left(p_{i}^{(t)} ;\r\nr\\right)=\\left\\{p_{j}^{\\left(t^{\\prime}\\right)}\r\n\\mid\\left\\|\\mathbf{x}_{j}^{\\left(t^{\\prime}\\right)}-\\mathbf{x}_{i}^{(t)}\\right\\|&lt;r\\left(\\left|t^{\\prime}-t\\right|\\right)\\right\\}\r\n\\]</span></p>\r\n<p><strong>Chained-flow\r\ngrouping</strong>：物体的运动通常沿着一定的轨迹方向。因此运动可以通过<strong>场景流</strong>[28]来进行描述。首先对于所有的时间<span\r\nclass=\"math inline\">\\(t\\)</span>，利用已知的两个相邻帧的点云<span\r\nclass=\"math inline\">\\(p_i^{t},p_j^{t-1}\\)</span>，通过场景流估计算子<span\r\nclass=\"math inline\">\\(\\mathcal{F}_{0}\\)</span>(如FlowNet3D[14])来找到<span\r\nclass=\"math inline\">\\(p_i^{t}\\)</span>在<span\r\nclass=\"math inline\">\\(t-1\\)</span>帧的对应虚拟点云<span\r\nclass=\"math inline\">\\(p_i^{\\prime(t-1)}\\)</span>，</p>\r\n<p><span class=\"math display\">\\[\r\n\\left\\{\\mathfrak{f}_{i}^{(t,\r\nt-1)}\\right\\}_{i}=\\mathcal{F}_{0}\\left(\\left\\{p_{i}^{(t)}\\right\\},\\left\\{p_{j}^{(t-1)}\\right\\}\\right)\r\n\\]</span></p>\r\n<p>估计得到的点云即 <span\r\nclass=\"math inline\">\\(\\mathbf{x}_{i}^{\\prime(t-1)}=\\mathbf{x}_{i}^{(t)}+\\mathfrak{f}_{i}^{(t,\r\nt-1)}\\)</span></p>\r\n<p>为了找到<span class=\"math inline\">\\(p_i^{t}\\)</span>在<span\r\nclass=\"math inline\">\\(t-2\\)</span>帧的对应虚拟点云，首先用上述同样的方式计算<span\r\nclass=\"math inline\">\\(p_j^{t-1}\\)</span>在<span\r\nclass=\"math inline\">\\(t-2\\)</span>帧的反向流<span\r\nclass=\"math inline\">\\(\\mathfrak{f}_{j}^{(t-1,\r\nt-2)}\\)</span>，然后通过<span\r\nclass=\"math inline\">\\(p_i^{\\prime(t-1)}\\)</span>和<span\r\nclass=\"math inline\">\\(p_j^{t-1}\\)</span>的距离来对<span\r\nclass=\"math inline\">\\(\\mathfrak{f}_{j}^{(t-1,\r\nt-2)}\\)</span>进行一个加权插值得到<span\r\nclass=\"math inline\">\\(\\mathfrak{f}_{i}^{(t-1, t-2)}\\)</span>：</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathfrak{f}_{i}^{\\prime(t-1, t-2)}=\\frac{\\sum_{j=1}^{k}\r\nw\\left(\\mathbf{x}_{j}^{(t-1)}, \\mathbf{x}_{i}^{(t-1)}\\right)\r\n\\mathfrak{f}_{j}^{(t-1, t-2)}}{\\sum_{j=1}^{k}\r\nw\\left(\\mathbf{x}_{j}^{(t-1)}, \\mathbf{x}_{i}^{\\prime(t-1)}\\right)}\r\n\\]</span></p>\r\n<p>其中<span class=\"math inline\">\\(w\\left(\\mathbf{x}_{1},\r\n\\mathbf{x}_{2}\\right)=\\frac{1}{d\\left(\\mathbf{x}_{1},\r\n\\mathbf{x}_{2}\\right)^{p}}\\)</span>为反距离函数，这样即可以得到<span\r\nclass=\"math inline\">\\(t-2\\)</span>时刻的估计点云：<span\r\nclass=\"math inline\">\\(\\mathbf{x}_{i}^{\\prime(t-2)}=\\mathbf{x}_{i}^{(t)}+\\mathfrak{f}_{i}^{(t,\r\nt-1)}+{\\mathfrak{f}}_{i}^{(t-1, t-2)}\\)</span>。</p>\r\n<p>对于<span class=\"math inline\">\\(t-2\\)</span>往前的帧都可以重复上述\r\nchained 插值方式进行处理得到。最终可以根据虚拟点云来确定邻域范围为：</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathcal{N}_{c}\\left(p_{i}^{(t)} ;\r\nr\\right)=\\left\\{p_{j}^{\\left(t^{\\prime}\\right)}\r\n\\mid\\left\\|\\mathbf{x}_{j}^{\\left(t^{\\prime}\\right)}-\\mathbf{x}_{i}^{\\prime\\left(t^{\\prime}\\right)}\\right\\|&lt;r\\right\\}\r\n\\]</span></p>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[28] Sundar Vedula, Simon Baker, Peter Rander, Robert Collins, and\r\nTakeo Kanade. Three-dimensional scene flow. In ICCV,1999</p>\r\n<p>[14] Xingyu Liu, Charles. R. Qi, and Leonidas J. Guibas. Flownet3d:\r\nLearning scene flow in 3d point clouds. In CVPR, 2019.</p>\r\n","categories":["深度学习"],"tags":["深度学习","点云","序列学习"]},{"title":"Hexo+Next7.8 功能性配置","url":"/2020/07/23/Next7-8-%E5%8A%9F%E8%83%BD%E6%80%A7%E9%85%8D%E7%BD%AE/","content":"<p>环境信息：</p>\r\n<ul>\r\n<li>Next 7.8.0</li>\r\n<li>hexo 4.2.1</li>\r\n<li>npm 6.14.5</li>\r\n<li>Next 配置文件指 **项目根目录/themes/next/_config.yml**</li>\r\n<li>项目配置文件指 **项目根目录/_config.yml**</li>\r\n<li>安装命令没特别说明都在 项目根目录 下进行</li>\r\n<li>注意在配置文件中配置字段时，请严格控制缩进</li>\r\n</ul>\r\n<p><strong>请根据目录章节按需阅读。所有配置都建立在2020年 7.8\r\n版本的基础之上实现的，保新保质，绝对不是复制偷搬那些祖传博客。</strong></p>\r\n<blockquote>\r\n<p>在吗？吐槽无数遍，2020 的人为什么写博客还抄的 Next4.0\r\n版本！就算你不想用 2020 大改版的版本，好歹和我一样用个 7.8\r\n吧！！至少来个 7.0+吧孩子们！！退一万步 6.0+也是可以的啊！！</p>\r\n</blockquote>\r\n<p>一些比较常规的功能性配置 Next\r\n文档里都有的。虽然是英文文档，虽然可能和你的版本有一点点不同，但它是基本跟着最新版本，比较全面。另外可以多摸摸\r\nNext\r\n配置文件，里面注释写的蛮详细的，有些东西看注释就知道能开启什么功能，当然，有很多功能需要额外插件支持。</p>\r\n<p><a href=\"https://theme-next.js.org/docs/\">Next 官方手册</a></p>\r\n<p>友情建议：进行较大更改之前，先通过git等方式进行保存。并且更改后为了避免样式不刷新，尽量先<code>hexo clean</code>清除样式再生成，并且最好先在本地<code>hexo s</code>部署。确认没有千疮百孔再推到线上吧。</p>\r\n<p><span id=\"more\"></span></p>\r\n<h2 id=\"站点概览描述\">站点概览描述</h2>\r\n<p>在项目配置里，第一段填写相关描述，如果是 next\r\n主题，会显示在侧边栏中。</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Site</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">我是一个标题</span></span><br><span class=\"line\"><span class=\"attr\">subtitle:</span> <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">&#x27;我是一段描述&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">keywords:</span> <span class=\"string\">Sitch,Blog</span></span><br><span class=\"line\"><span class=\"attr\">author:</span> <span class=\"string\">Sitch</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-CN</span></span><br><span class=\"line\"><span class=\"attr\">timezone:</span> <span class=\"string\">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"配置头像\">配置头像</h2>\r\n<p>在 Next 配置文件下找到 <code>avatar</code>字段，有如下配置项：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Sidebar Avatar</span></span><br><span class=\"line\"><span class=\"attr\">avatar:</span></span><br><span class=\"line\">  <span class=\"comment\"># Replace the default image and set the url here. 你的头像图片路径</span></span><br><span class=\"line\">  <span class=\"attr\">url:</span> <span class=\"string\">/images/avatar.png</span></span><br><span class=\"line\">  <span class=\"comment\"># If true, the avatar will be dispalyed in circle. 要不要圆化</span></span><br><span class=\"line\">  <span class=\"attr\">rounded:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"comment\"># If true, the avatar will be rotated with the cursor. 要不要在指针悬停时旋转头像</span></span><br><span class=\"line\">  <span class=\"attr\">rotated:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\r\n<p>如上给了个示例路径，然后将头像放在 <strong>主题</strong>目录下的\r\nsource/images/avatar.png 即可。</p>\r\n<p>另外两个属性可以按需配置。</p>\r\n<p>重新生成部署网站，瞅瞅你的大头照吧。</p>\r\n<blockquote>\r\n<p>头像图片大小没关系，会自动缩放，但是比例不变，即使圆化也会变成椭圆。因此请注意图片比例最好是正方形，美观。</p>\r\n</blockquote>\r\n<h2 id=\"next-的分类和标签\">Next 的分类和标签</h2>\r\n<p>在 next\r\n主题配置里，选择下列字段进行注释和取消注释即可启用相关页面，例如分类页和标签页。\r\n&gt;分类有层级，标签没有层级。</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">menu:</span> <span class=\"comment\"># 子链接 || font-font awesome 图标</span></span><br><span class=\"line\">  <span class=\"attr\">home:</span> <span class=\"string\">/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-home</span></span><br><span class=\"line\">  <span class=\"comment\">#about: /about/ || fa fa-user</span></span><br><span class=\"line\">  <span class=\"comment\">#tags: /tags/ || fa fa-tags</span></span><br><span class=\"line\">  <span class=\"attr\">categories:</span> <span class=\"string\">/categories/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-th</span></span><br><span class=\"line\">  <span class=\"attr\">archives:</span> <span class=\"string\">/archives/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-archive</span></span><br><span class=\"line\">  <span class=\"comment\"># schedule: /schedule/ || fa fa-calendar</span></span><br><span class=\"line\">  <span class=\"comment\"># sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class=\"line\">  <span class=\"comment\">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>\r\n<p>需要生成两个对应主页，在项目根目录下输入相应命令，创建相关页面。</p>\r\n<ul>\r\n<li><code>hexo new page categories</code></li>\r\n<li><code>hexo new page tags</code></li>\r\n</ul>\r\n<p>并且打开生成的页面，在元数据中相应添加字段</p>\r\n<ul>\r\n<li><code>type: categories</code></li>\r\n<li><code>type: tags</code>。</li>\r\n</ul>\r\n<p>想要为博客分类，即在自己的每篇博客描述头中，加入<code>categories:</code>\r\n<code>tags:</code>的相关字段，例如这篇：</p>\r\n<figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\">categories: </span><br><span class=\"line\"><span class=\"bullet\">-</span> 博客搭建</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"hexo文章资源管理\">hexo文章资源管理</h2>\r\n<p>想要简单使用懒得管理，直接放在\r\n<strong>项目目录/source/images</strong> 中。然后通过\r\n<strong>/images/something.jpg</strong> 路径进行调用。</p>\r\n<p>想要有规律的整理的话，hexo也有自带组织方式。资源管理功能打开后，Hexo会在hexo\r\nnew的时候创建一个和文章同名文件夹，将文章相关资源放进去即可。生成网页时资源和文章在同一路径，因此可以利用相对路径直接调用资源。</p>\r\n<p><a\r\nhref=\"https://hexo.io/zh-cn/docs/asset-folders\">hexo文档相关章节</a></p>\r\n<p>项目配置中设置：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">post_asset_folder:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>图片推荐使用Win10照片编辑器质量调整进行压缩。\r\n用照片编辑器打开图片，右键--调整大小--自定义尺寸--质量40%。压缩比高的惊人，粗略观感也没有太大区别。例如我1.8KB的图片质量40%可以变成0.09KB。</p>\r\n</blockquote>\r\n<h2 id=\"音乐\">音乐</h2>\r\n<h3 id=\"网易云音乐\">网易云音乐</h3>\r\n<p>先去网易云音乐里歌曲页面生成<strong>外链播放器</strong>，\r\n不能生成的可查找特殊方法生成。</p>\r\n<p>在 项目/themes/next/layout/_macro/sidebar.swig 中，\r\n插入复制的代码，比如插入在最下面某一段。 &gt;注意 2020 版本后缀不是\r\nswig，相关文件也不一样</p>\r\n<h3 id=\"aplayer全局音乐播放器\">aplayer全局音乐播放器</h3>\r\n<p>虽然网易云音乐足够播放一首歌或一个歌单，但是仅限定于网易云可怜的版权库里。</p>\r\n<p>通过使用APlayer播放器，可以播放任意来源的音乐，例如QQ音乐【我喜欢】的歌单。</p>\r\n<blockquote>\r\n<p>注意是原版APlayer，不是hexo-tag-aplayer</p>\r\n</blockquote>\r\n<p>无基础偷懒可以复制以下代码至 **主题目录/layout/_layout.swig**\r\n中，我放在了<code>&lt;/html&gt;</code>的前一行。</p>\r\n<blockquote>\r\n<p>有基础可以去看看中文文档，安装npm包，并且自定义使用。</p>\r\n</blockquote>\r\n<p>可以通过文档查看各个参数的意义，进行播放的设置。\r\n示例代码中是以<strong>QQ音乐</strong>为服务器，以<strong>我自己的歌单</strong>为播放列表。</p>\r\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- require APlayer --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- require MetingJS --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--如果将本体放在body里面，导致页面加载出现问题，请尝试放到body体后面--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;aplayer&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">data-id</span>=<span class=\"string\">&quot;3036324986&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">data-server</span>=<span class=\"string\">&quot;tencent&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">data-type</span>=<span class=\"string\">&quot;playlist&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">data-fixed</span>=<span class=\"string\">&quot;true&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">data-order</span>=<span class=\"string\">&quot;list&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">data-volume</span>=<span class=\"string\">&quot;0.65&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">data-autoplay</span>=<span class=\"string\">&quot;false&quot;</span>   </span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">date-preload</span>=<span class=\"string\">&quot;auto&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">data-theme</span>=<span class=\"string\">&quot;#cc543a&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\r\n<p>当然，全局播放器会在每一次切换站内页面时中断。\r\n要不中断播放请安装<strong>pjax</strong>功能，详见下一节。</p>\r\n<blockquote>\r\n<p>我为了百度统计，hexo-douban等功能不冲突，关闭了pjax。</p>\r\n</blockquote>\r\n<p>参考资料：<a\r\nhref=\"https://hakurei.red/2019/11/25/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80APlayer%E6%92%AD%E6%94%BE%E5%99%A8/\">Macyrate的APlyaer博客</a></p>\r\n<p><a href=\"https://aplayer.js.org/#/zh-Hans/\">Aplayer文档</a></p>\r\n<h2 id=\"pjax\">pjax</h2>\r\n<p>pjax可以使网页变成单页应用，即在站内切换页面并不会刷新网页，极大提高网页运行速度。</p>\r\n<p>但是！这么好的东西为什么不是默认开启的呢？\r\npjax会扰乱网站的一些其他功能。如hexo-douban页面，百度统计的访客记录\r\n......</p>\r\n<p>如果网站没有其他功能需求，建议开Pjax，否则建议不安装。</p>\r\n<p>在Next配置文件中设置pjax为true，并且去对应网站查看安装插件的方法。\r\n如git\r\nclone安装：<code>git clone https://github.com/theme-next/theme-next-pjax themes/next/source/lib/pjax</code>。</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Easily enable fast Ajax navigation on your website.</span></span><br><span class=\"line\"><span class=\"comment\"># Dependencies: https://github.com/theme-next/theme-next-pjax</span></span><br><span class=\"line\"><span class=\"attr\">pjax:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"数学公式支持\">数学公式支持</h2>\r\n<p>参考官方文档，需要切换到带有渲染mathjax的渲染引擎</p>\r\n<p>安装pandoc软件，<a\r\nhref=\"https://github.com/jgm/pandoc/releases/\">下载地址</a></p>\r\n<blockquote>\r\n<p>出现错误exit with code null\r\n大概是没有安装pandoc软件就直接安装了插件，补安装后如果还报错重启一下。</p>\r\n</blockquote>\r\n<p>命令行安装插件</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm uninstall hexo-renderer-marked --save</span><br><span class=\"line\">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure>\r\n<p>在 主题/_config.yml中，打开mathjax功能：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Math Formulas Render Support</span></span><br><span class=\"line\"><span class=\"attr\">math:</span></span><br><span class=\"line\">  <span class=\"comment\"># Default (true) will load mathjax / katex script on demand.</span></span><br><span class=\"line\">  <span class=\"comment\"># That is it only render those page which has `mathjax: true` in Front-matter.</span></span><br><span class=\"line\">  <span class=\"comment\"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span></span><br><span class=\"line\">  <span class=\"attr\">per_page:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span></span><br><span class=\"line\">  <span class=\"attr\">mathjax:</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"comment\"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class=\"line\">    <span class=\"attr\">mhchem:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\r\n<p>在Markdown中写下：<code>$$a^n+b^n=(a+b)(a^&#123;n−1&#125;b^0−a^&#123;n−2&#125;b^1+a^&#123;n−3&#125;b^2−…−ab^&#123;n−2&#125;+a^0b^&#123;n−1&#125;)$$</code>，最终效果如下：</p>\r\n<p><span\r\nclass=\"math display\">\\[a^n+b^n=(a+b)(a^{n−1}b^0−a^{n−2}b^1+a^{n−3}b^2−…−ab^{n−2}+a^0b^{n−1})\\]</span></p>\r\n<p>最后重新运行即可</p>\r\n<h2 id=\"导入豆瓣评价页面\">导入豆瓣评价页面</h2>\r\n<p>个人博客肯定想记录点自己生活向的东西，看过的电影，玩过的游戏,看过的书就是一个很好的记录对象。</p>\r\n<blockquote>\r\n<p>程序员大概很少有时间看文学书</p>\r\n</blockquote>\r\n<p>之前我是用 <strong>markdown</strong>\r\n写了个文本条目性质的，不说难看吧，但起码豆瓣条目自带一些影片介绍信息。..</p>\r\n<h3 id=\"安装-hexo-douban-插件\">安装 hexo-douban 插件</h3>\r\n<p>命令行输入</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-douban --save</span><br></pre></td></tr></table></figure>\r\n<p>将下面的配置写入<strong>项目</strong>配置文件：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">douban:</span> <span class=\"comment\">#不想启用的页面注释掉即可</span></span><br><span class=\"line\">  <span class=\"attr\">user:</span> <span class=\"string\">豆瓣</span> <span class=\"string\">id</span>  </span><br><span class=\"line\">  <span class=\"attr\">builtin:</span> <span class=\"literal\">false</span>  <span class=\"comment\">#是否将生成豆瓣页面功能嵌入到 hexo s 和 hexo g</span></span><br><span class=\"line\">  <span class=\"attr\">book:</span></span><br><span class=\"line\">    <span class=\"attr\">title:</span> <span class=\"string\">&#x27;This is my book title&#x27;</span>  <span class=\"comment\">#页面标题</span></span><br><span class=\"line\">    <span class=\"attr\">quote:</span> <span class=\"string\">&#x27;This is my book quote&#x27;</span>  <span class=\"comment\">#页面序言</span></span><br><span class=\"line\">  <span class=\"attr\">movie:</span></span><br><span class=\"line\">    <span class=\"attr\">title:</span> <span class=\"string\">&#x27;This is my movie title&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">quote:</span> <span class=\"string\">&#x27;This is my movie quote&#x27;</span></span><br><span class=\"line\">  <span class=\"attr\">game:</span></span><br><span class=\"line\">    <span class=\"attr\">title:</span> <span class=\"string\">&#x27;This is my game title&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">quote:</span> <span class=\"string\">&#x27;This is my game quote&#x27;</span></span><br><span class=\"line\">  <span class=\"attr\">timeout:</span> <span class=\"number\">10000</span> <span class=\"comment\">#爬取豆瓣数据的超时时间，别管了</span></span><br></pre></td></tr></table></figure>\r\n<p>豆瓣 id 可以在进入你的豆瓣个人主页，观察网址获得。通常为：</p>\r\n<p><code>https://www.douban.com/people/你的id/</code></p>\r\n<h3 id=\"hexo-douban-命令\">hexo douban 命令</h3>\r\n<p>用法如下：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Usage:</span> <span class=\"string\">命令行输入</span> <span class=\"string\">hexo</span> <span class=\"string\">douban</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">Description:</span></span><br><span class=\"line\"><span class=\"string\">爬取生成豆瓣相关页面</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">Options:</span> <span class=\"comment\">#默认参数 -bgm</span></span><br><span class=\"line\">  <span class=\"string\">-b,</span> <span class=\"string\">--books</span>   <span class=\"string\">Generate</span> <span class=\"string\">douban</span> <span class=\"string\">books</span> <span class=\"string\">only</span></span><br><span class=\"line\">  <span class=\"string\">-g,</span> <span class=\"string\">--games</span>   <span class=\"string\">Generate</span> <span class=\"string\">douban</span> <span class=\"string\">games</span> <span class=\"string\">only</span></span><br><span class=\"line\">  <span class=\"string\">-m,</span> <span class=\"string\">--movies</span>  <span class=\"string\">Generate</span> <span class=\"string\">douban</span> <span class=\"string\">movies</span> <span class=\"string\">only</span></span><br><span class=\"line\">  <span class=\"string\">-h，显示帮助</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"使用方法\">使用方法</h3>\r\n<ul>\r\n<li><code>hexo douban</code>生成相关页面再进行部署。</li>\r\n<li>builtin 开启时，直接 hexo s 和 hexo g 即包含生成过程。</li>\r\n</ul>\r\n<blockquote>\r\n<p>注意安装了 hexo-douban\r\n之后，我们多了个<code>hexo douban</code>的命令，因此不能再用<code>hexo d</code>作为<code>hexo deploy</code>的缩写了。</p>\r\n</blockquote>\r\n<h3 id=\"开个主页栏\">开个主页栏</h3>\r\n<p>生成部署后就可以通过<code>/主网址/movies</code>类似的形式访问了，但这样显然不方便，因此我们开个主页栏给它。</p>\r\n<p>和之前开启分类页一样，在<strong>主题</strong>配置文件中，找到 menu\r\n字段，添加相应的值，如下以 movies 举例进行修改：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">menu:</span> <span class=\"comment\"># 子链接 || font-font awesome 图标</span></span><br><span class=\"line\">  <span class=\"attr\">home:</span> <span class=\"string\">/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-home</span></span><br><span class=\"line\">  <span class=\"comment\">#about: /about/ || fa fa-user</span></span><br><span class=\"line\">  <span class=\"attr\">tags:</span> <span class=\"string\">/tags/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-tags</span></span><br><span class=\"line\">  <span class=\"attr\">categories:</span> <span class=\"string\">/categories/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-th</span></span><br><span class=\"line\">  <span class=\"attr\">archives:</span> <span class=\"string\">/archives/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-archive</span></span><br><span class=\"line\">  <span class=\"attr\">movies:</span> <span class=\"string\">/movies/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-film</span>  <span class=\"comment\">#添加了 movies 页</span></span><br><span class=\"line\">  <span class=\"comment\">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class=\"line\">  <span class=\"comment\">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class=\"line\">  <span class=\"comment\">#commonweal: /404/ || fa fa-heartbeat</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>但是这样开启之后，显示的是 movies\r\n，想改成中文显示需要在<code>主题目录/languages/zh-CN</code>中配置一下，自己打开看看就懂得怎么配了，懒得贴实例了哈=。=</p>\r\n<h3 id=\"参考资料\">参考资料</h3>\r\n<p><a href=\"https://github.com/mythsman/hexo-douban\">hexo-douban\r\n文档</a></p>\r\n<h2 id=\"字数统计和阅读时长已废弃\">字数统计和阅读时长（已废弃）</h2>\r\n<p><strong>hexo-symbols-count-time 已失去维护，且其依赖项highlight\r\nversion9 已经过时，无法使用。</strong></p>\r\n<p>在 next 主题配置文件中搜索 wordcount，可以看到它默认支持的插件是 <a\r\nhref=\"https://github.com/theme-next/hexo-symbols-count-time\">hexo-symbols-count-time</a></p>\r\n<p>使用命令行 npm\r\n输入命令进行安装：<code>npm i hexo-symbols-count-time --save</code></p>\r\n<p>项目_config.yml 里追加一段（没追加这一段导致统计为 NaN</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">symbols_count_time:</span></span><br><span class=\"line\"> <span class=\"attr\">symbols:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"> <span class=\"attr\">time:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"> <span class=\"attr\">total_symbols:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">total_time:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">awl:</span> <span class=\"number\">2</span>      <span class=\"comment\">#设置 2 个字符看作一个字</span></span><br><span class=\"line\">  <span class=\"attr\">wpm:</span> <span class=\"number\">200</span>    <span class=\"comment\">#每分钟阅读字数</span></span><br></pre></td></tr></table></figure>\r\n<p>next 主题的_config.yml 里找到字段 symbols_count_time\r\n按需配置即可：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Post wordcount display settings</span></span><br><span class=\"line\"><span class=\"comment\"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class=\"line\"><span class=\"attr\">symbols_count_time:</span></span><br><span class=\"line\">  <span class=\"attr\">separated_meta:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">item_text_post:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">item_text_total:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>重新生成部署即可，如果没有效果，试试 hexo clean 再重新生成</p>\r\n<h2 id=\"首页摘要-阅读全文\">首页摘要 阅读全文</h2>\r\n<p>如果你是找了半天博客，发现他们都说 Next\r\n自带自动摘要功能，但自己这就是不起作用的时候，恭喜你，和我一起把那些馊饭博客砸了吧。</p>\r\n<p>7.6 以后的 Next 删除了自动摘要功能，原因是它觉得它负担了太多。..</p>\r\n<p>我 7.8 的 Next\r\n配置文件里只有个<code>excerpt_description</code>，这个功能是自动将博客头描述里的<code>description</code>字段当作摘要。</p>\r\n<p>所以现在首页摘要只有两种办法：</p>\r\n<ul>\r\n<li>为每个博客写好 description</li>\r\n<li>在博客中间手动添加<code>&lt;!-- more --&gt;</code>以截断</li>\r\n</ul>\r\n<h2 id=\"添加百度分析-现需备案才能使用\">添加百度分析\r\n(现需备案才能使用)</h2>\r\n<p>登陆 <a\r\nhref=\"https://tongji.baidu.com/web/10000256460/welcome/login\">百度统计</a></p>\r\n<p>进入个人页，选择侧栏的代码获取页</p>\r\n<p>可以看到如下一段代码，找到<code>hm.js?</code>之后的序列号复制。</p>\r\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">var</span> _hmt = _hmt || [];</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> hm = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;script&quot;</span>);</span><br><span class=\"line\">  hm.src = <span class=\"string\">&quot;https://hm.baidu.com/hm.js? 复制这段&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> s = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">&quot;script&quot;</span>)[<span class=\"number\">0</span>]; </span><br></pre></td></tr></table></figure>\r\n<p>填写在 next 配置里的百度分析字段中：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Baidu Analytics</span></span><br><span class=\"line\"><span class=\"attr\">baidu_analytics:</span> <span class=\"string\">粘贴到这里</span></span><br></pre></td></tr></table></figure>\r\n<p>之后等待一段时间就可以去百度分析主页看网站情况啦。</p>\r\n<p>然后你就能开心地发现几天，几十天，几百天，访问量蹭蹭蹭的涨，访问 ip\r\n一直都只有 1 个 hhhh。</p>\r\n<p>嗯，其实在被搜索引擎收录之前别人是搜不到你的博客的。</p>\r\n<p>请捞一捞下面的 Google 收录方法。</p>\r\n<h2 id=\"搜索引擎收录\">搜索引擎收录</h2>\r\n<p>以 Next 主题配置 Google 收录为例。</p>\r\n<p>登录 <a href=\"https://search.google.com/search-console/\">Google\r\nSearch Console</a></p>\r\n<blockquote>\r\n<p>当然，没有账号的话需要自己搞好 Google 账号</p>\r\n</blockquote>\r\n<h3 id=\"选择资源类型\">选择资源类型</h3>\r\n<p>我是 GitHub Pages\r\n域名的个人网站，所以选右边的单网址的资源类型。把博客网址复制过去即可创建资源。</p>\r\n<h3 id=\"验证网站所有权\">验证网站所有权</h3>\r\n<p>Goolge 推荐验证方法是下载 HTML\r\n文件。但是，我们不用。毕竟一个<code>hexo clean</code>网页就没了。..</p>\r\n<p>选下面的 HTML 标记验证，可以看到形如下面的一段代码。</p>\r\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;google-site-verification&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\r\n<p>把 xxxx 的东西复制好。</p>\r\n<p>打开 Next\r\n的配置文件，搜索到<code>google_site_verification</code>字段，把复制的字段填进去就好。</p>\r\n<p><code>hexo clean;hexo g;hexo d</code>一套刷新网站组合拳。</p>\r\n<p>回刚才的 Google 家里点击进行验证即可。</p>\r\n<p>验证成功后可以 Google\r\n搜索<code>site: 你的网址</code>试试，理应看到你的博客网址。</p>\r\n<blockquote>\r\n<p>这里很多看很多博客都是在抄几年前的方法，明明 2020 了啊哥哥们，Next\r\n已经传宗接代到 8.0\r\n了！！已经有内置<code>google-site-verification</code>字段了！！</p>\r\n<p>明明限制了搜索时间是半年以内，结果 2020 年这群人写的教程还是抄的 10\r\n年的东西看着好烦啊喂！！！！！！！！！！！！！！</p>\r\n</blockquote>\r\n<h3 id=\"添加站点地图-sitemap\">添加站点地图 SiteMap</h3>\r\n<p>站点地图可以将我们网站的组织架构提供给 Google，都是为了搜索优化==</p>\r\n<p>安装 hexo 自动生成站点地图的插件：</p>\r\n<p><code>npm install hexo-generator-sitemap --save</code></p>\r\n<p>安装成功后在项目配置文件中添加：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">sitemap:</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">sitemap.xml</span></span><br></pre></td></tr></table></figure>\r\n<p>这样插件每次会在<code>hexo g</code>时自动生成 sitemap.xml\r\n文件，放在/public/下面。</p>\r\n<blockquote>\r\n<p>注意博客文件名带有<code>&amp;</code>时，生成的 sitemap.xml\r\n会有错误，我的解决办法是修改文件名。</p>\r\n</blockquote>\r\n<p>其实我们也知道每次部署出去的网站也就是/public/目录，所以 sitemap.xml\r\n相当于放在网站根目录下面。</p>\r\n<p>因此我们把<code>你的网站地址/sitemap.xml</code>这个链接提交给 Google\r\n即可。</p>\r\n<p>执行<code>hexo g;hexo d</code>生成 sitemap 并部署出去。</p>\r\n<p>在 <a\r\nhref=\"https://search.google.com/search-console/sitemaps/\">Google\r\nSearchConsole</a> 侧栏找到站点地图，提交上面说的链接，完毕。</p>\r\n<h3 id=\"百度收录\">百度收录</h3>\r\n<p>百度收录也是完全同理，next\r\n也内置了验证字段。需要注意的是，百度收录仅支持一级域名收录，所以假如没有自己的域名，GitHub\r\nPages 必须是个人主页user.github.io。</p>\r\n<p>并且由于百度无法爬取github\r\npages，因此需要自己主动提交网址供索引：</p>\r\n<ul>\r\n<li>next可以开启<strong>主动推送 baidu_push:\r\ntrue</strong>功能，每次点击你的某个网址时，会推送该网址给百度。(注意要在自己网站上关闭浏览器的广告拦截插件，这个会限制hexo脚本运行)</li>\r\n<li>自己去站点管理页主动提交sitemap。</li>\r\n</ul>\r\n<h2 id=\"站内本地搜索\">站内本地搜索</h2>\r\n<p>安装插件：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>\r\n<p>编辑<strong>项目</strong>配置文件，新增字段：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">search:</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">search.json</span>  <span class=\"comment\">#支持 json 或者 xml，默认 xml，但我用的有问题，推荐 json</span></span><br><span class=\"line\">  <span class=\"attr\">field:</span> <span class=\"string\">post</span></span><br><span class=\"line\">  <span class=\"attr\">format:</span> <span class=\"string\">html</span></span><br><span class=\"line\">  <span class=\"attr\">limit:</span> <span class=\"number\">10000</span></span><br></pre></td></tr></table></figure>\r\n<p>编辑<strong>主题</strong>配置文件，修改字段：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Local search</span></span><br><span class=\"line\"><span class=\"attr\">local_search:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"评论系统-valine\">评论系统 Valine</h2>\r\n<blockquote>\r\n<p>“会有人讨论吗？”——好的，回来填评论系统的坑了。</p>\r\n</blockquote>\r\n<p>Next 支持多评论系统同时存在 ...\r\n虽然我不知道哪个憨憨会同时装躲个评论系统，评论数据又不能共享。</p>\r\n<p>Next 内建支持很多评论系统，我选择了在国内支持比较友好的 Valine。</p>\r\n<p>可以跟着 Next\r\n官方教程做，当然不愿意看英文也无所谓，欢迎继续跟着我~</p>\r\n<p><a\r\nhref=\"https://theme-next.js.org/docs/third-party-services/comments.html\">Next-Valine</a></p>\r\n<p><strong><a\r\nhref=\"https://leancloud.cn/dashboard/login.html#/signin\">LeanCloud\r\n注册登录</a></strong>： Valine 使用了 LeanCloud 作为数据段，因此去\r\nLeanCloud 注册登录就行，然后创建应用。虽然这个注册需要实名制 ...\r\n有点小小小在意。</p>\r\n<p><strong>获取 ID 和\r\nKey</strong>：进入创建好的应用，选择<code>设置-&gt;应用 Keys</code>子页，复制<code>APP ID</code>和<code>App Key</code>。</p>\r\n<p><strong>Next 配置</strong>，在<strong>主题</strong>配置文件中搜索\r\ncomments, 找到字段如下，这里基本不用修改，按需看注释选择配置吧：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Multiple Comment System Support</span></span><br><span class=\"line\"><span class=\"attr\">comments:</span></span><br><span class=\"line\">  <span class=\"comment\"># Available values: tabs | buttons</span></span><br><span class=\"line\">  <span class=\"attr\">style:</span> <span class=\"string\">tabs</span></span><br><span class=\"line\">  <span class=\"comment\"># Choose a comment system to be displayed by default.</span></span><br><span class=\"line\">  <span class=\"comment\"># Available values: changyan | disqus | disqusjs | gitalk | livere | valine</span></span><br><span class=\"line\">  <span class=\"attr\">active:</span> <span class=\"string\">valine</span></span><br><span class=\"line\">  <span class=\"comment\"># Setting `true` means remembering the comment system selected by the visitor.</span></span><br><span class=\"line\">  <span class=\"attr\">storage:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\"># Lazyload all comment systems.</span></span><br><span class=\"line\">  <span class=\"attr\">lazyload:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"comment\"># Modify texts or order for any navs, here are some examples.</span></span><br><span class=\"line\">  <span class=\"attr\">nav:</span></span><br><span class=\"line\">    <span class=\"comment\">#disqus:</span></span><br><span class=\"line\">    <span class=\"comment\">#  text: Load Disqus</span></span><br><span class=\"line\">    <span class=\"comment\">#  order: -1</span></span><br><span class=\"line\">    <span class=\"comment\">#gitalk:</span></span><br><span class=\"line\">    <span class=\"comment\">#  order: -2</span></span><br></pre></td></tr></table></figure>\r\n<p>在<strong>主题</strong>配置文件中搜索 valine\r\n，找到相应的字段如下：</p>\r\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">valine:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"attr\">appid:</span> <span class=\"comment\">#你的 APPID</span></span><br><span class=\"line\">  <span class=\"attr\">appkey:</span> <span class=\"comment\">#你的 APPkey</span></span><br><span class=\"line\">  <span class=\"attr\">notify:</span> <span class=\"literal\">false</span> <span class=\"comment\"># 邮件提醒</span></span><br><span class=\"line\">  <span class=\"attr\">verify:</span> <span class=\"literal\">false</span> <span class=\"comment\"># 验证码</span></span><br><span class=\"line\">  <span class=\"attr\">placeholder:</span> <span class=\"string\">欢迎用你的脸滚一滚键盘~</span>  <span class=\"comment\">#评论输入框预置文字</span></span><br><span class=\"line\">  <span class=\"attr\">avatar:</span> <span class=\"string\">mm</span> <span class=\"comment\"># Gravatar style</span></span><br><span class=\"line\">  <span class=\"attr\">guest_info:</span> <span class=\"string\">nick,mail,link</span> <span class=\"comment\"># 自定义评论区头部</span></span><br><span class=\"line\">  <span class=\"attr\">pageSize:</span> <span class=\"number\">10</span> <span class=\"comment\"># 分页限制大小</span></span><br><span class=\"line\">  <span class=\"attr\">language:</span> <span class=\"comment\"># 语言，可用值：en, zh-cn</span></span><br><span class=\"line\">  <span class=\"attr\">visitor:</span> <span class=\"literal\">false</span> <span class=\"comment\"># Article reading statistic</span></span><br><span class=\"line\">  <span class=\"attr\">comment_count:</span> <span class=\"literal\">true</span> <span class=\"comment\"># If false, comment count will only be displayed in post page, not in home page</span></span><br><span class=\"line\">  <span class=\"attr\">recordIP:</span> <span class=\"literal\">false</span> <span class=\"comment\"># 是否记录 IP</span></span><br><span class=\"line\">  <span class=\"attr\">serverURLs:</span> <span class=\"comment\"># 注意国际版需要填写这里。</span></span><br><span class=\"line\">  <span class=\"comment\">#post_meta_order: 0</span></span><br></pre></td></tr></table></figure>\r\n<p>把 enable 置 true，并且对应粘贴好之前的 AppID 和 AppKey。</p>\r\n<p>重新部署就可以用了，默认为每个页面开启评论系统。</p>\r\n<blockquote>\r\n<p>特别注意LeanCloud国际版需要填写serverURLs字段：在LeanCloud\r\n设置--应用凭证--REST API服务器地址。</p>\r\n</blockquote>\r\n<h3 id=\"页面单独关闭评论\">页面单独关闭评论</h3>\r\n<p>在 markdown\r\n文件的元数据描述符中，添加<code>comments: false</code>，即可在当前页面关闭评论。</p>\r\n<blockquote>\r\n<p>推荐导航栏的那几个导航页都关掉，例如分类页、标签页、关于页。</p>\r\n</blockquote>\r\n<h3 id=\"管理评论数据\">管理评论数据</h3>\r\n<p>登录 LeanCloud\r\n对应应用的管理页面，选择<code>存储-&gt;结构化数据-&gt;Comment</code>，即可看到评论数据，并且可以偷偷行使你的管理权限。</p>\r\n<h3 id=\"评论邮件通知-valine-admin\">评论邮件通知 valine-admin</h3>\r\n<p><a href=\"https://github.com/DesertsP/Valine-Admin\">官网地址</a></p>\r\n<h2 id=\"更换自定义域名\">更换自定义域名</h2>\r\n<p>首先，找一个卖域名的网站买好自己的域名= =并且做好DNS解析转到Github\r\nPages，腾讯云是可以一键解析到目标网址如： alobal.github.io。</p>\r\n<p>然后在你的博客source文件夹下，新建一个CNAME文件，内容写上你的域名如：sitchzou.com，重新部署即可。</p>\r\n<blockquote>\r\n<p>注意Github\r\npages设置里也可以改域名，但是只在那里改的话，你会发现每次部署域名都失效。因为它本质上就是在你的仓库根目录下创建了CNAME文件，但是你自己没在source里建的话，每次部署就把这个文件删除了。</p>\r\n</blockquote>\r\n<h2 id=\"hexo忽略文章\">Hexo忽略文章</h2>\r\n<p>不要用Hexo配置文件的 exclude字段来忽略 'source/_posts/'\r\n中的文章，这样没有用。在要忽略的文件的文件名之前加一个下划线\"_\"即可忽略。</p>\r\n<blockquote>\r\n<p>使用 'skip_render'可跳过指定文件的渲染，即将文件原封不动发布。</p>\r\n</blockquote>\r\n<h2 id=\"错误排除\">错误排除</h2>\r\n<h3 id=\"hexo升级到5.4引发bug\">hexo升级到5.4引发BUG</h3>\r\n<p><strong>next7.8的目录跳转功能失效</strong>：<a\r\nhref=\"https://www.github.com/next-theme/hexo-theme-next/commit/0d2b3af50b3b597fb3d0ecd6a6ffdfbf6b92745b\">参考该commit修改文件即可</a></p>\r\n<p><strong>阅读全文失效</strong>：严格按照<code>&lt;!-- more --&gt;</code>分割，之前的版本中格式比较随意也能兼容，5.4不行。</p>\r\n<h3 id=\"mathjax配置好但不渲染\">Mathjax配置好但不渲染</h3>\r\n<p>主题_config中vendors下的mathjax误添加了enable字段，删掉留空即可。</p>\r\n<h1 id=\"参考资料-1\">参考资料</h1>\r\n<p><a href=\"https://theme-next.js.org/docs/\">Next Document</a>， <a\r\nhref=\"http://theme-next.iissnan.com/\">Next 中文入门文档</a></p>\r\n","categories":["工具"],"tags":["博客"]},{"title":"PCT","url":"/2021/12/18/PCT/","content":"<p><strong>PCT: Point cloud transformer</strong></p>\r\n<ul>\r\n<li>Guo M H, Cai J X, Liu Z N, et al. PCT: Point cloud transformer[J].\r\nComputational Visual Media, 2021, 7(2): 187-199.</li>\r\n<li>清华</li>\r\n<li>CVMJ</li>\r\n</ul>\r\n<p>提出了基于Transformer的PCT网络。Transformer在NLP和图像处理取得了巨大成功，其内在的置换不变性也十分适合点云学习。为了更好的捕捉点云局部信息，使用了最远点采样和最近邻搜索来加强输入的embedding处理。实验证明PCT达到了分类分割和法向估计的SOTA。</p>\r\n<p>由于点云和自然语言是完全不同的数据类型，因此PCT对Transformer作出了几项调整：</p>\r\n<ul>\r\n<li><strong>Coordinate-based input\r\nembedding</strong>：Transformer里的positional encoding\r\n是为了区分不同位置的同一个词。然而点云没有位置顺序关系，因此PCT中将\r\npositional encoding 和 input embedding\r\n结合了起来，基于坐标进行编码。</li>\r\n<li><strong>Optimized offset-attention module</strong>：是原始\r\nself-attention 的升级模块。它把原来的attention\r\nfeature换成了self-attention的输入和attention\r\nfeature之间的offset。同一个物体在不同的变换下的绝对坐标完全不一样，因此相对坐标更鲁棒。</li>\r\n<li><strong>Neighbor embedding module</strong>：\r\n注意力机制有效捕捉全局特征，但可能忽视局部几何信息，而这在点云中很重要。句子中的每个单独的词都有基本的语义信息，但是点云中孤立的点不存在语义信息。因此使用了一个neighbor\r\nembedding\r\n策略来进行改良，让注意力机制着重于分析点局部邻域的信息，而不是孤立的点的信息。</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<h1 id=\"transformer基础\">Transformer基础</h1>\r\n<p>Transformer是一个解码编码结构，包含了三个主要模块：<strong>input\r\nembedding、positional\r\nencoding、self-attention</strong>。Self-attention是核心模块，其通过基于全局上下文产生细粒度的注意力特征信息。Transformer所有的操作都是并行的并且顺序无关的。</p>\r\n<ol type=\"1\">\r\n<li>Self-attention 将input embedding 和 positional\r\nencoding之和作为输入，使用线性层对每个词计算\r\n<strong>query，key，value</strong>。</li>\r\n<li>通过任意两个词的query 和 key\r\n向量的点积，计算两者之间的<strong>注意力权重</strong>。</li>\r\n<li>定义<strong>注意力特征</strong>：所有value向量以注意力权重的加权和。因此输出的每个词的注意力特征与所有的输入有关，因此能够学习全局上下文信息。</li>\r\n</ol>\r\n<h1 id=\"pct-point-cloud-transformer\">PCT: Point Cloud Transformer</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/sVc8zeN.png\"\r\nalt=\"PCT架构：由input coordinates的embedding开始，通过attention学习特征表示，再通过线性层进行特征输出。LBRD为Linear，Batch Normalization，ReLU，Dropout\" />\r\n<figcaption aria-hidden=\"true\">PCT架构：由input\r\ncoordinates的embedding开始，通过attention学习特征表示，再通过线性层进行特征输出。LBRD为Linear，Batch\r\nNormalization，ReLU，Dropout</figcaption>\r\n</figure>\r\n<p>PCT目标是将输入的点编码到一个高维特征空间，以便于体现点之间的语义关系。编码上的原则基本与原始Transformer保持一致，除了忽略掉了positional\r\nembedding，因为input coordinates已经包含了这一部分。</p>\r\n<h2 id=\"朴素pct\">朴素PCT</h2>\r\n<p>修改原生Transformer最简单的办法就是把点云看做句子，把点看做单词。</p>\r\n<ol type=\"1\">\r\n<li>使用一种忽视了点间作用的朴素的point\r\nembedding，即致力于在嵌入空间中将语义接近的点放得更近。</li>\r\n<li>使用原生的Self-attention机制计算词元的语义相关性。由于Query，Key，Value都是由共享的线性变换层计算得到，因此它们都是<strong>顺序无关</strong>。Softmax和加权求和同样也是<strong>顺序无关</strong>。因此，整个self-attention处理是<strong>顺序无关</strong>，以至于很适合处理无序的点云数据。最终Self-attention层计算如下：\r\n<span class=\"math display\">\\[\r\nF_{out}=SA(F_{in})=LBR(F_{sa})+F_{in}\r\n\\]</span></li>\r\n</ol>\r\n<figure>\r\n<img src=\"https://i.imgur.com/YgYNRPq.png\"\r\nalt=\"Offset-Attention结构：通过一个转换开关可以选择Self-Attention或是Offset-Attention的normalization方式。虚线代表的是Self-Attention。\" />\r\n<figcaption\r\naria-hidden=\"true\">Offset-Attention结构：通过一个转换开关可以选择Self-Attention或是Offset-Attention的normalization方式。虚线代表的是Self-Attention。</figcaption>\r\n</figure>\r\n<h2 id=\"offset-attention\">Offset-Attention</h2>\r\n<p>图卷积网络中体现了使用拉普拉斯矩阵 <span\r\nclass=\"math inline\">\\(L=D-E\\)</span>\r\n来代替原有邻接矩阵E的优势。类似的，在PCT中使用offset-attention(OA)来代替原始的self-attention(SA)来获得更好的效果：</p>\r\n<p><span class=\"math display\">\\[\r\nF_{out}=OA(F_{in})=LBR(F_{in}-F_{sa})+F_{in}\r\n\\]</span></p>\r\n<p>normalization方式也有所不同。如上图开关处所示，PCT中对第一维使用了softmax，对第二维使用了1范数来规范化attention\r\nmap。相比于传统的Transformer更强化了注意力权重，并且减少了噪声影响。</p>\r\n<p>带有上述Offset-Attention和input embedding的网络被称为 <strong>simple\r\nPCT(SPCT)</strong>。</p>\r\n<h2 id=\"增强局部特征-neighbor-embedding\">增强局部特征 Neighbor\r\nembedding</h2>\r\n<p>PCT通过point embedding\r\n可以有效的抽取全局特征，但是却忽略了同样重要的局部信息。借鉴PointNet++和DGCNN，PCT设计了一个<strong>neighbor\r\nembedding</strong>来增强局部学习能力。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/9qRySPy.png\"\r\nalt=\"左：Neighbor embedding。中：Sampling and grouping。右上：采样示例。右下：KNN聚类示例\" />\r\n<figcaption aria-hidden=\"true\">左：Neighbor embedding。中：Sampling and\r\ngrouping。右上：采样示例。右下：KNN聚类示例</figcaption>\r\n</figure>\r\n<p>如图所示，neighbor embedding包含两个LBR和Sampling and\r\ngrouping(SG)。LBR层用于基础的point\r\nembedding，SG层用于采样点云，并且聚合采样点kNN的邻域特征。思路来源于<strong>EdgeConv</strong>[26]。</p>\r\n<ol type=\"1\">\r\n<li>先通过FPS进行下采样，然后对于每一个采样点，找到其在<strong>原始点云</strong>中的kNN邻域，</li>\r\n<li>计算每个采样点的邻域特征：即计算邻域相对于中心点的差分特征，然后拼接输出：\r\n<span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\Delta \\boldsymbol{F}(p) &amp;=\\text { concat }_{q \\in\r\n\\operatorname{knn}(p, \\mathcal{P})}(\\boldsymbol{F}(q)-\\boldsymbol{F}(p))\r\n\\\\\r\n\\left.\\widetilde{\\boldsymbol{F}}_{(} p\\right)\r\n&amp;=\\operatorname{concat}(\\Delta \\boldsymbol{F}(p),\r\n\\operatorname{RP}(\\boldsymbol{F}(p), k)) \\\\\r\n\\boldsymbol{F}_{s}(p)\r\n&amp;=\\operatorname{MP}(\\operatorname{LBR}(\\operatorname{LBR}(\\widetilde{\\boldsymbol{F}}(p))))\r\n\\end{aligned}\r\n\\]</span> MP为Max Pooling，RP为repeating vector <span\r\nclass=\"math inline\">\\(x\\)</span> <span class=\"math inline\">\\(k\\)</span>\r\ntimes。</li>\r\n</ol>\r\n<h2 id=\"分类和分割任务的区别\">分类和分割任务的区别</h2>\r\n<p>分类只需要对所有点给出一个全局的类别，所以处理时SG层将点云进行采样压缩了。</p>\r\n<p>分割和法向估计任务中，由于要给每一个点一个输出信息(部件标签或者法向信息)，因此SG层只用来抽取局部特征，而不对原始点云进行压缩。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/n7OolGg.jpg\" alt=\"分割效果图\" />\r\n<figcaption aria-hidden=\"true\">分割效果图</figcaption>\r\n</figure>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[6] Vaswani, A.; Shazeer, N.; Parmar, N.; Uszkoreit, J.; Jones, L.;\r\nGomez, A. N.; Kaiser, L.; Polosukhin, I. Attention is all you need. In:\r\nProceedings of the 31st International Conference on Neural Information\r\nProcessing, 6000–6010, 2017.</p>\r\n<p>[26] Wang, Y.; Sun, Y.; Liu, Z.; Sarma, S. E.; Bronstein, M. M.;\r\nSolomon, J. M. Dynamic graph CNN for learning on point clouds. ACM\r\nTransactions on Graphics Vol. 38, No. 5, Article No. 146, 2019.</p>\r\n","categories":["深度学习"],"tags":["深度学习","点云","序列学习"]},{"title":"PSTNet","url":"/2022/01/06/PSTNet/","content":"<ul>\r\n<li>Fan H, Yu X, Ding Y, et al. PSTNet: Point spatio-temporal\r\nconvolution on point cloud sequences[C]//International Conference on\r\nLearning Representations. 2020.</li>\r\n<li>National University of Singapore</li>\r\n</ul>\r\n<h1 id=\"introduction\">Introduction</h1>\r\n<p>点云可以准确捕捉场景的集合信息，同时对不同的光照条件有较强的鲁棒性。另外，可以通过附带RGB图像来作为3D点的附加特征，以增强点云的能力。</p>\r\n<p>动态点云是不规则和无序的，为了建模点云的动力学，一种解决方案是将点云转换为3D体素序列，然后对体素序列应用4D卷积(Choy等人，2019)。然而，直接对体素序列执行卷积需要大量的计算。此外，在<strong>体素化过程中，量化误差是不可避免的</strong>，这可能会限制需要精确测量场景几何的应用。另一个解决方案MeteorNet\r\n(Liu et al.， 2019e)是扩展静态点云方法PointNet++ (Qi et al.，\r\n2017b)来处理原始点云序列。</p>\r\n<p>这篇文章的point spatio-temporal (PST)\r\nconvolution用于直接处理点云序列。由于点云在空间上无序但在时间上有序，因此可以解耦空间和时间信息，来对点云序列进行建模。</p>\r\n<p>点云序列在帧之间没有对应关系，因此PSTNet提出了一个 point tube\r\n结构来保持时空上的局部结构。</p>\r\n<p>主要工作：</p>\r\n<ul>\r\n<li>首次尝试解耦点云序列的空间和时间信息，提出PST卷积来编码点云序列。</li>\r\n<li>PST transposed\r\nconvolution，用于解码序列，完成point-level的预测任务</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<h1 id=\"point-spatio-temporal-convolutional-net\">Point Spatio-Temporal\r\nConvolutional Net</h1>\r\n<h2\r\nid=\"decomposing-space-and-time-in-point-cloud-sequence-modeling\">DECOMPOSING\r\nSPACE AND TIME IN POINT CLOUD SEQUENCE MODELING</h2>\r\n<p>点云空间上无序，时间上有序，因此可以解耦这两个维度来减少空间的不规则对时间模型的影响。另外空间和时间的变化尺度一般不一样，不能在网络中将两者同等对待。通过解耦两者，不仅时空模型更好做了，捕获时间信息的能力上也有显著改善。PST\r\n卷积为：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\boldsymbol{F}_{t}^{\\prime(x, y, z)}&amp;=\\sum_{k=-\\lfloor l /\r\n2\\rfloor}^{\\lfloor l / 2\\rfloor} \\sum_{\\left\\|\\left(\\delta_{x},\r\n\\delta_{y}, \\delta_{z}\\right)\\right\\| \\leq r}\r\n\\mathbf{W}^{\\left(\\delta_{x}, \\delta_{y}, \\delta_{z}\\right)}_k \\cdot\r\n\\boldsymbol{F}_{t+k}^{\\left(x+\\delta_{x}, y+\\delta_{y},\r\nz+\\delta_{z}\\right)}，\\\\\r\n&amp;=\\sum_{k=-\\lfloor l / 2\\rfloor}^{\\lfloor l / 2\\rfloor}\r\n\\sum_{\\left\\|\\left(\\delta_{x}, \\delta_{y}, \\delta_{z}\\right)\\right\\|\r\n\\leq r} \\mathbf{T}_{k}^{\\left(\\delta_{x}, \\delta_{y}, \\delta_{z}\\right)}\r\n\\cdot\\left(\\mathbf{S}_{k}^{\\left(\\delta_{x}, \\delta_{y},\r\n\\delta_{z}\\right)} \\cdot \\boldsymbol{F}_{t+k}^{\\left(x+\\delta_{x},\r\ny+\\delta_{y}, z+\\delta_{z}\\right)}\\right),\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(\\mathbf{W} \\in \\mathbb{R}^{C^{\\prime}\r\n\\times C \\times l}\\)</span>为卷积算子，可分解为时间卷积<span\r\nclass=\"math inline\">\\(\\mathbf{T} \\in \\mathbb{R}^{C^{\\prime} \\times C_m\r\n\\times l}\\)</span>和空间卷积<span class=\"math inline\">\\(\\mathbf{S} \\in\r\n\\mathbb{R}^{C_m \\times C\r\n}\\)</span>，另外由于时间卷积核空间卷积的互相独立，公式可以进一步化为：</p>\r\n<p><span class=\"math display\">\\[\r\n\\boldsymbol{F}_{t}^{\\prime(x, y, z)}=\\sum_{k=-\\lfloor l /\r\n2\\rfloor}^{\\lfloor l / 2\\rfloor} \\mathbf{T}_{k} \\cdot\r\n\\sum_{\\left\\|\\left(\\delta_{x}, \\delta_{y}, \\delta_{z}\\right)\\right\\|\r\n\\leq r} \\mathbf{S}^{\\left(\\delta_{x}, \\delta_{y}, \\delta_{z}\\right)}\r\n\\cdot \\boldsymbol{F}_{t+k}^{\\left(x+\\delta_{x}, y+\\delta_{y},\r\nz+\\delta_{z}\\right)},\r\n\\]</span></p>\r\n<p>首先空间卷积就存在一个问题，怎么去定义卷积。因为不同的点的邻居的位置偏移完全不一样，我们不可能做一个巨大的卷积核，把所有的位置偏移量<span\r\nclass=\"math inline\">\\(\\theta_{x,y,z}\\)</span>都囊括在核里，因此可以把这个空间卷积转换为一个关于偏移的固定大小的函数<span\r\nclass=\"math inline\">\\(f((\\delta_{x}, \\delta_{y}, \\delta_{z};\\theta)\r\n:\\mathbb{R}^{1x3} \\rightarrow \\mathbb{R}^{C_m \\times\r\nC}\\)</span>，具体实现如下：</p>\r\n<p><span class=\"math display\">\\[\r\nf\\left(\\left(\\delta_{x}, \\delta_{y}, \\delta_{z}\\right) ;\r\n\\boldsymbol{\\theta}\\right)=\\boldsymbol{\\theta}_{d}\r\n\\cdot\\left(\\delta_{x}, \\delta_{y}, \\delta_{z}\\right)^{T} \\cdot 1 \\odot\r\n\\boldsymbol{\\theta}_{s}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(\\boldsymbol{\\theta}_{d} \\in\r\n\\mathbb{R}^{C_m \\times 3}\\)</span>是displacement transform\r\n核，用于捕捉位移的空间局部结构。 <span\r\nclass=\"math inline\">\\(\\boldsymbol{\\theta}_{s} \\in \\mathbb{R}^{C_m \\times\r\nC}\\)</span> 是sharing核，用于增加特征维度，增强特征表示能力。最终<span\r\nclass=\"math inline\">\\(f\\)</span>即使用固定大小的子核，针对任意一个偏移<span\r\nclass=\"math inline\">\\(\\theta_{x,y,z}\\)</span>计算产生一个变换特征的矩阵。来替代原大小不定的卷积操作的权重变换。</p>\r\n<h2 id=\"point-tube\">Point Tube</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/BUVS67Q.png\" alt=\"Point tube\" />\r\n<figcaption aria-hidden=\"true\">Point tube</figcaption>\r\n</figure>\r\n<p>Point\r\ntube结构用于维护点云的时空局部结构，和体素不一样的是，体素是规则划分的，point\r\ntube\r\n是基于输入序列动态生成的，即稠密区域有更多的tube。构造方式如下：</p>\r\n<p><strong>时间关键帧的选择</strong>：对于点云序列，需要采样出关键帧来作为tube的中心。这里和卷积窗口一样的思路，基于temporal\r\nkernel size (l), temporal stride (st) and temporal padding\r\n(p)来采样关键帧，左右两边即是tube两端。</p>\r\n<p><strong>空间关键点的选择</strong>：在关键帧中进行FPS采样</p>\r\n<p><strong>传播空间关键点</strong>：将关键帧中关键点的位置直接传播到邻域帧，也视为这些帧的关键点。</p>\r\n<p><strong>寻找空间邻居</strong>：搜寻r半径的邻域作为邻居</p>\r\n<p>有了Point\r\ntube的邻域关系，就可以使用PST卷积进行时空局部邻域的卷积。</p>\r\n<h2 id=\"pst-transposed-convolution\">PST Transposed Convolution</h2>\r\n<p>得到了点云整体的特征，有时候对于point-wise的任务还需要将特征传播给所有点。因此PST转置卷积即输入编码信息，输出每个点的特征<span\r\nclass=\"math inline\">\\([P_i;F_i]=F_i^{\\prime\\prime} \\in\r\n\\mathbb{R}^{C^{\\prime\\prime} \\times N}\\)</span>，具体操作如下：</p>\r\n<p>首先<strong>解码时间</strong>：通过一个时间上的转置卷积，将特征恢复到原来的时间长度：</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathbf{T}^{\\prime} \\cdot \\boldsymbol{F}_{t}^{\\prime(x, y,\r\nz)}=\\left[M_{t-\\lfloor l / 2\\rfloor}^{\\prime(x, y, z)}, \\cdots,\r\nM_{t+\\lfloor l / 2\\rfloor}^{\\prime(x, y, z)}\\right],\r\n\\]</span></p>\r\n<p><span\r\nclass=\"math inline\">\\(F_t\\)</span>为输入的tube特征，通过PST转置卷积<span\r\nclass=\"math inline\">\\(\\mathbf{T^\\prime} \\in \\mathbb{R}^{l \\times\r\nC_m^\\prime \\times C^\\prime}\\)</span>，得到<span\r\nclass=\"math inline\">\\(M_t\\)</span>：即解码时间后，每个帧的空间卷积结果。</p>\r\n<p>然后<strong>解码空间</strong>：受PointNet++里的启发，在关键点和其余点之间根据距离权重进行插值传播特征：</p>\r\n<p><span class=\"math display\">\\[\r\nF_{t}^{\\prime \\prime(x, y, z)}=S^{\\prime} \\cdot\r\n\\frac{\\sum_{\\left\\|\\left(\\delta_{x}, \\delta_{y},\r\n\\delta_{z}\\right)\\right\\| \\leq r} w\\left(\\delta_{x}, \\delta_{y},\r\n\\delta_{z}\\right) M_{t}^{\\prime\\left(x+\\delta_{x}, y+\\delta_{y},\r\nz+\\delta_{z}\\right)}}{\\sum_{\\left\\|\\left(\\delta_{x}, \\delta_{y},\r\n\\delta_{z}\\right)\\right\\| \\leq r} w\\left(\\delta_{x}, \\delta_{y},\r\n\\delta_{z}\\right)}, w\\left(\\delta_{x}, \\delta_{y},\r\n\\delta_{z}\\right)=\\frac{1}{\\left\\|\\left(\\delta_{x}, \\delta_{y},\r\n\\delta_{z}\\right)\\right\\|^{2}}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(S^{\\prime} \\in \\mathbb{R}^{C^{\\prime\r\n\\prime} \\times C_{m}^{\\prime}}\\)</span>\r\n是一个共享核，用于增强特征的插值，并且将特征维度从<span\r\nclass=\"math inline\">\\(C_m^\\prime\\)</span>变换成<span\r\nclass=\"math inline\">\\(C^{\\prime\\prime}\\)</span>。</p>\r\n<h1 id=\"experiment\">Experiment</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/eLaiMX0.png\"\r\nalt=\"MSR-Action3D 动作识别准确率\" />\r\n<figcaption aria-hidden=\"true\">MSR-Action3D 动作识别准确率</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/bCnQo4g.png\" alt=\"NTU 动作识别准确率\" />\r\n<figcaption aria-hidden=\"true\">NTU 动作识别准确率</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/4mFXeJz.png\"\r\nalt=\"上为输入点云，颜色表示深度。下为PST卷积的输出。PST卷积最终得到了运动的主要部位\" />\r\n<figcaption\r\naria-hidden=\"true\">上为输入点云，颜色表示深度。下为PST卷积的输出。PST卷积最终得到了运动的主要部位</figcaption>\r\n</figure>\r\n","categories":["深度学习"],"tags":["深度学习","点云","序列学习"]},{"title":"Point4DTransformer","url":"/2022/02/17/Point4DTransformer/","content":"<ul>\r\n<li>Fan H, Yang Y, Kankanhalli M. Point 4D transformer networks for\r\nspatio-temporal modeling in point cloud videos[C]//Proceedings of the\r\nIEEE/CVF Conference on Computer Vision and Pattern Recognition. 2021:\r\n14204-14213.</li>\r\n<li>CVPR</li>\r\n<li>新加坡国立大学/悉尼科技大学</li>\r\n</ul>\r\n<h1 id=\"introduction\">Introduction</h1>\r\n<p>想把点云转为规则数据再进行卷积，一方面由于其稀疏性，通常需要定义稀疏卷积[6]。另外体素化本身也需要额外的计算[59]，而这限制了实时处理的能力。</p>\r\n<p>另一种方案是直接处理点云序列。由于点云序列具有不规则性和无序性，其使得点云在不同帧之间不具有连续性。因此通常会使用point\r\ntracking来捕获动态点云[36]，但这是一个很难的任务。而且tracking通常都是依赖于点的颜色，这也不容易扩展到无色点云。Point\r\n4D Transformer 用于对原始点云序列进行建模，并在3D 动作识别和4D\r\n语义分割任务上证明了优越性。P4DTransformer主要包含：</p>\r\n<ol type=\"1\">\r\n<li>4D\r\nconvolution，对点云序列的时空局部结构进行embedding处理。并且通过这种时空聚合，减少了后续transformer需要处理的点数。</li>\r\n<li>transformer，通过自注意力学习序列全局的appearance和motion信息。相关的局部结构会通过注意力权重联系起来，而不需要显示的进行tracking。</li>\r\n</ol>\r\n<figure>\r\n<img src=\"https://i.imgur.com/6UPkPKK.png\" alt=\"结构图\" />\r\n<figcaption aria-hidden=\"true\">结构图</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h1 id=\"point-4d-convolution仿pstnet\">Point 4D\r\nConvolution(仿PSTNet)</h1>\r\n<p>基于网格的卷积已经被证明了在学习局部结构时很有用[23,18,51,4,17]。卷积的关键在于如何学习一个权重核，其给出了从中心点到周围偏移点的权重关系。由于传统卷积中，数据是离散的，因此可以方便地对偏移量进行卷积。然而点云坐标是连续且不规则的，其偏移量有无穷多个。因此在4D卷积中使用一个函数<span\r\nclass=\"math inline\">\\(\\zeta\\)</span>来间接生成卷积核，而不是直接给出一个核让它去学习。4D卷积定义如下：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n&amp;\\boldsymbol{F}_{t}^{\\prime(x, y, z)}=\\sum_{\\left(\\delta_{x},\r\n\\delta_{y}, \\delta_{z}, \\delta_{t}\\right) \\in G} \\zeta\\left(\\delta_{x},\r\n\\delta_{y}, \\delta_{z}, \\delta_{t}\\right) \\cdot\r\n\\boldsymbol{F}_{t+\\delta_{t}}^{\\left(x+\\delta_{x}, y+\\delta_{y},\r\nz+\\delta_{z}\\right)} \\\\\r\n&amp;=\\sum_{\\delta_{t}=-r_{t}}^{r_{t}} \\sum_{\\left\\|\\left(\\delta_{x},\r\n\\delta_{y}, \\delta_{z}\\right)\\right\\| \\leq r_{s}} \\zeta\\left(\\delta_{x},\r\n\\delta_{y}, \\delta_{z}, \\delta_{t}\\right) \\cdot\r\n\\boldsymbol{F}_{t+\\delta_{t}}^{\\left(x+\\delta_{x}, y+\\delta_{y},\r\nz+\\delta_{z}\\right)}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(F_t: \\mathbb{R}^{C \\times\r\n1}\\)</span>为点在帧t时的特征(C个特征)，<span\r\nclass=\"math inline\">\\(\\delta_x,\\delta_y,\\delta_z,\\delta_t\\)</span>为时空上的偏移量。<span\r\nclass=\"math inline\">\\(\\cdot\\)</span>为矩阵乘法。<span\r\nclass=\"math inline\">\\(\\sum\\)</span>可以使用不同的pooling方法实现，如sum-pooling，max-pooling，average-pooling。<span\r\nclass=\"math inline\">\\(G\\)</span>为时空邻域，其通过空间半径<span\r\nclass=\"math inline\">\\(r_s\\)</span>和时间半径<span\r\nclass=\"math inline\">\\(r_t\\)</span>来确定。$:^{1 } <sup>{C</sup>C}\r\n$用于对给定偏移量生成一个权重核：</p>\r\n<p><span class=\"math display\">\\[\r\n\\zeta\\left(\\delta_{x}, \\delta_{y}, \\delta_{z}, \\delta_{t}\\right) \\cdot\r\n\\boldsymbol{f}=\\left(\\boldsymbol{W}_{d} \\cdot\\left(\\delta_{x},\r\n\\delta_{y}, \\delta_{z}, \\delta_{t}\\right)^{T}\\right)\r\n\\odot\\left(\\boldsymbol{W}_{f} \\cdot \\boldsymbol{f}\\right)\r\n\\]</span></p>\r\n<p><span\r\nclass=\"math inline\">\\(\\boldsymbol{f}=\\boldsymbol{F}_{t+\\delta_{t}}^{\\left(x+\\delta_{x},\r\ny+\\delta_{y}, z+\\delta_{z}\\right)}\\)</span> 为偏移点的特征。 <span\r\nclass=\"math inline\">\\(\\boldsymbol{W}_{d} \\in\\)</span> <span\r\nclass=\"math inline\">\\(\\mathbb{R}^{C^{\\prime} \\times 4}\\)</span> 和 <span\r\nclass=\"math inline\">\\(\\boldsymbol{W}_{f} \\in \\mathbb{R}^{C^{\\prime}\r\n\\times C}\\)</span>用于提升特征维度，分别将坐标和额外特征统一变换到<span\r\nclass=\"math inline\">\\(C^\\prime\\)</span>维度，然后再通过 <span\r\nclass=\"math inline\">\\(\\odot\\)</span> 逐元素算子(如加法和乘法)\r\n将坐标信息和特征信息结合。 换句话说，<span\r\nclass=\"math inline\">\\(\\zeta\\left(\\delta_{x}, \\delta_{y}, \\delta_{z},\r\n\\delta_{t}\\right)\\)</span>\r\n即实现了对任意偏移量进行加权处理(模拟卷积)。</p>\r\n<p>如果不存在除坐标特征外的额外特征 <span\r\nclass=\"math inline\">\\(\\boldsymbol{F}_{t}\\)</span>，则形式变为 <span\r\nclass=\"math inline\">\\(\\zeta\\left(\\delta_{x}, \\delta_{y}, \\delta_{z},\r\n\\delta_{t}\\right)=\\boldsymbol{W}_{d} \\cdot\\left(\\delta_{x}, \\delta_{y},\r\n\\delta_{z},\r\n\\delta_{t}\\right)^{T}\\)</span>，即也单纯进行了一个MLP的坐标信息加强。</p>\r\n<h1 id=\"transformer\">Transformer</h1>\r\n<p>通过4D卷积的可以得到一个局部结构的embedding：<span\r\nclass=\"math inline\">\\(F_t^{\\prime(x,y,z)}\\)</span>。由于点的坐标反应了局部结构的关系，因此对embedding再次强化坐标信息：</p>\r\n<p><span class=\"math display\">\\[\r\n\\boldsymbol{I}^{(x,y,z,t)}=\\boldsymbol{W}_i \\dot\r\n(x,y,z,t)^T+\\boldsymbol{F}_t^{\\prime(x,y,z)}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(\\boldsymbol{W}_i : \\mathbb{R}^{C^\\prime\r\n\\times 4}\\)</span>。最终自注意力的输入特征为<span\r\nclass=\"math inline\">\\(\\boldsymbol{I}: \\mathbb{R}^{C^\\prime \\times\r\nL^\\prime N^\\prime}\\)</span></p>\r\n<p>有几点值得注意的：</p>\r\n<ul>\r\n<li>自注意力的softmax是序列范围的，而不是帧范围的。所谓帧范围，即一个帧内所有的权重累加为1。而序列范围即整个序列所有帧的所有<span\r\nclass=\"math inline\">\\(I_i\\)</span>权重累加为1。</li>\r\n<li>使用多头注意力机制。</li>\r\n<li>参考[10,53]在Transformer中使用LayerNorms[1]，MLP，ReLU，残差连接[18]</li>\r\n</ul>\r\n<h1 id=\"效果\">效果</h1>\r\n<p>准确率上SOTA：</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/oskcS3W.png\"\r\nalt=\"在NTU RGB+D上的准确率比较\" />\r\n<figcaption aria-hidden=\"true\">在NTU RGB+D上的准确率比较</figcaption>\r\n</figure>\r\n<p>计算上有一定的优越性：</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/QBcUYLp.png\"\r\nalt=\"处理每个视频的运行时间比较\" />\r\n<figcaption aria-hidden=\"true\">处理每个视频的运行时间比较</figcaption>\r\n</figure>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[1] Lei Jimmy Ba, Jamie Ryan Kiros, and Geoffrey E. Hinton. Layer\r\nnormalization. arXiv, 1607.06450, 2016</p>\r\n<p>[6] Christopher B. Choy, JunYoung Gwak, and Silvio Savarese. 4d\r\nspatio-temporal convnets: Minkowski convolutional neu- ral networks. In\r\nCVPR, 2019.</p>\r\n<p>[10] Alexey Dosovitskiy, Lucas Beyer, Alexander Kolesnikov, Dirk\r\nWeissenborn, Xiaohua Zhai, Thomas Unterthiner, Mostafa Dehghani,\r\nMatthias Minderer, Georg Heigold, Sylvain Gelly, Jakob Uszkoreit, and\r\nNeil Houlsby. An image is worth 16x16 words: Transformers for image\r\nrecognition at scale. In ICLR, 2021.</p>\r\n<p>[12] Hehe Fan, Xiaojun Chang, De Cheng, Yi Yang, Dong Xu, and\r\nAlexander G. Hauptmann. Complex event detection by identifying reliable\r\nshots from untrimmed videos. In ICCV, 2017.</p>\r\n<p>[18] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep\r\nresidual learning for image recognition. In CVPR, 2016.</p>\r\n<p>[36] Xingyu Liu, Mengyuan Yan, and Jeannette Bohg. Meteornet: Deep\r\nlearning on dynamic 3d point cloud sequences. In ICCV, 2019.</p>\r\n<p>[53] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit,\r\nLlion Jones, Aidan N. Gomez, Lukasz Kaiser, and Illia Polosukhin.\r\nAttention is all you need. In NeurIPS, 2017.</p>\r\n","categories":["深度学习"],"tags":["深度学习","点云"]},{"title":"PSTT","url":"/2022/03/21/PSTT/","content":"<ul>\r\n<li>Wei Y, Liu H, Xie T, et al. Spatial-Temporal Transformer for 3D\r\nPoint Cloud Sequences[C]//Proceedings of the IEEE/CVF Winter Conference\r\non Applications of Computer Vision. 2022: 1171-1180.</li>\r\n<li>中山大学</li>\r\n<li>不在CCF h5指数62 排计算机视觉第12</li>\r\n</ul>\r\n<p>提出了<strong>Spatio-Temporal\r\nSelf-Attention(STSA)</strong>模块和<strong>Resolution\r\nEmbedding(RE)</strong>模块。STSA用于时空联系，RE用于聚合邻域特征，增强特征图的分辨率。</p>\r\n<p>现有的基于point的时空方法要么是使用注意力机制，要么是使用RNN模型。然而，这些方法依赖于长期联系，导致信息冗余。STSA使用了自注意力来提取帧间联系。这样会使冗余程度下降，鲁棒性提高(残差+layer\r\nnormalization)，训练速度提升。</p>\r\n<p>另外，在语义分割上面的编码器-解码器结构，在编码器降维时会造成信息丢失。RE模块使用了注意力权重来加强分辨率。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"resolution-embedding-re\">Resolution Embedding (RE)</h1>\r\n<p>先是时空邻域构造：即多帧的ball query，并且使用两个pointnet++的set\r\nabstraction layers进行特征抽取。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/IKzp3Gd.png\"\r\nalt=\"RE结构：维度b，s，d分别代表batch，num_points，feature。\" />\r\n<figcaption\r\naria-hidden=\"true\">RE结构：维度b，s，d分别代表batch，num_points，feature。</figcaption>\r\n</figure>\r\n<ul>\r\n<li>Feature Block：使用set abstraction层提取特征 <span\r\nclass=\"math inline\">\\(n_i^t\\)</span>。</li>\r\n<li>Resolution\r\nBlock：将空间分为两部分，然后把特征再叠加在一起。最后通过一个MLP进行降维处理。通过这样的处理最终抽取出邻域间的信息\r\n<span class=\"math inline\">\\(k_i^t\\)</span>。</li>\r\n</ul>\r\n<p>最终使用两个scalar attention来进行两种特征的融合：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\na_{1},a_{2}&amp;=Softmax(MLP(k_i^t,n_i^t)) \\\\\r\nI_i^t&amp;=a_1 \\cdot k_i^t + a_2 \\cdot n_i^t\r\n\\end{aligned}\r\n\\]</span></p>\r\n<h1 id=\"spatio-temporal-self-attentionstsa\">Spatio-Temporal\r\nSelf-Attention(STSA)</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/ZcaaX9j.png\" alt=\"STSA\" />\r\n<figcaption aria-hidden=\"true\">STSA</figcaption>\r\n</figure>\r\n<p>在一组空间特征<span\r\nclass=\"math inline\">\\(I\\)</span>输入到SA之前，先将每个空间特征<span\r\nclass=\"math inline\">\\(I_i^t\\)</span>划分为多个patches，并且按时间维度上拼接不同时间的patches，最后得到<span\r\nclass=\"math inline\">\\(F_{input} \\in \\mathbb{R}^{N \\times\r\nd}\\)</span>。</p>\r\n<p>由于自注意力会引入初始权重的随机性，导致输出特征可能和输入特征相去甚远。因此将自注意力的计算结果和输入特征构造一个<strong>残差连接</strong>，形成最后的输出特征。另外，Layer\r\nNormalization是常用的加速注意力模型收敛的工具：</p>\r\n<p><span class=\"math display\">\\[\r\nF_{output}=LayerNorm[FeedForward(F_{sa_out}+F_{input})]\r\n\\]</span></p>\r\n<h1 id=\"效果\">效果</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/WtxOupd.png\" alt=\"MSRAction3D效果\" />\r\n<figcaption aria-hidden=\"true\">MSRAction3D效果</figcaption>\r\n</figure>\r\n","categories":["深度学习"],"tags":["深度学习","点云"]},{"title":"PointLSTM","url":"/2021/12/09/PointLSTM/","content":"<p><strong>An Efficient PointLSTM for Point Clouds Based Gesture\r\nRecognition</strong></p>\r\n<p>Min Y, Zhang Y, Chai X, et al. An efficient pointlstm for point\r\nclouds based gesture recognition[C]//Proceedings of the IEEE/CVF\r\nConference on Computer Vision and Pattern Recognition. 2020:\r\n5761-5770.</p>\r\n<p>把手势识别看作一个不规则序列的识别任务，致力于在点云序列中找到长期空间关联性。PointLSTM用于在保持空间结构的前提下，将信息从过去传播到未来。PointLSTM将过去的邻域点状态信息与现在的特征结合，以通过一个权重共享的LSTM层更新现在状态信息。这个方法可以集成在很多序列学习方法中。</p>\r\n<p>在手势识别上，（NVGesture、SHREC'17）达到SOTA，超越了之前基于骨架的方法。</p>\r\n<p>主要贡献工作：</p>\r\n<ul>\r\n<li>提出PointLSTM\r\n，在不规则序列数据上，保持空间结构的同时抽取长期时空联系。</li>\r\n<li>简化版本PointLSTM-PSS可以减少计算，并且易于探索改善性能的方法。</li>\r\n<li>在3D手势识别和动作识别上展现出了实时应用的巨大潜力。</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<h1 id=\"introduction\">Introduction</h1>\r\n<p>相比于RGB数据，点云更精准的描述了物体表面的几何结构和距离信息，从而为手势识别提供辅助。如何从点云中抽取丰富的特征则是一个主要任务。Qi\r\net\r\nal.[30]的PointNet可以从原始点云直接抽取信息。PointNet++[31]则扩展了层级聚合和采样操作，以捕捉局部联系特征。一些近期工作[19,\r\n20,\r\n23]对聚类操作做出了调整，以便于从时空领域中抽取运动特征和结构特征。然而这些工作仅局限于短期模型，缺乏捕捉长期联系的能力。</p>\r\n<p>近期RNN和LSTM在序列模型上的成功[3,7]提供了解决上述问题的灵感。然而点云数据是无序的，因此直接在没有对齐的点云序列上应用一个权重共享的LSTM层会有更新困难的问题。因此，<strong>如何在保持空间结构的前提下利用时间信息就是主要的挑战。</strong></p>\r\n<p>为了解决这个问题，提出了点云定制版的LSTM，即<strong>PointLSTM</strong>。理想情况下，当前帧的每个点都希望找到一个过去的点与之对应，并且进行相关处理。然而这是一个条件很强的假设，实际基本不可能满足，因此放松一点条件：寻找并聚合过去帧中相关的一些点的状态。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/X9tjztV.png\"\r\nalt=\"原图 1：s为state，f为feature。(a)理想状态下，每个点都能找到其在上一个时间步中对应的点。(b)在没有那么强的假设条件下，PointLSTM也能从过去的空间邻域中聚合相关信息\" />\r\n<figcaption aria-hidden=\"true\">原图\r\n1：s为state，f为feature。(a)理想状态下，每个点都能找到其在上一个时间步中对应的点。(b)在没有那么强的假设条件下，PointLSTM也能从过去的空间邻域中聚合相关信息</figcaption>\r\n</figure>\r\n<p>另外，为减少计算提出了一个<strong>带有Point-shared\r\nstates的PointLSTM简化版本：PointLSTM-PSS</strong>。</p>\r\n<h1 id=\"related-work\">Related Work</h1>\r\n<p><strong>基于视觉手势识别</strong></p>\r\n<p>[2,26,27]使用了图神经网络和LSTM来学习手部关节的时空序列。然而基于骨架的方法对遮挡状态，运动速度，图像分辨率等都十分敏感。相比于骨架数据，点云数据更能反映几何特征。</p>\r\n<p><strong>序列模型的LSTM</strong></p>\r\n<p>[3,7]等工作都证实了在序列模型中，RNN的一个特例LSTM拥有出色的长期模型能力。PointRNN[8]和CloudLSTM[43]都在动态点云上应用了RNN，以进行pointwise的预测。</p>\r\n<p>PointLSTM不同于它们使用pooling操作来汇总局部信息来进行逐点的预测，而是保持了空间结构，并且使用pooling操作来找到全局特征的相关信息。</p>\r\n<h1 id=\"method\">Method</h1>\r\n<h2 id=\"pointlstm\">PointLSTM</h2>\r\n<p>为解决之前的 当前帧无法匹配过去帧\r\n的问题，根据同一帧中的点是否共享状态信息，提出了两个解决办法来包容没有对齐的点云。</p>\r\n<p>定义：</p>\r\n<ul>\r\n<li>点云时间序列为 <span\r\nclass=\"math inline\">\\(\\mathbb{P}\\)</span>。每帧包含任意数量的点 <span\r\nclass=\"math inline\">\\(\\mathbb{P}^{(t)}=\\{p_{i}^{(t)} \\mid i=\\)</span>\r\n<span class=\"math inline\">\\(1,2, \\cdots, n_{t}\\}\\)</span>。每个点<span\r\nclass=\"math inline\">\\(p_{i}^{(t)}\\)</span> 可以表示为两部分：一个 <span\r\nclass=\"math inline\">\\(d\\)</span> 维坐标 <span\r\nclass=\"math inline\">\\(\\boldsymbol{x}_{i}^{(t)}\\)</span> 和一个 <span\r\nclass=\"math inline\">\\(m\\)</span> 维 特征向量 <span\r\nclass=\"math inline\">\\(\\boldsymbol{f}_{i}^{(t)}\\)</span></li>\r\n<li>点 <span class=\"math inline\">\\(p_{i}^{(t)}\\)</span>在 <span\r\nclass=\"math inline\">\\(\\mathbb{P}^{(t+\\Delta t)}\\)</span>\r\n帧的邻域点集：<span class=\"math inline\">\\(\\mathcal{N}_{\\Delta\r\nt}\\left(\\boldsymbol{x}_{i}^{(t)}\\right)\\)</span></li>\r\n<li>一般的LSTM层: <span class=\"math inline\">\\(h^{(t)},\r\nc^{(t)}=LSTM(\\boldsymbol{y}^{(t)}, h^{(t-1)}，c^{(t-1)})\\)</span></li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://i.imgur.com/RhUqy7a.png\"\r\nalt=\"原图 2：(a)在PointLSTM中每个点有独立的state，基于当前输入和过去邻域的states进行更新。(b)PointLSTM-PSS同一帧中的点共享一个state，基于对输出的一系列states取平均进行更新。\" />\r\n<figcaption aria-hidden=\"true\">原图\r\n2：(a)在PointLSTM中每个点有独立的state，基于当前输入和过去邻域的states进行更新。(b)PointLSTM-PSS同一帧中的点共享一个state，基于对输出的一系列states取平均进行更新。</figcaption>\r\n</figure>\r\n<h3 id=\"point-independent-states\">Point-independent states</h3>\r\n<p>假设每个点有独立的state <span\r\nclass=\"math inline\">\\(h^{(t)}_i\\)</span> 和cell state <span\r\nclass=\"math inline\">\\(c^{(t)}_i\\)</span>。对每个点，在过去的邻域中找到相关点形成点对\r\n<span class=\"math inline\">\\(\\left(p_{i}^{(t)}, p_{j}^{(t-1)}\\right),\r\np_{j}^{(t-1)} \\in\r\n\\mathcal{N}_{-1}\\left(x_{i}^{(t)}\\right)\\)</span>。通过点对计算输出：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\boldsymbol{y}_{i, j}^{(t)}\r\n&amp;=\\left[\\boldsymbol{x}_{i}^{(t)}-\\boldsymbol{x}_{j}^{(t-1)} ;\r\n\\boldsymbol{f}_{i}^{(t)}\\right] \\\\\r\n\\tilde{h}_{i, j}^{(t)}, \\tilde{\\boldsymbol{c}}_{i, j}^{(t)}\r\n&amp;=\\operatorname{LSTM}\\left(\\boldsymbol{y}_{i, j}^{(t)},\r\nh_{j}^{(t-1)}, c_{j}^{(t-1)}\\right)\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>得到每一对点 <span class=\"math inline\">\\(\\left(p_{i}^{(t)},\r\np_{j}^{(t-1)}\\right)\\)</span> 的临时state和cell state <span\r\nclass=\"math inline\">\\(\\tilde{h}_{i, j}^{(t)}, \\tilde{c}_{i,\r\nj}^{(t)}\\)</span>。再利用这些临时变量更新点云每个点 <span\r\nclass=\"math inline\">\\(p_{i}^{(t)}\\)</span> 的states和cell states <span\r\nclass=\"math inline\">\\(h_{i}^{(t)},\r\nc_{i}^{(t)}\\)</span>实现全部更新：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{gathered}\r\nh_{i}^{(t)}=g\\left(\\tilde{h}_{i, 1}^{(t)}, \\tilde{h}_{i, 2}^{(t)},\r\n\\cdots, \\tilde{h}_{i, n_{t-1}}^{(t)}\\right) \\\\\r\nc_{i}^{(t)}=g\\left(\\tilde{c}_{i, 1}^{(t)}, \\tilde{c}_{i, 2}^{(t)},\r\n\\cdots, \\tilde{c}_{i, n_{t-1}}^{(t)}\\right)\r\n\\end{gathered}\r\n\\]</span></p>\r\n<p>其中<span\r\nclass=\"math inline\">\\(g\\)</span>是一个对称函数，实现中采取一个max\r\npooling层</p>\r\n<h3 id=\"point-shared-states\">Point-shared states</h3>\r\n<p>如上每个点都要计算点对则消耗巨大。简化版本中同一帧的所有点拥有同一个states和cell\r\nstates。计算公式即把上面公式中<span\r\nclass=\"math inline\">\\(h_i，c_i\\)</span>表示每个点的<span\r\nclass=\"math inline\">\\(i\\)</span>去掉即可。即每一个时间步只需计算一轮。</p>\r\n<h2 id=\"neighborhood-grouping\">Neighborhood Grouping</h2>\r\n<p>为体现出是否对齐的影响，采用了两种grouping方式</p>\r\n<p><strong>Direct grouping</strong></p>\r\n<p>直接寻找中心点<span\r\nclass=\"math inline\">\\(p_{t,i}\\)</span>的k近邻。在物体静止的时候可以聚合相邻帧的空间信息。如果不设距离限制，同样也可以捕捉到一些运动信息。</p>\r\n<p><strong>Aligned grouping</strong></p>\r\n<p>假设当前点 <span class=\"math inline\">\\(p^{(t)}_i\\)</span>\r\n在前一帧中有一个虚拟的对应点 <span\r\nclass=\"math inline\">\\(\\tilde{p}^{(t-1)}_i\\)</span>\r\n，通过估计它们之间的反向流 $ ^{(t)}_i= ^{(t)}_i-x^{(t)}_i$ 来定位 <span\r\nclass=\"math inline\">\\(\\tilde{p}^{(t-1)}_i\\)</span>\r\n，并借此找到上一帧中的k邻域点集 <span\r\nclass=\"math inline\">\\(\\mathcal{N}_{-1}\\left(\\boldsymbol{x}_{i}^{(t)};k\\right)\\)</span>\r\n。</p>\r\n<p>然而，这种非刚性场景流估计依然是一个难题。</p>\r\n<h2 id=\"实现细节\">实现细节</h2>\r\n<h3 id=\"density-based-sampling-layer\">Density-based sampling layer</h3>\r\n<p>从深度视频中得到的大多数点都是多余的。工作[23]说明了对于手势识别，每帧100-200的小数目点云是一个合理的选择。因此为了减少计算冗余，采用了一个基于密度的采样方法[21]，点\r\n<span class=\"math inline\">\\({x}^{(t)}_i\\)</span> 密度估计如下：</p>\r\n<p><span class=\"math display\">\\[\r\n\\rho\\left(\\boldsymbol{x}_{i}^{(t)}\\right)=\\frac{1}{n_{t} r^{d}}\r\n\\sum_{j=1}^{n_{t}}\r\nw\\left(\\frac{\\boldsymbol{x}_{i}^{(t)}-\\boldsymbol{x}_{j}^{(t)}}{r}\\right)\r\n\\]</span></p>\r\n<p>其中 <span class=\"math inline\">\\(r\\)</span> 是 <span\r\nclass=\"math inline\">\\({x}^{(t)}_i\\)</span> 与其第k近邻的欧拉距离。<span\r\nclass=\"math inline\">\\(w\\)</span>\r\n是一个有界可积权重函数。通过密度估计，在每一个采样层中，都采样密度较小的点，即对应点云的边界信息。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/hShx5Nx.png\"\r\nalt=\"原图 4：第一行是从深度信息中分割出手部区域的点云序列，且经过预处理。第一行每帧有128个点。第二行通过采样后每帧有64个点。第三行显示了对应的骨架序列。\" />\r\n<figcaption aria-hidden=\"true\">原图\r\n4：第一行是从深度信息中分割出手部区域的点云序列，且经过预处理。第一行每帧有128个点。第二行通过采样后每帧有64个点。第三行显示了对应的骨架序列。</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>动作识别和手势识别的区别：Gesture手势识别是设计用于非口语交流，携带有语言特性。Action动作是完成一个目的的行为形式，拥有更大的类内变化。</p>\r\n</blockquote>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[1] Roy P, Bhattacharya S, Roy P P, et al. Position and Rotation\r\nInvariant Sign Language Recognition from 3D Point Cloud Data with\r\nRecurrent Neural Networks[J]. arXiv preprint arXiv:2010.12669, 2020.</p>\r\n<p>[2] Yuxiao Chen, Long Zhao, Xi Peng, Jianbo Yuan, and Dimitris N\r\nMetaxas. Construct dynamic graphs for hand gesture recognition via\r\nspatial-temporal attention. In British Machine Vision Conference,\r\n2019</p>\r\n<p>[3] Kyunghyun Cho, Bart Van Merrienboer, Caglar Gulcehre, ¨Dzmitry\r\nBahdanau, Fethi Bougares, Holger Schwenk, and Yoshua Bengio. Learning\r\nphrase representations using rnn encoder-decoder for statistical machine\r\ntranslation. In Proceedings of the Conference on Empirical Methods in\r\nNatural Language Processing, pages 1724–1734, 2014</p>\r\n<p>[7] Jeffrey Donahue, Lisa Anne Hendricks, Sergio Guadarrama,Marcus\r\nRohrbach, Subhashini Venugopalan, Kate Saenko,and Trevor Darrell.\r\nLong-term recurrent convolutional networks for visual recognition and\r\ndescription. In Proceedings of the IEEE Conference on Computer Vision\r\nand Pattern Recognition, pages 2625–2634, 2015.</p>\r\n<p>[8] Hehe Fan and Yi Yang. Pointrnn: Point recurrent neural network\r\nfor moving point cloud processing. arXiv preprint arXiv:1910.08287,\r\n2019.</p>\r\n<p>[19] Xingyu Liu, Charles R Qi, and Leonidas J Guibas.Flownet3d:\r\nLearning scene flow in 3d point clouds. In Proceedings of the IEEE\r\nConference on Computer Vision and Pattern Recognition, pages 529–537,\r\n2019.</p>\r\n<p>[20] Xingyu Liu, Mengyuan Yan, and Jeannette Bohg. Meteornet: Deep\r\nlearning on dynamic 3d point cloud sequences. In Proceedings of the IEEE\r\nInternational Conference on Computer Vision, pages 9246–9255, 2019</p>\r\n<p>[21] YP Mack and Murray Rosenblatt. Multivariate k-nearest neighbor\r\ndensity estimates. Journal of Multivariate Analysis, 9(1):1–15,\r\n1979.</p>\r\n<p>[23] Yuecong Min, Xiujuan Chai, Lei Zhao, and Xilin Chen. Flickernet:\r\nAdaptive 3d gesture recognition from sparse point clouds. In British\r\nMachine Vision Conference, 2019.</p>\r\n<p>[26] Xuan Son Nguyen, Luc Brun, Olivier Lezoray, and S ´ ebastien ´\r\nBougleux. A neural network based on spd manifold learning for\r\nskeleton-based hand gesture recognition. In Proceedings of the IEEE\r\nConference on Computer Vision and Pattern Recognition, pages\r\n12036–12045, 2019.</p>\r\n<p>[27] Juan C Nunez, Raul Cabido, Juan J Pantrigo, Antonio S\r\nMontemayor, and Jose F Velez. Convolutional neural networks and long\r\nshort-term memory for skeleton-based human activity and hand gesture\r\nrecognition. Pattern Recognition, 76:80–94, 2018.</p>\r\n<p>[30] Charles R Qi, Hao Su, Kaichun Mo, and Leonidas J Guibas.\r\nPointnet: Deep learning on point sets for 3d classification and\r\nsegmentation. In Proceedings of the IEEE Conference on Computer Vision\r\nand Pattern Recognition, pages 652–660,</p>\r\n<p>[31] Qi C R, Yi L, Su H, et al. Pointnet++: Deep hierarchical feature\r\nlearning on point sets in a metric space[J]. arXiv preprint\r\narXiv:1706.02413, 2017.</p>\r\n<p>[43] Chaoyun Zhang, Marco Fiore, Iain Murray, and Paul Patras.\r\nCloudlstm: A recurrent neural model for spatiotemporal point-cloud\r\nstream forecasting. arXiv preprint arXiv:1907.12410, 2019.</p>\r\n","categories":["深度学习"],"tags":["深度学习","点云","序列学习"]},{"title":"PointNet++","url":"/2021/11/29/PointNet++/","content":"<p><strong>PointNet++: Deep Hierarchical Feature Learning on Point Sets\r\nin a Metric Space</strong></p>\r\n<p>Qi C R, Yi L, Su H, et al. Pointnet++: Deep hierarchical feature\r\nlearning on point sets in a metric space[J]. Advances in neural\r\ninformation processing systems, 2017, 30.</p>\r\n<p>最初的PointNet[2]没有捕捉到点的局部结构特征，限制了细粒度和复杂场景的识别、泛化能力。PointNet++则引出了一个分层结构神经网络，它在多级结构的点云中递归地应用PointNet。</p>\r\n<p>由于在均匀点云密度上训练的网络在非均匀密度点云上性能极大的削弱，PointNet++提出了一个新颖的学习网络层，可以自适应整合多种尺度的特征。</p>\r\n<p>实验表明PointNet++能够高效且鲁棒的学习到点云的深度特征，并且效果达到目前最优。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"introduction\">Introduction</h1>\r\n<p>PointNet基本思想是学习到每个点的空间编码，并且整合所有独立的点的特征成一个全局点云特征。PointNet没有捕捉局部结构特征，而局部结构特征是卷积网络成功的的关键之一。CNN可以通过规则网格的输入，沿着多分辨率的层级结构，以逐渐增大的尺度来捕捉特征。<strong>这种能够沿着多级结构捕捉局部特征的能力带来了更好的泛化能力。</strong></p>\r\n<p>PointNet++则是通过空间上的多级结构去处理点云。PointNet++通过潜在空间的距离度量，将点云划分为一系列堆叠的局部区域。和CNNs类似，PointNet++从小的局部邻域中捕捉到几何结构的局部特征，然后再整合到更大的尺度之中进行处理，形成更高级的特征，直到获得全局特征。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/5BC3Bo8.png\"\r\nalt=\"原图 2：PointNet++网络结构图\" />\r\n<figcaption aria-hidden=\"true\">原图 2：PointNet++网络结构图</figcaption>\r\n</figure>\r\n<p><strong>Problem Statement</strong>：对于<span\r\nclass=\"math inline\">\\(\\mathcal{X}=(M,\r\nd)\\)</span>，M是点集（不一定均匀分布），d为距离度量。希望学习到一个函数<span\r\nclass=\"math inline\">\\(\\mathcal{f}\\)</span>来抽取<span\r\nclass=\"math inline\">\\(\\mathcal{X}\\)</span>中的语义特征。</p>\r\n<p><strong>关键问题</strong>：</p>\r\n<ol type=\"1\">\r\n<li>怎么去划分局部区域</li>\r\n<li>怎么去捕捉局部特征</li>\r\n</ol>\r\n<p>这两个问题实际上相关，划分的同一个局部结构中使用的特征学习器（PointNet）可以进行权重共享，即形同于卷积的形式来学习局部结构特征。</p>\r\n<p><strong>如何去划分局部区域？</strong>局部区域即一个空间中的球形邻域，参数包括中心点和大小。</p>\r\n<ul>\r\n<li>中心点：为了覆盖到完整的点集，应该使用最远点采样算法（FPS）选出代表邻域的中心点。</li>\r\n<li>大小：不同于CNNs小尺寸卷积核往往有更好的效果。小的邻域可能不足以让PointNets捕捉特征。</li>\r\n</ul>\r\n<h1 id=\"method\">Method</h1>\r\n<h2 id=\"hierarchical-point-set-feature-learning\">Hierarchical Point Set\r\nFeature Learning</h2>\r\n<p>和PointNet直接max\r\npooling整个点集不同，PointNet++对点集进行了分级管理，随着层级逐步抽取越来越大的区域特征。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/ha5H68M.png\"\r\nalt=\"原图 2 ：分级结构网络示意图\" />\r\n<figcaption aria-hidden=\"true\">原图 2 ：分级结构网络示意图</figcaption>\r\n</figure>\r\n<p>分层结构由<strong>set abstraction\r\n层</strong>构成。每个层中会处理其包含的点集，并且抽取出一个更少元素的新点集。set\r\nabstraction详细结构为：</p>\r\n<h3 id=\"sampling-层\">Sampling 层</h3>\r\n<p>从输入点集中使用FPS采样一个子集。这些点即作为每个局部邻域的中心点。</p>\r\n<h3 id=\"grouping-层\">Grouping 层</h3>\r\n<p>在中心点附近使用ball\r\nQuery查找相邻点，以便构建出局部邻域。输入包括原点集<span\r\nclass=\"math inline\">\\(N \\times (d+C)\\)</span>以及采样点集<span\r\nclass=\"math inline\">\\(N^` \\times\r\nd\\)</span>。输出包含K个元素的邻域点集<span class=\"math inline\">\\(N^`\r\n\\times K \\times\r\n(d+c)\\)</span>。每个邻域的K不一定相同，PointNet层最终会将其统一到一个相同长度的特征向量。</p>\r\n<h3 id=\"pointnet-层\">PointNet 层</h3>\r\n<p>使用了一个mini-PointNet来编码抽取每个邻域的特征。输出<span\r\nclass=\"math inline\">\\(N^` \\times\r\n(d+C^`)\\)</span>。处理时每个邻域中点集坐标转换成了相对中心点的偏移坐标：<span\r\nclass=\"math inline\">\\(x_i=x_i-\\hat{x}\\)</span>，以便于捕捉点间联系关系。</p>\r\n<h2\r\nid=\"robust-feature-learning-under-non-uniform-sampling-denisty\">Robust\r\nFeature Learning under Non-Uniform Sampling Denisty</h2>\r\n<p>从Grouping层可知，每个邻域的密度是不一样的。而非均匀分布会给点集特征提取带来一个较大的困难。稠密区域的特征可能不能泛化到稀疏区域。理想中，我们希望从尽可能小的邻域中提取特征。然而对于稀疏邻域来说，同样小的区域存在着采样不足的问题而不能提取特征。因此PointNet++通过一个密度自适应的PointNet层来结合不同尺度下的邻域特征。</p>\r\n<p>在PointNet++中，每个set abstraction\r\n层都会提取多尺度下的局部特征，并且根据邻域密度来智能地组合起来。其有两种类型的密度自适应层来实现以上目的：</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/uvgtlsr.png\"\r\nalt=\"原图 3：自适应密度示意图。(a)为MSG层。(b)为MRG层\" />\r\n<figcaption aria-hidden=\"true\">原图\r\n3：自适应密度示意图。(a)为MSG层。(b)为MRG层</figcaption>\r\n</figure>\r\n<h3 id=\"multi-scale-groupingmsg\">Multi-scale grouping（MSG）</h3>\r\n<p>一种简单而有效的多尺度提取方法：使用多种尺度的grouping层，并且利用PointNet层去提取每个尺度下的特征，最终concat组合成一个统一多尺度的特征。</p>\r\n<p>训练时通过随机dropout，使得网络能够接触到不同密度不同分布的点集，使得训练后网络能够找到更优的策略来组合多维度特征。在测试时则不进行dropout。</p>\r\n<h3 id=\"multi-resolution-groupingmrg\">Multi-resolution\r\ngrouping（MRG）</h3>\r\n<p>上面的MSG方法显然是计算昂贵的。比起MSG，MRG避免了很多最低层次的计算，更加高效。在<span\r\nclass=\"math inline\">\\(L_i\\)</span>尺度下，一个邻域的特征由两个向量连接而成。一个向量是通过set\r\nabstraction层抽取低级尺度<span\r\nclass=\"math inline\">\\(L_{i-1}\\)</span>下的子邻域的特征来获得。另一个向量是使用一个单独的PointNet直接处理邻域所有的点来得到。</p>\r\n<p>当邻域的密度较低时，低尺度特征很容易受到采样稀疏性影响，因此逐尺度总结的特征会变得没有直接提取的特征可靠，从而更依赖直接特征。另一方面，当密度过高时，逐尺度特征能够提供更精细的细节。</p>\r\n<h2 id=\"point-feature-propagation-for-set-segmentation\">Point Feature\r\nPropagation for Set Segmentation</h2>\r\n<p>set\r\nabstraction层会对原始点云进行二次采样，然而对于分割任务需要获得所有原始点的特征。一个办法是在所有尺度的set\r\nabstraction中将所有的点都作为中心点进行计算一次，而这计算很昂贵。<strong>另一个方法是将二次采样的点的特征传播到原始的点。</strong></p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/9j4usHP.png\" alt=\"原图 2：分割网络图\" />\r\n<figcaption aria-hidden=\"true\">原图 2：分割网络图</figcaption>\r\n</figure>\r\n<p>PointNet++采用了一个分层传播策略，包括<strong>基于距离插值</strong>和<strong>层级跳跃链接</strong>。</p>\r\n<ul>\r\n<li>设<span class=\"math inline\">\\(N_{l-1},N_l\\)</span>为<span\r\nclass=\"math inline\">\\(l\\)</span>层set\r\nabstraction的输入和输出的点集大小(<span class=\"math inline\">\\(N_l \\leq\r\nN_{l-1}\\)</span>)，feature propagation层会将<span\r\nclass=\"math inline\">\\(N_l \\times (d+C)\\)</span>的输入数据传播给<span\r\nclass=\"math inline\">\\(N_{l-1}\\)</span>个点，<strong>即在<span\r\nclass=\"math inline\">\\(N_{l-1}\\)</span>点的坐标上进行特征的插值。</strong>插值方法选择了在K近邻之上的反距离加权平权（实验采用p=2，k=3）：\r\n<span class=\"math display\">\\[\r\n  f^{(j)}(x)=\\frac{\\sum_{i=1}^{k} w_{i}(x) f_{i}^{(j)}}{\\sum_{i=1}^{k}\r\nw_{i}(x)} \\quad \\text { where } \\quad w_{i}(x)=\\frac{1}{d\\left(x,\r\nx_{i}\\right)^{p}}, j=1, \\ldots, C\r\n  \\]</span></li>\r\n<li>然后将<span\r\nclass=\"math inline\">\\(N_{l-1}\\)</span>点上的插值特征与从set\r\nabstraction层跳跃链接过来的特征进行连接。</li>\r\n<li>连接后的特征传递给unit\r\npointnet层（类1x1卷积层）。其中使用了一些共享权重的全连接层和ReLU层，以便更新每个点的特征向量。</li>\r\n<li>重复以上处理过程，直到特征传播给了原始的所有点</li>\r\n</ul>\r\n<h1 id=\"experiments\">Experiments</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/2ORoLoL.png\"\r\nalt=\"原图 4：Table2中with normal指点特征中加了face normals特征。左下图是随机dropout结果。右下图显示了在非均匀密度下的效果。DP表示random dropout。SSG表示single scale grouping。\" />\r\n<figcaption aria-hidden=\"true\">原图 4：Table2中with\r\nnormal指点特征中加了face\r\nnormals特征。左下图是随机dropout结果。右下图显示了在非均匀密度下的效果。DP表示random\r\ndropout。SSG表示single scale grouping。</figcaption>\r\n</figure>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[2] C. R. Qi, H. Su, K. Mo, and L. J. Guibas. Pointnet: Deep learning\r\non point sets for 3d classification and segmentation. arXiv preprint\r\narXiv:1612.00593, 2016.</p>\r\n","categories":["深度学习"],"tags":["点云"]},{"title":"PointNet-Based-Hand-Gesture-Recognition","url":"/2021/12/11/PointNet-Based-Hand-Gesture-Recognition/","content":"<p><strong>A PointNet-Based Solution for 3D Hand Gesture\r\nRecognition</strong></p>\r\n<p>Mirsu R, Simion G, Caleanu C D, et al. A pointnet-based solution for\r\n3d hand gesture recognition[J]. Sensors, 2020, 20(11): 3226.</p>\r\n<ol type=\"1\">\r\n<li>在Kaggle上公开了<a\r\nhref=\"https://www.kaggle.com/cdcaleanu/upt-tof-3d-hand-gesture-database?select=01_amp.bin\">手势数据集</a></li>\r\n<li>使用PCA进行手前臂分割</li>\r\n<li>使用基于直方图的邻域策略规范化点云大小</li>\r\n<li>使用PointNet架构完成3D DRGB图的手势识别</li>\r\n</ol>\r\n<h2 id=\"多级手部分割\">多级手部分割</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/6MCc6kE.png\" alt=\"多级分割流程图\" />\r\n<figcaption aria-hidden=\"true\">多级分割流程图</figcaption>\r\n</figure>\r\n<h3 id=\"预处理\">预处理</h3>\r\n<p>由于分类时直接对3D点云使用了深度学习，因此预处理好点云数据也很重要。详细工作可参考之前的paper[28]。</p>\r\n<p><strong>过滤平滑</strong>：使用中值滤波来去除斑点噪声。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/LzqDVdk.png\"\r\nalt=\"(a)未平滑原始深度图 (b)平滑过滤后\" />\r\n<figcaption aria-hidden=\"true\">(a)未平滑原始深度图\r\n(b)平滑过滤后</figcaption>\r\n</figure>\r\n<p><strong>筛选出手部区域</strong>：默认手部是屏幕最近的物体。因此从最近点开始，选取一个深度区间7cm左右的所有点。同时进行计数。若这个区间的点总数小于阈值，则说明最近的点是一个离群点，不可靠。因此将区间往后移动重新划分。</p>\r\n<p><strong>区域内聚类</strong>：\r\n通过区域，中心，等方式进行计算聚类。如果有多个类，则选择左上方的作为手部区域。</p>\r\n<p><strong>手前臂分割</strong>：通过PCA找到数据的对称轴。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/7baQ8zl.png\"\r\nalt=\"(a)(b)PCA找到的手前臂轴和手部区域轴，(c)PCA无效的状态\" />\r\n<figcaption\r\naria-hidden=\"true\">(a)(b)PCA找到的手前臂轴和手部区域轴，(c)PCA无效的状态</figcaption>\r\n</figure>\r\n<p>并且利用一个手部检测窗口，一个手腕检测窗口来找到手腕分界线：计算两个窗口内点数的比例，找到一个比例极值处作为手腕分界线。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/i2G6tHJ.png\"\r\nalt=\"红框为手部检测窗口，每一轮增大一点。绿框为手腕检测窗口，大小固定。\" />\r\n<figcaption\r\naria-hidden=\"true\">红框为手部检测窗口，每一轮增大一点。绿框为手腕检测窗口，大小固定。</figcaption>\r\n</figure>\r\n<p><strong>采样压缩点云</strong>：移除邻居最多的点，或者保留邻域最小的点</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/p9uOoIM.png\" alt=\"点云采样示意图\" />\r\n<figcaption aria-hidden=\"true\">点云采样示意图</figcaption>\r\n</figure>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[28] Simion, G.; Caleanu, C. Multi-stage 3D segmentation for ToF\r\nbased gesture recognition system. In Proceedings of the 2014 11th\r\nInternational Symposium on Electronics and Telecommunications (ISETC),\r\nTimisoara, Romania, 15–16 November 2014; pp. 1–4.</p>\r\n","categories":["深度学习"],"tags":["深度学习","点云","序列学习"]},{"title":"PointNet","url":"/2021/11/14/PointNet/","content":"<p><strong>PointNet: Deep Learning on Point Sets for 3D Classification\r\nand Segmentation</strong></p>\r\n<p>Qi C R, Su H, Mo K, et al. Pointnet: Deep learning on point sets for\r\n3d classification and segmentation[C]//Proceedings of the IEEE\r\nconference on computer vision and pattern recognition. 2017:\r\n652-660.</p>\r\n<p>点云是重要的几何数据结构。由于点云的不规则形式，大部分人都将其转化为规则的3D体素网格，或者图像集合。这篇文章定义了一个全新的神经网络类型，其可以直接使用点云格式，并且很好的保持了点云输入中的置换不变性，即PointNet。</p>\r\n<p>PointNet为点云的各种应用如目标识别、部件分割、语义分割等，提供了统一的架构。</p>\r\n<p>PointNet虽然简单，但是十分高效。实验上，它和最先进的模型效果旗鼓相当，甚至更好。理论上，文章分析了网络在学习什么，并且分析了为什么网络对输入的置换和缺失具有很好的鲁棒性。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"introduction\">Introduction</h1>\r\n<p>传统的卷积结构为实现权值共享和其他核优化方法，需要高度规则的输入数据格式，因此经常会把点云和网格转化为规则的去做。但是这样会造成数据不必要的冗余，并且引入了人为量化误差而掩盖了数据本身的不变性。</p>\r\n<p>点云十分简单，并且避免了网格的复杂性，因此网络容易从中学习。但是点云仅仅是点集，因此需要在网络计算中进行一些对称化，来保证其排列不变性。更进一步，还应该考虑到刚体运动的不变性。</p>\r\n<p><strong>single symmetric function: max pooling.</strong>\r\n网络可以学习到一系列用于筛选出兴趣点的优化方法，并且将其筛选条件进行编码。最后的全连接层收集了学习到的最优特征，整合进整个形状的全局描述子。</p>\r\n<p><strong>空间变换网络</strong>：输入数据容易进行刚体变换或仿射变换：因为每一个点的变换是独立的。因此可以在PointNet处理数据之前添加一个数据依赖的空间变换网络，来对数据进行规范化处理，有利于改善结果。</p>\r\n<p><strong>点云数据特征</strong>：</p>\r\n<ol type=\"1\">\r\n<li>无序性：点云数据是一个无序的集合，因此网络如果要处理N个3D点的点云集合，需要对N!种不同的排列组合的输入保持不变性。</li>\r\n<li>点间联系：点云中的点并不是孤立存在的，一群邻近点可以形成一个有语义的子集。因此，网络必须要能够捕捉到这种邻近点群形成的局部结构特征，以及局部结构特征之间的联系。</li>\r\n<li>变换不变性：例如旋转和平移不应该影响点云的分类和分割。</li>\r\n</ol>\r\n<h1 id=\"亮点\">亮点</h1>\r\n<p>三个关键点：</p>\r\n<ol type=\"1\">\r\n<li>max pooling 层作为对称函数来聚合所有点云信息。</li>\r\n<li>一个局部和全局信息的组合结构。</li>\r\n<li>两个节点对齐T-net网络。用于对齐输入点和点特征。</li>\r\n</ol>\r\n<h2 id=\"针对无序输入的对称函数\">针对无序输入的对称函数</h2>\r\n<p><strong>两个现有策略</strong>：</p>\r\n<ol type=\"1\">\r\n<li>将输入进行规范化排序</li>\r\n</ol>\r\n<p>虽然排序听起来简单，但实际上无法找到一个在有扰动的情况下，依然稳定的排序顺序。因为这实际上是在把高维数据降维至一维直线，同时还要保证空间上的相似性（spatial\r\nproximity），而这是一件无法实现的事。因此排序依然无法解决无序性问题，如图5所示，对排序后的点集使用MLP进行训练效果依然很差，虽然比起不排序的好一点点。</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>将输入看作类似RNN那样的sequence，另外还通过各种排列组合来增强训练数据。</li>\r\n</ol>\r\n<p>考虑到点集可以看作是一种序列信号，因此引入了RNN的使用。并且期望通过随机排列序列来对RNN进行训练，这样RNN可以对输入顺序保有一定的不变性。然而《OrderMatters》[2]告诉我们RNN的输入顺序会影响网络的学习效果。尽管RNN对小批量序列有一定的顺序鲁棒性，但这很难在点云成千上万的数据批量上成立。从实验上，RNN为基础的模型依然表现的不够好。</p>\r\n<p><strong>PointNet策略</strong>：\r\n使用一个简单的对称函数来聚合每一个点的信息。</p>\r\n<blockquote>\r\n<p>对称函数：函数接收一系列的向量作为输入，输出一个新的向量。并且该输出不受输入向量间顺序的影响。例如+、*都是对称函数。</p>\r\n</blockquote>\r\n<p>本质上是对点集中变换过的每个元素使用一个对称函数，来近似等于一个通用函数(general\r\nfunction):</p>\r\n<p><span class=\"math display\">\\[\r\nf\\left(\\left\\{x_{1}, \\ldots, x_{n}\\right\\}\\right) \\approx\r\ng\\left(h\\left(x_{1}\\right), \\ldots, h\\left(x_{n}\\right)\\right)\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(f: 2^{\\mathbb{R}^{N}} \\rightarrow\r\n\\mathbb{R}, h: \\mathbb{R}^{N} \\rightarrow \\mathbb{R}^{K}\\)</span> 且\r\n<span class=\"math inline\">\\(g:\\)</span> <span\r\nclass=\"math inline\">\\(\\underbrace{\\mathbb{R}^{K} \\times \\cdots \\times\r\n\\mathbb{R}^{K}}_{n} \\rightarrow \\mathbb{R}\\)</span> 为对称函数。</p>\r\n<p>主观上看，这种模型十分简单：h看作MLP，g看作一个一元函数和max\r\npooling的结合体，实验证明这种模型十分有效。通过一系列的h，网络可以学习得到多种多样的f，来描述点云特性。</p>\r\n<h2 id=\"局部信息和全局信息整合\">局部信息和全局信息整合</h2>\r\n<p>通过对无序输入的处理，可以得到一个<span\r\nclass=\"math inline\">\\(f\\)</span>的向量<span\r\nclass=\"math inline\">\\([f_1,...,f_k]\\)</span>，即算是一种全局特征描述子。为了进行点云分割，不仅需要全局信息，还需要和局部信息进行结合。</p>\r\n<p>PointNet将先得到的全局特征重新与每个点的特征连接起来，然后计算出新的每个点的特征，即产生局部特征和全局特征的整合。</p>\r\n<p>通过这种整合，PointNet能够给出有关于局部几何信息和全局语义信息的点的数量。例如，PointNet可以精准预测每个点的法线（即证明网络可以整合点的局部信息）。</p>\r\n<h2 id=\"节点对齐网络\">节点对齐网络</h2>\r\n<p>为了让点云经过几何变换后依然有相同的语义标签，一个自然的做法是在特征抽取前将点云对齐到一个规范化空间。PointNet中通过一个小型网络T-net来预测一个仿射变换矩阵，并且直接将这个仿射变换应用在输入点云的坐标数据上，来实现对齐。</p>\r\n<p>在特征空间上也可以这样做，通过一个网络来预测特征的变换矩阵，来实现对不同输入点云的特征的对齐。不过由于特征空间的高纬度，这样的操作极大增加了网络更新的困难。因此PointNet在损失函数中添加了一个正则项，来迫使特征变换矩阵更像一个正交矩阵（正交变换不会损失数据信息）：</p>\r\n<p><span class=\"math display\">\\[\r\nL_{r e g}=\\left\\|I-A A^{T}\\right\\|_{F}^{2}\r\n\\]</span></p>\r\n<p><span\r\nclass=\"math inline\">\\(A\\)</span>是特征变换矩阵。实验证明，这个正则化可以使网络变得更加稳定，且整体效果更好。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/nnVKzLc.png\"\r\nalt=\"表 5 在ModelNet40上的对齐变换测试\" />\r\n<figcaption aria-hidden=\"true\">表 5\r\n在ModelNet40上的对齐变换测试</figcaption>\r\n</figure>\r\n<h1 id=\"网络详细结构\">网络详细结构</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/KiBbOvL.png\"\r\nalt=\"图1 PointNet结构图：Classification输出全局label。Segmentation网络最后输出每个点的分数。\" />\r\n<figcaption aria-hidden=\"true\">图1\r\nPointNet结构图：Classification输出全局label。Segmentation网络最后输出每个点的分数。</figcaption>\r\n</figure>\r\n<ul>\r\n<li>主体每一层都使用了ReLU和Batchnorm，最后一个输出为256的全连接层之后使用了dropout=0.7。</li>\r\n<li>一维卷积层（权值共享MLP）：\r\n使用多个大小为1，步长为1的卷积核，对每一个点进行卷积，不涉及到其他点。</li>\r\n<li>第一个T-Net：三层共享权值的MLP（64，128，1024）+ max pooling+\r\n两层全连接（512，256\r\n），最终输出3X3矩阵。除了最后一层都使用了ReLU和batch\r\nnormalization。</li>\r\n<li>第二个T-Net：结构相同，最后输出64X64矩阵。</li>\r\n<li>softmax分类损失携带一个一个权重0.001的正则损失，以便于让矩阵接近正交。</li>\r\n</ul>\r\n<h1 id=\"理论支撑\">理论支撑</h1>\r\n<p>证明过程有时间再看，目前先看对网络的理论性支撑。</p>\r\n<h2 id=\"集合函数万能近似定理\">集合函数万能近似定理</h2>\r\n<p>证明了PointNet理论上拟合函数的正确性。</p>\r\n<p>对于 Hausdorff 距离 <span class=\"math inline\">\\(d_{H}(\\cdot, \\cdot)\r\n.\\)</span> 假设<span class=\"math inline\">\\(f: \\mathcal{X} \\rightarrow\r\n\\mathbb{R}\\)</span> 是一个Hausdorff度量的连续集合函数。<span\r\nclass=\"math inline\">\\(\\quad \\forall \\epsilon&gt;\\)</span> <span\r\nclass=\"math inline\">\\(0, \\exists\\)</span> 一个连续函数<span\r\nclass=\"math inline\">\\(h\\)</span>和一个对称函数 <span\r\nclass=\"math inline\">\\(g\\left(x_{1}, \\ldots, x_{n}\\right)=\\gamma \\circ M\r\nA X\\)</span>, 对于任意 <span class=\"math inline\">\\(S \\in\r\n\\mathcal{X}\\)</span>有：</p>\r\n<p><span class=\"math display\">\\[\r\n\\left|f(S)-\\gamma\\left(\\underset{x_{i} \\in\r\nS}{\\operatorname{MAX}}\\left\\{h\\left(x_{i}\\right)\\right\\}\\right)\\right|&lt;\\epsilon\r\n\\]</span></p>\r\n<p>其中 <span class=\"math inline\">\\(x_{1}, \\ldots, x_{n}\\)</span> 是\r\n<span class=\"math inline\">\\(S\\)</span>的无序子集元素 , <span\r\nclass=\"math inline\">\\(\\gamma\\)</span> 是连续函数， <span\r\nclass=\"math inline\">\\(M A X\\)</span> 是 vector max operator：输入<span\r\nclass=\"math inline\">\\(n\\)</span>个向量并且输出一个每个元素位置都是最大值的向量.</p>\r\n<h2 id=\"维度瓶颈和稳定性\">维度瓶颈和稳定性</h2>\r\n<p>证明了PointNet受max pooling层维度影响很大，且其鲁棒性也与max\r\npooling层有关。表现结果是PointNet会学习到一个形状的<strong>关键点轮廓</strong>来表示这个形状。</p>\r\n<p>定义<span\r\nclass=\"math inline\">\\(\\bold{u}={\\operatorname{MAX}}\\left\\{h\\left(x_{i}\\right)\\right\\}\\)</span>为最后一层是输出K维的max\r\npooling层的网络。假设有如上定义的<span class=\"math inline\">\\(\\mathrm{u}:\r\n\\mathcal{X} \\rightarrow \\mathbb{R}^{K}\\)</span> 且 <span\r\nclass=\"math inline\">\\(f=\\gamma \\circ\\)</span> u。那么有：</p>\r\n<ol type=\"a\">\r\n<li><p>输入数据是关键点集的超集，则运算不会产生损失：<span\r\nclass=\"math inline\">\\(\\forall S, \\exists \\mathcal{C}_{S},\r\n\\mathcal{N}_{S} \\subseteq \\mathcal{X}, f(T)=f(S) if \\mathcal{C}_{S}\r\n\\subseteq T \\subseteq \\mathcal{N}_{S}\\)</span></p></li>\r\n<li><p>关键点集元素数不超过K：<span\r\nclass=\"math inline\">\\(\\left|\\mathcal{C}_{S}\\right| \\leq\r\nK\\)</span></p></li>\r\n</ol>\r\n<h1 id=\"优缺点\">优缺点</h1>\r\n<p>PointNet具有很强的鲁棒性，通过其对关键点集的提取，可以在有较多的点云损失的情况下依然保持分类能力。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/GxXDDfN.png\"\r\nalt=\"图 6 PointNet鲁棒性测试。中间的图是均匀分布异常点的结果。右边的图是给每个点数据添加不相关的高斯噪声的结果。\" />\r\n<figcaption aria-hidden=\"true\">图 6\r\nPointNet鲁棒性测试。中间的图是均匀分布异常点的结果。右边的图是给每个点数据添加不相关的高斯噪声的结果。</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/NNo3Lpu.png\"\r\nalt=\"图 7 PointNet学习到点云的关键点集：关键点集为那些对maxpooling特征有贡献的点。upper-bound点集为给定同样的全局特征信息，最多能包含的点。\" />\r\n<figcaption aria-hidden=\"true\">图 7\r\nPointNet学习到点云的关键点集：关键点集为那些对maxpooling特征有贡献的点。upper-bound点集为给定同样的全局特征信息，最多能包含的点。</figcaption>\r\n</figure>\r\n<p>PointNet只有全局特征和每个点的特征，丢失了局部点间特征。如网络结构所示，卷积层不涉及到任何点间联系。后续PointNet++[3]有关注点间联系的问题。</p>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[2] O. Vinyals, S. Bengio, and M. Kudlur. Order matters: Sequence to\r\nsequence for sets. arXiv preprint arXiv:1511.06391, 2015.</p>\r\n<p>[3] Hao C R Q L Y, Guibas S L J. PointNet++: Deep Hierarchical\r\nFeature Learning on Point Sets in a Metric Space[J]. arXiv preprint\r\narXiv:1706.02413, 2017.</p>\r\n<p><a\r\nhref=\"https://blog.csdn.net/qq_27136953/article/details/109960161?utm_medium=distribute.wap_relevant.none-task-blog-2~default~baidujs_title~default-4.wap_blog_relevant_default&amp;spm=1001.2101.3001.4242.3\">理论证明详解博客</a></p>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/86331508\">网络结构介绍博客</a></p>\r\n","categories":["深度学习"],"tags":["点云"]},{"title":"PointTransformer","url":"/2021/12/18/PointTransformer/","content":"<p><strong>Point Transformer</strong></p>\r\n<ul>\r\n<li>Zhao H, Jiang L, Jia J, et al. Point transformer[C]//Proceedings of\r\nthe IEEE/CVF International Conference on Computer Vision. 2021:\r\n16259-16268.</li>\r\n<li>港中文</li>\r\n</ul>\r\n<p>self-attention是天然的一个集合操作：将位置信息作为元素属性，并且视作集合处理。而另一方面点云天然就是位置属性的集合，因此self-attention直觉上很适合点云数据。之前已经有一些工作[48,21,50,17]在点云分析上使用了attention。他们在整个点云上使用全局的注意力机制，而这会带来昂贵的计算。并且他们使用了标量点积的注意力，即不同通道之间共享相同的聚合权重。</p>\r\n<p>相反，Point Transformer有以下优势：</p>\r\n<ul>\r\n<li><strong>局部应用注意力机制</strong>，使得拥有处理百万点数的大场景的能力。</li>\r\n<li>使用了<strong>vector\r\nattention</strong>，而这是实现高准确率的重要因素。</li>\r\n<li>阐述了<strong>position\r\nencoding</strong>的重要性，而不是像之前的工作一样忽略的位置信息。</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<h1 id=\"point-transformer\">Point Transformer</h1>\r\n<h2 id=\"原始transoformer操作\">原始Transoformer操作</h2>\r\n<p>Self-attention操作可以分为两类：<span\r\nclass=\"math inline\">\\(y_i\\)</span>为输出特征，<span\r\nclass=\"math inline\">\\(\\varphi,\\psi,\\alpha\\)</span>为逐点的线性变换操作。<span\r\nclass=\"math inline\">\\(\\delta\\)</span>为position encoding，<span\r\nclass=\"math inline\">\\(\\rho\\)</span>为标准化操作，如softmax。</p>\r\n<ul>\r\n<li>scalar\r\nattention：计算线性变换后的特征的标量积，并且将这个标量积结果当做聚合<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>变换特征的注意力权重。 <span\r\nclass=\"math display\">\\[\r\n\\mathbf{y}_{i}=\\sum_{\\mathbf{x}_{j} \\in \\mathcal{X}}\r\n\\rho(\\varphi\\left(\\mathbf{x}_{i}\\right)^T\r\n\\psi\\left(\\mathbf{x}_{j})+\\delta\\right)\r\n\\alpha\\left(\\mathbf{x}_{j}\\right)\r\n\\]</span></li>\r\n<li>vector attention：<span\r\nclass=\"math inline\">\\(\\beta\\)</span>作为一个relation函数(如减法)，<span\r\nclass=\"math inline\">\\(\\gamma\\)</span>作为一个映射函数(如MLP)，产生vector\r\nattention。这样产生的vector形式的attention能够调节独立的特征通道。 <span\r\nclass=\"math display\">\\[\r\n\\mathbf{y}_{i}=\\sum_{\\mathbf{x}_{j} \\in \\mathcal{X}}\r\n\\rho\\left(\\gamma\\left(\\beta\\left(\\varphi\\left(\\mathbf{x}_{i}\\right),\r\n\\psi\\left(\\mathbf{x}_{j}\\right)\\right)+\\delta\\right)\\right) \\odot\r\n\\alpha\\left(\\mathbf{x}_{j}\\right)\r\n\\]</span></li>\r\n</ul>\r\n<h2 id=\"point-transformer层\">Point Transformer层</h2>\r\n<p>基于vector self-attention，relation\r\nfunction使用了减法，并且在attention vector <span\r\nclass=\"math inline\">\\(\\gamma\\)</span> 和线性特征 <span\r\nclass=\"math inline\">\\(\\alpha\\)</span> 两边都加上了position encoding\r\n<span class=\"math inline\">\\(\\delta\\)</span>。</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathbf{y}_{i}=\\sum_{\\mathbf{x}_{j} \\in \\mathcal{X}(i)}\r\n\\rho\\left(\\gamma\\left(\\varphi\\left(\\mathbf{x}_{i}\\right)-\\psi\\left(\\mathbf{x}_{j}\\right)+\\delta\\right)\\right)\r\n\\odot\\left(\\alpha\\left(\\mathbf{x}_{j}\\right)+\\delta\\right)\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/AMxRPzg.png\"\r\nalt=\"Point transformer layer\" />\r\n<figcaption aria-hidden=\"true\">Point transformer layer</figcaption>\r\n</figure>\r\n<h2 id=\"position-encoding\">Position Encoding</h2>\r\n<p>位置编码对于self-attention十分重要，它可以学习局部结构。因此设计了一个可训练的参数化位置编码模型：</p>\r\n<p><span class=\"math display\">\\[\r\n\\delta=\\theta(p_i-p_j)\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(p\\)</span>为坐标，<span\r\nclass=\"math inline\">\\(\\theta\\)</span>为两个线性层和一个ReLU的MLP，并且位置编码模型和其他层一起进行端到端的训练。</p>\r\n<h2 id=\"point-transformer-block\">Point Transformer Block</h2>\r\n<p>本文构造了一个残差Point Transformer Block，其中Point Transformer\r\nLayer是其核心。如下图所示，Block集成了self-attention层，降维和加速的线性层，一个残差连接。这个Block接受所有点的坐标，并且输出每个点的特征向量。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/2rU3ABC.png\" alt=\"关键结构图\" />\r\n<figcaption aria-hidden=\"true\">关键结构图</figcaption>\r\n</figure>\r\n<h2 id=\"基于block的完整网络结构\">基于Block的完整网络结构</h2>\r\n<p>整个网络完全由point transformer，线性变换，pooling\r\n层构建，而没有使用卷积辅助。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/IR9kdzM.png\"\r\nalt=\"完整的语义分割和分类网络\" />\r\n<figcaption aria-hidden=\"true\">完整的语义分割和分类网络</figcaption>\r\n</figure>\r\n<p><strong>主体结构</strong>：首先对点云进行五次的下采样。下采样的比例可以根据应用场景调整，例如想要轻量化加速模型什么的。这些阶段主要连续使用了两个变换模块：特征编码transition\r\ndown和特征解码transition up。</p>\r\n<p><strong>Transition\r\ndown</strong>：主要功能是压缩点云。通过FPS算法进行采样点云<span\r\nclass=\"math inline\">\\(P_1\\)</span>生成子集<span\r\nclass=\"math inline\">\\(P_2\\)</span>，同时在采样前点云上<span\r\nclass=\"math inline\">\\(P_1\\)</span>使用kNN聚合特征向量。总之，<span\r\nclass=\"math inline\">\\(P_1\\)</span>的输入特征会以下一下处理：</p>\r\n<ol type=\"1\">\r\n<li>线性变换</li>\r\n<li>batch normalization</li>\r\n<li>ReLU</li>\r\n<li>FPS采样产生<span class=\"math inline\">\\(P_2\\)</span>，对<span\r\nclass=\"math inline\">\\(P_2\\)</span>的每个点，寻找其在<span\r\nclass=\"math inline\">\\(P_1\\)</span>的kNN，进行max pooling提取特征。</li>\r\n</ol>\r\n<p><strong>Transition\r\nup</strong>：对于预测密集型任务(语义分割)，使用了一种<strong>U-net的结构</strong>：使用对称的解码器与上面的编码器相配对。解码器的主要功能是将<span\r\nclass=\"math inline\">\\(P_2\\)</span>的特征映射到它的超集<span\r\nclass=\"math inline\">\\(P_1\\)</span>。<span\r\nclass=\"math inline\">\\(P_2\\)</span>的输入经过以下处理：</p>\r\n<ol type=\"1\">\r\n<li>线性变换</li>\r\n<li>batch normalization</li>\r\n<li>ReLU</li>\r\n<li>通过三维插值映射特征到超集<span\r\nclass=\"math inline\">\\(P_1\\)</span>。其中插值特征的生成不仅依赖于前一个解码器的输出特征，还依赖于匹配的编码器特征。</li>\r\n</ol>\r\n<p><strong>Output\r\nhead</strong>：对于语义分割，最终生成了每个点的特征向量。使用一个MLP层来将特征最终映射到logits。对于分类，使用全局平均池化来获得整个点集的特征，最终在通过一个MLP来映射到logits。</p>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[17] Juho Lee, Yoonho Lee, Jungtaek Kim, Adam Kosiorek, Seungjin\r\nChoi, and Yee Whye Teh. Set transformer: A framework for attention-based\r\npermutation-invariant neural networks. In ICML, 2019.</p>\r\n<p>[21] Xinhai Liu, Zhizhong Han, Yu-Shen Liu, and Matthias Zwicker.\r\nPoint2sequence: Learning the shape representation of 3d point clouds\r\nwith an attention-based sequence to sequence network. In AAAI, 2019.</p>\r\n<p>[48] Saining Xie, Sainan Liu, Zeyu Chen, and Zhuowen Tu. Attentional\r\nshapecontextnet for point cloud recognition. In CVPR, 2018.</p>\r\n<p>[50] Jiancheng Yang, Qiang Zhang, Bingbing Ni, Linguo Li, Jinxian\r\nLiu, Mengdie Zhou, and Qi Tian. Modeling point clouds with\r\nself-attention and gumbel subset sampling. In CVPR, 2019.</p>\r\n","categories":["深度学习"],"tags":["深度学习","点云","序列学习","Transformer"]},{"title":"SIGGRAPH2021翻阅","url":"/2021/10/09/SIGGRAPH2021%E7%BF%BB%E9%98%85/","content":"<h3\r\nid=\"unsupervised-learning-for-cuboid-shape-abstraction-via-joint-segmentation-from-point-clouds\">Unsupervised\r\nLearning for Cuboid Shape Abstraction via Joint Segmentation from Point\r\nClouds</h3>\r\n<p>KAIZHI YANG,XUEJIN CHEN, University of Science and Technology of\r\nChina, China</p>\r\n<p>将复杂的3D物体表达成简单的几何图元，即<strong>形状提取</strong>（shape\r\nabstract），对于几何建模、结构分析、形状合成来说十分重要。这篇文章中提出了一个无监督的形状提取方法，可以把点云映射到紧凑的立方体表示。利用部件分割和立方体形态来联合预测立方体的分布，并且在自监督学习中加强形状提取和部件分割的一致性。</p>\r\n<p><strong>立方体提取</strong>，利用一种变分自动编码网络，将点云输入转换成一系列的参数化立方体。</p>\r\n<p><strong>分割网络</strong>，\r\n根据点和立方体的联系，将每一个点分配到一个立方体中。在没有人工标注点云部件的情况下，设计了四个新的损失函数，以联合监督有关\r\n<strong>立方体压缩和几何相似度</strong> 的两条线路。</p>\r\n<p><strong>评估</strong>，在大量的形状数据集上进行评估，并且证明了比起现有方法的优越性。另外，在网络架构和学习到的特征的基础上，此方法可以支持诸如结构化形状生成，形状插值，结构化形状聚类。</p>\r\n<p>3D形状提取，3D结构表达，点云，结构分割</p>\r\n<span id=\"more\"></span>\r\n<h3\r\nid=\"sp-gan-sphere-guided-3d-shape-generation-and-manipulation\">SP-GAN:\r\nSphere-Guided 3D Shape Generation and Manipulation</h3>\r\n<p>RUIHUI LI, XIANZHI LI, KA-HEI HUI, and CHI-WING FU, The Chinese\r\nUniversity of Hong Kong, China</p>\r\n<p><strong>SP-GAN</strong>,一种新的用于指导点云生成3D形状的，无监督球体引导生成模型。</p>\r\n<p><strong>设计亮点</strong>,将复杂的3D形状生成工作分解成<strong>全局形状模型</strong>和<strong>局部结构调整</strong>，以便于简化学习过程并且加强形状生成质量。并且，此模型形成了球上的点和生成形状的点之间的隐式的稠密对应关系，以便于各种形状的结构可知的形状的操作，例如部件编辑，形状插值，复合形状部件组合等等。</p>\r\n<p><strong>比起现有模型</strong>，SP-GAN能够合成，各种各样的，高质量的，细节丰富的形状，并且提高了部件可知（part-aware）的形状的生成和操控的可控性，并且可以在<strong>没有任何部件标注</strong>的基础上训练。</p>\r\n<p>通过一个<strong>全局监督</strong>（prior）（球体上均匀分布的点），在空间上引导生成过程，并且在其上附加一个<strong>局部监督</strong>（a\r\nrandom latent code）来给每一个球上的点提供局部细节。</p>\r\n<p><strong>评估</strong>，在可视化和量化的评估下，比起现有最好的模型，该模型能够生成多样的、高细节低噪声的点云结构。</p>\r\n<p>形状分析和合成，生成模型，3D形状生成，3D形状操控，点云</p>\r\n<h3\r\nid=\"single-depth-view-based-real-time-reconstruction-of-hand-object-interactions\">Single\r\nDepth View Based Real-Time Reconstruction of Hand-Object\r\nInteractions</h3>\r\n<p>HAO ZHANG, YUXIAO ZHOU, YIFEI TIAN, JUN-HAI YONG, and FENG XU,\r\nTsinghua University</p>\r\n<p>重构手持物的交互，因其强遮挡性和复杂的运动性，是一件有挑战的工作。</p>\r\n<p><strong>实时重建</strong>，通过单深度信息来即时重建手部动作，物品形状，以及刚体/非刚体的运动。</p>\r\n<p><strong>关节学习网络</strong>，在深度图中分割手和手持物，并且预测手部的3D关键点。通过两个任务共享大多数网络层次，可以为实时性能节省计算消耗。</p>\r\n<p><strong>数据集</strong>，构造了一个混合数据集以便于利用真实数据（真实世界的分布）和合成数据（改变物体、运动、视点）训练网络。</p>\r\n<p>接着在一个统一优化（uniform\r\noptimization）中利用两个目标的深度和关键点，来重构交互动作。受益于一个新的切向接触约束，该系统不仅解决了留存的模糊性，还保持了实时的性能。</p>\r\n<p><strong>评估</strong>，对于不同的手和不同形状的手持物，不同的交互动作，运动的相机视角，该系统都能有效。</p>\r\n<p>单深度摄像头，手部追踪，目标重建，手持物交互</p>\r\n<h3\r\nid=\"learning-skeletal-articulations-with-neural-blend-shapes\">Learning\r\nSkeletal Articulations with Neural Blend Shapes</h3>\r\n<p>PEIZHUO LI, CFCS, Peking University &amp; AICFVE, Beijing Film\r\nAcademy KFIR ABERMAN, Google Research RANA HANOCKA, Tel-Aviv University\r\nLIBIN LIU, CFCS, Peking University OLGA SORKINE-HORNUNG, ETH Zurich\r\n&amp; AICFVE, Beijing Film Academy BAOQUAN CHEN∗, CFCS, Peking\r\nUniversity &amp; AICFVE, Beijing Film Academy</p>\r\n<p>利用动作捕捉数据进行角色动画设计是一个长久的计算机动画问题。</p>\r\n<p><strong>关键方向</strong>，骨骼数据转换为可用的动捕数据，关节区域的形变，而这通常需要高度定制和针对特定姿势的改进。<br />\r\n<strong>神经技术</strong>，利用预定义的骨骼结构包裹表达3D角色，而这可以产生高质量的姿势相关变形。</p>\r\n","categories":["深度学习"]},{"title":"SequentialPointNet","url":"/2021/12/26/SequentialPointNet/","content":"<p><strong>SequentialPointNet: A strong parallelized point cloud\r\nsequence network for 3D action recognition</strong></p>\r\n<ul>\r\n<li>Li X, Huang Q, Wang Z, et al. SequentialPointNet: A strong\r\nparallelized point cloud sequence network for 3D action recognition[J].\r\narXiv preprint arXiv:2111.08492, 2021.</li>\r\n<li>河海大学 CS</li>\r\n<li><a\r\nhref=\"https://github.com/XingLi1012/SequentialPointNet.git\">源码仓库</a></li>\r\n</ul>\r\n<p>针对人类动作在空间上复杂，在时间上简单的特性，不平等的对待空间信息和时间信息。提出了一个强并行能力的点云序列网络SequentialPointNet：一个帧内appearance编码模块，一个帧间动作编码模块。</p>\r\n<ul>\r\n<li>为了对人体动作丰富的空间信息建模，每帧先在帧内的appearance\r\nencoding中并行处理，并且输出一个特征向量序列，描述静态的appearance在时间维度上的改变。</li>\r\n<li>为了建模简单的时间维度上的变化，在帧间的动作编码模块中，在特征向量序列中应用了\r\n时间上的位置编码和分层的池化策略。</li>\r\n<li>为了更好的挖掘时空内容，聚合人体动作的多级特征。</li>\r\n</ul>\r\n<h1 id=\"帧间编码\">帧间编码</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/AfhgtrM.png\" alt=\"帧间编码\" />\r\n<figcaption aria-hidden=\"true\">帧间编码</figcaption>\r\n</figure>\r\n<p><strong>Temporal position\r\nembedding</strong>：和Transformer的positional\r\nencoding差不多。将时间上的位置进行encoding：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{gathered}\r\nP E_{t, 2 h}=\\sin \\left(t / 10000^{2 h / d_{\\text {sout }}}\\right) \\\\\r\nP E_{t, 2 h+1}=\\cos \\left(t / 10000^{2 h / d_{\\text {sout }}}\\right)\\\\\r\n\\widehat{f}_{t, h}=f_{t, h}+P E_{t, h}\r\n\\end{gathered}\r\n\\]</span></p>\r\n<p><strong>共享MLP</strong>：在时间位置编码之后，再进行特征抽取，加强信息。</p>\r\n<p><strong>Hierarchical pyramid max\r\npooling</strong>：类似于多卷积核操作。将时间序列化为不同的几个部分，并且使用max\r\npooling分别抽取特征。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/unueYdQ.png\" alt=\"层级式max pooling\" />\r\n<figcaption aria-hidden=\"true\">层级式max pooling</figcaption>\r\n</figure>\r\n<p><strong>多级特征抽取</strong>：序列层级学习是帧间的分级策略，还有帧内的多级特征抽取：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{gathered}\r\nP=\\underset{t=1, \\ldots,\r\nT}{\\operatorname{MAX}}\\left\\{\\operatorname{MAX}_{j=1, \\ldots,\r\nn_{2}}\\left\\{r_{j}^{t}\\right\\}\\right\\} \\\\\r\nR=\\operatorname{MAX}_{t=1, \\ldots, T}\\left\\{f_{t}\\right\\}\r\n\\end{gathered}\r\n\\]</span></p>\r\n","categories":["深度学习"],"tags":["点云","序列学习"]},{"title":"SPCMNet：LearningSceneDynamics","url":"/2022/03/19/SPCMNet-LearningSceneDynamics/","content":"<ul>\r\n<li>He P, Emami P, Ranka S, et al. Learning Scene Dynamics from Point\r\nCloud Sequences[J]. International Journal of Computer Vision, 2022:\r\n1-27.</li>\r\n<li>Q1 CCF-A</li>\r\n<li>University of Florida ，CS</li>\r\n</ul>\r\n<p>主要是做序列点云的场景流估计以及预测任务。之前的场景流估计一般都是t-1帧预测t帧，两帧之间的联系。本文定义了序列多帧联系的场景流估计问题。并且基于这个问题，提出了一些序列学习的方法。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/FQFKpVw.png\" alt=\"整体结构图\" />\r\n<figcaption aria-hidden=\"true\">整体结构图</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<ul>\r\n<li>Intra-Frame Feature Pyramid\r\n(IFFP)：依照了PointPWC-Net的结构，由于不能直接对点云进行传统卷积，使用了PointConv层进行卷积处理。<strong>并且通过多次FPS采样卷积中心，构建了多个金字塔式特征</strong>。</li>\r\n<li>Inter-Frame Spatiotemporal Correlation (IFSC):\r\n为了能找到时空联系，很自然我们希望使时间维度上的receptive\r\nfield能够尽可能覆盖到整个序列。因此借鉴了传统序列模型的<strong>LSTM结构</strong>,使用了一个\r\n<strong>recurrent cost volume</strong> 结构来保存一定的时间信息。</li>\r\n<li>Multi-scale Coarse-to-Fine Prediction: 两个帧的特征+cost\r\nvolume的特征生成最低级(粗粒度)的预测点，然后通过Pointnet++的特征上采样传播逐渐生成细粒度特征。</li>\r\n</ul>\r\n<h1 id=\"recurrent-cost-volume\">Recurrent Cost Volume</h1>\r\n<p>PointPWC-Net(2020)提出的<strong>可学习的相继两个点云的matching\r\ncost</strong>：找到<span\r\nclass=\"math inline\">\\(p_t^j\\)</span>在上一帧中的邻域，并且计算邻域所有点与其的特征差和坐标差。</p>\r\n<p><span class=\"math display\">\\[\r\n\\operatorname{Cost}\\left(p_{t}^{j},\r\np_{t-1}^{i}\\right)=\\phi_{\\mathrm{MLP}}\\left(c_{t-1}^{i}-c_{t}^{j},\r\nx_{t-1}^{i}, x_{t}^{j}\\right)\r\n\\]</span></p>\r\n<p>然而这种<strong>点对点</strong>的matching cost对异常点特别敏感。</p>\r\n<p>FlowNet3D(2019)的flow\r\nembedding层则是<strong>点对集合</strong>的matching\r\ncost，其通过聚合邻域的特征一定程度上解决了这个问题。其先通过<strong>ball\r\nquery</strong>找到邻域，然后计算邻域每个点对中心点的matching\r\ncost，并且使用max\r\npooling进行邻域聚合。然而这种聚合的坏处就是会丢失一些运动信息。</p>\r\n<p>本文提出了一种 <strong>集合对集合</strong>的matching\r\ncost。这种从点对点到集合对集合的变化，有点像2003年Chui and\r\nRangarajan在传统点云匹配问题上的softmax到softassign\r\ncost的改变。具体对点<span class=\"math inline\">\\(p_t^j\\)</span>的matching\r\ncost定义如下：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\operatorname{CV}\\left(p_{t}^{j}\\right) &amp;=\\sum_{p_{t}^{k} \\in\r\nM\\left(p_{t}^{j}\\right)} \\omega_{M}\\left(p_{t}^{k}, p_{t}^{j}\\right) \\\\\r\n&amp; \\times \\sum_{p_{t-1}^{i} \\in N\\left(p_{t}^{k}\\right)}\r\n\\omega_{N}\\left(p_{t-1}^{i}, p_{t}^{k}\\right)\r\n\\operatorname{Cost}\\left(p_{t-1}^{i}, p_{t}^{k}\\right)\\\\\r\n\\omega_{M}\\left(p_{t}^{k},\r\np_{t}^{j}\\right)&amp;=\\operatorname{MLP}\\left(c_{t}^{k}-c_{t}^{j}\\right)\r\n\\\\\r\n\\omega_{N}\\left(p_{t-1}^{i},\r\np_{t}^{k}\\right)&amp;=\\operatorname{MLP}\\left(c_{t-1}^{i}-c_{t}^{k}\\right)\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>其中 <span class=\"math inline\">\\(M\\)</span> 为空间邻域，<span\r\nclass=\"math inline\">\\(N\\)</span>\r\n为时空邻域(即在t-1帧的空间邻域),可以通过ball-query和KNN得到。上式即对于点<span\r\nclass=\"math inline\">\\(p_t^j\\)</span>，先计算其空间邻域的特征差，然后对于空间邻域的每一个点，计算其时空邻域的特征差。两者累积相乘得到最终的cost\r\nvolume。</p>\r\n<p>下面来看cost volume怎么利用在Recurrent记忆元上。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/Ae1A1cz.png\" alt=\"RCV\" />\r\n<figcaption aria-hidden=\"true\">RCV</figcaption>\r\n</figure>\r\n<p>在RCV中，输入是当前帧的点坐标<span\r\nclass=\"math inline\">\\(C_t\\)</span>和特征<span\r\nclass=\"math inline\">\\(X_t\\)</span>。内部保留了<span\r\nclass=\"math inline\">\\(C_{t-1}\\)</span>来记录最近的点信息，同时利用两个隐状态<span\r\nclass=\"math inline\">\\(H_{t-1}\\)</span>和<span\r\nclass=\"math inline\">\\(M_{t-1}\\)</span>来作为记忆元存储。记忆元的更新方法如下：</p>\r\n<p><span class=\"math display\">\\[\r\n\\operatorname{CV}\\left(\\boldsymbol{P}_{t} ;\r\n\\boldsymbol{P}_{t-1}\\right)=\\operatorname{CV}\\left(\\boldsymbol{C}_{t},\r\n\\boldsymbol{X}_{t} ;\\boldsymbol{C}_{t-1},\\left\\{\\boldsymbol{H}_{t-1},\r\n\\boldsymbol{M}_{t-1}\\right\\}\\right)\r\n\\]</span></p>\r\n<p>即计算t帧点云内所有点关于t-1帧的cost\r\nvolume。其中t-1帧的特征用隐状态表示。</p>\r\n<p>定义了算子之后，接下来隐状态的更新和LSTM类似。<span\r\nclass=\"math inline\">\\(I\\)</span>，<span\r\nclass=\"math inline\">\\(F\\)</span>，<span\r\nclass=\"math inline\">\\(O\\)</span>分别为输入门，遗忘门，输出门。</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nI_{t} &amp;=\\sigma_{I}\\left(C V_{I}\\left(\\boldsymbol{C}_{t},\r\n\\boldsymbol{X}_{t} ; \\boldsymbol{C}_{t-1},\r\n\\boldsymbol{H}_{t-1}\\right),\\right.\\\\\r\nF_{t} &amp;=\\sigma_{F}\\left(C V_{F}\\left(\\boldsymbol{C}_{t},\r\n\\boldsymbol{X}_{t} ; \\boldsymbol{C}_{t-1},\r\n\\boldsymbol{H}_{t-1}\\right),\\right.\\\\\r\nO_{t} &amp;=\\sigma_{O}\\left(C V_{O}\\left(\\boldsymbol{C}_{t},\r\n\\boldsymbol{X}_{t} ; \\boldsymbol{C}_{t-1},\r\n\\boldsymbol{H}_{t-1}\\right)\\right.\\\\\r\n\\hat{\\boldsymbol{M}}_{t-1} &amp;=C V_{M}\\left(\\boldsymbol{C}_{t}, \\text\r\n{ None } ; \\boldsymbol{C}_{t-1}, \\boldsymbol{M}_{t-1}\\right), \\\\\r\n\\hat{\\boldsymbol{H}}_{t} &amp;=\\tanh \\left(C\r\nV_{H}\\left(\\boldsymbol{C}_{t}, \\boldsymbol{X}_{t} ;\r\n\\boldsymbol{C}_{t-1}, \\boldsymbol{H}_{t-1}\\right)\\right), \\\\\r\n\\boldsymbol{M}_{t} &amp;=F_{t} \\odot \\hat{\\boldsymbol{M}}_{t-1}+I_{t}\r\n\\odot \\hat{\\boldsymbol{H}}_{t}, \\\\\r\n\\boldsymbol{H}_{t} &amp;=O_{t} \\odot \\boldsymbol{M}_{t},\r\n\\end{aligned}\r\n\\]</span></p>\r\n","categories":["深度学习"],"tags":["深度学习","点云"]},{"title":"《SexEducation 2》观后感","url":"/2021/05/07/SexEducation%E8%A7%82%E5%90%8E%E6%84%9F/","content":"<h2 id=\"爱恨分明的各路人色剧透吐槽\">爱恨分明的各路人色（剧透吐槽）</h2>\r\n<h3\r\nid=\"亚当可能是感觉转变最细腻的一个角色了\">亚当，可能是感觉转变最细腻的一个角色了</h3>\r\n<p>从一个整天面无表情的四肢发达头脑简单的霸凌大块头，逐渐展露出内心对自己取向的拒绝，被冷漠的父亲养成的外壳式自我坚强，高大的身体里好像一个弱小委屈的小男孩在迷茫地用最原始的粗暴探寻自己的道路。最后到面对自己面对外界，当着全校学生和家长的面，牵起埃里克的手，甚至开始温温柔柔地像邻家大男孩。</p>\r\n<p>最后在埃里克家长面前收获真爱并且被家长夸赞，嘴角第一次弧度上扬，可爱。当然埃里克说的其实也很有道理，欺凌了那么久，给埃里克造成了那么久的打击，别人不原谅他不和他做朋友是理所应当的，不过和梅芙一开始不原谅母亲不同，他勇敢地面对了自己的一切，努力地转变着自己的行为，最后大家都可以选择原谅和不原谅，都是合情合理的。</p>\r\n<p>相反梅芙妈那边就不一样了，明明没啥改变还指责别人不原谅自己？不原谅是人家的合情合理。更何况不值得原谅。</p>\r\n<span id=\"more\"></span>\r\n<h3\r\nid=\"虽然大块头小男孩亚当很讨喜但是rahim出场的还是很可悲以及值得惋惜\">虽然大块头小男孩亚当很讨喜，但是Rahim出场的还是很可悲以及值得惋惜。</h3>\r\n<p>和亚当的拒绝后反转不同，Rahim从第二季开头上线开始，就是很直爽潇洒地承认自己对Eric的感情，勇敢的和他在一起，帮助他突破在公众环境下gay的身份认知，愿意陪他干所有事，可惜和Eric脑波对不上，不喜欢他的音乐剧爱好，get不到他的笑点，虽然这里亚当能get到就很剧情刻意。最后还要被Eric无情抛弃。虽然主角视角里Eric是终于面对了真爱，但Rahim这里他只是勇敢恋爱了然后爱人还有旧情未断甚至抛弃了他罢了。一个可怜的酷酷角色。</p>\r\n<h3\r\nid=\"说实话第二季梅芙的周围人都让人讨厌\">说实话，第二季梅芙的周围人都让人讨厌。</h3>\r\n<h3 id=\"首先是不请自来的母亲\">首先是不请自来的母亲</h3>\r\n<p><strong>十几年抛弃女儿毫无音讯，结果最后无路可去想回就回？回就算了，还好像对方不原谅你还是对方的错一样？</strong></p>\r\n<p>明明是自己抛弃了女儿多少年，把自己的错误一笔带过，还轻飘飘不可思议地质疑梅芙为什么不能原谅？请你先尊重认识一下自己的罪孽。一句轻飘飘的对不起不过是给自己原谅自己的借口，然后还可以谴责对方，“不过是一次错误为什么要这么对我”。？凭什么被伤害的人还要被你指点原谅。真想道歉请真心地用尽一切办法挽回对方。别人不原谅别人当然有权利不原谅，这时候你就恼羞成怒指责对方？这是来道歉的？这是倚老卖老来仗势说教的。</p>\r\n<p>另外被举报的时候，她哪来的道德高点和底气说“Never”。？你抛弃女儿十几年的时候你不觉得对方更应该“Never”？</p>\r\n<p>婴儿要被社区照顾的时候很心痛很憎恨的样子？还央求不带走你的孩子？孩子在家你照顾过她？盆栽枯死，婴儿衣服从来不洗，把婴儿丢给邻居女儿照顾，自己假装出门然后跑回家轻轻松松看电视？婴儿用来满足占有欲罢了。</p>\r\n<p>当然被举报也有一线机会洗白，那就是以撒的那个证据是错的，或者干脆就是陷害的。这样最后恼羞成怒，被误解的不甘“Never”是可以理解的。</p>\r\n<h3\r\nid=\"另外我很讨厌以撒这种人设以及他被对待的方式\">另外我很讨厌以撒这种人设，以及他被对待的方式</h3>\r\n<p>破坏梅芙旧爱是出自其私心无可厚非了，单从和梅芙相识开始就是欺人做坏事小人得意，圆滑捣乱的形象。这样居然还不会被讨厌，坏男孩真的是讨人喜欢吗。从我看来这种找茬的就很欠揍。</p>\r\n<p>故意丢书环节，第一次梅芙出于好意帮忙可以理解，当着面第二次丢书再要你捡，这真的不算是找茬骚扰吗？然后还得寸进尺，还要帮你推进去，还要帮你跳舞。正常人不早该踹一脚上去了。</p>\r\n<p>还非要跟着别人去没被邀请的Party，啊这，你撩妹可以好好撩，别搞得那么讨人厌不好吗。</p>\r\n<p>更绝的是梅芙一个酷酷的人还会不断妥协最后成为朋友，虽然梅芙的形象很明朗的是假装scary实际温柔。</p>\r\n<p><strong>与其说讨厌以撒的伪找茬式搭讪交友，不如说讨厌梅芙向这些无理取闹妥协温柔地过分。</strong></p>\r\n<p>之后也是一些手段阻止梅芙收获真正的幸福，用其他短评的话来说就是：以便和他一起待在深渊。</p>\r\n","categories":["生活"]},{"title":"SkeletonTransformer","url":"/2022/01/08/SkeletonTransformer/","content":"<ul>\r\n<li>Plizzari C, Cannici M, Matteucci M. Skeleton-based action\r\nrecognition via spatial and temporal transformer networks[J]. Computer\r\nVision and Image Understanding, 2021, 208: 103219.</li>\r\n<li>Politecnico di Torino 意大利都灵理工大学</li>\r\n<li>Q3</li>\r\n</ul>\r\n<h1 id=\"introduction\">Introduction</h1>\r\n<p>尽管ST-GCN的结构已经在骨架动作识别中广泛应用，但是仍然有一些结构上的缺陷。</p>\r\n<p>本文设计了Spatial Self-Attention (SSA)\r\n模块，用于在骨架之间动态的建立联系，而独立于人体真实骨架结构。另外在时间维度上设计了Temporal\r\nSelf-Attention (TSA)模块用于学习关节在时间上的变化。</p>\r\n<h1 id=\"spatialtemporal-transformer-st-tr\">Spatial–Temporal Transformer\r\n(ST-TR)</h1>\r\n<p>Self-Attention最初的灵感是希望对句子中单词进行跨越距离的相关性编码。因此本文希望同样的方式也可以应用到骨架节点上。</p>\r\n<p><strong>空间上</strong>：节点之间的相关性是很重要的，<strong>因此抛弃了任何预定义的骨架结构</strong>，让self-attention自动查找关节关系，类似于动态边的图卷积。</p>\r\n<p><strong>时间上</strong>：也希望通过self-attention查找出不同帧的关系。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/MYJ50cH.png\"\r\nalt=\"时空两个Self-Attention，两者都使用了多头注意力机制\" />\r\n<figcaption\r\naria-hidden=\"true\">时空两个Self-Attention，两者都使用了多头注意力机制</figcaption>\r\n</figure>\r\n<h2 id=\"spatial-self-attention-ssa\">Spatial Self-Attention (SSA)</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/7XzfJ4V.png\" alt=\"SSA\" />\r\n<figcaption aria-hidden=\"true\">SSA</figcaption>\r\n</figure>\r\n<p>类似于文本的self-Attention，抛开图结构，对关节点进行注意力计算。，最终输出这个关节点经过注意力编码的特征：</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathbf{z}_{i}^{t}=\\sum_{j}\r\n\\operatorname{softmax}_{j}\\left(\\frac{\\alpha_{i\r\nj}^{t}}{\\sqrt{d_{\\mathrm{k}}}}\\right) \\mathbf{v}_{j}^{t}\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/4eAkiFl.png\" alt=\"详细结构\" />\r\n<figcaption aria-hidden=\"true\">详细结构</figcaption>\r\n</figure>\r\n<h2 id=\"temporal-self-attention-tsa\">Temporal Self-Attention (TSA)</h2>\r\n<p>在时间计算中，每个关节点被视为独立的存在，去计算帧之间的注意力关联性：</p>\r\n<p><span class=\"math display\">\\[\r\n\\alpha_{t u}^{v}=\\mathbf{q}_{t}^{v} \\cdot \\mathbf{k}_{u}^{v} \\quad\r\n\\forall v \\in V, \\quad \\mathbf{z}_{t}^{v}=\\sum_{j}\r\n\\operatorname{softmax}_{u}\\left(\\frac{\\alpha_{t\r\nu}^{v}}{\\sqrt{d_{\\mathrm{k}}}}\\right) \\mathbf{v}_{u}^{v},\r\n\\]</span></p>\r\n<h2 id=\"two-stream-spatialtemporal-transformer-st-tr-network\">Two-Stream\r\nSpatial–Temporal Transformer (ST-TR) Network</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/MqxcnCa.png\" alt=\"ST-TR\" />\r\n<figcaption aria-hidden=\"true\">ST-TR</figcaption>\r\n</figure>\r\n<p>为了结合SSA和TSA模块，构造了一个 two-stream\r\narchitecture(ST-TR)。SSA和TSA分别独立在S-TR stream和 T-TR\r\nstream进行应用，然后再融合。(Shi et al. 2019)</p>\r\n<p>两个streams中都先应用了三层的残差网络对特征进行提取。S-TR中在空间上使用了GCN进行提取特征，T-TR中使用了标准的2D卷积(TCN,Yan\r\net al. 2018)。</p>\r\n<p>然后在后续的S-TR模块，T-TR模块(结构如上图)处理中分别用SSA和TSA来替换GCN和TCN。</p>\r\n<p>最后在经历一系列S-TR ,\r\nT-TR模块的处理后，通过累加起两个stream的softmax输出来获得最终的score。</p>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p>[1] Shi, L., Zhang, Y., Cheng, J., Lu, H., 2019b. Two-stream adaptive\r\ngraph convolutional networks for skeleton-based action recognition. In:\r\nProceedings of the IEEE Conference on Computer Vision and Pattern\r\nRecognition. pp. 12026–12035.</p>\r\n<p>[2] Shi, L., Zhang, Y., Cheng, J., Lu, H., 2019a. Skeleton-based\r\naction recognition with directed graph neural networks. In: Proceedings\r\nof the IEEE Conference on Computer Vision and Pattern Recognition. pp.\r\n7912–7921.</p>\r\n","categories":["深度学习"],"tags":["深度学习","点云","序列学习"]},{"title":"Swin Transformer","url":"/2022/03/30/Swin%20Transformer/","content":"<ul>\r\n<li>Liu Z, Lin Y, Cao Y, et al. Swin transformer: Hierarchical vision\r\ntransformer using shifted windows[C]//Proceedings of the IEEE/CVF\r\nInternational Conference on Computer Vision. 2021: 10012-10022.</li>\r\n<li>微软</li>\r\n</ul>\r\n<p>在视觉中做Transformer有两大问题，图片比起语言分辨率过高，以及图片中的目标尺度有大有小，变化很大。为了解决这两个问题，Swim\r\nTransformer一方面做了<strong>多分辨率的层级式结构</strong>，另一方面设计了\r\n<strong>shift of the window partition between consecutive self-attention\r\nlayers</strong>。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/Kojn8xQ.png\" alt=\"多分辨率层级结构\" />\r\n<figcaption aria-hidden=\"true\">多分辨率层级结构</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/inorpV4.png\"\r\nalt=\"shifted window：l+1层相对与l层，其子窗口划分进行了偏移。由于在新的一个子窗口内进行自注意力计算，会设计到上一级的多个窗口，因此提供了窗口的连接性。\" />\r\n<figcaption aria-hidden=\"true\">shifted\r\nwindow：l+1层相对与l层，其子窗口划分进行了偏移。由于在新的一个子窗口内进行自注意力计算，会设计到上一级的多个窗口，因此提供了窗口的连接性。</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h1 id=\"architecture\">Architecture</h1>\r\n<figure>\r\n<img src=\"https://i.imgur.com/42v5Q1S.png\"\r\nalt=\"(a)整体结构 (b)两个级联的注意力模块，W-MSA为常规window的多头注意力。SW-MSA为shifted window的多头注意力。\" />\r\n<figcaption aria-hidden=\"true\">(a)整体结构\r\n(b)两个级联的注意力模块，W-MSA为常规window的多头注意力。SW-MSA为shifted\r\nwindow的多头注意力。</figcaption>\r\n</figure>\r\n<p>整体管线思路很清晰：</p>\r\n<ol type=\"1\">\r\n<li>将图像划分为多个不重合的partition，每个partition视为一个词元token。</li>\r\n<li>Stage1：对词元进行基础的变换，linear\r\nembedding和self-attention。</li>\r\n<li>Stage2~4：每一个层对patch进行特征融合以及新的注意力计算。</li>\r\n</ol>\r\n<h1 id=\"shifted-window-based-self-attention\">Shifted Window based\r\nSelf-Attention</h1>\r\n<p>标准的Transformer和ViT都在构造全局的自注意力计算。然而这样的计算复杂度很高，导致很多高分辨率场景无法使用。</p>\r\n<p><strong>Self-attention in non-overlapped\r\nwindows</strong>：为了节省效率，Swim Transformer希望在local\r\nwindow中计算自注意力。每一个window包含多个patch（即window不是patch）。</p>\r\n<p><strong>Shifted window partitioning in successive\r\nblocks</strong>：上述的window方法通过局部计算减少了计算量，但另一方面导致不同window之间缺乏联系，而不像全局自注意力那样计算的是全局联系。因此采用了上图所示的shifted\r\nwindow方法。</p>\r\n<p>但是shifted\r\nwindow带来的一个问题是window数目会变多，且大小会不一致。一个朴素的解决办法即\r\n<strong>填充法</strong>，将不同大小的window都pad到同样的大小，并且在计算自注意力时mask掉pad的区域。但是这样明显的增加了计算量（window数目增多）。</p>\r\n<p>一种高效的方法是\r\n<strong>割补法</strong>：如图所示，将不同大小的非邻接window组合成原大小的window，这样即保留了跨window的计算连接性，还保证了同样的计算量。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/oUUAWxq.png\"\r\nalt=\"割补法：凑齐原大小的window\" />\r\n<figcaption aria-hidden=\"true\">割补法：凑齐原大小的window</figcaption>\r\n</figure>\r\n<h1 id=\"relative-position-bias\">relative position bias</h1>\r\n<p>对于自注意力的每个head，引入了相对位置编码<span\r\nclass=\"math inline\">\\(B \\in \\mathbb{R}^{M^2 \\times M^2}\\)</span>：</p>\r\n<p><span class=\"math display\">\\[\r\n\\operatorname{Attention}(Q, K, V)=\\operatorname{SoftMax}\\left(Q K^{T} /\r\n\\sqrt{d}+B\\right) V\r\n\\]</span></p>\r\n<p>其中<span class=\"math inline\">\\(Q,K,V \\in \\mathbb{R}^{M^2 \\times\r\nd}\\)</span>, <span\r\nclass=\"math inline\">\\(M^2\\)</span>为window的数目。由于在每个轴上\r\n<strong>相对位置</strong> 的变化范围是<span\r\nclass=\"math inline\">\\([-M+1,M-1]\\)</span>，即最大位置差为2M-1。因此其又构造了一个更小一点的子矩阵<span\r\nclass=\"math inline\">\\(\\hat{B} \\in \\mathbb{R}^{(2M-1) \\times\r\n(2M-1)}\\)</span>，用于存储每个位置差对应的值。而真正的<span\r\nclass=\"math inline\">\\(B\\)</span>中所有的取值，都可以从<span\r\nclass=\"math inline\">\\(\\hat{b}\\)</span>中拿到。</p>\r\n<p>位置编码可以带来<strong>significant improvements</strong></p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/ZnI1aMA.png\" alt=\"位置编码的消融学习\" />\r\n<figcaption aria-hidden=\"true\">位置编码的消融学习</figcaption>\r\n</figure>\r\n","categories":["深度学习"],"tags":["深度学习","点云"]},{"title":"UnityShader半透明物体问题","url":"/2022/05/22/UnityShader%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E9%81%AE%E6%8C%A1%E9%97%AE%E9%A2%98/","content":"<p>为了写一个半透明物体的shader，有以下几点基础要求：</p>\r\n<ol type=\"1\">\r\n<li>更近的不透明物体要挡住透明物体。因此透明物体<strong>需要深度测试</strong>来决定是否渲染。</li>\r\n<li>透明物体不能挡住透明物体。因此透明物体之间不能进行深度测试来剔除渲染，即透明物体<strong>不能写入深度</strong>。\r\n<img src=\"https://i.imgur.com/eRfC2Zz.png\"\r\nalt=\"开启深度写入，透明物体错误地挡住透明物体\" /></li>\r\n<li>既然不能写入深度，不透明物体与透明物体之间的渲染顺序就十分关键。如果更远的不透明物体晚一点渲染，其会不合理地挡住更近的透明物体(因为透明物体没有写入深度值)。因此需要<strong>分离渲染顺序队列</strong>。</li>\r\n<li>透明物体之间的顺序问题。当然Unity也知道顺序很关键，由于没有fragment-level的顺序信息，因此unity会对透明物体按object-level从远到近排序，再进行渲染。这通常没有问题，但是当两个透明物体的深度是交叉的时候就会产生错误。因此理想解决方案是<strong>顺序无关透明（order\r\nindependent transparency, OIT）</strong>，即逐像素排序。 <img\r\nsrc=\"https://i.imgur.com/rcWdI9Y.png\"\r\nalt=\"透明物体之间的渲染顺序错误。交叉地带应该由A覆盖B，实际上由于B的中心点更近，因此其所有fragment都在A之后渲染，导致B错误的覆盖A。\" /></li>\r\n</ol>\r\n<span id=\"more\"></span>\r\n<p>总之，一个寻常的半透明shader，通常要设置渲染队列，关闭深度写入，开启透明混合，如下所示：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SubShader</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Tags </span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        &quot;Queue&quot;=&quot;Transparent&quot; </span><br><span class=\"line\">        &quot;IgnoreProjector&quot;=&quot;True&quot; </span><br><span class=\"line\">        &quot;RenderType&quot;=&quot;Transparent&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Pass</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class=\"line\">        ZWrite Off //关闭深度写入</span><br><span class=\"line\">        Blend SrcAlpha OneMinusSrcAlpha //设置Blend模式</span><br><span class=\"line\"></span><br><span class=\"line\">        CGPROGRAM</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        ENDCG</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/8BLR7zs.png\"\r\nalt=\"寻常的透明效果。透明的knot中间包含了一个不透明的球\" />\r\n<figcaption\r\naria-hidden=\"true\">寻常的透明效果。透明的knot中间包含了一个不透明的球</figcaption>\r\n</figure>\r\n<p>效果如上图所示，然而其中依然存在着一些问题:</p>\r\n<ol type=\"1\">\r\n<li><strong>非凸网格的自我遮挡问题</strong>(同上第4点，即透明物体的fragment-level顺序问题)。由于我们对这个shader关闭了深度写入，因此knot上前后自遮挡的几个透明fragment会产生渲染顺序问题(注意这里不是背面和正面的顺序关系，遮挡的几个fragment都是knot的正面)。这里可以选择<strong>优化分割网格，使其成为不自遮挡的凸网格</strong>。</li>\r\n<li><strong>双面渲染问题</strong>，我们看不到透明物体的背面。因为Unity默认将背对摄像机的面剔除了。然而这是不合理的，哪有透明物体对自己反而不透明的道理。因此我们需要<strong>关闭背面剔除\r\nCull\r\nOff</strong>。而同时渲染背面和正面之后，又会回到<strong>自我穿插问题</strong>，即由于没有顺序关系，背面可能挡住正面。</li>\r\n</ol>\r\n<p>自我遮挡问题可以通过切分网格解决，但是更寻常的双面渲染问题还是需要shader进行解决。由于核心问题是让<strong>背面比正面更早渲染</strong>，因此可以使用两个Pass，前面的Pass\r\nCull Front渲染背面，后面的Pass Cull Back渲染正面。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SubShader</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Tags </span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        &quot;Queue&quot;=&quot;Transparent&quot; </span><br><span class=\"line\">        &quot;IgnoreProjector&quot;=&quot;True&quot; </span><br><span class=\"line\">        &quot;RenderType&quot;=&quot;Transparent&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    Pass</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Cull Front</span><br><span class=\"line\">        Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class=\"line\">        ZWrite Off //关闭深度写入</span><br><span class=\"line\">        Blend SrcAlpha OneMinusSrcAlpha //设置Blend模式</span><br><span class=\"line\">        CGPROGRAM</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        ENDCG</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Pass</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Cull Back</span><br><span class=\"line\">        Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class=\"line\">        ZWrite Off //关闭深度写入</span><br><span class=\"line\">        Blend SrcAlpha OneMinusSrcAlpha //设置Blend模式</span><br><span class=\"line\">        CGPROGRAM</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        ENDCG</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","categories":["基础"],"tags":["Unity","图形"]},{"title":"Unity优化基础","url":"/2023/05/14/Unity%E4%BC%98%E5%8C%96%E5%9F%BA%E7%A1%80/","content":"<h2 id=\"ugui\">UGUI</h2>\r\n<h3 id=\"动静分离\">动静分离</h3>\r\n<p>如果每个UI元素都独立一次drawcall的话，那显然会极大浪费渲染队列，因此UGUI在绘制UI时会将UI元素进行网格合并的操作，以减少DC一次绘制。</p>\r\n<p>合并的出发点没有问题，但因此只要任何一个UI元素一变，网格就需要重新绘制，这样节省下来的DC全用在合并顶点上了，因此就需要UI元素的动静分离。UGUI中以Canvas为合并网格的基础，因此我们需要尽可能把动态UI元素放在单独的Canvas中，把静止常态的UI放在另一个Canvas中。</p>\r\n<blockquote>\r\n<p>嵌套子Canvas也不会和父Canvas合并</p>\r\n</blockquote>\r\n<h3 id=\"重ui的分解\">重UI的分解</h3>\r\n<p>随着UI嵌套的越来越厚、越来越多，项目后期的一个UI对象可能会套着好几层UI面板，并且用的时候只显示某一个，隐藏其他的。因此虽然看起来没什么，但在对这个重UI实例化和销毁的时候会变得很慢，因此可以考虑把不必要的二级UI拆分成单独的对象，在需要时才实例化生成，而不是激活和隐藏。</p>\r\n<p>不管分不分解，加载这些对象的CPU时间都是需要的，但本质上我们把集中的大段CPU作业拆解成了多个小段，以降低卡顿。当然，也要注意如果拆分不当，导致小元素频繁实例化和销毁也会造成性能浪费。</p>\r\n<h3 id=\"加载优化\">加载优化</h3>\r\n<p>UI加载并实例化需要做完：加载GameObject对象、网格合并、组件初始化、素材资源加载等任务，并不算轻松。因此可以考虑在CPU缓和的情况下<strong>预加载</strong>UI：例如提前加载AB包素材。或者像上一节中对UI进行<strong>激活和隐藏处理</strong>，而不是生成和销毁。激活和隐藏不用再改变内存，但是组件的重新enable也会带来一定开销，因此再极端一点可以考虑直接把UI移出屏幕并且关闭部分更新，以形成隐藏。</p>\r\n<h3 id=\"字体拆分\">字体拆分</h3>\r\n<p>字体图集也是一项比较重的资源，而UI中如果同时有几种不同的字体，也会对内存造成一定负担。因此可以针对于特定使用场景，提取出特定词汇单独生成一个字体图集使用，比较常见的有登录场景字体、数值字体、常用字字体。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"ai寻路\">AI寻路</h2>\r\n<p>寻路算法中最经典的就是A星算法。虽然经典的最短路径算法有Dijkstra和Floyd，但是其复杂度分别是O(N<sup>2)和O(N</sup>3)，空间复杂度都是O(N^2)，因此根本不适合游戏这种大型路径搜索需求。并且更重要的一点是，游戏寻路根本不在乎是不是<strong>最短</strong>路径，只需要是一条能走通的路径就行，这就是A星算法的根本目标，其使用贪心算法寻找局部优解来寻路，平均时间复杂度为O(N\r\nlogN)。然而，A星的具体实现中还有很多细节可以优化。</p>\r\n<h3 id=\"大场景分割\">大场景分割</h3>\r\n<p>假如游戏场景很大，那么贪心搜索空间就会十分庞大，我们需要尽可能缩小搜索范围。回头想想，之所以我们要启用寻路算法，是因为出发点和目标点之间存在障碍物，不能直线到达。然而在大场景中，大部分路径是可以直接到达的，并不需要费劲寻路。</p>\r\n<p>因此，我们可以把大场景分割成数个内部无障碍的区域。在区域内部，可以直接直线寻路。在区域外部，则是一个区域与区域之间的固定寻路\r\n(从区域A到区域B，我们只需要提供一条固定路线即可)。而寻路既然已经不是动态的，那我们可以离线计算寻路路径，存储给实时使用，极大节省实时效率。</p>\r\n<blockquote>\r\n<p>当然，区域外部一旦发生改变，这些离线结果都需要重新计算。</p>\r\n</blockquote>\r\n<h3 id=\"堆存储openlist节点\">堆存储openlist节点</h3>\r\n<p>在贪心搜索局部最优解时，我们需要维护一个排序列表来方便获得最优节点\r\n(最小损失的节点)。我们要么在每次插入新openlist节点时有序插入，要么每次确定最优节点时先排一次序。排序本身就是一件很慢的<span\r\nclass=\"math inline\">\\(NlogN\\)</span>行为，因此不可能每次都排序。而如果是有序插入，例如二分查找插入点插入，那么需要<span\r\nclass=\"math inline\">\\(log N\\)</span>的查找时间以及<span\r\nclass=\"math inline\">\\(N\\)</span> 的数组移动时间。\r\n为了避开数组移动的麻烦，同时保持有序插入的便捷，我们可以使用<strong>最小堆/优先队列来维护openlist节点列表</strong>，这样我们只有<span\r\nclass=\"math inline\">\\(logN\\)</span>的插入时间，而不需要移动原数据。</p>\r\n<h3 id=\"openlist搜索规则优化-jps\"><a\r\nhref=\"https://www.guyuehome.com/35023\">openlist搜索规则优化 JPS</a></h3>\r\n<p>贪心的一个问题在于它是一步一个脚印去走的，因此即使是从(0,0)到(0,50)这样的直线路径，也会存储至少50个寻路节点，并且消耗50次插入时间，以及openlist空间包含这50个节点的所有邻居。那我们是不是能简化这种直线路径呢？</p>\r\n<p>跳点算法 Jump Point Search (JPS)\r\n框架上还是A星的框架，同样是搜索节点，加入openlist，从openlist中取出最优节点寻路。JPS主要改动在于它的搜索节点策略，它不像贪心一样每一步都将所有邻居加入openlist。JPS只在openlist记录那些关键的<strong>跳点</strong>节点，也就是直线的拐点，而对于平常的直线路径节点则不记录。</p>\r\n<figure>\r\n<img src=\"image.gif\" alt=\"贪心搜索\" />\r\n<figcaption aria-hidden=\"true\">贪心搜索</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"image2.gif\" alt=\"JPS搜索\" />\r\n<figcaption aria-hidden=\"true\">JPS搜索</figcaption>\r\n</figure>\r\n<p>JPS具体规则较为复杂，可以参考上文链接，这里简单概括下两个主要思路：</p>\r\n<p><strong>一，检查当前节点是否是跳点</strong>。简而言之，跳点就是发生拐弯的节点。那么什么时候会发生拐弯呢？如下图，我们从绿色父节点A出发，一路沿途检查节点是否为跳点\r\n(沿什么途则在后文)，经过若干次检查后，我们开始检查橙色节点B。我们首先知道B有一个邻居黄色节点C，且B和C中间有障碍物。此时我们检查A到C的最短路径，发现必须要经过B节点拐弯去C点，这时候B就是C的跳点，C就是B的强迫邻居(forced\r\nneighbor)，并且我们可以把B加入openlist。</p>\r\n<figure>\r\n<img src=\"image.png\"\r\nalt=\"Current是Parent到Forced Neighbor唯一最短路径的必经点，因此它是跳点。假如把黑色障碍去掉，那么Parent到黄色节点就有多条路径，就不存在跳点，也不存在Forced Neighbor。\" />\r\n<figcaption aria-hidden=\"true\">Current是Parent到Forced\r\nNeighbor唯一最短路径的必经点，因此它是跳点。假如把黑色障碍去掉，那么Parent到黄色节点就有多条路径，就不存在跳点，也不存在Forced\r\nNeighbor。</figcaption>\r\n</figure>\r\n<p>同样，假如A到跳点B中间本身就需要在D点拐一次弯(即A与B非直线可达，D与B直线可达)，那么D也是跳点。注意这里要求B是跳点，D才是跳点，要不然这个拐弯就没有意义了是不是。</p>\r\n<blockquote>\r\n<p>因此整个跳点检查有点类似于栈模式，先确定最后一个跳点，然后才能认为之前的拐点是跳点。</p>\r\n</blockquote>\r\n<figure>\r\n<img src=\"image-1.png\" alt=\"绿色到橙色需要在蓝色拐弯，蓝色则也是跳点\" />\r\n<figcaption\r\naria-hidden=\"true\">绿色到橙色需要在蓝色拐弯，蓝色则也是跳点</figcaption>\r\n</figure>\r\n<p><strong>二，往什么方向搜索跳点</strong>。现在我们知道了怎么检查一个点是否是跳点，但是去检查哪些点呢？由于JPS只关心直线走到尽头后的拐弯点，因此基本原则是先以直线方向一路检查是否为跳点，结束后再斜向进一步搜索内圈。具体细节则可另外搜索。</p>\r\n<figure>\r\n<img src=\"image-2.png\" alt=\"先直线搜索，不行再斜向进一步。\" />\r\n<figcaption\r\naria-hidden=\"true\">先直线搜索，不行再斜向进一步。</figcaption>\r\n</figure>\r\n","categories":["基础"],"tags":["unity"]},{"title":"网络编程基础 (Unity+C#)","url":"/2021/10/20/Unity%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/","content":"<h2 id=\"基础流程\">基础流程</h2>\r\n<p><strong>客户端流程</strong>:</p>\r\n<ol type=\"1\">\r\n<li>socket.Connect（远程IP地址，远程端口）</li>\r\n<li>socket.Send/BenginSend发送数据</li>\r\n<li>socket.Receive/BeginReceive接收服务端数据</li>\r\n<li>网络操作(如心跳协议)</li>\r\n<li>socket.Close关闭连接</li>\r\n</ol>\r\n<p><strong>服务器流程</strong>:</p>\r\n<ol type=\"1\">\r\n<li>listenfd.Bind（ipEp）将创建的空套接字listenfd绑定到IP+端口。</li>\r\n<li>listenfd.Listen（backlog）开启监听</li>\r\n<li>listenfd.Accept/BeginAccept接收客户端连接。Accept/EndAccept返回连接的Socket对象，对于服务器来说，它有一个监听Socket（listenfd）用来监听（Listen）和应答（Accept），对每个客户端的连接再创建一个专门的Socket（connfd）用来处理该客户端的数据。</li>\r\n<li>connfd.Receive/BeginReceive 接受数据</li>\r\n<li>网络操作(如心跳协议)</li>\r\n<li>socket.Close关闭连接</li>\r\n</ol>\r\n<span id=\"more\"></span>\r\n<h3 id=\"服务器处理socket阻塞\">服务器处理socket阻塞</h3>\r\n<p>由于服务器需要对接多个客户端，因此服务器不能在一个客户端处阻塞等待，而需要进行特殊的阻塞处理。</p>\r\n<p><strong>异步操作（性能最优）</strong>：使用Socket的异步API，把阻塞轮询交给内部。异步处理都由<code>BeginXXX</code>API进行异步等待开始，并且绑定一个回调函数<code>CustomCallback</code>，这样在异步响应时就会使用回调函数来进行处理。在回调函数内部，首先使用对应的<code>EndXXX</code>API来拿到响应数据，对数据处理完成后，可以在回调函数内再次调用<code>BeginXXX</code>，以串行开启新一轮的异步等待。代码示例如下：</p>\r\n<figure class=\"highlight cs\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Connect</span>(<span class=\"params\"><span class=\"built_in\">string</span> ip, <span class=\"built_in\">int</span> port</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"comment\">//进行连接准备操作</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"comment\">//使用Begin API来开启异步等待，并绑定回调函数ConnectCallback</span></span><br><span class=\"line\">    socket.BeginConnect(ip, port, ConnectCallback, socket);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Connect回调</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">ConnectCallback</span>(<span class=\"params\">IAsyncResult ar</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        Socket socket = (Socket) ar.AsyncState;</span><br><span class=\"line\">        <span class=\"comment\">//结束等待 收取响应数据</span></span><br><span class=\"line\">        socket.EndConnect(ar);</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"comment\">//进行一些数据处理操作</span></span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"comment\">//再次调用Begin，开启新一轮的异步等待</span></span><br><span class=\"line\">        socket.BeginReceive( readBuff.bytes, readBuff.writeIdx, </span><br><span class=\"line\">                                        readBuff.remain, <span class=\"number\">0</span>, ReceiveCallback, socket);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    catch (SocketException ex)&#123;</span><br><span class=\"line\">        Debug.Log(<span class=\"string\">&quot;Socket Connect fail &quot;</span> + ex.ToString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>C#和.NET中的异步IO使用了操作系统的IOCP (IO Completion Ports)\r\n线程池，从结果来看，程序异步等待的代价可以忽略不计。<a\r\nhref=\"https://stackoverflow.com/questions/42847851/on-windows-c-does-socket-beginreceive-take-a-background-thread-before-or-af\">参考</a></p>\r\n</blockquote>\r\n<p><strong>Poll和Select轮询</strong>：比起异步程序，同步程序更简单明了，而且不会引发线程问题。既然诸如Receive的Socket操作会阻塞，那为了避免阻塞，我们在正式的Socket操作之前可以先检查Socket状态，只有有效时才正式进入Socket的阻塞操作。而这就是<code>Poll</code>方法干的事:</p>\r\n<p><code>socket.Poll（int microSeconds，SelectMode mode）</code></p>\r\n<p>Poll会检查调用方socket的状态,\r\nmicroSeconds设置检查的阻塞时间，超时且状态无效则会返回fasle，以便跳过后续处理。<strong>Poll本质上就是轮询</strong>。相比于直接使用<code>socket.Receive</code>阻塞在一个socket上，使用poll可以不停地轮询所有的socket.但由于其本质上一直在循环查询，<strong>因此其CPU占用率会较高</strong>。</p>\r\n<p><strong>多路复用Select</strong>方法和Poll类似，其同时检测多个Socket，并返回通过检查的sockets。</p>\r\n<p><code>public static void Select(IList checkRead，IList check Write，IList checkError，int microSeconds)</code></p>\r\n<blockquote>\r\n<p>Poll/Select\r\n内部都是存储一个文件描述符fd集合来表示关注的sockets列表，然后通过操作系统去检查IO，并对应修改fd。回到用户程序时，程序则遍历检查修改后的fd集合，来检查哪些sockets完成IO，整个过程消耗O(n)时间。Poll和Select的区别在于存储fd集合的数据结构不同。</p>\r\n</blockquote>\r\n<p>linux中还有一种<strong>epoll</strong>的优化方法。从Poll/Select的函数调用可以看出，每次调用都会临时传入待检测的fd数据，而没有在内部持续保存。因此，一方面，epoll创建了一个内核中的红黑树来跟踪维护所有<code>epoll_ctl</code>注册的socket，避免重复的数据拷贝和内存管理。另一方面，epoll会维护一个就绪链表。当一个socket的IO事件触发时，就会把这个socket加入到就绪列表，这样在用户程序获取就绪socket时可以直接拿走链表数据，而不需要再去遍历检查所有socket。</p>\r\n<h2 id=\"消息通信\">消息通信</h2>\r\n<p>当socket连接建立完成后，就需要让C/S两端进行消息的通信。而为了针对不同的消息响应不同的功能，我们首先需要定义一下通信协议如<code>消息长度消息名称|参数1，参数2，...</code>，这样我们就可以通过字符串分割或序列化处理解析消息。</p>\r\n<p>不过实际上发送消息时<code>socket.Send</code>并没有真的发出网络包，而是写入到了操作系统的socket发送缓冲区中，而什么时候发送则由操作系统决定，而<code>socket.Receive</code>也只是从socket接受缓冲区中提取数据，<strong>这两者都不保证消息的完整传输</strong>，因此就会出现缓冲区的<strong>黏包半包问题</strong>：比如多条消息累积在缓冲区，被接收方一次性提取。又或者由于网络是分包传输的，接收方可能先收到部分消息，一段时间后再收到剩余消息。总而言之，我们需要确保消息传送的完整性，通常会对消息协议进行以下几种改造：</p>\r\n<ol type=\"1\">\r\n<li>附带长度信息，标识消息完整长度</li>\r\n<li>附带结束符号，标识消息的结束</li>\r\n<li>固定长度</li>\r\n</ol>\r\n<p>最终，附带长度信息后的<strong>发送消息</strong>格式如下：</p>\r\n<figure class=\"highlight cs\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">byte</span>[] bodyBytes = System.Text.Encoding.Default.GetBytes(sendStr);<span class=\"comment\">//将消息本体 &quot;消息名称|参数1，参数2，...&quot; 转为字节</span></span><br><span class=\"line\">Int16 len =(Int16)bodyBytes.Length;<span class=\"comment\">//利用2字节作为长度信息，以便检查消息的完整性。  </span></span><br><span class=\"line\"><span class=\"built_in\">byte</span>[] lenBytes = BitConverter.GetBytes(len);<span class=\"comment\">//将长度数据转为字节，内部根据大端小端设备分别转换</span></span><br><span class=\"line\"><span class=\"built_in\">byte</span>[] sendBytes = lenBytes.Concat(bodyBytes).ToArray();<span class=\"comment\">//拼接完整的发送数据</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>接收消息</strong>同样需要保证接收消息的完整性，因此可以先构造一个接收缓冲区存储<code>socket.Receive</code>的数据，并等待完整消息的到达。</p>\r\n<figure class=\"highlight cs\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">byte</span>[] readBuff = <span class=\"keyword\">new</span> <span class=\"built_in\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\"><span class=\"built_in\">int</span> buffCount = <span class=\"number\">0</span>;<span class=\"comment\">//已接收的字节，新收到的字节则在readBuff[buffCount]处开始写入。</span></span><br></pre></td></tr></table></figure>\r\n<p>有了缓冲区之后，接收放即可尝试在缓冲区里提取数据：</p>\r\n<ol type=\"1\">\r\n<li>缓冲区数据&lt;=2字节，连长度信息都不完整，等待。</li>\r\n<li>缓冲区数据&gt;2字节，读取头部2字节获取消息长度，接收字节&lt;消息长度，不完整，等待。</li>\r\n<li>缓冲区数据&gt;2字节，读取头部2字节获取消息长度，接收字节&gt;=消息长度：即存在一条完整消息。按长度取出该条数据，并挪动缓冲区：<code>Array.Copy(readBuff，msgStart，readBuff，0，count);</code></li>\r\n</ol>\r\n<blockquote>\r\n<p>但是数组移位是一个低效的办法，因此可以把缓冲数组做成循环数组,同时还可以考虑自动扩展等优化功能。</p>\r\n</blockquote>\r\n<h3 id=\"大端小端问题\">大端小端问题</h3>\r\n<p>完整的字节数据发送流程已经构建好了，但是字节数据本身还存在一些问题(虽然BitConverter已经给我们隐藏好了)。网络传输中我们一般习惯大端字节序，即一串字节数据中，高位在低地址：<code>A1=10*16+1*1</code>，这种模式更像我们平常阅读字符串的模式。然而，常见的x86、ARM处理器是小端字节序，即一串字节数据中，低位在低地址<code>A1=10*1+1*16</code>，这种模式更贴合内存读取的顺序。如果要手动解决两种模式的差异，可以在数据协议中规定好以一种模式为主，例如将所有字节数据都转换为小端存储。</p>\r\n<h3 id=\"发送不完整\">发送不完整</h3>\r\n<p>我们已经知道<code>socket.Send</code>只是把数据写入缓冲区，其同时有一个返回值，告诉我们写入了多少字节。这说明即使是写入缓冲区，<code>Send</code>也并不保证消息的完整写入，同样需要我们自行处理。</p>\r\n<p><strong>重复Send</strong>：容易想到发送不成功就多发送几次。如果待发送的字节数&gt;0，则再次调用Send，此时注意<code>Send</code>需要偏移已写入的字节数。</p>\r\n<p>但这种方法有个问题，就是需要保证多次写入的过程中，存储的消息不变。比如在第一次发送不完整，第二次Send还没开始，此时有异步的新消息写入了了缓冲区，那么旧消息的第二次写入就会存在偏移位置的错误。</p>\r\n<p><strong>发送消息队列</strong>：因此类似于接收缓冲区的思路，发送方也会创建一个发送消息队列。每次想要发送消息，则将消息入队(队列操作记得加锁)，并且另一方面从队列中取出头部元素进行重复Send。</p>\r\n<p>通过队列的存在，其把异步的消息流整合为了同步顺序的消息流，这样保证了每次只发送一条消息，不会被后续消息干扰。</p>\r\n<h2 id=\"同步\">同步</h2>\r\n<p>虽然已经实现了网络数据的传输，但由于传输中的延迟、丢包等问题，网络消息到达每一个客户端的时间并不统一、稳定，因此还需要额外的技术来保证客户端之间的同步。</p>\r\n<h3 id=\"状态同步\">状态同步</h3>\r\n<p>状态同步就是数据同步，客户端A定时向其他客户端广播自身数据同步，然后进行强行数据处理。这样的缺点在于<strong>延迟越大也就会造成越大的瞬移</strong>，因此观感很不友好。</p>\r\n<p>为了平滑瞬移的观感，显而易见我们可以使用插值的方法，也就是所谓的\r\n<strong>跟随算法</strong>：收到目标数据后，用一段时间去插值更新，而不是一步到位。这样虽然视觉上更平滑了，但由于插值更新必然是发生在收到同步数据之后，再花上一段时间去更新，那么必然和真实的客户端A数据存在较大的延迟和误差。</p>\r\n<p>因此为了节省插值时间，我们可以在收到同步数据之前就开始插值，即\r\n<strong>预测算法</strong>：在其他客户端本地保持客户端A的运动轨迹，自行本地预测，然后在同步数据到来时再进行跟随同步或者瞬移同步。这在稳定运动状态时效果很好，不过在不稳定的运动时容易导致回滚、闪回。示例代码如下：</p>\r\n<figure class=\"highlight cs\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//收到位置同步消息时，顺便计算出预测位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SyncPos</span>(<span class=\"params\">MsgSyncTank msg</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//同步位置</span></span><br><span class=\"line\">    Vector3 pos = <span class=\"keyword\">new</span> Vector3(msg.x, msg.y, msg.z);</span><br><span class=\"line\">    Vector3 rot = <span class=\"keyword\">new</span> Vector3(msg.ex, msg.ey, msg.ez);</span><br><span class=\"line\">    <span class=\"comment\">//计算匀速运动下的预测位置</span></span><br><span class=\"line\">    forecastPos = pos + <span class=\"number\">2</span>*(pos - lastPos);</span><br><span class=\"line\">    forecastRot = rot + <span class=\"number\">2</span>*(rot - lastRot);</span><br><span class=\"line\">    <span class=\"comment\">//跟随算法 强行同步</span></span><br><span class=\"line\">    <span class=\"comment\">// forecastPos = pos;  </span></span><br><span class=\"line\">    <span class=\"comment\">// forecastRot = rot;</span></span><br><span class=\"line\">    <span class=\"comment\">//更新</span></span><br><span class=\"line\">    lastPos = pos;</span><br><span class=\"line\">    lastRot = rot;</span><br><span class=\"line\">    <span class=\"comment\">//记录预测时的时间，以便后续插值</span></span><br><span class=\"line\">    forecastTime = Time.time;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//SyncPos计算出预测位置之后，update中插值移动到预测位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ForecastUpdate</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//插值时间</span></span><br><span class=\"line\">    <span class=\"built_in\">float</span> t = (Time.time - forecastTime) / CtrlTank.syncInterval;</span><br><span class=\"line\">    t = Mathf.Clamp(t, <span class=\"number\">0f</span>, <span class=\"number\">1f</span>);</span><br><span class=\"line\">    <span class=\"comment\">//插值位置</span></span><br><span class=\"line\">    Vector3 pos = transform.position;</span><br><span class=\"line\">    pos = Vector3.Lerp(pos, forecastPos, t);</span><br><span class=\"line\">    transform.position = pos;</span><br><span class=\"line\">    <span class=\"comment\">//插值旋转</span></span><br><span class=\"line\">    Quaternion quat = transform.rotation;</span><br><span class=\"line\">    Quaternion forcastQuat = Quaternion.Euler(forecastRot);</span><br><span class=\"line\">    quat = Quaternion.Lerp(quat, forcastQuat, t);</span><br><span class=\"line\">    transform.rotation = quat;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"帧同步\">帧同步</h3>\r\n<p>帧同步即指令同步、操作同步，把客户端A的指令发送给其他客户端，然后让其他客户端在本地执行指令完成同步模拟。相比于状态同步会因为同步数据的庞大而导致延迟、阻塞，帧同步的好处在于只需要发送指令，因此网络数据量很小，有助于缓解网络延迟。当然，如果只是简单的逐指令转发，那和普通的网络转发就没有什么区别了，会因为各客户端执行情况的不一样，造成严重的偏离。为了统一度量同步时间，这里引入了\r\n<strong>同步帧</strong> 的服务器时间概念，来度量诸如 \"客户端 A\r\n在第3同步帧发出向前指令，客户端 B 在第5同步帧收到指令\"\r\n这样的同步事件。以下\"帧\"都代表\"同步帧\"。</p>\r\n<p>统一度量衡后，我们就能知道是不是发生了指令执行情况的延迟问题。因此一种解决方案是<strong>快机等待慢机</strong>：A在第3帧发出指令后，自己并不执行。直到其他客户端在第5帧收到指令后，服务器才在第5帧告诉所有客户端开始执行。</p>\r\n<blockquote>\r\n<p>这样还可以利用投票法防止作弊，因为客户端严格一致，服务器可以收集客户端操作的结果来进行投票表决如\"是否击中\"的消息。</p>\r\n</blockquote>\r\n<h2 id=\"示例类图\">示例类图</h2>\r\n<h2 id=\"错误排除\">错误排除</h2>\r\n<blockquote>\r\n<p>在Unity中，只有主线程可以操作UI组件。由于异步回调是在其他线程执行的，不能直接操作unityUI组件。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>启动8888端口的服务器后，总发现有一个不知名本地端口会连接上来，然后出现消息解析错误。想了半天代码哪里有问题，结果使用netstat\r\n-aon|findstr \"8888\"排查后发现是迅雷的后台服务和这个端口冲突了...</p>\r\n</blockquote>\r\n<h2 id=\"参考资料\">参考资料</h2>\r\n<p><a\r\nhref=\"https://book.douban.com/subject/30432848/\">Unity3D网络游戏实战(第2版)</a></p>\r\n","categories":["基础"],"tags":["unity","网络","C#"]},{"title":"VMware-虚拟机繁忙卡死-vmware-vmx进程杀不掉-拒绝访问","url":"/2020/02/17/VMware-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B9%81%E5%BF%99%E5%8D%A1%E6%AD%BB-vmware-vmx%E8%BF%9B%E7%A8%8B%E6%9D%80%E4%B8%8D%E6%8E%89-%E6%8B%92%E7%BB%9D%E8%AE%BF%E9%97%AE/","content":"<h2 id=\"问题\">问题</h2>\r\n<p>前几天win10系统更新到了1909，打开VMware\r\n15.0.2时系统通知该版本可能无法运行=\r\n=没管它开了虚拟机，结果就是虚拟机黑屏卡死，vm工作台无法结束，后台vmware-vmx进程拒绝访问</p>\r\n<h2 id=\"解决步骤\">解决步骤</h2>\r\n<ol type=\"1\">\r\n<li><p>打开windows【服务】面板</p>\r\n<p>1.1 可以WIN+R 输入 services.msc 打开</p>\r\n<p>1.2 也可以在win10的搜索框中直接搜索 “服务”</p></li>\r\n<li><p>按【v】键，快速找到vmware相关服务，全部\r\n右键-属性-禁用，且停止运行。</p></li>\r\n<li><p>全部停止运行后，任务管理器已经可以关掉vm的主进程，但其实后台还有一个vmware-vmx没关掉，也关不掉。</p></li>\r\n<li><p>此时【重启】电脑，注意是重启，不是关机再开机，可以发现vmware-vmx已经没有了</p></li>\r\n<li><p>但和其他博客说的不同，此时恢复vmware相关服务，再开虚拟机一样是卡死，同样的问题。</p></li>\r\n<li><p>因此打开vmware的安装程序，准备修复，先别点下修复=\r\n=（文件夹里找，或者控制面板-卸载或更改程序里找）</p></li>\r\n<li><p>我修复运行的时候，提示无法写入文件glib-2.0.dll，vmPerfmon.dll，所以修复之前可以手动先删除这两个文件看看=\r\n=在vmware安装目录下面，假如无法删除可以把后缀名改为.txt，这样就不会阻碍vmware的修复程序。</p></li>\r\n<li><p>修复程序运行完成，打开vmware，提示你更新新版本，或者你自己选项里检查更新一下=\r\n=，换到新版本。当然你直接卸载下一个应该也是一样。</p></li>\r\n<li><p>我升级到15.5.1，重启之后可以正常运行，并且之前的虚拟机信息没有丢失。</p></li>\r\n</ol>\r\n<h2 id=\"总结\">总结</h2>\r\n<p>应该是win 1909 和\r\nvmware的15.0的版本冲突，看其他人说1903也有问题。总之要听信windows为数不多的劝告，换新版本吧=\r\n=</p>\r\n","categories":["工具"]},{"title":"VSCode 配置 Microsoft C++","url":"/2020/08/25/VSCode%E9%85%8D%E7%BD%AEMicrosoftCpp/","content":"<h2 id=\"前言\">前言</h2>\r\n<p>本文是我自己翻译 Microsoft 的 <a\r\nhref=\"https://code.visualstudio.com/docs/cpp/config-msvc\">英文原文</a></p>\r\n<p>因为自己刚学 C++的时候，直接是装的 Visual Studio 2017，一套 20G 的\r\nIDE 解决所有事情，但是用着用着发现了 Visual Studio Code\r\n这个极致现代美感的编辑器！再看 VS 那傻大粗的体量实在不想用。</p>\r\n<p>然而 VSCode 只是个编辑器，要用来写\r\nC++还需要配置相应的编译器环境。网上大部分配置教程都是从下一个 MinGW 出发\r\n... 然而我本身已经装过了 VS，Microsoft C++环境已经有了，想着能不能直接给\r\nVSCode 用。</p>\r\n<p>但是找了半天没发现什么有用的教程，最后在微软官方文档中找到了英文教程，虽然也不是很全面，但入门使用是够了的。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"预备环境\">预备环境</h2>\r\n<h3 id=\"安装-visual-studio-code\">安装 <a\r\nhref=\"https://code.visualstudio.com/download\">Visual Studio\r\nCode</a></h3>\r\n<p>希望代码业非代码业都能试试这个编辑器（笑</p>\r\n<p>无论敲 markdown 还是代码都很舒服。</p>\r\n<h3 id=\"安装-vscode-的-cc-扩展\">安装 <a\r\nhref=\"https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools\">VSCode\r\n的 C/C++ 扩展</a></h3>\r\n<p>如果已经安装好了 VSCode，可以直接在如下的扩展视图 (Ctrl+Shift+X)\r\n里搜索'C++'然后安装作者是 Microsoft 的即可。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/cpp/cpp-extension.png\"\r\nalt=\"扩展视图\" />\r\n<figcaption aria-hidden=\"true\">扩展视图</figcaption>\r\n</figure>\r\n<h3 id=\"安装-microsoft-visual-c-编译工具集\">安装 Microsoft Visual C++\r\n编译工具集</h3>\r\n<p>本身之前在 VS 写 C++的人已经安装好了，不用管。</p>\r\n<p>有 VS 的人可以直接在 VS Installer 中勾选 C++ 工具集进行安装即可。</p>\r\n<p>没有 VS 的人可以直接单独下载 Microsoft C++ 工具集，去 <a\r\nhref=\"https://visualstudio.microsoft.com/downloads#other\">下载页面</a>\r\n滚动到最底部，展开 All downloads 直到找到 <strong>Build Tools for Visual\r\nStudio</strong>，进行下载。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/build-tools-for-vs.png\"\r\nalt=\"下载 Build Tools\" />\r\n<figcaption aria-hidden=\"true\">下载 Build Tools</figcaption>\r\n</figure>\r\n<p>点击这个会运行 Visual Studio Installer， 然后会展示 Visual Studio\r\n可用的构建工具集，选中 C++的安装即可。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/cpp-build-tools.png\"\r\nalt=\"VS Installer 安装 C+=\" />\r\n<figcaption aria-hidden=\"true\">VS Installer 安装 C+=</figcaption>\r\n</figure>\r\n<h3 id=\"检查安装效果\">检查安装效果</h3>\r\n<p>为了从命令行或者 VSCode 中使用 MSVC，你必须以 <strong>VS\r\n开发人员提示符 (Developer Command Prompt for Visual Studio)</strong>\r\n为基础运行。常规的 Shell，例如 PowerShell，Bash，或者 Windows\r\n命令行都不具有必须的路径环境变量集。</p>\r\n<p>为了打开 VS 开发人员提示符，在 Windows\r\n开始菜单中搜索“开发人员”（安装的英文版请搜索\"developer\"），即可在搜索结果中打开。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/developer-cmd-prompt-menu.png\"\r\nalt=\"搜索“开发人员”\" />\r\n<figcaption aria-hidden=\"true\">搜索“开发人员”</figcaption>\r\n</figure>\r\n<p>你可以测试你是不是真的有了 C++\r\n编译器，<code>cl.exe</code>，在打开的提示符中输入\r\n'cl'，如果输出版权和版本信息，以及基础用法描述，则恭喜你安装正确。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/check-cl-exe.png\"\r\nalt=\"安装正确\" />\r\n<figcaption aria-hidden=\"true\">安装正确</figcaption>\r\n</figure>\r\n<p>在开始使用之前，如果提示符的初始路径是在构建工具集所在的位置，请将提示符中的当前目录切换到你想要的项目目录，毕竟你不会想要把程序写在那个疙瘩角落。</p>\r\n<h2 id=\"创建-hello-world\">创建 Hello World</h2>\r\n<p>请跟着下面的代码做，在提示符中，创造一个新文件夹\r\n“projects”，用于存储所有 VSCode\r\n项目，然后创建一个子文件夹名叫“helloworld”，并且用 VSCode\r\n打开这个子文件夹。</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir projects</span><br><span class=\"line\">cd projects</span><br><span class=\"line\">mkdir helloworld</span><br><span class=\"line\">cd helloworld</span><br><span class=\"line\">code .</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>注意这里个人推荐你使用纯英文路径。你永远不知道什么时候会挖一天一个月的中文路径\r\nBUG。</p>\r\n</blockquote>\r\n<p><code>code .</code>命令会用 VSCode\r\n打开当前目录，并且构建成“工作区（workspace）”，当你继续跟着教程走，最终会在这个工作区中创建一个<code>.vscode</code>文件夹，里面有文件如下：\r\n- tasks.json （编译指令） - launch.json （调试器设置） -\r\nc_cpp_properties.json （编译器路径及 智能感知 IntelliSense 设置）</p>\r\n<h3 id=\"添加一个源代码文件\">添加一个源代码文件</h3>\r\n<p>在 VSCode 资源管理器 (<code>Ctrl+Shift+E</code>)\r\n中，点击<strong>新建文件</strong>按钮，并且命名为<code>helloworld.cpp</code>。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/new-file-button.png\"\r\nalt=\"new file\" />\r\n<figcaption aria-hidden=\"true\">new file</figcaption>\r\n</figure>\r\n<p>打开新建的文件，粘贴如下代码：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    vector&lt;string&gt; msg &#123;<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;C++&quot;</span>, <span class=\"string\">&quot;World&quot;</span>, <span class=\"string\">&quot;from&quot;</span>, <span class=\"string\">&quot;VS Code&quot;</span>, <span class=\"string\">&quot;and the C++ extension!&quot;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> string&amp; word : msg)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; word &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>然后按下<code>Ctrl+S</code>保存文件。注意你可以看到刚添加的文件会在\r\nVSCode 的资源管理器中出现。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/file-explorer.png\"\r\nalt=\"出现文件\" />\r\n<figcaption aria-hidden=\"true\">出现文件</figcaption>\r\n</figure>\r\n<p>你也可以在上方菜单栏的<strong>文件</strong>菜单下，打开<strong>自动保存</strong>，以自动保存文件的修改。</p>\r\n<p>最左边的活动栏可以让你打开不同的视图，例如<strong>搜索</strong>，<strong>源代码管理</strong>，和<strong>运行</strong>。待会你会用到<strong>运行</strong>，其他的你可以在\r\nVSCode 的 <a\r\nhref=\"https://code.visualstudio.com/docs/getstarted/userinterface\">用户交互文档</a>\r\n中查阅相关信息。</p>\r\n<blockquote>\r\n<p>注意当你保存或打开一个 C++文件时，你可能可以看到一个来自\r\nC/C++扩展的关于测试版本的通知，这可以让你体验扩展的新特性。你可以点<code>X</code>无视它。</p>\r\n</blockquote>\r\n<h3 id=\"探索智能感知intellisense\">探索智能感知（IntelliSense）</h3>\r\n<p>在你新建的<code>helloworld.cpp</code>文件中，鼠标悬浮在<code>vector</code>或<code>string</code>上可以看到相应的类型信息。在<code>msg</code>的声明语句之后，敲入<code>msg.</code>以尝试调用一个成员函数。这是你会立刻看到一个语法补全列表，展示了所有的成员函数，并且还能看到一个有关<code>msg</code>类型信息的窗口。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/wsl/msg-intellisense.png\"\r\nalt=\"msg\" />\r\n<figcaption aria-hidden=\"true\">msg</figcaption>\r\n</figure>\r\n<p>你可以按下<code>Tab</code>直接插入选中的那一项。之后，当你输入小括号时，你可以看到有关函数参数的相关信息。</p>\r\n<h3 id=\"编译-helloworld.cpp\">编译 helloworld.cpp</h3>\r\n<p>接下来，你将创建一个<code>tasks.json</code>文件，以告诉 VSCode\r\n怎么去编译这个程序。这个编译配置（task）会唤醒 Microsoft C++\r\n编译器，编译这个源代码生成可执行文件。</p>\r\n<p>在主菜单中，点击 <strong>终端 &gt;\r\n配置默认生成任务</strong>，这会展示一系列预定义好的 C++\r\n编译器编译配置，选择<code>C/C++ cl.exe build active file</code>，这会在当前目录中生成一个<code>.vscode</code>子文件夹，并且在里面创建<code>tasks.json</code>文件。</p>\r\n<p>你新建的<code>tasks.json</code>文件应该长得和下面差不多：\r\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">&quot;version&quot;</span>: <span class=\"string\">&quot;2.0.0&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">&quot;tasks&quot;</span>: [</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;shell&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">&quot;label&quot;</span>: <span class=\"string\">&quot;C/C++: cl.exe build active file&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">&quot;command&quot;</span>: <span class=\"string\">&quot;cl.exe&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">&quot;args&quot;</span>: [</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">&quot;/Zi&quot;</span>,</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">&quot;/EHsc&quot;</span>,</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">&quot;/Fe:&quot;</span>,</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">&quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">&quot;$&#123;file&#125;&quot;</span></span><br><span class=\"line\">\t\t\t],</span><br><span class=\"line\">\t\t\t<span class=\"attr\">&quot;options&quot;</span>: &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">&quot;cwd&quot;</span>: <span class=\"string\">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">&quot;problemMatcher&quot;</span>: [</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">&quot;$msCompile&quot;</span></span><br><span class=\"line\">\t\t\t],</span><br><span class=\"line\">\t\t\t<span class=\"attr\">&quot;group&quot;</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">&quot;kind&quot;</span>: <span class=\"string\">&quot;build&quot;</span>,</span><br><span class=\"line\">                <span class=\"attr\">&quot;isDefault&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li><strong>command</strong> 指定了想要运行的程序是\"cl.exe\"</li>\r\n<li><strong>args</strong> 指定了 cl.exe\r\n的一系列命令行参数，这些参数必须按照编译器期望的顺序进行指定。</li>\r\n<li><strong>/Fe:</strong> 指定生成可执行文件的输出目录 这个配置告诉 C++\r\n编译器去找到<code>$&#123;file&#125;</code>文件，编译它，并且在当前目录<code>$&#123;fileDirname&#125;</code>下生成和源文件同名但扩展名是<code>.exe</code>的可执行文件<code>$&#123;fileBasenameNoExtension&#125;.exe</code>，在我们的例子中会得到<code>helloworld.exe</code>。</li>\r\n</ul>\r\n<blockquote>\r\n<p>你可以在 <a\r\nhref=\"https://code.visualstudio.com/docs/editor/variables-reference\">变量参考</a>\r\n中了解更多关于<code>tasks.json</code>的信息</p>\r\n</blockquote>\r\n<ul>\r\n<li>label\r\n的值是你在配置列表里看到的关于配置的描述，你可以随便乱改。</li>\r\n<li>problemMatcher 的值指定了用于查找错误或警告的输出解析器。对于 cl.exe\r\n，<code>$msCompile</code>是最好的选择。</li>\r\n<li>isDefault: true\r\n是指定了当你按下<code>Ctrl+Shift+B</code>时，会运行的配置。仅仅是图个方便而已。设为\r\nfalse 了一样可以从 <strong>终端 &gt; 运行生成任务</strong>中运行。</li>\r\n</ul>\r\n<h3 id=\"编译运行\">编译运行</h3>\r\n<ol type=\"1\">\r\n<li><p>返回<code>helloworld.cpp</code>页面。因为你想要编译<code>helloworld.cpp</code>，而你的配置会编译当前文件（the\r\nactive file）。</p></li>\r\n<li><p>按下<code>Ctrl+Shift+B</code>或者从 <strong>终端 &gt;\r\n运行生成任务</strong>中运行编译任务。</p></li>\r\n<li><p>编译开始后，你可以看到 VSCode\r\n的集成终端面板会出现在源代码编辑器的下方。在编译完成后，可以看到编译成功或者失败。假如成功，输出应该长这样（中文环境应该是如图的对应翻译）</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/build-output-in-terminal.png\"\r\nalt=\"successful output\" />\r\n<figcaption aria-hidden=\"true\">successful output</figcaption>\r\n</figure></li>\r\n<li><p>点击终端面板的<code>+</code>按钮创建一个新的终端。在里面输入运行<code>ls</code>，你可以看到<code>helloworld.exe</code>文件和一些\r\nC++ 中间文件已经生成了，并且还有 Debug\r\n相关文件（<code>helloworld.obj</code>,<code>helloworld.pbd</code>）</p></li>\r\n</ol>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/helloworld-in-terminal.png\"\r\nalt=\"ls\" />\r\n<figcaption aria-hidden=\"true\">ls</figcaption>\r\n</figure>\r\n<ol start=\"5\" type=\"1\">\r\n<li>你可以命令行输入<code>./helloworld.exe</code>运行文件。</li>\r\n</ol>\r\n<h3 id=\"修改-tasks.json\">修改 tasks.json</h3>\r\n<p>你可以用<code>$&#123;workspaceFolder&#125;\\\\*.cpp</code>代替<code>$&#123;file&#125;</code>，以同时编译多个\r\nC++ 文件。这回编译所有的当前目录下的\r\n<code>.cpp</code>文件。当然你也可以通过修改<code>$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe</code>，以替换输出文件的名字。</p>\r\n<h2 id=\"调试-helloworld.cpp\">调试 helloworld.cpp</h2>\r\n<p>接下来你会创建一个<code>launch.json</code>文件，以配置当你按下<code>F5</code>进行调试时，VSCode\r\n怎么去运行 Microsoft C++\r\n调试器。在主菜单中，点击<code>运行 &gt;  添加配置</code>，选择\r\n<strong>C++ （Windows）</strong>。</p>\r\n<p>接下来可以看到一个预定义的调试配置列表，选择\r\n<code>cl.exe build and debug active file</code>。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/build-and-debug-active-file.png\"\r\nalt=\"debug\" />\r\n<figcaption aria-hidden=\"true\">debug</figcaption>\r\n</figure>\r\n<p>这时 VSCode 会创建一个<code>launch.json</code>的文件如下：\r\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;</span>: <span class=\"string\">&quot;0.2.0&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;configurations&quot;</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;cl.exe build and debug active file&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;cppvsdbg&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;request&quot;</span>: <span class=\"string\">&quot;launch&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;program&quot;</span>: <span class=\"string\">&quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;args&quot;</span>: [],</span><br><span class=\"line\">      <span class=\"attr\">&quot;stopAtEntry&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;cwd&quot;</span>: <span class=\"string\">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;environment&quot;</span>: [],</span><br><span class=\"line\">      <span class=\"attr\">&quot;externalConsole&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;preLaunchTask&quot;</span>: <span class=\"string\">&quot;cl.exe build active file&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li>program\r\n指定了想要调试的程序，即当前目录下，和当前文件同基础名的<code>.exe</code>文件。</li>\r\n<li>stopAtEntry 默认为\r\nfalse，调试器不会事先添加任何断点。我们修改为<code>true</code>，则会在进入<code>main</code>函数时暂停并等待我们的调试。</li>\r\n</ul>\r\n<h3 id=\"开始调试\">开始调试</h3>\r\n<ol type=\"1\">\r\n<li><p>返回<code>helloworld.cpp</code>，这样它就是“当前文件”了。</p></li>\r\n<li><p>按<code>F5</code>或者点击<code>运行 &gt; 启动调试</code>。此时会有一些\r\nUI 界面的变化：</p></li>\r\n</ol>\r\n<ul>\r\n<li><p>集成终端会在底部出现，在\r\n<code>调试输出</code>标签下，你可以看到体现调试器正在运行的输出。</p></li>\r\n<li><p>在<code>main</code>函数的第一行编辑器会产生高亮。这是之前的修改导致的\r\nC++ 扩展预先帮我们打好的断点。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/stopAtEntry.png\"\r\nalt=\"main\" />\r\n<figcaption aria-hidden=\"true\">main</figcaption>\r\n</figure></li>\r\n<li><p>左边侧栏会出现<strong>运行</strong>视图</p></li>\r\n<li><p>编辑器上方会出现调试控制面板。你可以随便挪动。</p></li>\r\n</ul>\r\n<h3 id=\"逐步执行代码\">逐步执行代码</h3>\r\n<p>现在我们已经做好了逐步执行代码的准备。</p>\r\n<ol type=\"1\">\r\n<li><p>在调试控制面板点击<strong>单步跳过（F10）</strong>按钮，直到语句<code>for (const string&amp; word : msg)</code>高亮。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/cpp/step-over-button.png\"\r\nalt=\"Step Over\" />\r\n<figcaption aria-hidden=\"true\">Step Over</figcaption>\r\n</figure>\r\n<p><strong>单步跳过</strong>命令会跳过在<code>msg</code>变量创建并初始化时，所有<code>vector</code>和<code>string</code>类的内部函数调用。注意到左边<strong>变量</strong>窗口，此时看起来可能有点不对劲。虽然调试器已经能看到循环控制的变量名了，但此时当前语句还没有执行，因此读取不到变量值。另一方面，因为<code>msg</code>的语句执行完了，它的值是可以看到的。</p></li>\r\n<li><p>再按一下<strong>单步跳过</strong>以进入下一条语句（跳过了所有内部代码）。此时**变量*窗口可以看到循环变量的信息了。</p></li>\r\n<li><p>再按一下<strong>单步跳过</strong>以执行<code>cout</code>语句。<strong>注意</strong>如果是\r\n2019.3 的扩展版本，直到循环完成前是看不到任何输出的。</p></li>\r\n<li><p>你可以一直按下去直到所有输出结束。当然如果你想要更细致一点，试着点击<strong>单步调试（F11）</strong>,\r\n以逐步执行 C++ 标准库中的内部代码。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/msvc-system-header-stepping.png\"\r\nalt=\"incode\" />\r\n<figcaption aria-hidden=\"true\">incode</figcaption>\r\n</figure>\r\n<p>如果想要返回你自己的代码。可以一直按<strong>单步跳过</strong>直到返回。另外也可以切换到<code>helloworld.cpp</code>中在某个语句处按<code>F9</code>打一个断点，此时在左边会出现一个红点表明这一行已经打上了断点：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/cpp/breakpoint-in-main.png\"\r\nalt=\"breakpoint\" />\r\n<figcaption aria-hidden=\"true\">breakpoint</figcaption>\r\n</figure>\r\n<p>这时按下<code>F5</code>会自动执行到断点处再次暂停。再次在断点位置按<code>F9</code>也可以取消掉断点。</p></li>\r\n</ol>\r\n<h3 id=\"设置监视\">设置监视</h3>\r\n<p>调试时，有些时候我们想要盯着程序中某些变量进行观察。可以通过<strong>监视变量</strong>功能实现这一想法。</p>\r\n<ol type=\"1\">\r\n<li><p>在调试时，左侧的<strong>监视</strong>窗口，点击<code>+</code>按钮，即可创建一个新的监视对象，例如输入循环控制变量的名字<code>word</code>,此时监视窗口会一直显示这个变量的值。请在逐步执行循环时观察监视窗口的变化。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/cpp/watch-window.png\"\r\nalt=\"watch\" />\r\n<figcaption aria-hidden=\"true\">watch</figcaption>\r\n</figure></li>\r\n<li><p>同样的，假如修改程序，在循环语句前假如<code>int i=0;</code>，在循环内部假如<code>++i;</code>。此时我们可以和刚才一样添加对<code>i</code>的监视。</p></li>\r\n<li><p>为了在暂停时快速查看任何变量的值，我们也可以把鼠标指针悬浮在变量上，即显示变量值。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/cpp/mouse-hover.png\"\r\nalt=\"hover\" />\r\n<figcaption aria-hidden=\"true\">hover</figcaption>\r\n</figure></li>\r\n</ol>\r\n<h2 id=\"cc-配置\">C/C++ 配置</h2>\r\n<p>如果你想要更多关于 C/C++\r\n扩展的配置，你可以创建一个<code>c_cpp_properties.json</code>文件，在其中你可以修改编译器路径、编译C++标准等等。</p>\r\n<p>通过（Ctrl+Shift+P）打开命令面板，输入<code>C/C++: 编辑配置(UI)（ C/C++: Edit configurations(UI) ）</code>，你可以查看\r\nC/C++ 的UI配置界面。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/cpp/command-palette.png\"\r\nalt=\"C++ UI\" />\r\n<figcaption aria-hidden=\"true\">C++ UI</figcaption>\r\n</figure>\r\n<p>这会打开 <strong>C/C++ 配置页面</strong>\r\n，当你在这里进行修改，VSCode会把变动写进<code>.vscode</code>文件夹下的<code>c_cpp_properties.json</code>文件中。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://code.visualstudio.com/assets/docs/cpp/msvc/configurations-ui.png\"\r\nalt=\"C/C++\" />\r\n<figcaption aria-hidden=\"true\">C/C++</figcaption>\r\n</figure>\r\n<p>如果你直接打开json文件，可以看到长得如下：</p>\r\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;configurations&quot;</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;Win32&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;includePath&quot;</span>: [<span class=\"string\">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>],</span><br><span class=\"line\">      <span class=\"attr\">&quot;defines&quot;</span>: [<span class=\"string\">&quot;_DEBUG&quot;</span>, <span class=\"string\">&quot;UNICODE&quot;</span>, <span class=\"string\">&quot;_UNICODE&quot;</span>],</span><br><span class=\"line\">      <span class=\"attr\">&quot;windowsSdkVersion&quot;</span>: <span class=\"string\">&quot;10.0.18362.0&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;compilerPath&quot;</span>: <span class=\"string\">&quot;C:/Program Files (x86)/Microsoft Visual Studio/2019/BuildTools/VC/Tools/MSVC/14.24.28314/bin/Hostx64/x64/cl.exe&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;cStandard&quot;</span>: <span class=\"string\">&quot;c11&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;cppStandard&quot;</span>: <span class=\"string\">&quot;c++17&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;intelliSenseMode&quot;</span>: <span class=\"string\">&quot;msvc-x64&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;</span>: <span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>如果你的程序包含 不在当前目录或者不在标准库路径的\r\n头文件，则你只需要在这里添加<strong>IncludePath</strong>即可。</p>\r\n<h3 id=\"编译器路径\">编译器路径</h3>\r\n<p><code>compilerPath</code>编译器路径配置是十分重要的一项配置。扩展会利用它推断\r\nC++\r\n标准库头文件的路径。只有当扩展知道怎么去找这些文件了，它才能提供<strong>智能补全</strong>和<strong>找到定义</strong>的相关功能。</p>\r\n<p>C/C++\r\n扩展会尝试通过它在你系统上找到的默认编译器位置，自动填充<code>compilePath</code>。</p>\r\n<p>一般搜索路径和顺序如下： - 首先检查 Microsoft Visual C++ compilerOpe\r\n- 然后检查 Windows Subsystem for Linux (WSL) 的g++ - 之后是 Mingw-w64的\r\ng++</p>\r\n<p>如果你安装了 g++ 或者\r\nWSL，你可能需要更改<code>compilerPath</code>以匹配项目偏好的编译器。对于\r\nMicrosoft\r\nC++，编译器路径一般和下面差不多，但是根据特定安装版本不同而有差异：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:/Program Files (x86)/Microsoft Visual Studio/2017/BuildTools/VC/Tools/MSVC/14.16.27023/bin/Hostx64/x64/cl.exe</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>注意，你可能不是安装在默认C盘位置。找到你的VS安装位置，然后找里面的VC子目录即可。</p>\r\n</blockquote>\r\n<h2 id=\"复用-c-配置\">复用 C++ 配置</h2>\r\n<p>VSCode 现在已经配置好使用 Microsoft C++\r\n编译器了。这个配置目前仅对当前工作区生效。为了复用配置，请把<code>.vscode</code>中的JSON文件复制到新的项目文件夹中，并且按需修改相关源文件和可执行文件的名字。</p>\r\n<h2 id=\"错误排除\">错误排除</h2>\r\n<h3 id=\"无法识别cl.exe\">无法识别\"cl.exe\"</h3>\r\n<p>如果你看到：</p>\r\n<ul>\r\n<li>cl : 无法将“cl”项识别为\r\ncmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。</li>\r\n<li>The term 'cl.exe' is not recognized as the name of a cmdlet,\r\nfunction, script file, or operable program.</li>\r\n</ul>\r\n<p>这通常意味着你不是通过 <strong>VS开发人员命令提示符（Developer\r\nCommand Prompt for Visual Studio\r\n）</strong>打开的VSCode，因此VSCode不知道<code>cl.exe</code>编译器的路径。</p>\r\n<p>你总是可以通过在VSCode终端中输入<code>cl</code>检查有没有在开发人员提示符中打开VSCode。</p>\r\n<blockquote>\r\n<p>...这个官方解决方案和没说一样，可以自行配置全局Path系统变量。</p>\r\n</blockquote>\r\n<h2 id=\"更进一步\">更进一步</h2>\r\n<ul>\r\n<li><p>探索<a\r\nhref=\"https://code.visualstudio.com/docs/editor/codebasics\">VSCode\r\n用户指南</a></p></li>\r\n<li><p>复习<a\r\nhref=\"https://code.visualstudio.com/docs/languages/cpp\">C++\r\n扩展概述</a></p></li>\r\n<li><p>创建一个新的工作区，复制<code>.vscode</code>下的JSON文件过去，并且对设置进行适当的调整，开始你的代码生活！</p></li>\r\n</ul>\r\n","categories":["工具"],"tags":["cpp","VSCode"]},{"title":"Win10-cmd-PowerShell-SSH无法创建目录-和-SCP-找不到文件","url":"/2020/02/17/Win10-SSH%E9%94%99%E8%AF%AF/","content":"<h3 id=\"确定错误信息\">确定错误信息</h3>\r\n<p><strong>输入 SSH root@remotenode</strong></p>\r\n<blockquote>\r\n<p>输出: 无法创建目录 Could not create directory: C:\\123\\456\\789.ssh\r\n无法添加信任主机列表 Failed to add.....</p>\r\n</blockquote>\r\n<p>然而.ssh目录明明就在用户名文件夹下存在= =</p>\r\n<p>配置的免密登录远程主机也不能用</p>\r\n<p><strong>输入 scp ./test.txt root@remotenode:/root/test.win</strong>\r\n&gt;输出: 无法找到文件 : No Such File</p>\r\n<p>事实上这个文件存在</p>\r\n<h3 id=\"原因猜测-用户名带中文或特殊字符-导致路径无法识别\">原因猜测:\r\n用户名带中文或特殊字符, 导致路径无法识别</h3>\r\n<p>cmd和PowerShell 的编码都是GBK, 讲道理是可以用中文的...</p>\r\n<p>使用chcp 65001换成utf-8也不行</p>\r\n<p>当然也不可能重命名用户名文件夹..一大堆程序数据都在下面呢= =</p>\r\n<h3 id=\"可行方案\">可行方案 :</h3>\r\n<p><strong>1. 使用git bash 代替[cmd/PowerShel]</strong> 之前装git有装git\r\nbash. 并且git bash 里可以设置中文字符集,因此就试了一下,\r\n发现完全没有障碍= =</p>\r\n<p>环境什么的完全没变, 可以正常找到.ssh目录 , 可以正常写入 known_host\r\n,除了在第一次登的时候询问写入known_host, 之后免密登录也可以正常使用.</p>\r\n<p>scp可以正常发送用户名目录下的文件, 不会找不到.</p>\r\n<p>果然查遍全网也解决不了的问题是cmd自身的问题= =</p>\r\n<p><strong>2. 使用SSH工具,如Putty</strong> 使用Putty open登录主机,\r\n好像不会提示known_host 的事情, 但是可以顺利免密登录.</p>\r\n","categories":["工具"]},{"title":"git使用相关","url":"/2020/08/18/git%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%85%B3/","content":"<h1 id=\"奇怪的问题汇总\">奇怪的问题汇总</h1>\r\n<h2\r\nid=\"git连接github每次都需要输入账号密码\">git连接GitHub每次都需要输入账号密码</h2>\r\n<h3 id=\"背景\">背景</h3>\r\n<p>问题在于git clone\r\n的时候选择的链接是HTTPS的，因此在这个仓库中，git不会通过SSH密钥去进行免密认证。</p>\r\n<h3 id=\"解决方案\">解决方案</h3>\r\n<p>命令行输入<code>git config  -l</code></p>\r\n<p>可以看到一大堆信息，关注其中一条与链接相关的：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">remote.origin.url=https://...</span><br></pre></td></tr></table></figure>\r\n<p>我们需要url的https链接改回ssh即可。</p>\r\n<p>命令行输入 <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git config remote.origin.url git@github.com:你的仓库地址</span><br></pre></td></tr></table></figure></p>\r\n<p>试着<code>git push</code>一下=。=</p>\r\n<p><span id=\"more\"></span></p>\r\n<h2\r\nid=\"存在ssh密钥但访问github时permission-denied-publickey\">存在SSH密钥，但访问GitHub时Permission\r\ndenied (publickey)</h2>\r\n<h3 id=\"背景-1\">背景</h3>\r\n<p>在之前SSH默认路径下<code>C:/用户/xxx/.ssh</code>是存在id_rsa文件的。</p>\r\n<p>但我们命令行输入<code>ssh -vT git@github.com</code>，在identity\r\nfile开头，id_rsa结尾的行中 最后结尾是 -1 ,说明SSH找不到id_rsa。</p>\r\n<h3 id=\"解决办法\">解决办法</h3>\r\n<p>尝试重新生成SSH密钥，命令行输入</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -b 4096 -C &quot;你的邮箱“</span><br></pre></td></tr></table></figure>\r\n<p>在尝试生成时，命令行会提示一句请确认文件保存位置: <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Enter file in which to save the key (/c/WINDOWS/system32/config/systemprofile/.ssh/id_rsa):</span><br></pre></td></tr></table></figure></p>\r\n<p>注意那个默认位置...是的，这玩意把默认位置改了找不到原来的SSH文件了。憨憨</p>\r\n<p>复制原来的密钥文件过去即可。</p>\r\n<h3 id=\"参考资料\">参考资料</h3>\r\n<p><a\r\nhref=\"https://docs.github.com/cn/enterprise/2.19/user/github/authenticating-to-github/troubleshooting-ssh\">GitHub\r\nSSH故障排除文档</a></p>\r\n","categories":["工具"],"tags":["git"]},{"title":"pyqt安装找不到designer.exe问题","url":"/2021/03/31/pyqt%E5%AE%89%E8%A3%85%E6%89%BE%E4%B8%8D%E5%88%B0designer-exe%E9%97%AE%E9%A2%98/","content":"<blockquote>\r\n<p>又是一个被复制粘贴的脏教程坑的案例，此文献给从泥沼中求生的安装者。</p>\r\n</blockquote>\r\n<p>pip install pyqt5 pip install pyqt5-tools</p>\r\n<p>安装就这样，最好给个管理员权限。</p>\r\n<p><strong>designer所在目录<code>AppData\\Local\\Programs\\Python\\Python37\\Lib\\site-packages\\qt5_applications\\Qt\\bin</code></strong></p>\r\n<p>不是脏教程写的乱七八糟的什么在pyqt-tools下面，什么pyqt的QT下面，东抄西抄把过时的东西留到现代太烦了。</p>\r\n","tags":["python","pyqt"]},{"title":"ffmpeg常用命令","url":"/2021/10/12/ffmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"<h3 id=\"裁剪片段\">裁剪片段</h3>\r\n<p>ffmpeg -ss hh:mm:ss -i input.mp4 -t 60 -c copy output.mp4</p>\r\n<blockquote>\r\n<p>ffmpeg -ss 起始时间 -i 输入视频 -t 持续时间 -c copy 输出视频</p>\r\n</blockquote>\r\n<h3 id=\"转换格式包括音频\">转换格式（包括音频）</h3>\r\n<p>ffmpeg -i input.mp4 output.mp3</p>\r\n<h3 id=\"规格修改\">规格修改</h3>\r\n<p>转换分辨率 ffmpeg -i input.mp4 -filter:v scale=1280:720 -c:a copy\r\noutput.mp4 转换比特率 ffmpeg -i input.mp4 -b 5000K output.mp4</p>\r\n","categories":["工具"],"tags":["ffmpeg"]},{"title":"卷积神经网络CNN","url":"/2021/10/22/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN/","content":"<h1 id=\"cnn\">CNN</h1>\r\n<p>空间不变性： 检测对象和图像位置无关<br />\r\n局部性：先从局部区域特征做起，在高层再集成局部特征预测</p>\r\n<h2 id=\"从全连接层到卷积\">从全连接层到卷积</h2>\r\n<p><span class=\"math inline\">\\([\\mathbf{X}]_{i, j}\\)</span>和<span\r\nclass=\"math inline\">\\([\\mathbf{H}]_{i,\r\nj}\\)</span>分别表示输入图像和隐藏表示中位置<span\r\nclass=\"math inline\">\\((i,j)\\)</span>处的像素。且不妨使<span\r\nclass=\"math inline\">\\(k = i+a\\)</span>,<span\r\nclass=\"math inline\">\\(l=j+b\\)</span> <span class=\"math display\">\\[\r\n\\begin{split}\\begin{aligned} \\left[\\mathbf{H}\\right]_{i, j} &amp;=\r\n[\\mathbf{U}]_{i, j} + \\sum_k \\sum_l[\\mathsf{W}]_{i, j, k,\r\nl}  [\\mathbf{X}]_{k, l}\\\\ &amp;=  [\\mathbf{U}]_{i, j} +\r\n\\sum_a \\sum_b [\\mathsf{V}]_{i, j, a, b}  [\\mathbf{X}]_{i+a,\r\nj+b}.\\end{aligned}\\end{split}\r\n\\]</span></p>\r\n<h3 id=\"需要完成的目标\">需要完成的目标：</h3>\r\n<ol type=\"1\">\r\n<li><p><strong>平移不变形：</strong><span\r\nclass=\"math inline\">\\(\\mathsf{V}\\)</span>和<span\r\nclass=\"math inline\">\\(\\mathsf{U}\\)</span>实际上不依赖于<span\r\nclass=\"math inline\">\\((i,j)\\)</span>的值，即<span\r\nclass=\"math inline\">\\([\\mathsf{V}]_{i, j, a, b} = [\\mathbf{V}]_{a,\r\nb}\\)</span>。即卷积核不变，简化<span\r\nclass=\"math inline\">\\(\\mathsf{H}\\)</span>为：</p>\r\n<p><span class=\"math display\">\\[\r\n[\\mathbf{H}]_{i, j} = u + \\sum_a\\sum_b [\\mathbf{V}]_{a, b}\r\n[\\mathbf{X}]_{i+a, j+b}.\r\n\\]</span></p>\r\n<p>这就是<strong>卷积</strong>(准确来说卷积层是个错误的叫法，卷积层用到的其实是<strong>互相关运算\r\n(cross-correlation)</strong>，而不是卷积运算)，使用<span\r\nclass=\"math inline\">\\([\\mathbf{V}]_{a, b}\\)</span>对位置<span\r\nclass=\"math inline\">\\((i,j)\\)</span>附近的像素<span\r\nclass=\"math inline\">\\((i+a,j+b)\\)</span>进行加权得到<span\r\nclass=\"math inline\">\\([\\mathbf{H}]_{i, j}\\)</span></p></li>\r\n<li><p><strong>局部性：</strong> 即给<span\r\nclass=\"math inline\">\\(a,b\\)</span>一个范围限定，使其不要联系到很远的位置，得到<span\r\nclass=\"math inline\">\\([\\mathbf{H}]_{i.j}\\)</span>：<br />\r\n<span class=\"math display\">\\[\r\n[\\mathbf{H}]_{i, j} = u + \\sum_{a = -\\Delta}^{\\Delta} \\sum_{b =\r\n-\\Delta}^{\\Delta} [\\mathbf{V}]_{a, b}  [\\mathbf{X}]_{i+a, j+b}.\r\n\\]</span> 这就是卷积层，<span\r\nclass=\"math inline\">\\([\\mathbf{V}]\\)</span>即是卷积核</p></li>\r\n</ol>\r\n<h3 id=\"卷积数学定义\">卷积数学定义：</h3>\r\n<p>卷积是测量 f 和 g 之间（把其中一个函数“翻转”并移位 x\r\n时）的重叠。<br />\r\n&gt;注意这个翻转，实际上卷积层不使用翻转，是互相关运算</p>\r\n<p><span class=\"math display\">\\[\r\n(f * g)(\\mathbf{x}) = \\int f(\\mathbf{z}) g(\\mathbf{x}-\\mathbf{z})\r\nd\\mathbf{z}.\r\n\\]</span></p>\r\n<p>离散形式：</p>\r\n<p><span class=\"math display\">\\[\r\n(f * g)(i) = \\sum_a f(a) g(i-a).\r\n\\]</span></p>\r\n<h3 id=\"多通道\">多通道</h3>\r\n<p>图像往往包含三通道，即每个像素点还包括一个长度为3的数组，因此卷积操作也要扩展一个维度：</p>\r\n<p><span class=\"math display\">\\[\r\n[\\mathsf{H}]_{i,j,d} = \\sum_{a = -\\Delta}^{\\Delta} \\sum_{b =\r\n-\\Delta}^{\\Delta} \\sum_c [\\mathsf{V}]_{a, b, c, d} [\\mathsf{X}]_{i+a,\r\nj+b, c},\r\n\\]</span></p>\r\n<h3 id=\"多通道-1\">多通道</h3>\r\n<p>图像往往包含三通道，即每个像素点还包括一个长度为3的数组，因此卷积操作也要扩展一个维度：</p>\r\n<p><span class=\"math display\">\\[\r\n[\\mathsf{H}]_{i,j,d} = \\sum_{a = -\\Delta}^{\\Delta} \\sum_{b =\r\n-\\Delta}^{\\Delta} \\sum_c [\\mathsf{V}]_{a, b, c, d} [\\mathsf{X}]_{i+a,\r\nj+b, c},\r\n\\]</span></p>\r\n","categories":["深度学习"]},{"title":"七天上海狗狗攻略","url":"/2021/05/25/%E4%B8%83%E5%A4%A9%E4%B8%8A%E6%B5%B7%E7%8B%97%E7%8B%97%E6%94%BB%E7%95%A5/","content":"<h2 id=\"准备\">准备</h2>\r\n<p>必备：</p>\r\n<ul>\r\n<li>身份证，很多地方刷身份证拿门票。<br />\r\n</li>\r\n<li>口罩，路上随意，地铁景点必需。<br />\r\n</li>\r\n<li>随申码（上海的健康码），支付宝或微信提前注册好。</li>\r\n</ul>\r\n<p>注意：</p>\r\n<ul>\r\n<li>是否需要预约线上买票，疫情期间蛮多景点要的。<br />\r\n</li>\r\n<li>学生证，门票降价。<br />\r\n</li>\r\n<li>水，室内景点需要。<br />\r\n</li>\r\n<li>地铁，手机有NFC功能可以开通NFC上海地铁卡，刷手机就行。没有的话下一个metro大都会APP刷二维码。<br />\r\n</li>\r\n<li>充电宝，看手机情况。<br />\r\n</li>\r\n<li>考虑考虑现金硬币？公交轮渡小玩具可能需要投币。<br />\r\n</li>\r\n<li>下个单车APP，美团什么的。</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<h2 id=\"田子坊线\">田子坊线</h2>\r\n<p>7线东安路-&gt;9线打浦桥 10分钟<br />\r\n预估时长：下午+晚上</p>\r\n<h3 id=\"田子坊\">田子坊</h3>\r\n<blockquote>\r\n<p>全天候开放<br />\r\n预估时长：2~3小时<br />\r\n但是一些商家和工作室一般都在早上10点左右开门。最好不太早去。\r\n田子坊的小店有太多陡峭的狭窄楼梯，尽量避免穿高跟鞋和超短裙。</p>\r\n</blockquote>\r\n<p>很文艺的一个地方，各种小店，吃的喝的卖的，文艺店，艺术气氛，弄堂气息。钱可以不带，拍照设备请准备好。沿路都是小吃，不过很商业化，有些一点也不好吃。其中\r\n<strong>洛神花冻</strong>（网友强推👍），还有<strong>猫先生之家</strong>\r\n可以撸猫，甚至还有菜市场卖一些水果什么的。可以顺便买点菜回民宿了= =</p>\r\n<h3 id=\"琉璃艺术博物馆\">琉璃艺术博物馆</h3>\r\n<blockquote>\r\n<p>非周一 10：00~17:00（16:30停止入场） 门票30 预估时长：1~2小时</p>\r\n</blockquote>\r\n<p>田子坊7号门出来可以顺便看看琉璃艺术博物馆.<br />\r\n1楼是卖场，出售一些琉璃制品，2楼以上都是博物馆，展出世界艺术师的各种琉璃制品。</p>\r\n<figure>\r\n<img src=\"琉璃艺术博物馆.jpg\"\r\nalt=\"牡丹外墙：如果错过入馆时间，夜景也很不错\" />\r\n<figcaption\r\naria-hidden=\"true\">牡丹外墙：如果错过入馆时间，夜景也很不错</figcaption>\r\n</figure>\r\n<h3 id=\"可选日月光商场恋爱博物馆\">（可选）日月光商场/恋爱博物馆</h3>\r\n<blockquote>\r\n<p>预估时长：1小时+0.5小时<br />\r\n恋爱博物馆开放：10~21：30 门票68</p>\r\n</blockquote>\r\n<p>逛完景点旁边就是一个<strong>日月光商圈</strong>，可以找点好吃的走走消化消化。日月光中心泰康区五楼有一个\r\n<strong>恋爱博物馆</strong>，展出一些恋爱纪念品以及其背后的故事，为热恋的情侣做一个见证，可同时寄存一件物品及其意义。一年后同时持证才能拿走。</p>\r\n<h2 id=\"上海博物馆线\">上海博物馆线</h2>\r\n<p>7线东安路 -&gt; 1线人民广场 27分钟</p>\r\n<h3 id=\"上海博物馆\">上海博物馆</h3>\r\n<blockquote>\r\n<p>非周一 9~17（16停止入场）<br />\r\n预估时长：4~5小时 半天<br />\r\n实名制预约，免费，上海博物馆官网、微信公众号。每日限额8000人</p>\r\n</blockquote>\r\n<p>文物界“半壁江山”之誉，是一座大型的中国古代艺术博物馆。馆藏文物近百万件，以青铜器、陶瓷器、书法、绘画为特色。人很多，高峰需要排队一小时，建议早上或者中午进去。并且需要安检，别乱带东西。建议使用讲解辅助，上海博物馆APP即可，不用租实体导览器。</p>\r\n<p>中午去逛，晚上出来可以在<strong>人民广场</strong>看看夜景走一走。<br />\r\n上午去逛，下午可以走路去旁边<strong>上海当代艺术馆</strong> 、\r\n<strong>上海城市规划展示馆</strong> 看看。</p>\r\n<h3 id=\"可选上海当代艺术馆\">（可选）上海当代艺术馆</h3>\r\n<blockquote>\r\n<p>非周一 10~18（17停）<br />\r\n预估时长：1~2小时</p>\r\n</blockquote>\r\n<p>动态艺术展览，注意在网上看好当前展览项目。</p>\r\n<h3 id=\"可选上海城市规划展示馆\">（可选）上海城市规划展示馆</h3>\r\n<blockquote>\r\n<p>非周一 9~17 门票30<br />\r\n预估时长：1小时</p>\r\n</blockquote>\r\n<p>上海蓬勃发展的时代缩影，以1：500比例真实生动反映上海内环以内110平方公里核心城区的规划与现状。</p>\r\n<h2 id=\"武康路线旧法租界\">武康路线（旧法租界）</h2>\r\n<blockquote>\r\n<p>预估时长：1小时<br />\r\n7线东安路 -&gt; 常熟路 +步行1公里 20分钟</p>\r\n</blockquote>\r\n<p>散步拍照一条小街。\r\n比较有上世纪上海最繁华的时候的烙印，沿途很多有腔调的咖啡馆。西班牙式、法国文艺复兴式等风格的建筑极富特色，两旁的古树郁郁葱葱。</p>\r\n<p>晚上不会亮灯，光线不好风景不好，白天去。一条路，随便怎么走。<strong>武康大楼</strong>或<strong>巴金故居</strong>，从其中一个往另一个的方向走。</p>\r\n<figure>\r\n<img src=\"RosaGallica.jpg\" alt=\"旁边的Rosa Gallica花店\" />\r\n<figcaption aria-hidden=\"true\">旁边的Rosa Gallica花店</figcaption>\r\n</figure>\r\n<h2 id=\"甜爱路线\">甜爱路线</h2>\r\n<p>7线东安路 -&gt; 8线虹口足球场1号口 45分钟<br />\r\n预估时长：1~2小时</p>\r\n<h3 id=\"甜爱路\">甜爱路</h3>\r\n<blockquote>\r\n<p>预估时长：0.5小时+公园散步1小时</p>\r\n</blockquote>\r\n<p>一条很短的小路，墙上满是情话。留下爱的誓言和签名，在此合影留念。\r\n其实这条路很普通。但是普通带来的幽静，刚好适合情侣散步，有牵手的人一起走过就足够浪漫。</p>\r\n<p>另外请带好一封贴好邮票的情书，溧阳路1338号门卫处可以盖上“甜爱路\"以及“LOVE”的邮戳。</p>\r\n<p>旁边有<strong>鲁迅故居</strong>（非周一\r\n9~16）、<strong>鲁迅纪念馆</strong>（公园）。</p>\r\n<h3 id=\"老场坊\">1933老场坊</h3>\r\n<blockquote>\r\n<p>预估时长：1小时</p>\r\n</blockquote>\r\n<p>有些艺术工作室在里面，建议非周末去，周末人走楼空挺落寞的。<br />\r\n旧屠宰场改为的艺术工作室圈。<br />\r\n没什么特殊亮点，建筑结构比较艺术，适合拍照散步。</p>\r\n<h2 id=\"外滩线\">外滩线</h2>\r\n<p>4线外圈东安路-&gt;8线-&gt;10线豫园 1号口 30分钟<br />\r\n预估时长：下午+晚上</p>\r\n<h3 id=\"豫园\">豫园</h3>\r\n<blockquote>\r\n<p>非周一 9~16:30 （16停止入园）门票40<br />\r\n预估时长：1~2小时<br />\r\n疫情期间需预约，携程/美团./去哪儿/同程/驴妈妈。古典园林，设计精巧，环境清幽，亭台楼阁、假山、池塘样样俱全。园林没特别喜好的话去过一个就可以了，豫园在市中心比较方便。上海五大园林哪个近可以去哪个。建议使用语音讲解，感受园林设计内涵。</p>\r\n</blockquote>\r\n<h3 id=\"城隍庙\">城隍庙</h3>\r\n<blockquote>\r\n<p>小吃街全天候开放<br />\r\n预估时长：1小时</p>\r\n</blockquote>\r\n<p>夜晚金碧辉煌的商业化小吃街。在豫园对面，适合当豫园逛完的用餐点了。小吃街去过一个也就行了。</p>\r\n<p>南翔馒头店<br />\r\n鲜得来排骨<br />\r\n五芳斋点心<br />\r\n小绍兴的白斩鸡<br />\r\n......</p>\r\n<p>除开小吃街，也可以买票进寺庙，有财神殿和求姻缘之类的。（8: 30\r\n~16:30） 票价10</p>\r\n<h3 id=\"bfc外滩枫泾市集夜市\">BFC外滩枫泾（市集夜市）</h3>\r\n<blockquote>\r\n<p>周末 10~22</p>\r\n</blockquote>\r\n<p>大概是最嚣张最方便最豪华的夜市了。城隍庙吃完直接往江边走就是夜市区域，正好去逛逛夜市消化放松。</p>\r\n<h3 id=\"外滩\">外滩</h3>\r\n<blockquote>\r\n<p>预估时长：2~3小时</p>\r\n</blockquote>\r\n<p>晚上7点，资本闪耀起了它的辉煌。必须！晚上去！夜市逛完北上，沿江夜景走过去看看万国建筑景色。也可以地铁到南京东路，穿南京东路逛逛商业街到外滩中心。</p>\r\n<p><strong>浦江观光隧道</strong>不推荐，光管隧道而已，没有风景。</p>\r\n<p>来回走走，可以回到夜市那边去渡口坐交通渡轮去<strong>东方明珠</strong>那边，2元可以往返。（不是观光游轮）<br />\r\n&gt;外滩金陵东路码头 -&gt;\r\n浦东东昌路码头（距陆家嘴15分钟路）08：00~21:30 some minutes</p>\r\n<p>一直北上的话，如果白天时间还早可以去<strong>外滩美术馆</strong>逛逛</p>\r\n<h3 id=\"可选上海外滩美术馆\">（可选）上海外滩美术馆</h3>\r\n<blockquote>\r\n<p>周一关门 10:00~18：00</p>\r\n</blockquote>\r\n<p>有兴趣可以看看，2021.6是《帘幕》主题展。<br />\r\n一系列关于监控时代的批判性问题，试图釐清不同地域间的共生关係，从被忽略的视角出发，理解跨国交流的重要性。</p>\r\n<h3 id=\"东方明珠\">东方明珠</h3>\r\n<blockquote>\r\n<p>9~21 预估时长：1小时<br />\r\n需要【东方明珠】公众号预约买票，推荐双球票。200左右<br />\r\n东昌路渡口要走1.2公里过来</p>\r\n</blockquote>\r\n<p>想登高看城市夜景可以上去。几大高楼推荐东方明珠，靠江景色好且有城市情怀。不过也就只是用来看看夜景，上面没有其他的。</p>\r\n<p>第一颗球98m，商场娱乐项目。\r\n第二颗球263m，主要观光层。登高游览，晚上上去看外滩夜景还是不错。\r\n有空中旋转餐厅——捞钱用的，午餐170/人，晚餐200/人。\r\n第三颗球340m...体现分级感，也是捞钱用的。特别不推荐！</p>\r\n<p>上电梯要排挺久队，可以拿点宣传手册或者看看书玩玩手机游戏。电梯直达二球，然后可以选择上下。下来后一楼0m有一个<strong>上海历史发展陈列馆</strong>，记载上海历史变迁的感觉。顺便去逛逛就可。注意需要安检，别乱带东西。</p>\r\n<blockquote>\r\n<p>雨天大风天雾天别上..非全封闭，大风大雨会感觉很危险。雾天也看不到啥。</p>\r\n</blockquote>\r\n<h2 id=\"泰晤士小镇线\">泰晤士小镇线</h2>\r\n<p>地方很偏，晕车要死，通勤也会比较累。</p>\r\n<p>预估时长：半天</p>\r\n<h3 id=\"泰晤士小镇\">泰晤士小镇</h3>\r\n<blockquote>\r\n<p>全天候开放 预估时长：2小时左右，不喜欢走路可能0.5小时就想回去了。</p>\r\n</blockquote>\r\n<p>英伦风的安静街道，天气清爽的时候适合情侣来压马路，慢节奏的郊游之旅。风景很好，能进的建筑不多，钟书阁很出名，钟书阁对面有个prince\r\nstreet，运气好可以看见一只萨摩耶！</p>\r\n<h3 id=\"广富林遗址公园水下博物馆\">广富林遗址公园（水下博物馆）</h3>\r\n<blockquote>\r\n<p>预估时长：1小时<br />\r\n泰晤士小镇打车 14分钟</p>\r\n</blockquote>\r\n<p>略</p>\r\n<h3 id=\"上海影视乐园\">上海影视乐园</h3>\r\n<blockquote>\r\n<p>8:30~16:30 预估时长：1.5小时</p>\r\n</blockquote>\r\n<p>著名影视取景城(《功夫》《色戒》等)，老上海滩景色，可能能遇到拍片现场...然后被封路。</p>\r\n<h2 id=\"其他小景点\">其他小景点</h2>\r\n<h3 id=\"中华艺术宫\">中华艺术宫</h3>\r\n<blockquote>\r\n<p>非周一 10:00~18：00 预估时长：1小时<br />\r\n7线东安路 -&gt; 8线中华艺术宫 3号口 16分钟</p>\r\n</blockquote>\r\n<p>世博园仅剩下的中国馆，有点空旷东西不多，有超大动态清明上河图。附近有\r\n<strong>上海宋城</strong> 世博公园区。</p>\r\n<h3 id=\"上海宋城\">上海宋城</h3>\r\n<blockquote>\r\n<p>周一~周五 10~21 节假日9:30~21<br />\r\n预估时长：2小时<br />\r\n7线东安路 -&gt; 8线中华艺术宫 3号口 16分钟</p>\r\n</blockquote>\r\n<p>演艺公园，可能偏亲子。消费很高。评价两极分化，好评很多，但也据说非常一般。</p>\r\n<p>门票399最低，内还要单独消费，有换装区，数千套服装的换装体验，最低158/人。也很多演出剧场，如《上海千古情》。但一张票只能看一场。399一场...</p>\r\n<h3 id=\"m50创意园\">M50创意园</h3>\r\n<blockquote>\r\n<p>预估时长：1小时<br />\r\n7线-&gt;13线江宁路 1号口-&gt;步行1.2公里 35分钟</p>\r\n</blockquote>\r\n<p>艺术园区。类似1933老场坊。众多艺术工作室的园区。墙上以前有很多涂鸦很酷，但好像被拆的所剩无几，天气清凉可以走走。</p>\r\n<h3 id=\"圣依纳爵主教座堂\">圣依纳爵主教座堂</h3>\r\n<blockquote>\r\n<p>非周日9~16 周日 14~16<br />\r\n预估时长：0.5小时<br />\r\n在徐家汇游客服务中心取票免费参观</p>\r\n</blockquote>\r\n<p>徐家汇天主教大教堂，白天想散步消化可以过去看看，弥撒时间为平日的06:15和7:00，周六06:15,07:00，16:30，18:00。</p>\r\n<h3 id=\"安义夜市\">安义夜市</h3>\r\n<blockquote>\r\n<p>周五20：00~周日24:00<br />\r\n预估时长：0.5小时</p>\r\n</blockquote>\r\n<p>小吃散步热闹夜市</p>\r\n<h3 id=\"宜家宝山超大店\">宜家宝山超大店</h3>\r\n<blockquote>\r\n<p>预估时长：3小时，半天<br />\r\n7线-&gt;大场镇 30分钟</p>\r\n</blockquote>\r\n<p>超大，应有尽有。很多主题房间，家装完美示例，每个房间还有很多小细节小装饰，值得瞅瞅。</p>\r\n<h3 id=\"思南集市\">思南集市</h3>\r\n<blockquote>\r\n<p>预估时长：1小时<br />\r\n7线-&gt;9线 打浦桥-&gt; 步行1公里 30分钟</p>\r\n</blockquote>\r\n<p>有吃有玩有艺术展</p>\r\n","categories":["生活"]},{"title":"四元数与三维旋转","url":"/2022/05/13/%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E%E4%B8%89%E7%BB%B4%E6%97%8B%E8%BD%AC/","content":"<p>在三维空间中描述旋转是一件挺麻烦的事。常用的<strong>欧拉角</strong>虽然直观简单，但是存在<strong>顺序依赖</strong>和<strong>万向节死锁</strong>的问题，在通用的旋转运算上并不可行。进而引入的<strong>四维数</strong>虽然在运算上很有效，但是对于第一次见到的人来说一点也不算直观、易懂。</p>\r\n<p><a\r\nhref=\"https://krasjet.github.io/quaternion/\">Krasjet的文章</a>从二维复数出发，进而理解三维四元数的表示意义，循序渐进，通俗易懂，因此记录一下学习笔记。</p>\r\n<h1 id=\"复数与2d旋转\">复数与2D旋转</h1>\r\n<p>复数的定义和运算性质不再赘述。对于$ z = a + bi $，相当于对复数基底 $\r\n(1,i) $ 的线性组合，因此可以表示为一个列向量 <span\r\nclass=\"math inline\">\\(z=[a,b]^T\\)</span>，但更进一步，其实我们能把复数表示为矩阵。</p>\r\n<p>对于两个复数<span class=\"math inline\">\\(z_1 = a + bi , z_2=c +\r\ndi\\)</span>，可以得到观察一下其乘法结果：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nz_1z_2&amp;=a \\boldsymbol{c} -b \\boldsymbol{d} \\\\\r\n    &amp;+(b \\boldsymbol{c}+a \\boldsymbol{d})i \\\\\r\n    &amp;=\\left[\\begin{array}{cc}\r\n        a &amp; -b \\\\\r\n        b &amp; a\r\n        \\end{array}\\right]\\left[\\begin{array}{l}\r\n        c \\\\\r\n        d\r\n        \\end{array}\\right]\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>我们知道右边的<span class=\"math inline\">\\([c,d]^T\\)</span>是<span\r\nclass=\"math inline\">\\(z_2\\)</span>的列向量表示形式，而左边的矩阵，也只和<span\r\nclass=\"math inline\">\\(z_1\\)</span>的系数有关，因此也可以看做是<span\r\nclass=\"math inline\">\\(z_1=a+bi\\)</span>的矩阵表示。我们不妨尝试将两边都写成矩阵形式：</p>\r\n<p><span class=\"math display\">\\[\r\nz_1z_2=\\left[\\begin{array}{cc}\r\n        a &amp; -b \\\\\r\n        b &amp; a\r\n        \\end{array}\\right]\r\n        \\left[\\begin{array}{l}\r\n        c &amp; -d\\\\\r\n        d &amp; c\r\n        \\end{array}\\right]\r\n    =\\left[\\begin{array}{cc}\r\n        ac-bd &amp; -(bc+ad) \\\\\r\n        bc+ad &amp; ac-bd\r\n        \\end{array}\\right]\r\n    =ac-bd + (bc+ad)i\r\n\\]</span></p>\r\n<p>上式可以看出<span\r\nclass=\"math inline\">\\(z_1,z_2,z_1z_2\\)</span>在矩阵表示下也同样满足复数基本运算。这时我们可以发现一个神奇的现象：<strong>复数可以表示为矩阵，复数乘法可以表示为矩阵乘法</strong>，而矩阵乘法进而可以让我们联想到矩阵表示的仿射变换：</p>\r\n<p><span class=\"math display\">\\[\r\nz=\\left[\\begin{array}{cc}\r\n        a &amp; -b \\\\\r\n        b &amp; a\r\n        \\end{array}\\right]\r\n=\\sqrt{a^2+b^2}\r\n\\left[\\begin{array}{cc}\r\n        \\frac{a}{\\sqrt{a^2+b^2}} &amp; \\frac{-b}{\\sqrt{a^2+b^2}} \\\\\r\n        \\frac{b}{\\sqrt{a^2+b^2}} &amp; \\frac{a}{\\sqrt{a^2+b^2}}\r\n        \\end{array}\\right]\r\n\\]</span></p>\r\n<p>这种式子是不是很眼熟——即以a，b为边的三角变换式：</p>\r\n<p><span class=\"math display\">\\[\r\nz=\\sqrt{a^2+b^2}\\left[\\begin{array}{cc}\r\n        cos\\theta &amp; -sin\\theta \\\\\r\n        sin\\theta &amp; cos\\theta\r\n        \\end{array}\\right]\r\n=\\left[\\begin{array}{cc}\r\n        ||z|| &amp; 0 \\\\\r\n        0 &amp; ||z||\r\n        \\end{array}\\right]\r\n\\left[\\begin{array}{cc}\r\n        cos\\theta &amp; -sin\\theta \\\\\r\n        sin\\theta &amp; cos\\theta\r\n        \\end{array}\\right]\r\n\\]</span></p>\r\n<p>此时复数<span class=\"math inline\">\\(z=a+bi=||z||(cos\\theta+sin\\theta\r\ni)\\)</span>表示的二维变换水落石出，左边的矩阵是一个\r\n<strong>等比放缩矩阵</strong>，右边的矩阵是一个\r\n<strong>旋转矩阵</strong>。<strong>复数乘法，即是两个变换矩阵的作用。</strong></p>\r\n<p>并且再将复数的三角形式代回<span\r\nclass=\"math inline\">\\(z_1z_2\\)</span>可知，<span\r\nclass=\"math inline\">\\(z_1z_2=cos(\\theta+\\alpha)+sin(\\theta+\\alpha)\r\ni\\)</span> ，即复数的累乘，在变换上体现为旋转角度的累加<span\r\nclass=\"math inline\">\\(\\theta+\\alpha\\)</span>，以及缩放上的累乘。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"三维旋转\">三维旋转</h1>\r\n<p>三维旋转描述起来比二维旋转更弯弯绕绕一些，但其实理解起来也不难。</p>\r\n<p>要旋转<span class=\"math inline\">\\(\\theta\\)</span>角，三维向量<span\r\nclass=\"math inline\">\\(v\\)</span>首先得确定一个三维的旋转轴心<span\r\nclass=\"math inline\">\\(u\\)</span>，并且通过投影分解成<strong>垂直平面的二维旋转</strong>：</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(v\\)</span>和<span\r\nclass=\"math inline\">\\(u\\)</span>构成的平面<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>：在这个平面上不进行任何旋转，因为这个平面的旋转是<strong>靠近或远离<span\r\nclass=\"math inline\">\\(u\\)</span>的旋转</strong>，而这不符合我们以<span\r\nclass=\"math inline\">\\(u\\)</span>为旋转轴的初心。</li>\r\n<li>垂直于<span class=\"math inline\">\\(\\alpha\\)</span>的平面<span\r\nclass=\"math inline\">\\(\\beta\\)</span>：在这个平面上<strong>以<span\r\nclass=\"math inline\">\\(u\\)</span>为圆心旋转<span\r\nclass=\"math inline\">\\(\\theta\\)</span>角</strong>。</li>\r\n</ul>\r\n<p>因此简单计算可得任意轴旋转公式为：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nv^`&amp;=\\mathbf{v}_{\\|}+\\cos (\\theta) \\mathbf{v}_{\\perp}+\\sin\r\n(\\theta)\\left(\\mathbf{u} \\times \\mathbf{v}_{\\perp}\\right) \\\\\r\n&amp;=cos\\theta v + (1-cos\\theta)(uv)u + sin\\theta (u \\times v)\r\n\\end{aligned}\r\n\\]</span></p>\r\n<blockquote>\r\n<p><span class=\"math inline\">\\(v_{\\|}=cos\\theta v\\)</span>即<span\r\nclass=\"math inline\">\\(v\\)</span>在<span\r\nclass=\"math inline\">\\(u\\)</span>上的投影向量，其不参与旋转。后面一大串即垂直平面上<span\r\nclass=\"math inline\">\\(v_{\\perp}\\)</span>的二维旋转，具体推导细节可参考<a\r\nhref=\"https://krasjet.github.io/quaternion/\">Krasjet的文章第2节</a></p>\r\n</blockquote>\r\n<h1 id=\"四元数与三维旋转\">四元数与三维旋转</h1>\r\n<p>四元数基本性质：</p>\r\n<p><span class=\"math display\">\\[\r\nq=a+bi+cj+dk \\\\\r\ni^2=j^2=k^2=ijk=-1 \\\\\r\nij=k, jk=i, ki=j \\\\\r\nqq^{-1}=1\r\n\\]</span></p>\r\n<p>同样我们可以写成向量形式：<span\r\nclass=\"math inline\">\\(q=[a,b,c,d]^T\\)</span>。将实部和虚部分离，可以写为:</p>\r\n<p><span class=\"math display\">\\[\r\nq=\\left[\\begin{array}{cc}\r\n        a  \\\\\r\n        \\boldsymbol{u}\r\n        \\end{array}\\right]\r\n， (\\boldsymbol{u}=[x,y,z]^T)\r\n\\]</span></p>\r\n<p>那么我们可以找到四元数的矩阵形式吗？同样通过<span\r\nclass=\"math inline\">\\(q_1q_2\\)</span>来尝试一下：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nq_{1} q_{2}=&amp; a e+a f i+a g j+a h k+\\\\\r\n&amp; b e i-b f+b g k-b h j+\\\\\r\n&amp; c e j-c f k-c g+c h i+\\\\\r\n&amp; d e k+d f j-d g i-d h \\\\\r\n=&amp;(a e-b f-c g-d h)+\\\\\r\n&amp;(b e+a f-d g+c h) i+\\\\\r\n&amp;(c e+d f+a g-b h) j+\\\\\r\n&amp;(d e-c f+b g+a h) k \\\\\r\n=&amp;\\left[\\begin{array}{cccc}\r\n    a &amp; -b &amp; -c &amp; -d \\\\\r\n    b &amp; a &amp; -d &amp; c \\\\\r\n    c &amp; d &amp; a &amp; -b \\\\\r\n    d &amp; -c &amp; b &amp; a\r\n    \\end{array}\\right]\\left[\\begin{array}{l}\r\n    e \\\\\r\n    f \\\\\r\n    g \\\\\r\n    h\r\n    \\end{array}\\right]\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>可以发现<span\r\nclass=\"math inline\">\\(q_1\\)</span>表现为这样的矩阵对我们帮助不大。一方面由于四元数乘法不满足交换律，<span\r\nclass=\"math inline\">\\(q_1\\)</span>用来左乘和右乘时的矩阵并不一样。另一方面，这样的矩阵晦涩抽象，难以整理出相关三维联系。</p>\r\n<p>因此借鉴之前实部与虚部分离的整理方式，可以写出<span\r\nclass=\"math inline\">\\(q_1q_2=[a,\\boldsymbol{u}] \\cdot\r\n[e,\\boldsymbol{v}]\\)</span>简化版本：</p>\r\n<p><span class=\"math display\">\\[\r\nq_1q_2=[ae-\\boldsymbol u \\boldsymbol v, a\\boldsymbol v+e\\boldsymbol\r\nu+\\boldsymbol u \\times \\boldsymbol v] \\\\\r\n\\]</span></p>\r\n<blockquote>\r\n<p>从中可以推导出一个有用的共轭性质：<span\r\nclass=\"math inline\">\\(qq^*=[a,\\boldsymbol{u}][a,\\boldsymbol{-u}]=[a^2+\\|v\\|^2,0]\\)</span></p>\r\n</blockquote>\r\n<p>再回想<span\r\nclass=\"math inline\">\\(\\boldsymbol{v}\\)</span>的旋转公式，可以发现形式有点相似了：</p>\r\n<p><span class=\"math display\">\\[\r\nv^`=\\mathbf{v}_{\\|}+\\cos (\\theta) \\mathbf{v}_{\\perp}+\\sin\r\n(\\theta)\\left(\\mathbf{u} \\times \\mathbf{v}_{\\perp}\\right)\r\n\\]</span></p>\r\n<p>此时不如尝试用四元数替换掉旋转公式里的三维向量，令<span\r\nclass=\"math inline\">\\(\\dot v=[0,\\boldsymbol v],\\dot u=[0,\\boldsymbol\r\nu]，\\dot v_\\|,\\dot v_\\perp\\)</span>等同理。这样一来，旋转公式中<span\r\nclass=\"math inline\">\\(v_\\|,v_\\perp\\)</span>可以直接替换成四元数<span\r\nclass=\"math inline\">\\(\\dot v_\\|,\\dot v_\\perp\\)</span>，但是<span\r\nclass=\"math inline\">\\(\\mathbf{u} \\times\r\n\\mathbf{v}_{\\perp}\\)</span>还不行。</p>\r\n<blockquote>\r\n<p><span\r\nclass=\"math inline\">\\([0,v],[0,u]\\)</span>中的向量即三维空间中的旋转向量<span\r\nclass=\"math inline\">\\(v\\)</span>和旋转轴向量<span\r\nclass=\"math inline\">\\(u\\)</span>。</p>\r\n</blockquote>\r\n<p>再看四元数乘积公式<span class=\"math inline\">\\(q_1q_2=[ae-\\boldsymbol\r\nv \\boldsymbol u, a\\boldsymbol u+e\\boldsymbol v+\\boldsymbol v \\times\r\n\\boldsymbol u]\\)</span>，<span\r\nclass=\"math inline\">\\(a,e\\)</span>是两个四元数的实部，而在我们的替换中，所有的实部都为0，此时四元数乘积为<span\r\nclass=\"math inline\">\\(q_1q_2=[0,\\boldsymbol v \\times \\boldsymbol\r\nu]\\)</span>。因此我们可以用四元数<span class=\"math inline\">\\(\\dot u \\dot\r\nv_\\perp=[0,\\boldsymbol u \\times \\boldsymbol v_\\perp]\\)</span> 来替换\r\n<span class=\"math inline\">\\(\\mathbf{u} \\times\r\n\\mathbf{v}_{\\perp}\\)</span> 。</p>\r\n<p>至此，可以得到四元数版本的旋转公式：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\dot v^`&amp;=\\dot{\\mathbf{v}_{\\|}}+\\cos (\\theta)\r\n\\dot{\\mathbf{v}_{\\perp}}+\\sin (\\theta)\\left(\\dot u \\dot v_\\perp\\right)\r\n\\\\\r\n&amp;= \\dot{\\mathbf{v}_{\\|}}+(\\cos (\\theta) +\\sin (\\theta)\\dot u) \\dot\r\nv_\\perp \\\\\r\n&amp;= \\dot{\\mathbf{v}_{\\|}} + \\dot q \\dot v_\\perp, \\ \\ \\ \\ \\ which \\\r\n\\   \\dot q=[cos\\theta,0]+[0,sin\\theta u]=\\cos (\\theta) +\\sin\r\n(\\theta)\\dot u\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>最终，我们实现通过一个额外的四元数<span class=\"math inline\">\\(\\dot\r\nq=[\\cos (\\theta),\\sin (\\theta) \\boldsymbol{u}]\\)</span>，即可表示<span\r\nclass=\"math inline\">\\(v\\)</span>绕任意轴<span\r\nclass=\"math inline\">\\(u\\)</span>的旋转<span\r\nclass=\"math inline\">\\(\\theta\\)</span>角。反过来，给定一个四元数，我们也可以很轻易地从实部得到其代表的<strong>旋转角度<span\r\nclass=\"math inline\">\\(\\theta\\)</span></strong>，从虚部得到其代表的<strong>旋转轴<span\r\nclass=\"math inline\">\\(\\boldsymbol{u}\\)</span></strong>。</p>\r\n<blockquote>\r\n<p>代码小提示：可以发现，四元数的x,y,z,w属性并不直接代表旋转角度，因此不能在旋转时直接修改四元数的属性。当然，也不能先转成欧拉角——修改——再存回四元数，这样就失去了四元数的意义。通常，我们构造一个表示旋转变换的四元数，然后与原来的角度相乘，即可完成旋转。</p>\r\n</blockquote>\r\n<p>根据四元数运算可以将旋转 <strong><span\r\nclass=\"math inline\">\\(\\theta\\)</span></strong> 角进一步化简为：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\dot v^`&amp;=\\dot p \\dot v \\dot p^* ,  \\ \\ \\ which \\ \\ \\ \\ \\dot\r\np=[cos\\frac{\\theta}{2},sin\\frac{\\theta}{2} \\boldsymbol{u}] \\\\\r\n&amp;= [0, \\cos (\\theta) \\mathbf{v}+(1-\\cos (\\theta))(\\mathbf{u} \\cdot\r\n\\mathbf{v}) \\mathbf{u}+\\sin (\\theta)(\\mathbf{u} \\times \\mathbf{v})]\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>而这种表示形式下也可以很方便地进行旋转的复合：</p>\r\n<p><span class=\"math display\">\\[\r\nv^`=\\dot p_2 ( \\dot p_1 v \\dot p_1^* ) \\dot p_2^*\r\n\\]</span></p>\r\n<p>当然，在已知最终变换<span\r\nclass=\"math inline\">\\(p=p_2p_1\\)</span>和初始变换<span\r\nclass=\"math inline\">\\(p_1\\)</span>的情况下，我们可能要求解中间变换<span\r\nclass=\"math inline\">\\(p_2\\)</span>，此时：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\np_2p_1&amp;=p \\\\\r\np_2p_1p_1^{-1} &amp;=p p_1^{-1} \\\\\r\np_2 &amp;= pp_1^{-1} \\\\\r\np_2 &amp;=pp_1^*\r\n\\end{aligned}\r\n\\]</span></p>\r\n<blockquote>\r\n<p>默认所有变换向量都是单位向量，因此变换四元数都是单位四元数，有<span\r\nclass=\"math inline\">\\(p^{-1}=p^*\\)</span></p>\r\n</blockquote>\r\n<p>更进一步，多次求解中间变换即可实现高阶变换插值。</p>\r\n","categories":["基础"],"tags":["数学"]},{"title":"再见，狂野之心","url":"/2022/03/20/%E5%86%8D%E8%A7%81%EF%BC%8C%E7%8B%82%E9%87%8E%E4%B9%8B%E5%BF%83/","content":"<p>再见，狂野之心 Sayonara Wild Hearts</p>\r\n<h1\r\nid=\"极具视觉冲击和音画享受霓虹梦幻的非竞技音游\">极具视觉冲击和音画享受，霓虹梦幻的非竞技音游</h1>\r\n<h2 id=\"音游中最具有冲击力的唯美画面\">音游中最具有冲击力的唯美画面</h2>\r\n<p>场景维度大开大合，色彩很有霓虹绚丽的感觉，但是又没有让人不适的光污染。</p>\r\n<p>配合上音乐和速度的双重冲击，整个游戏氛围都让人疯狂。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.akamai.steamstatic.com/steam/apps/1122720/ss_03804e3335afd5edddceafe722ff1c4eb3c19931.jpg?t=1629747217\"\r\nalt=\"霓虹梦幻的画面\" />\r\n<figcaption aria-hidden=\"true\">霓虹梦幻的画面</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h2 id=\"玩法丰富多样\">玩法丰富多样</h2>\r\n<p>虽然主体都是收集躲避障碍式的音游，但这游戏愣是把流程做出了花...包括骑摩托车、踩滑板、斗舞、发射激光、挥舞利剑以及击破心脏寻找和声等各种元素。</p>\r\n<ul>\r\n<li>最基本的摩托模式，享受每小时200英里的速度感。</li>\r\n<li>最与众不同的2D电子模式，在一块类似于吃豆人的电子屏中享受慢节奏的冲击力。</li>\r\n<li>...</li>\r\n<li>还有四五场精彩的BOSS战，每个BOSS都有完全不同的攻击方式和画面效果，有让毁天灭地世界崩坏的，有双子变换空间的(类似titanfall2？)，有机甲式的（像蓝毒兽？？）...每一场BOSS战都是音乐与画面的淋漓尽致。</li>\r\n</ul>\r\n<h2 id=\"梦幻迷离的音乐\">梦幻迷离的音乐</h2>\r\n<p>激情温柔，疯狂又忧伤，梦幻迷离的电子声，就像游戏名的感觉一样：\r\n再见，狂野之心。</p>\r\n<p>别的不说，我先买OST为敬。（哦qq音乐有专辑...不用买了</p>\r\n<h2 id=\"缺点\">缺点</h2>\r\n<p><strong>流程过短</strong>...我时不时暂停聊天地玩，全通关也就100分钟。而且大部分关卡只有1~2分钟的流程，甚至让人觉得音乐都没来得及放完就结束了。只有BOSS战才能带来完整的3~4分钟的完整享受。</p>\r\n<blockquote>\r\n<p>当然如果想刷全满分的话，能玩一个月吧大概...</p>\r\n</blockquote>\r\n<p>难度曲线不友好，想要通关是挺容易的，死亡没有惩罚可以从自动存档点继续，即使分再低过了也就是过了，没有任何影响。但是想要追求高分的话，由于场景速度很快，并且场景整体色调和收集品没有特别大，你很难在场景空间高速迭代的过程中即时做出反应，只能通过背板预判应该走哪里。并且combo也不影响音乐节奏，并不是很需要追求分数。</p>\r\n<p>这个游戏重点还是在<strong>音乐和画面的交叉冲击中，给你带来音画沉浸的两小时，并不建议当成一个挑战性的音游</strong>。</p>\r\n<p><strong>愿你享受迷离</strong>。</p>\r\n","categories":["生活"],"tags":["游戏"]},{"title":"学习的旅程","url":"/2022/04/04/%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%97%85%E7%A8%8B/","content":"<p>看到几篇很棒的博客，<a\r\nhref=\"http://mindhacks.cn/2008/09/17/learning-habits-part3/\">如何阅读——刘未鹏</a>，<a\r\nhref=\"http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/\">怎样花两年时间去面试一个人</a>，想要从中汲取一些知识，并且记录一些自己的思绪。</p>\r\n<h1 id=\"学习的方向\">学习的方向</h1>\r\n<p>其实现在的在校生根本不缺学习的动力(特别是<strong>计算机</strong>，特别是<strong>研究生</strong>)，毕竟现在的大环境已经卷的不成样子。看着各大公司的招聘简历，以及相关面经，会发现<strong>大学的课程完全不足以培养你进入大厂工作</strong>，如果真只是按部就班上完了全部课程，那恭喜你达到了新成就<strong>毕业即失业</strong>。在这个能力为硬指标的行业，但凡对工作有所期望的人，都会想方设法去学习更多的东西，起码面试三轮可以有能力通过一轮吧。</p>\r\n<span id=\"more\"></span>\r\n<p>但是虽然学生们都有动力，对我自己来说，进入计算机专业之前也是充满期待，希望自己经过几年的大学培养能够拥有一定的能力来解决问题，进而能够利用技术去实现自己的兴趣爱好。但是，学生并不知道需要去学什么，需要去钻研什么，需要掌握什么理论框架，需要尝试什么技术手段。计算机是一个宛如宇宙一般的庞大领域，就算花个几百年也不可能各个领域都掌握精通，要成为一个有用的人必须选择一个细分领域进行学习。然而这时初生牛犊面对无止境的知识海洋，根本没有能力决定这个领域学到哪，那个领域应该了解多少，底层和顶层应该怎么分配学习。</p>\r\n<blockquote>\r\n<p>他们往往很想学点东西，但又不知道哪些重要哪些不重要，到底该学到什么程度，不知道导致不确定，不确定导致决策瘫痪，干脆嘛也不动，荒废时间。\r\n——刘未鹏</p>\r\n</blockquote>\r\n<p>另一方面，企业在招聘时如何挖掘出有潜力，有能力的学生也是一件很难的事。在微软进行招聘的刘给出的答案值得我们进行参考：<strong>书单+GitHub=长达两年的招聘</strong>。</p>\r\n<p><strong>书单</strong>：对于基础知识和底层原理来说，有没有看过这个领域的<strong>好书</strong>的人，有着质的不同。\"看了就是看了，必然能学到东西，没看就是没看。知道和不知道，区别是本质的\"。不管是不是用心看，真有去看过一遍，并且确实是被公认的<strong>好书</strong>，那自己也自然会被吸引进去。</p>\r\n<p>当然这里一个核心的问题就是，怎么去找<strong>好书</strong>？国内大学计算机课本的含金量有目共睹，只学过课本甚至称不上是读过书。选择好书的一个很简单有效的原则——去找企业或者招聘者，在官网或者博客中给出的书单。企业为了招到最合适的候选人，必然会给出最合适的书单，例如微软：</p>\r\n<ul>\r\n<li>Code: The Hidden Language of Computer Hardware and Software\r\n（《编码的奥秘》）</li>\r\n<li>Computer System: A Programmer’s Perspective\r\n（《深入理解计算机系统》） / Windows via C/C++ （《Windows核心编程》 /\r\n《程序员的自我修养》</li>\r\n<li>Code Complete 2（《代码大全》）/ The Pragmatic Programmer\r\n（《程序员修炼之道》，我也把这本书称为《代码小全》）</li>\r\n<li>Programming Pearls （《编程珠玑》） / Algorithms / Algorithm Design\r\n/ 《编程之美》</li>\r\n<li>The C Programming Language</li>\r\n<li>The C++ Programming Language / Programming: Principles and Practice\r\nUsing C++ / Accelerated C++</li>\r\n<li>The Structure and Interpretation of Computer Programs\r\n（《计算机程序的构造和解释》）</li>\r\n<li>Clean Code / Implementation Patterns</li>\r\n<li>Design Patterns （《设计模式》） / Agile Software Development,\r\nPrinciples, Patterns, and Practices</li>\r\n<li>Refactoring （《重构》）</li>\r\n</ul>\r\n<p><strong>GitHub</strong>：企业怎么鉴别读书之外的工程能力呢？GitHub。其不可伪造、不可短时间恶补。每个人的GitHub\r\nHistory都是这个人所作所为的见证，每一条commit，issue，pr，甚至为项目写的文档，都是构成一个代码人的重要结构。企业能从中看到信息，而作为学生，我们也自然应该维护好其中的信息。<strong>积极与同行交流，积极寻找同好，积极code，记住自己的每一步都在造就自己的历史。</strong></p>\r\n<blockquote>\r\n<p>从你的GitHub旅程开始，你就已经一脚踏进了真正的企业，而企业的面试也已经开始。</p>\r\n</blockquote>\r\n<h1 id=\"知识的输出\">知识的输出</h1>\r\n<p>第一个优点：大家都知道好记性不如烂笔头，记录我们的学习往往能够帮助我们巩固并理清知识脉络，而不是囫囵吞枣看完就算学完。</p>\r\n<p>第二个优点：从公司的角度来看，<strong>知识的输出，其实是大家认识你的重要途径</strong>：</p>\r\n<p>你在豆瓣写的书评，最简单的层次上，体现了你是否读过这本书(无意义无价值的书评，既不会被认为是读过，甚至还会拉低别人对你的评价)。如果写的好，更体现了你对这本书的理解与认识。</p>\r\n<blockquote>\r\n<p>就像你的Steam游戏评测历史，将你的游戏爱好与兴趣点暴露无遗：)</p>\r\n</blockquote>\r\n<p>你的技术博客，以及各大社交平台的文章专栏，和GitHub一样，都是一点一滴积累出的关于你的历史。你写过的每篇文章，无论是作为笔记，还是作为见解，都表明了你对知识的理解程度。(当然，没有人喜欢完全复制粘贴的垃圾文章。)所谓面试时所需要考察的问题分析能力、举止言谈能力，很大程度上就记录在你写过的东西里，一个人无法在一个长期博客中伪装自己的知识储备和习惯。</p>\r\n<p>另一方面，计算机行业从不缺乏鼓励、赞扬、与辩驳。精彩的知识输出往往会给你带来同行的支持，例如知名度和交友圈。也会带来同行的评审，当我们和不知名的网友在评论区讨论半天的时候，大概是提升最快的时候~</p>\r\n<p>当招聘者发现你的技术文章被几十个人点赞、或者十几个人讨论，或者你的博客知名度本身已经在圈内赫赫有名，那你这个人的质量早就经过了数不清的检验，还需要担心什么呢？</p>\r\n<p><strong>笔记与博客</strong>：我个人会将笔记也写在博客里，如工具使用笔记、论文笔记等。不过这合适吗？我并不知道。</p>\r\n","categories":["生活"]},{"title":"尼尔机械纪元：月光下的童话悲曲","url":"/2022/03/28/%E5%B0%BC%E5%B0%94%E6%9C%BA%E6%A2%B0%E7%BA%AA%E5%85%83/","content":"<p>尼尔机械纪元：NieR: Automata</p>\r\n<h1 id=\"瑕不掩瑜的黑童话\">瑕不掩瑜的黑童话</h1>\r\n<p>值得注意的是,\r\n即使我很欣赏这个游戏，但是不得不说它完全不是一款集大成的3A大作,\r\n它只是一个在受限的预算下, 尽可能把自己的核心领域做出了极高的素质,\r\n同样另一方面，其不足之处也多了去了。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.akamai.steamstatic.com/steam/apps/524220/ss_c538e630c5cc224124104cc42ec6220ab90b5852.jpg?t=1646911723\"\r\nalt=\"末世的静美\" />\r\n<figcaption aria-hidden=\"true\">末世的静美</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h2 id=\"剧情基调-充满月光的忧郁童话\">剧情基调: 充满月光的忧郁童话</h2>\r\n<p><strong>(带有轻微主题剧透)</strong> 游戏剧情的大致背景,\r\n在商店介绍里很详细了，大致是人类后末世时代，人造机器人重返地球解开末世与人类的秘密。</p>\r\n<p>不是勇者斗恶龙那种打败大坏蛋的正道之光,不是最终幻想那种命运钦定剑与水晶的标准日式RPG的王道之路，<strong>是\"鬼才\"横尾太郎的致郁童话。</strong></p>\r\n<ul>\r\n<li>你可能会遇到一个因战斗失去了自己机器人孩子的机器人,\r\n它因无法忍受痛苦请求你格式化它的记忆, 之后再找它,\r\n发现毫无记忆的它开心地批量贩卖着孩子的零件.</li>\r\n<li>你可能会遇到一个失忆的反抗军, 她不知道自己的过去和未来,\r\n只是身上有几张风景照, 在你帮他认出这几个地点后,\r\n她想起来这些是和挚爱一起到过的地方, 然而挚爱已经去世.\r\n迷茫但无忧无虑的她, 只能变得悲伤.</li>\r\n<li>你可能会遇到一个请你帮他换零件的人造人, 最后在更换了太多零件之后,\r\n疑问自己还是自己吗? ----致敬忒修斯之船</li>\r\n<li>你可能会遇到一个机械生物为了追求另一个机械生物的爱,\r\n逐渐病态的悲剧。</li>\r\n</ul>\r\n<blockquote>\r\n<p>\"看着我, 我会用其他机械生物伙伴的部位来装饰, 我...会变得更漂亮哦,\r\n.....可以喜欢上我吗?\"</p>\r\n<p>\"太愚蠢了...吃了人造人就能变美, 这没有一点道理,\r\n但是我实践了..我吃到快吐了...不仅是人造人, 连我自己的同胞也吞下肚,\r\n但始终无法让他回头看我一眼..我始终无法让他回头看我一眼\"</p>\r\n<p>\"最后, 我发现了, 没有意义, 我无法得到那个人的心,\r\n----我看着镜中自己毫无意义的姿态放声大叫, 谁来..认同..我\"</p>\r\n</blockquote>\r\n<p>基本整个尼尔世界中的基调都是这种小清新致郁风格。但又不是完全故意迫害玩家心灵,\r\n更确切地说这种小致郁的基调对于营造末世忧郁风格很有帮助,\r\n同时也铺垫着尼尔主线本身的结局性质。</p>\r\n<p>另一方面, 除了这些主格调的忧郁, 玩家其实在主线过程中,\r\n更多直接体验的反而是正面回馈，例如反抗军的热情友好, 反战村庄的欢乐,\r\n以及和战友并肩作战的羁绊, 只不过会和逐渐揭开的主格调形成鲜明对比,\r\n然后更加凸显这个欢乐中忧郁的世界氛围, 所谓月光般的欢乐,\r\n又温柔又冰冷至极。</p>\r\n<p>除了这些主线支线所带来的比较充分的剧情,\r\n尼尔的每个武器都包含一个小剧场类型的武器背景故事。每个小剧情被分割成了四段话,\r\n随着武器的强化, 故事逐渐解锁,\r\n最终的结局往往也是让人有点回味...这些故事大多和游戏剧情无关,\r\n但是也是强化了世界观的忧郁风...</p>\r\n<blockquote>\r\n<p>很久以前, 有七个少年快乐并和睦地生活在一起</p>\r\n<p>一位占卜师来了, 说\"你们当中有一人是叛徒\", 少年们没信</p>\r\n<p>从第二天开始 , 每晚都有一人被杀害, 少年们开始相互怀疑</p>\r\n<p>只剩下最后一个少年, 少年看着自己沾满鲜血的手, 笑了,\r\n\"必须要去找出谁是叛徒\"</p>\r\n</blockquote>\r\n<h2 id=\"角色扮演-纯粹的故事向-却又带点奇怪的自由度\">角色扮演:\r\n纯粹的故事向, 却又带点奇怪的自由度</h2>\r\n<p>虽然是开放世界的角色扮演，但大部分主线支线都是不具有选择权的,\r\n或者是给了你选项, 但只要你不选规定的那个,\r\n会一直重复让你选..直到你改变心意...也就是说其实是<strong>一本道类型的体验型角色扮演</strong>,\r\n当然我个人并不觉得多选择有什么必要，因为我不喜欢强行多刷去看每一条分支。</p>\r\n<blockquote>\r\n<p>所谓追求自由选择，难道核心目的不是让玩家更有代入感吗，为什么玩家非要去看完所有其他可能呢=\r\n=结果让游戏好好的多选择自由扮演，变成了多剧情打包卖。</p>\r\n</blockquote>\r\n<p>~ (像刺客信条奥德赛那种罐头多选择算了吧,\r\n你还不如不给我选项呢...给了还反胃..)~</p>\r\n<p><strong>装备系统</strong>： 即芯片系统,\r\n玩家可以通过装备不同的芯片增强不同的属性,\r\n比如加暴击加回血加移动速度啥的...奇怪的自由度----因为主角是人造人,\r\n芯片系统中有个OS芯片..你可以把它拆了, 然后全剧终...</p>\r\n<p><strong>武器和辅助机</strong>： 拥有数十个武器, 但种类只有几种,\r\n每个武器可以强化增强属性, 同时解锁一些独有的BUFF,\r\n例如在自身生命值高的时候伤害增加。辅助机也同样可以强化升级,\r\n可以更换不同的攻击方式, 可以收集装备不同的特殊技能。</p>\r\n<p><strong>26个结局, 和主线强制多周目</strong>：26结局有点噱头的意思,\r\n真正把游戏玩完整其实只有一个结局。但制作组在一些奇奇怪怪的地方给了玩家一点自由度...</p>\r\n<ul>\r\n<li>比如序章开局战死, 嗯全剧终。算一个结局...</li>\r\n<li>比如打BOSS的时候玩家逃跑, 嗯全剧终。算一个结局...</li>\r\n<li>有些友好型的敌对机械生物, 虽然大家是朋友,\r\n但玩家可以做些不太好的事，嗯全剧终。算一个结局，和成就。</li>\r\n<li>大部分类似于这样的小结局。</li>\r\n</ul>\r\n<p><strong>所谓强制多周目</strong>：并不是像其他游戏那种Game+形式,\r\n完全不变重复游玩, 事实上把尼尔的多周目理解为分章更好一些。</p>\r\n<ul>\r\n<li>第一章是作为2B, 以2B的视角体验前半段故事</li>\r\n<li>第二章是以9s的视角体验前半段故事, 故事大体是重复的,\r\n但会补充一些9s单独经历的剧情, 以及每个BOSS都会新增一些壁画形式的小故事,\r\n战斗方面在9s的侵入技能下, 会有较新的战斗体验,\r\n以及有一些只有9s的侵入才能做的支线和探索的宝箱.</li>\r\n<li>第三章是后半段全新故事, 接着第一章和第二章所描述的前半段,\r\n续写最后的篇章.\r\n第三章可以选择操作9s或者A2...当然我相信大部分人追求新意肯定是选A2了...</li>\r\n</ul>\r\n<h2 id=\"动作系统-易上手-强反馈的充实打击感-但欠缺深度\">动作系统: 易上手,\r\n强反馈的充实打击感, 但欠缺深度</h2>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.akamai.steamstatic.com/steam/apps/524220/extras/Nier_PRE_Launch-ENG_UK_Multi_06_Mod.jpg?t=1646911723\"\r\nalt=\"卡刀，火花，扎实的打铁之旅\" />\r\n<figcaption aria-hidden=\"true\">卡刀，火花，扎实的打铁之旅</figcaption>\r\n</figure>\r\n<p>尼尔动作系统本质就是 轻重攻击键的交替, 带来的不同的连招组合, 类似于\r\n无双大蛇2的连招系统。但是虽然听起来这样可以有很多连招组合,\r\n但尼尔武器类别其实只有几种, 同类别的武器打击方式基本是一样的,\r\n因此游玩过程中其实你从开头到结尾 , 打架的方式的新鲜感并不多。</p>\r\n<p><strong>当然作为白金出品,\r\n尼尔的打击感还是十分优秀的</strong>:该卡刀的卡刀, 视效音效应有具有,\r\n即使连招稍有单调, 但战斗体验还是很不错。还有一些辅助动作系统,\r\n算是增加了一些趣味。比如辅助机的几种辅助攻击方式, 例如机关枪,\r\n跟踪炮之类的。另外辅助机还可以装备一些特殊技能, 像重力场,\r\n激光炮....之类的。</p>\r\n<p><strong>讨巧的侵入系统</strong>：侵入敌人这个设定可以算是特别取巧刁钻!\r\n侵入过程是游玩一个弹幕小游戏, 没啥好介绍的, 但是侵入完成后 ,\r\n玩家可以选择操作敌人 (或者引爆敌人)。\r\n从开发方角度来看简直是神来一笔。一方面, 操作敌人不需要做新的素材,\r\n稍微适配一下玩家操作即可, 节省本就不高的预算。另一方面,\r\n本来单调的战斗体验在此时已经接近审美疲劳了,\r\n但是突然让玩家可以体验几乎每个敌人的战斗方式 (当然BOSS是不能操作的) ,\r\n于是玩家在接下来的每次战斗又可以获得全新的良好的体验。</p>\r\n<p><strong>较为优秀的BOSS战设计</strong>：虽然玩家打BOSS的方式大同小异,\r\n但是BOSS的攻击方式倒是千奇百怪 (当然脱离不了弹幕攻击这一大类) ,\r\n配合上优秀的氛围营造(音乐+剧情), 每场BOSS战虽然不是那种历久弥新,\r\n但也算是精彩。</p>\r\n<p><strong>再加上一些奇怪的战斗模式</strong>: 例如2D滚动卷轴空战模式,\r\n巨型机器人模式,\r\n横板卷轴动作...各种花里胡哨的小模式，填充了很大部分的游玩趣味。</p>\r\n<h2 id=\"bgm-氛围营造拉满\">BGM: 氛围营造拉满</h2>\r\n<p>即使大家对游戏素质有不同的评价,\r\n但音乐这一块毫无疑问压倒性的好评。(各大视频网站和音乐平台都有OST,\r\n音乐体验怎样可以听听看)。音乐技巧不谈，但是我从游玩角度来看 ,\r\n每个场景每段剧情每场战斗的BGM氛围营造的都特别棒.</p>\r\n<ul>\r\n<li>刚到废弃都市的时候, 空洞安静又带点忧郁。</li>\r\n<li>最著名的游乐园BGM, 一种末世之花的感觉?</li>\r\n<li>....所谓余音绕梁。</li>\r\n</ul>\r\n<p>游戏BGM不一定有很强的演奏编曲技术性，但是对氛围的营造这一块很成功，这作为游戏BGM已经够了。例如著名的水晶序曲Prelude，以及Final\r\nFantasy，Rivellon等</p>\r\n<h1 id=\"总结-核心体验十分优秀的神作\">总结, 核心体验十分优秀的神作</h1>\r\n<p>游戏大致风格就是如上所述, 剧情和音乐是尼尔的灵魂,\r\n但恰恰这两点不好在评测中描述出来, 因此只能把我感触中的音乐体验,\r\n和温柔忧郁的世界观风格介绍一下, 但只能提供一个概述的感觉,\r\n游戏本身的优秀与震撼人心最好能亲自体验。每个游戏都不会是完美的,\r\n必然有其重要想要给玩家体验到的东西 , 也必然有不足之处.\r\n用Gamker的话来说就是游戏的核心体验, 只要这个游戏把自己的核心体验做好了,\r\n给它的目标人群带来了一段优秀的游戏体验, 那它就是优秀的。</p>\r\n<p>当然再看综合素质的话, 尼尔还是有很多缺点：</p>\r\n<ul>\r\n<li>比如战斗系统虽然作为ARPG够用, 但真的不丰富多样, 也没有技能系统 ,\r\n战斗体验在三周目时趋于平淡</li>\r\n<li>比如画面优化很差, 虽然画面加上光影, 体积光和雾气效果的弥漫,\r\n其实还挺有末世感觉. 但不能掩盖细节缺失, 素材贫乏,\r\n优化还差的画面缺陷..</li>\r\n<li>比如地图设计反人类 (是用于看的地图,\r\n不是游戏整体地图结构)...虽然我不知道这种地图设计是为了满足世界观需要,\r\n还是单纯的为难玩家,\r\n还是单纯地技术不达标..总之这地图不太好用..甚至基本没用...</li>\r\n<li>比如大量的空气墙,\r\n大量的地方能看不能走.....因此虽然是开放世界鼓励探索..但其实空气墙的存在,\r\n事实上也只能走官方钦定的探索路线...让玩家不是很有探索欲望.</li>\r\n</ul>\r\n<p>在我看来, 尼尔想要营造的核心体验: 机械生物世界观,\r\n温柔忧郁又掺杂月光般的爱的悲剧风格,\r\n回味无穷的角色扮演体验。这些我都能够在游戏中充分地体验到,\r\n因此我个人认为这是一款特别优秀的游戏。</p>\r\n","categories":["生活"],"tags":["游戏"]},{"title":"基础算法总结","url":"/2021/03/17/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","content":"<h1 id=\"排序\">排序</h1>\r\n<h2 id=\"快速排序\">快速排序</h2>\r\n<p>在数组中选定一个分界数<code>pivot</code>,\r\n然后将所有其他的数和它进行比较，大于的小于的分成两部分，<code>pivot</code>放中间，这样这一轮就确定了一个数的位置，然后递归左右两边继续快排即可：</p>\r\n<ol type=\"1\">\r\n<li><p>首先确定一个分界数：可以直接固定取最开始或者最后的那个数，也可以用随机算法。随机取数会使效率更加稳定。然后把这个数交换到\r\nend，以便前面进行分块。</p></li>\r\n<li><p>如何将大于和小于的两部分分开：我们目标是让小于的部分在前，大于的部分在后————小于区\r\n和 大于区。两种分割方法：</p></li>\r\n</ol>\r\n<ul>\r\n<li><p>一种是利用两个标志位，<code>lo=start</code>和<code>hi=end-1</code>。思想是两个标志位互相\r\n把<strong>应该分配给对方的数</strong> 给对方。\r\n<code>if (nums[lo]&gt;pivot)</code>，显然 nums[lo] 的值不应该在 lo\r\n所处的小于区，因此我们把它丢到大于区<code>swap(nums[lo],nums[hi]);</code>。此时\r\nhi 所指的数是大于 pivot 的，是正确处于后半区的，因此 hi\r\n可以移动去处理下一个数，即 hi--。而 lo 获得了 hi\r\n交换过去的数，大于小于性未知，lo 不能动。</p>\r\n<p>else，nums[lo] 正确处于小于区，那么 lo\r\n去处理下一个数，lo++。</p></li>\r\n<li><p>另一种需要一个标志位和一个遍历位，即<code>lo=start</code>和<code>cur=start+1</code>。cur\r\n从 start+1 遍历到 end-1 ，lo\r\n指示着小于区的最后一个数的位置。思想是把所有小于区的全部分好，那么大于区的也自然而然分好了。</p>\r\n<p>if (nums[cur]&gt;pivot), 即当前数应该在大于区，即在 lo 之外，因为 cur\r\n本来就一定指在 lo 之外，因此不用移动当前数， cur 去处理下一个，\r\ncur++。</p>\r\n<p>else, 即当前数应该添加到小于区，即在 lo\r\n的下一个，因此交换<code>swap(nums[cur],nums[lo+1]);</code>, 同时 lo++\r\n更新到新边界。此时这个小于区的数已经分好。lo+1 换给 cur 的数，必然是 cur\r\n处理过的，因此 cur 只需要去下一个数处理，cur++。</p></li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<ol start=\"3\" type=\"1\">\r\n<li><p>分好区之后，把 pivot 插入到两区中间：因为我们之前把 pivot 放在了\r\nend，因此需要把 pivot 和 大于区的第一个数交换，如果 pivot 放在了 start，\r\n则是交换小于区的最后一个数。</p></li>\r\n<li><p>递归两个分区：获得了两个分区数组，一个固定位置的 pivot\r\n，继续在两个分区里分别排序即可。</p></li>\r\n</ol>\r\n<h3 id=\"示例代码\">示例代码</h3>\r\n<p>这里使用的是第一种分割方法，比较常见和经典。实现上需要注意 while\r\n循环出口时，lo 和 hi 的停留位置</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">sortArray</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;   </span><br><span class=\"line\">    <span class=\"comment\">//快速排序</span></span><br><span class=\"line\">    <span class=\"built_in\">sortArrayHelp</span>(nums,<span class=\"number\">0</span>,nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sortArrayHelp</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums,<span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> end)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(start&gt;=end)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pivot=nums[end];<span class=\"comment\">//end 为尾，不是尾后</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> lo=start,hi=end<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(lo&lt;=hi)<span class=\"comment\">//出口时 lo 和 hi 重叠在 hi 区的第一个</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[lo]&gt;pivot)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(nums[lo],nums[hi]);<span class=\"comment\">//交换两数</span></span><br><span class=\"line\">            hi--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            lo++;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">swap</span>(nums[lo],nums[end]);<span class=\"comment\">//注意 lo 的停留位置</span></span><br><span class=\"line\">    <span class=\"built_in\">sortArrayHelp</span>(nums,start,lo<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">sortArrayHelp</span>(nums,lo+<span class=\"number\">1</span>,end);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"性能分析\">性能分析</h3>\r\n<ul>\r\n<li><p>不稳定，存在打破 等值数 顺序的交换。</p></li>\r\n<li><p>时间复杂度最优 O(nlogn)，最差\r\nO(n^2)。因为快排主要部分就是分区，分区好坏决定了递归树的深度，且每一层递归树的操作代价之和，都是\r\nO(n), 因此分析时间要从分区的可能情况入手。</p>\r\n<blockquote>\r\n<p>每层的操作代价——每次在 n 大小的分区中，都要进行 n-1 次比较。和 cn\r\n次的移动操作，每层的所有分区代价之和，必然是 O(n) 级。</p>\r\n<p>其实每一层相比前一层少了一个确定的数，操作代价也会少\r\n1，但我们分析上限暂且只考虑操作最高代价为 n。</p>\r\n</blockquote>\r\n<p>最优即对半分区，即最优情况下递归树的深度为 log n。运行时间表达式：\r\nT(n)=2*T(n/2)+O(n)，解为 T(n)=O(nlgn)</p>\r\n<p>最坏情况即完全逆序，每次划分只能划出一个分区，递归树深度为 n\r\n。运行时间表达式： T(n)=T(n-1)+O(n)，解为 T(n)=O(n^n)</p>\r\n<p>平均划分深度为 lg n 级，因为不论划分比例是 1：9，还是\r\n1：99，只要是常数比例划分，都必然形成一个 lg n\r\n的递归树深度，最终运行时间解 T(n)=O(nlgn)。</p></li>\r\n<li><p>空间复杂度即堆栈空间的大小，最优 O(log_2 n), 最坏 O(n), 平均 O(lg\r\nn)</p></li>\r\n</ul>\r\n<h2 id=\"堆排序\">堆排序</h2>\r\n<p>通过构建一个最大堆，这样从最大堆每次弹出\r\nroot，即可获得最大数，然后重新整理剩下的堆，循环类推：</p>\r\n<ol type=\"1\">\r\n<li><p>构建最大堆，最大堆本身是二叉树结构，只不过维护了父结点比子节点大的特征。而二叉树本身也可以通过数组的形式实现，因此我们这里可以直接用数组实现最大堆。当然，另建数据结构也行，理解上会更简单点。</p></li>\r\n<li><p>首先明确，在数组结构的二叉树中，i 结点的父结点是\r\n(i-1)/2，子结点是 2i+1, 2i+2。</p>\r\n<p>我们可以把当前数组看成已经成形的二叉树，构建最大堆即维护好父子结点的大小关系即可。</p>\r\n<p>因此对于每个结点，检查其是否比父结点大，是的话就换上去，同时递归往上检查。</p>\r\n<p>最终遍历检查好每个结点，即完成了最大堆的构建。</p></li>\r\n<li><p>弹出当前堆的最大数，整理剩下的堆，再维护成一个最大堆。</p></li>\r\n<li><p>因为最大堆由上往下依次变小，因此当 root\r\n被弹出后，只需要在它的直接子节点中选出最大的一个来当 root\r\n即可，此时最大子节点必是堆中最大的数。当然由于我们相当于在子堆中弹出了\r\nroot，因此也要递归维护下去。</p></li>\r\n<li><p>重建好堆后即可再次弹出，如此循环。</p></li>\r\n</ol>\r\n<h3 id=\"示例代码-1\">示例代码</h3>\r\n<p>注意重建堆的实现细节，需要考虑到子节点是否越界，还有递归重建的终止条件是否正确。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">sortArray</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> <span class=\"comment\">//堆排序</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;   </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> length=nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"built_in\">buildHeap</span>(nums);</span><br><span class=\"line\">        <span class=\"comment\">// for(int i=0;i&lt;length;i++)</span></span><br><span class=\"line\">        <span class=\"comment\">//     cout&lt;&lt;nums[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> end=length<span class=\"number\">-1</span>;end&gt;<span class=\"number\">0</span>;end--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//把根放到 end</span></span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(nums[<span class=\"number\">0</span>],nums[end]);</span><br><span class=\"line\">            <span class=\"comment\">//重建新堆</span></span><br><span class=\"line\">            <span class=\"built_in\">reBuildHeap</span>(nums,<span class=\"number\">0</span>,end<span class=\"number\">-1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">buildHeap</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length=nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;length;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> child=i;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> parent=(child<span class=\"number\">-1</span>)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(parent&gt;=<span class=\"number\">0</span> &amp;&amp; nums[parent]&lt;nums[child])<span class=\"comment\">//注意 parent&gt;=0 不是&gt;0</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(nums[parent],nums[child]);</span><br><span class=\"line\">                <span class=\"comment\">//递归往上更新</span></span><br><span class=\"line\">                child=parent;</span><br><span class=\"line\">                parent=(parent<span class=\"number\">-1</span>)/<span class=\"number\">2</span>; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reBuildHeap</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums,<span class=\"keyword\">int</span> root,<span class=\"keyword\">int</span> end)</span><span class=\"comment\">//弹出根后 重新整理 heap,end 为尾后</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left=<span class=\"number\">2</span>*root+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right=left+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> max=left;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(right&lt;=end &amp;&amp; nums[right]&gt;nums[left])</span><br><span class=\"line\">            max=right;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left&lt;=end &amp;&amp; nums[max]&gt;nums[root])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(nums[max],nums[root]);</span><br><span class=\"line\">            <span class=\"built_in\">reBuildHeap</span>(nums,max,end);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"性能分析-1\">性能分析</h3>\r\n<ul>\r\n<li>不稳定，构建堆和重建堆难以控制交换</li>\r\n<li>时间复杂度 O(nlog n), 构建堆和重建堆时，每个元素都需要经历等于\r\n<strong>O(log n) 层数</strong> 的比较，因此所有元素的代价是 O(nlog\r\nn)。</li>\r\n<li>空间复杂度使用原数组构建堆时，O(1)。</li>\r\n</ul>\r\n<h2 id=\"冒泡排序\">冒泡排序</h2>\r\n<p>第 n 轮遍历，找出一个第 n 大，放在最后或最前，这样 n-1\r\n轮下来即全部排好：</p>\r\n<ol type=\"1\">\r\n<li><p>外层循环控制冒泡轮数</p></li>\r\n<li><p>内层循环为每次遍历，假如当前的比后一个大，则交换，最终一轮走下来会冒泡出最大的一个。</p></li>\r\n</ol>\r\n<h3 id=\"示例代码-2\">示例代码</h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">sortArray</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length=nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=length<span class=\"number\">-1</span>;i&gt;<span class=\"number\">0</span>;i--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;i;j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[j]&gt;nums[j+<span class=\"number\">1</span>])</span><br><span class=\"line\">                    <span class=\"built_in\">swap</span>(nums[j],nums[j+<span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"性能分析-2\">性能分析</h3>\r\n<ul>\r\n<li>稳定，不需要交换 等值数</li>\r\n<li>时间复杂度 O(n^2), 冒泡轮数固定，冒泡时比较次数也固定，因此\r\nT(n)=n+n-1+...1=(1+n)*n/2=O(n)</li>\r\n<li>空间复杂度 O(1), 不需要额外空间</li>\r\n</ul>\r\n<h2 id=\"归并排序\">归并排序</h2>\r\n<p>分治代表。先分别对左半边和右半边进行排序，然后再合并它俩的排序结果。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">MergeSort</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums,<span class=\"keyword\">int</span> left,<span class=\"keyword\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(left&gt;=right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid=(left+right)/<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">MergeSort</span>(left,mid);</span><br><span class=\"line\">    <span class=\"built_in\">MergeSort</span>(mid+<span class=\"number\">1</span>,right);</span><br><span class=\"line\">    <span class=\"comment\">//合并</span></span><br><span class=\"line\">    vector&lt;<span class=\"keyword\">int</span>&gt; temp=<span class=\"keyword\">new</span> vector&lt;<span class=\"keyword\">int</span>&gt;(right-left);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=left,j=mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp_i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[i]&lt;=nums[j])</span><br><span class=\"line\">            temp[temp_i]=nums[i++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            temp[temp_i]=nums[j++];</span><br><span class=\"line\">        temp_i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;=mid)</span><br><span class=\"line\">        temp[temp_i++]=nums[i++];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j&lt;=right)</span><br><span class=\"line\">        temp[temp_i++]=nums[j++];</span><br><span class=\"line\">    <span class=\"comment\">//放回原数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;k&lt;temp.length;k++)</span><br><span class=\"line\">        nums[left+k]=temp[k];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>时间复杂度稳定<span\r\nclass=\"math inline\">\\(O(n\\log{n})\\)</span>，每轮合并操作需要<span\r\nclass=\"math inline\">\\(O(n)\\)</span>，共有<span\r\nclass=\"math inline\">\\(\\log{n)\\)</span>轮。</li>\r\n<li>空间复杂度<span class=\"math inline\">\\(O(n)\\)</span></li>\r\n<li>稳定</li>\r\n</ul>\r\n<h2 id=\"箱子排序桶排序\">箱子排序/桶排序</h2>\r\n<p>将待排序数按数值区间或什么规则，划分成 N 类，准备好 N\r\n个链表，将相应类的数接在相应的链表后面，然后对每个链表内部进行排序，最后把所有链表按类别顺序连接起来，或者重新填入原数组即可：</p>\r\n<ol type=\"1\">\r\n<li>按规则划分成 N 类，通常按取值范围划分。</li>\r\n<li>创建 N 个链表</li>\r\n<li>遍历输入数值，将所有元素放入相应的链表</li>\r\n<li>对桶内进行排序，可随意采用排序方法。</li>\r\n<li>将结果放回原数组，或者连接所有的链表并返回链表结果。</li>\r\n</ol>\r\n<h3 id=\"示例代码-3\">示例代码</h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">bucketSort</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bucketSize=<span class=\"number\">100</span>; <span class=\"comment\">//桶大小</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> min_num=max_num=nums[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//找到数值范围</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> num:nums)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        min_num=<span class=\"built_in\">min</span>(min_num,num);</span><br><span class=\"line\">        max_num=<span class=\"built_in\">max</span>(max_num,num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//初始化桶</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> Count=(max_num-min_num+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bucketCount;<span class=\"comment\">//桶数量</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Count%bucketSize==<span class=\"number\">0</span>)<span class=\"comment\">//整除</span></span><br><span class=\"line\">        bucketCount=Count/bucketSize;</span><br><span class=\"line\">    <span class=\"keyword\">else</span><span class=\"comment\">//非整除</span></span><br><span class=\"line\">        bucketCount=Count/bucketSize+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;<span class=\"keyword\">int</span>&gt;[] buckets=<span class=\"keyword\">new</span> List[bucketCount];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//元素放入 List</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> num: nums)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index=(num-min)/bucketSize;<span class=\"comment\">//放入到 index 里</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(buckets[index]==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            buckets[index]=<span class=\"keyword\">new</span> List&lt;<span class=\"keyword\">int</span>&gt;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        buckets[index].<span class=\"built_in\">add</span>(num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> length=nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//将元素放回原数组</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;length)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> bucket:buckets)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(bucket==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">//桶内部任意方法排序</span></span><br><span class=\"line\">                <span class=\"built_in\">sort</span>(bucket);</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> num : bucket)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    nums[i]=num;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"性能分析-3\">性能分析</h3>\r\n<ul>\r\n<li>稳定，按原顺序插入桶，不会改变同值数的顺序</li>\r\n<li>空间复杂度 O(n+k),n 个链表节点存放元素，k 个桶</li>\r\n<li>时间复杂度 O(n+k), 确定桶数量 O(n), 分类 O(n), 放回\r\nO(n)。（没考虑内部排序时间）</li>\r\n</ul>\r\n<h2 id=\"其他简易排序\">其他简易排序</h2>\r\n<ul>\r\n<li>选择排序：每轮选出最大的一个，与数组末端的数交换位置。类似冒泡，只不过只交换一次。时间复杂度稳定<span\r\nclass=\"math inline\">\\(O(n^2)\\)</span>。不稳定</li>\r\n<li>插入排序：把排好的部分放在前端。每轮拿一个未排好的数去前端寻找插入点，时间复杂度<span\r\nclass=\"math inline\">\\(O(n)\\)</span> ~ <span\r\nclass=\"math inline\">\\(O(n^2)\\)</span>。稳定。</li>\r\n<li>希尔排序：先把数组等步长分成多个子数组，分别插入排序。然后逐渐收缩步长，排序更大的子数组。时间复杂度<span\r\nclass=\"math inline\">\\(O(n^{\\frac{4}{3}})\\)</span> ~ <span\r\nclass=\"math inline\">\\(O(n^2)\\)</span>。不稳定</li>\r\n</ul>\r\n<h2 id=\"参考资料\">参考资料</h2>\r\n<p><a\r\nhref=\"https://leetcode-cn.com/problems/sort-an-array/solution/shi-er-chong-pai-xu-suan-fa-bao-ni-man-yi-dai-gift/\">十二种排序算法包你满意（带\r\nGIF 图解）</a></p>\r\n<h1 id=\"树相关\">树相关</h1>\r\n<p>假定树结构如下：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> </span></span><br><span class=\"line\"><span class=\"class\"> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    TreeNode *left;</span><br><span class=\"line\">    TreeNode *right;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>(<span class=\"keyword\">int</span> x) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">left</span>(<span class=\"literal\">NULL</span>), <span class=\"built_in\">right</span>(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>递归思路很简单，只记录迭代思路。</p>\r\n<h2 id=\"前序遍历\">前序遍历</h2>\r\n<p>先根，再左结点，再右结点。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    vector&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    </span><br><span class=\"line\">    stack&lt;TreeNode*&gt; s;</span><br><span class=\"line\">    s.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!s.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        TreeNode * current=s.<span class=\"built_in\">top</span>();s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        result.<span class=\"built_in\">push_back</span>(current-&gt;val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(current-&gt;right) s.<span class=\"built_in\">push</span>(current-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(current-&gt;left) s.<span class=\"built_in\">push</span>(current-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"中序遍历\">中序遍历</h2>\r\n<p>先左，再根，再右。</p>\r\n<p>迭代时注意没有对左结点的输出，是把左结点继续往下看，看成以它为根的树根结点，然后统一用输出根结点的方式输出所有结点。</p>\r\n<blockquote>\r\n<p>根节点同时也是根父节点的左子结点，因此回溯上去的时候顺序是”父（左）-右“、”父（左）-右“。</p>\r\n<p>即输出当前根，然后进入右树，然后往上一层，此时上一层的左树就是刚刚解决好的。因此继续同样的\"根\r\n- 右\"顺序进行遍历。</p>\r\n</blockquote>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    vector&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    stack&lt;TreeNode*&gt; mem;</span><br><span class=\"line\">    TreeNode *current=root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!mem.<span class=\"built_in\">empty</span>()||current)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//左节点压栈</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(current)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            mem.<span class=\"built_in\">push</span>(current);</span><br><span class=\"line\">            current=current-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        current=mem.<span class=\"built_in\">top</span>();mem.<span class=\"built_in\">pop</span>();<span class=\"comment\">//输出当前子树根结点</span></span><br><span class=\"line\">        result.<span class=\"built_in\">push_back</span>(current-&gt;val);</span><br><span class=\"line\">        current=current-&gt;right;<span class=\"comment\">//进入当前子树右树</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"后序遍历\">后序遍历</h2>\r\n<p>先左，再右，最后根。</p>\r\n<p>和中序遍历一样，首先要走到左树最深处。但是迭代很难控制从下一层返回上来的时候，不再压栈子结点，因此需要在第一次压栈时，断开根结点和子节点的链接。</p>\r\n<ol type=\"1\">\r\n<li><p>取当前结点，先找左子树，左子树里面同样还要找左子树啊，因此是while找下去。</p></li>\r\n<li><p>直至左子树为NULL，再找右子树，注意右子树里面优先找的是<strong>左子树</strong>，因此<strong>不能while</strong>持续找右子树，而是进入右子树后当作全新的树，再同样的查找。</p></li>\r\n<li><p>迭代到某个结点后，左子树为NULL，右子树也为NULL，递归迭代停止，终于可以作为根结点进行输出了。</p></li>\r\n</ol>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    vector&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    stack&lt;TreeNode*&gt; s;<span class=\"comment\">//递归栈</span></span><br><span class=\"line\">    TreeNode* current;<span class=\"comment\">//当前处理结点</span></span><br><span class=\"line\">    s.<span class=\"built_in\">push</span>(root);<span class=\"comment\">//初始化栈</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!s.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        current=s.<span class=\"built_in\">top</span>();<span class=\"comment\">//取结点</span></span><br><span class=\"line\">        root=current;<span class=\"comment\">//保留父结点，后续断开连接要用</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//先遍历这结点的左结点，左左结点，左左左...结点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(current-&gt;left)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">push</span>(current-&gt;left);</span><br><span class=\"line\">            current=current-&gt;left;</span><br><span class=\"line\">            root-&gt;left=<span class=\"literal\">NULL</span>;<span class=\"comment\">//断开连接，避免返回到这个结点时又递归左树死循环</span></span><br><span class=\"line\">            root=current;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//然后进入右子树，注意进入右子树后还是优先找左子子树，因此不能无脑压栈右子树。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(current-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">push</span>(current-&gt;right);</span><br><span class=\"line\">            current=current-&gt;right;</span><br><span class=\"line\">            root-&gt;right=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            root=current;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span><span class=\"comment\">//已经走到最左端了，作为最外面的子树，它的左结点必然是空，并且else说明右子树也空，则可以输出自己了。</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result.<span class=\"built_in\">push_back</span>(current-&gt;val);</span><br><span class=\"line\">            s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"层序遍历\">层序遍历</h2>\r\n<p>即逐层的 从左到右访问所有结点。</p>\r\n<p>算法上主要是遍历一个结点，先把左右子节点装进去。</p>\r\n<p>值得考虑的是，怎么把每层结果分开？使用一个length在每层开始，检查队列长度获得该层长度，这样后面加入的子节点就不在长度范围内。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt; <span class=\"built_in\">levelOrder</span>(TreeNode* root) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    vector&lt;vecotr&lt;<span class=\"keyword\">int</span>&gt;&gt; result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">    queue&lt;TreeNode*&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())<span class=\"comment\">//队列不空</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; temp;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length=q.<span class=\"built_in\">size</span>();<span class=\"comment\">//获取当前层结点</span></span><br><span class=\"line\">        TreeNode* current=q.<span class=\"built_in\">front</span>();q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;length;i++)<span class=\"comment\">//分层计数</span></span><br><span class=\"line\">        &#123;       </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(current!=<span class=\"literal\">NULL</span>)<span class=\"comment\">//当前为有效结点，加入result，检查子节点</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                temp.<span class=\"built_in\">push_back</span>(current-&gt;val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(current-&gt;left) q.<span class=\"built_in\">push</span>(current-&gt;left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(current-&gt;right) q.<span class=\"built_in\">push</span>(current-&gt;right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        result.<span class=\"built_in\">push_back</span>(temp);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"链表相关\">链表相关</h1>\r\n<h2 id=\"判断链表是否有环\">判断链表是否有环</h2>\r\n<p><strong>双指针</strong>————假如有环，快指针将迟早能和慢指针相遇</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode *head)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span> || head-&gt;next==<span class=\"literal\">NULL</span>)<span class=\"comment\">//空链表或单结点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode* fast=head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//快慢指针移动</span></span><br><span class=\"line\">        fast=fast-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fast!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            fast=fast-&gt;next;</span><br><span class=\"line\">        head=head-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//检查移动后是否相遇</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fast==head)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"寻找链表环的入口\">寻找链表环的入口</h2>\r\n<p><a\r\nhref=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/c-shuang-zhi-zhen-z-by-zrita/\">参考题解</a></p>\r\n<p><strong>双指针</strong>————同上方法等待快慢指针相遇。</p>\r\n<h3 id=\"第一次相遇时\">第一次相遇时</h3>\r\n<ul>\r\n<li>环外距离 out</li>\r\n<li>环内距离 in</li>\r\n<li>环长 circle</li>\r\n<li>慢指针走过的距离：<code>len_s=out+in</code></li>\r\n<li>快指针走过的距离：<code>len_f= out+in+n*circle</code></li>\r\n</ul>\r\n<p>因为<code>len_f=2*len_s</code>\r\n推导出=》<code>len_s=n* circle</code></p>\r\n<p>此时把快指针置零，我们准备再让他俩走一遍直到相遇。</p>\r\n<h3 id=\"第二次相遇时\">第二次相遇时</h3>\r\n<p>设快指针走了x步相遇 此时大家走过的总距离如下：</p>\r\n<ul>\r\n<li>快指针走过的距离：<code>len_f=x</code></li>\r\n<li>慢指针走过的距离：<code>len_s=x+n*circle</code></li>\r\n</ul>\r\n<p>可以发现，当快指针刚到环入口，即x=out的时候：</p>\r\n<ul>\r\n<li>快指针走过的距离：<code>len_f=out</code></li>\r\n<li>慢指针走过的距离：<code>len_s=out+n*circle</code></li>\r\n</ul>\r\n<p>慢指针也恰好在环入口，只不过多走了n圈而已。</p>\r\n<p>此时他俩停留的地方即是环入口。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">detectCycle</span><span class=\"params\">(ListNode *head)</span> </span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">       ListNode* fast=head,*slow=head;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(fast==<span class=\"literal\">NULL</span> || fast-&gt;next==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">       <span class=\"keyword\">while</span>(fast &amp;&amp; fast-&gt;next)<span class=\"comment\">//第一次相遇</span></span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           fast=fast-&gt;next-&gt;next;</span><br><span class=\"line\">           slow=slow-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(fast==slow)</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(fast!=slow)<span class=\"comment\">//无环</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//有环</span></span><br><span class=\"line\">       fast=head;</span><br><span class=\"line\">       <span class=\"keyword\">while</span>(fast!=slow)<span class=\"comment\">//第二次相遇</span></span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           fast=fast-&gt;next;</span><br><span class=\"line\">           slow=slow-&gt;next;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"翻转链表\">翻转链表</h2>\r\n<p>不断将 head 后一个移到头部去。</p>\r\n<p>利用一个 root 维护头部</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ListNode* root=<span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    root-&gt;next=head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(head &amp;&amp; head-&gt;next)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ListNode* temp=head-&gt;next;<span class=\"comment\">//[1,2,3] </span></span><br><span class=\"line\">        head-&gt;next=temp-&gt;next;<span class=\"comment\">//1 接上 2 的后续</span></span><br><span class=\"line\"></span><br><span class=\"line\">        temp-&gt;next=root-&gt;next;<span class=\"comment\">//2 连上 头结点</span></span><br><span class=\"line\">        root-&gt;next=temp;<span class=\"comment\">//2 作为新的头结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"相交链表\">相交链表</h2>\r\n<p>找出两个链表的交点并返回</p>\r\n<p>容易知道用存储 map 做，但是需要较大存储空间</p>\r\n<p>假设：</p>\r\n<ul>\r\n<li>链表 A 长度为 a，独有部分长度为 c。</li>\r\n<li>链表 B 长度为 b，独有部分长度为 d。</li>\r\n</ul>\r\n<p>可以知道<code>a-c=b-d</code>，变换一下则是<code>a+d=b+c</code>。</p>\r\n<p>即一个指针走完 A，再去走 B 的独有部分，和另一个指针走完 B，再去走 A\r\n的独有部分，所需步数是相同的。</p>\r\n<p>换句话说，两个指针同时开始走，走到 NULL\r\n就切换到隔壁链表上走，此时两个指针对于交点是同距离的。</p>\r\n<p>继续同步走，双指针必然同时遇到交点，一直走到 NULL\r\n还没同时遇到则不存在交点。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ListNode* rootA=headA,*rootB=headB;</span><br><span class=\"line\">    <span class=\"comment\">//注意移动和跳转的顺序 是先跳到 root 再移动？还是用跳跃取代移动？</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(headA!=headB)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(headA==<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">            headA=rootB;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            headA=headA-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(headB==<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">            headB=rootA;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            headB=headB-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(headA==headB)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> headA;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"栈相关\">栈相关</h1>\r\n<h2 id=\"最小栈的实现\"><a\r\nhref=\"https://leetcode-cn.com/problems/min-stack/\">最小栈的实现</a></h2>\r\n<p>需要实现一个能随时获取<strong>当前</strong>最小元素的栈。</p>\r\n<h3 id=\"题解思路\">题解思路</h3>\r\n<p>一开始想的是维护一个 int min，但是次小值之类的是无法维护的。</p>\r\n<p>首先我们来看看当前最小值是怎么更新的，假设当前最小值是 min_cur：</p>\r\n<ul>\r\n<li>入栈一个比它大的值，那么此时栈当前最小不变。</li>\r\n<li>在它上面的比它大的元素出栈，反正没 min_cur\r\n小，因此出了也不影响栈当前最小=min_cur。</li>\r\n<li>入栈一个比它小的值，那么栈当前最小更新到新值 min_new。而且在 min_new\r\n上面的情景和 min_cur 一样，不用考虑了。</li>\r\n<li>出栈 min_new，则最小值由 min_new 往下的接管，而我们直到 min_new\r\n往下之前一直是 min_cur 管着最小值，因此又回到了 min_cur。</li>\r\n</ul>\r\n<p>即核心操作是，判断当前入出栈的元素是不是比之前的最小值小。且最小值的更新有着后进先出的特性，后面更新的最小值，必然也会先被出栈，然后返回上一个最小值，因此考虑使用一个<strong>辅助栈</strong>。</p>\r\n<p>辅助栈，存放有史以来的最小值记录，栈顶即当前状态最小值。假设当前最小值是\r\nmin_cur：</p>\r\n<ul>\r\n<li>主栈入栈的元素比最小值大时，辅助栈保存的最小值保持不变，重复入栈一个\r\nmin_cur。</li>\r\n<li>较小时，更新当前最小值，入栈一个 min_new。</li>\r\n<li>出栈时，辅助栈跟随主栈相应出栈。</li>\r\n</ul>\r\n<h2 id=\"每日温度单调栈\"><a\r\nhref=\"https://leetcode-cn.com/leetbook/read/queue-stack/genw3/\">每日温度</a>——单调栈</h2>\r\n<p>请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0\r\n来代替。</p>\r\n<p>气温列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在\r\n[30, 100] 范围内的整数。</p>\r\n<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76,\r\n73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>\r\n<h3 id=\"题解思路-1\">题解思路</h3>\r\n<p>有点类似接雨水的题目，要在一系列顺序高度中，找到一个凹区间。且易知较矮的凹区间，必然包含在较高的凹区间内（最外层区间除外）。</p>\r\n<p>换句话说，假如有 temperatures[i],temperatures[i+1] 两个气温：</p>\r\n<ul>\r\n<li>temperatures[i+1] &gt; temperatures[i]，则 i+1 就是 i 的新高温</li>\r\n<li>temperatures[i+1] &lt; temperatures[i]，则 i+1 的新高温肯定比 i\r\n的新高温更先出现，即有点后进先出的特性，考虑用栈。</li>\r\n</ul>\r\n<p>遍历 temperatures，并且维护一个栈：</p>\r\n<ul>\r\n<li>如果当前元素比栈顶元素小，那么它的新高温肯定比栈顶元素先出现，因此压入栈顶。</li>\r\n<li>如果当前元素比栈顶元素大，那么它可以作为栈顶元素的新高温，并且也可能是栈顶往下的元素的新高温，保持出栈，直到比当前栈顶元素小。</li>\r\n</ul>\r\n<h3 id=\"题解代码\">题解代码</h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dailyTemperatures</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; T)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        stack&lt;<span class=\"keyword\">int</span>&gt; lower;<span class=\"comment\">//保存的是下标而不是值，便于下标相减</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">result</span><span class=\"params\">(T.size(),<span class=\"number\">0</span>)</span></span>;<span class=\"comment\">//结果数组</span></span><br><span class=\"line\">        lower.<span class=\"built_in\">push</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;T.<span class=\"built_in\">size</span>();i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!lower.<span class=\"built_in\">empty</span>() &amp;&amp; T[i]&gt;T[lower.<span class=\"built_in\">top</span>()])<span class=\"comment\">//把所有比它小的出栈，并且计算差值</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result[lower.<span class=\"built_in\">top</span>()]=i-lower.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">                lower.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            lower.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"栈模拟队列\">栈模拟队列</h2>\r\n<p>栈后进先出，队列先进先出，容易想到通过两个栈的负负得正实现。假设有\r\nS1，S2 两个栈。 S1 用来入队，S2 用来出队。</p>\r\n<h3 id=\"双栈负负得正\">双栈负负得正</h3>\r\n<p>出栈时，先把原 S1 栈里所有元素倒进另一个栈 S2，这样队首是在 S2\r\n的顶部，即可出栈队首元素。</p>\r\n<p>入栈时，则再把 S2 这些元素倒回去，此时队尾在 S1\r\n的顶部，把元素压入即可。</p>\r\n<h3 id=\"优化\">优化</h3>\r\n<p>考虑到，入栈时把 S2 元素倒回 S1\r\n挺浪费效率的，因为出栈时又得倒过来。</p>\r\n<p>而且值得注意的是，S2 元素倒给 S1，S1 压入 N 个元素，再全部倒回 S2，原\r\nS2 元素还是在 S2 的顶部，即压入对其出队不产生影响。因此每次将 S1\r\n的元素倒给 S2 后，就不必要再拿回来了。S1 该压栈压栈，S2 该出栈出栈，S2\r\n空了再把 S1 现有元素全部倒过去。</p>\r\n<h2 id=\"中缀运算表达式转后缀表达式\">中缀运算表达式转后缀表达式</h2>\r\n<p>准备两个栈，一个运算数栈，一个运算符栈。</p>\r\n<p>从左到右依次扫描中缀表达式每个元素：</p>\r\n<ol type=\"1\">\r\n<li>如果是'('，则入栈。</li>\r\n<li>如果是')', 则持续出栈运算，直到出了一个'('。</li>\r\n<li>是其他运算符，如果比栈顶运算符优先级高，压栈。如果比栈顶优先级低，则先出栈运算，再比较新的栈顶。</li>\r\n</ol>\r\n<p>出栈运算：出栈一个运算符和两个运算数进行运算，把运算结果压回运算数栈。</p>\r\n<h1 id=\"队列相关算法\">队列相关算法</h1>\r\n<h3 id=\"基础-bfs-解法\">基础 BFS 解法</h3>\r\n<p>每个位置有两个滚动方向，四个位置即每个状态可以有 2*4=8\r\n个移动方向。我们要最短次数到达\r\ntarget，即完成一个最短路径搜索问题。容易想到就是 BFS 了。</p>\r\n<p>BFS 需要注意几个点：</p>\r\n<ul>\r\n<li>因为位置可以往回滚动，要限制不能走回头路，利用 set 判重。</li>\r\n<li>需要记录层次深度，考虑队列添加 null\r\n结点或者记录当前层次大小的办法。</li>\r\n<li>当前状态滚动到 target\r\n状态是有趋向的，因此可以考虑通过每个位置的距离决定应该优先朝上还是朝下滚，当然由于\r\ndeadends 的存在，不能只滚优先的那边。</li>\r\n</ul>\r\n<h3 id=\"双向-bfs-解法\">双向 BFS 解法</h3>\r\n<p>由于单向 BFS\r\n是金字塔结构，越往里每个层次的数越来越多，甚至是指数级增长，搜索难度越来越大。末端每增加一个层次的搜索开销，是前期层次开销的指数倍。</p>\r\n<p>因此考虑从起点和 target 点两端同时\r\nBFS，即多进行前期层次的搜索，减少后期末端层次的搜索。相对而言即是用倍数级开销替代了指数级开销。</p>\r\n<p>双向 BFS 注意：</p>\r\n<ul>\r\n<li>搜索终点是两个 BFS 相交，因此要使用 set 进行交集判断。</li>\r\n</ul>\r\n","categories":["算法"],"tags":["排序","二叉树"]},{"title":"屏蔽B站PC首页直播块舞蹈区","url":"/2021/01/28/%E5%B1%8F%E8%94%BDB%E7%AB%99%E9%A6%96%E9%A1%B5%E7%9B%B4%E6%92%AD%E5%9D%97%E8%88%9E%E8%B9%88%E5%8C%BA%E5%85%83%E7%B4%A0/","content":"<p>一直以来喜欢没事挂在B站首页，然后看看有没有些有趣的人直播好玩的东西什么的。然而，B站首推的主播大多都是舞见唱见，视频陪聊什么的，流量至上没有错，但是让我目标信息获取率极低就很烦。</p>\r\n<p>因此找了找根据分区删除元素的方式：</p>\r\n<p><code>www.bilibili.com##.live-card:has-text(舞见)</code></p>\r\n<h2 id=\"工具\">工具</h2>\r\n<ul>\r\n<li><p>Chrome系浏览器，可以用Chrome插件</p></li>\r\n<li><p>浏览器安装一个广告拦截插件，如Ads Killer Plus</p></li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<h2 id=\"添加屏蔽规则\">添加屏蔽规则</h2>\r\n<p>通常广告拦截插件都支持自定义规则，而显然舞见直播什么的不会被内置定义为广告，虽然实际上差不多。\r\n因此我们要自己写选择舞见的过滤器。 以Ads Killer Plus为例：</p>\r\n<p>首页直播块结构如下：.live-card &gt; a &gt; .up &gt; .txt &gt; .\r\ntag</p>\r\n<p>tag值即是主播分区名，如视频唱见、舞见...</p>\r\n<p>我们想要通过 tag=舞见\r\n去删除.live-card元素，正常的类选择器好像只能根据父元素选择子元素，而不能反过来。</p>\r\n<p>这时候就需要用到插件的扩展语法功能，例如这款插件有如下两个选择语法：</p>\r\n<h3 id=\"subjecthasarg\">subject:has(arg)</h3>\r\n<p>如果subject自身及其子元素有arg元素，则选定subject元素</p>\r\n<p>使用方法即正常选择器选出一个subject对象，然后后面加上<code>:has(arg)</code>，arg\r\n也是一个选择器对象。</p>\r\n<ul>\r\n<li>Description: Select element subject if and only if evaluating arg in\r\nthe context of subject returns one or more elements.</li>\r\n<li>Chainable: Yes.</li>\r\n<li>subject: Can be a plain CSS selector, or a procedural cosmetic\r\nfilter.</li>\r\n<li>arg: A valid plain CSS selector or procedural cosmetic filter, which\r\nis evaluated in the context of the subject element.</li>\r\n</ul>\r\n<h3 id=\"subjecthas-textneedle\">subject:has-text(needle)</h3>\r\n<p>如果subject自身及其子元素有needle文本值，则选定subject元素。\r\nneedle可用正则表达式。</p>\r\n<ul>\r\n<li>Description: Select element subject if the text needle is found\r\ninside the element subject or its children.</li>\r\n<li>Chainable: Yes.</li>\r\n<li>subject: Can be a plain CSS selector, or a procedural cosmetic\r\nfilter.</li>\r\n<li>needle: The literal text which must be found, or a literal regular\r\nexpression. If using a literal regular expression, you can optionally\r\nuse the i and/or m flags (version 1.15).</li>\r\n</ul>\r\n<blockquote>\r\n<p>注意冒号后面不能有空格</p>\r\n</blockquote>\r\n<p>我们只需判断分区文本值，因此用has-text即可，最终在自定义规则列表中添加如下规则应用：</p>\r\n<blockquote>\r\n<p>www.bilibili.com##.live-card:has-text(/电台|陪伴学习|萌宠|唱见|舞见|视频|虚拟主播/)</p>\r\n</blockquote>\r\n<h2 id=\"后话\">后话</h2>\r\n<p>上述规则会选定整个live-card板块，因此删除后B站直播块可能会有点排版不整齐，如果仅删除live-card下的a元素，则删除后会在原位置保留一块空白，保持元素排版整齐。</p>\r\n<p>另外这种方式应该适用于所有通过子类屏蔽父类的想法。</p>\r\n","categories":["工具"]},{"title":"开源协议(讲稿)","url":"/2021/12/30/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/","content":"<blockquote>\r\n<p>课程研讨讲稿，搜集资料的集合，完全非原创，仅供临时参考。</p>\r\n</blockquote>\r\n<p>近年来，开源正在变得越来越火，我们经常会看到\r\n“某企业宣布开源”、“某开源大会召开”、“某开源项目获得融资”。个人开发者与企业比以往任何时候都更愿意参与到开源项目的建设和贡献中，开源在国内\r\nIT 领域获得了前所未有的热度，也获得了产业界和投资圈的广泛关注。</p>\r\n<p>但总有些人听到开源一词时，就会误以为\r\n“<strong>开源软件是免费的，因此我可以不受限制地随意使用</strong>”。在开源诞生之初，自由软件是当时的主流提法，回顾开源的发展史，从自由软件到开源运动实现了非常大的跨越，前者更多的是一种精神的倡导，而后者着眼于软件的协同开放，因此会有非常严谨的开源许可证的规则和限制。开源软件能走到今天的发展程度，就是因为有了这么一套遵从开源精神的规则体系，才能够健康发展。开源精神的载体之一就是开源许可证，今天我们就来扒一扒开源许可证与开源的关系，以及它背后折射出的问题。</p>\r\n<span id=\"more\"></span>\r\n<hr />\r\n<h1 id=\"自由软件和开源软件\">自由软件和开源软件</h1>\r\n<p>开源软件与自由软件是两个不同的概念，只要符合开源软件定义的软件就能被称为开源软件。</p>\r\n<p>而自由软件有比开源软件更严格的概念，因此所有自由软件都是开放源代码的，但不是所有的开源软件都能被称为“自由”。但一般，绝大多数开源软件也都符合自由软件的定义。</p>\r\n<ol type=\"1\">\r\n<li>开源代码是，使用开放的开发方式，尽可能的使软件优化，公开，但不一定给予自由权。</li>\r\n<li>自由软件的原意就是要给予用户运用软件的自由，这个‘自由’就是自由软件的精神所在。</li>\r\n</ol>\r\n<p><strong>免费软件</strong>：是一种不须付费就可获取的软件，但是通常有其他的限制，用户并没有使用、复制、研究、修改和分发的自由。该软件的源代码不一定会公开。</p>\r\n<h1 id=\"什么是开源协议\">什么是开源协议？</h1>\r\n<p>OpenSource\r\nSoftware(OSS)：可以获取源代码的软件。如果一个程序员想将自己的代码开源，他有许多种选择，大致可以分成三类：</p>\r\n<ol type=\"1\">\r\n<li>将代码放入\"公共领域\"（public domain），彻底放弃版权。</li>\r\n<li>选择谨慎的许可证，如GPL，要求衍生代码必须开源。</li>\r\n<li>选择更宽松的许可证，比如BSD和Apache许可证，不要求衍生代码开源。</li>\r\n</ol>\r\n<p>两大阵营，FSF和OSI，对开源有着不同的理念。</p>\r\n<h2 id=\"fsffree-software-foundation自由软件基金会\">FSF（Free Software\r\nFoundation，自由软件基金会)</h2>\r\n<p>FSF 是开源泰斗 <strong>理查德·斯托曼 RMS</strong>\r\n创立的重要的开源软件基金会 (1985/10/04), FSF\r\n创立之初主要是为了筹集资金来建设 <strong>GNU：GNU is Not Unix</strong>\r\n的内核 Hurd 项目及工具链，虽然 GNU\r\n项目本身没有完成，但是该过程中创造出的大量软件工具，日后成为了 GNU/Linux\r\n的重要组成部分。</p>\r\n<p>FSF 建立了开源领域的第一个 <strong>copyleft</strong> 属性的许可证 -\r\n<strong>GPL (GNU Public License)</strong> 。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/n0x5S9v.png\" alt=\"RMS\" />\r\n<figcaption aria-hidden=\"true\">RMS</figcaption>\r\n</figure>\r\n<h3 id=\"copyleft\">CopyLeft</h3>\r\n<figure>\r\n<img src=\"https://i.imgur.com/LdcKipT.png\"\r\nalt=\"Copyleft：镜像而不是翻转。Copyleft保留著作权，而不是放弃著作权\" />\r\n<figcaption\r\naria-hidden=\"true\">Copyleft：镜像而不是翻转。Copyleft保留著作权，而不是放弃著作权</figcaption>\r\n</figure>\r\n<p>Copyleft是指任何人都可以重新分发软件，不管有没有进行修改，但必须同时保留软件所具有的自由特性。即拥有著作权，仅用于保护其自由。</p>\r\n<blockquote>\r\n<p>The licenses for most software and other practical works are designed\r\nto take away your freedom to share and change the works. By contrast,\r\nthe GNU General Public License is intended to guarantee your freedom to\r\nshare and change all versions of a program--to make sure it remains free\r\nsoftware for all its\r\nusers.（大多数软件许可是设计用以剥夺你的分享与修改软件的自由。相反地，GNU通用公共许可则是要保证您分享与修改自由软件的自由——确保软件对所有的用户而言都是自由的。）</p>\r\n</blockquote>\r\n<h3 id=\"gpl\">GPL</h3>\r\n<figure>\r\n<img src=\"https://i.imgur.com/bqc0c64.png\" alt=\"GPL\" />\r\n<figcaption aria-hidden=\"true\">GPL</figcaption>\r\n</figure>\r\n<p>GPL是第一个Copyleft类型的许可证，全身心追求软件的<strong>自由</strong>：</p>\r\n<ul>\r\n<li>基于任何目的，按你的意愿运行软件的<strong>自由</strong>。</li>\r\n<li>学习软件如何工作的自由，按你的意愿修改软件以符合你的计算的<strong>自由</strong>。</li>\r\n<li>分发软件副本的<strong>自由</strong>，因此你可以帮助你的好友。</li>\r\n<li>将你修改过的软件版本再分发给其他人的<strong>自由</strong>。这样可以让整个社区有机会共享你对软件的改动。</li>\r\n</ul>\r\n<p>GPL与其他一些更“许可的”自由软件许可证（比如BSD许可证）相比，主要区别就在于<strong>GPL寻求确保上述自由能在复制软件及派生作品中得到保障</strong>，要求GPL程序的派生作品也要在GPL之下。相反，BSD式的许可证并不禁止演绎作品变成专有软件。</p>\r\n<p>GPL保护的一个典型例子就是著名的 2009甲骨文收购SUN公司事件，Michael\r\nWidenius，MySQL创始人四处呼吁反对收购，因为他觉得甲骨文自己本来就做Oracle数据库，拥有了MySQL后只会杀死它。然而，MySQL是杀不死的：它的许可证是<strong>GPL</strong>。</p>\r\n<p>著名的应用：MySQL</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/dFsOCjk.png\" alt=\"MySQL许可证\" />\r\n<figcaption aria-hidden=\"true\">MySQL许可证</figcaption>\r\n</figure>\r\n<h2 id=\"osiopen-source-initiative开放源代码促进会\">OSI（Open Source\r\nInitiative，开放源代码促进会）</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/AR2BNJO.png\" alt=\"OSI\" />\r\n<figcaption aria-hidden=\"true\">OSI</figcaption>\r\n</figure>\r\n<p>OSI 由开源界泰斗 Bruce Perens 和 Eric S. Raymond (ESR) 在 1998\r\n年组建，目的是在理想的自由软件与商业之间达成一个平衡，务实的开源行动，负责管理各种开源规范。OSI\r\n组织认证过的许可大概有 80 种，包括 Apache License 、GPL 、MIT/BSD\r\n等。</p>\r\n<h1 id=\"开源许可证open-source-license\">开源许可证(Open Source\r\nLicense)</h1>\r\n<h2 id=\"lesser-gpl\">Lesser GPL</h2>\r\n<p>强制开源虽然很美好，但是现实不是理想国。除开一部分理想主义者，别人凭什么要居人篱下呢？LGPL允许LGPL授权的软件集成至他们自己的软件内（即使该软件是私有软件也被允许），同时不会受到Copyleft特性的许可证强制对软件开源的限制。该许可证常被用于一些（但不是全部）GNU程序库。</p>\r\n<blockquote>\r\n<p>\"After all, there are plenty of other C libraries; using the GPL for\r\nours would have driven proprietary software developers to use\r\nanother--no problem for them, only for us.\"\r\n\"毕竟，市场上的C库有的是。GPL许可证将迫使私有软件去使用他人的库，这不会给他们带来困扰，只会给我们带来困扰。\"</p>\r\n</blockquote>\r\n<h2 id=\"bsd\">BSD</h2>\r\n<p>是自由软件中使用最广泛的许可协议之一。从copyleft到copyright，BSD许可证往往认为是<strong>copycenter</strong>：</p>\r\n<ol type=\"1\">\r\n<li>源代码传播，则必须带有原来的BSD协议。</li>\r\n<li>二进制传播，则需在版权声明中带有原来的BSD协议。</li>\r\n<li>传播产品不能用原来的信息来进行市场推广。</li>\r\n</ol>\r\n<p>因此是对商业集成很友好的协议，而很多的公司企业在选用开源产品的时候都首选BSD协议。</p>\r\n<p>有意思的小故事：</p>\r\n<blockquote>\r\n<p>3.所有提及该软件功能或者使用该软件的广告材料必须展示以下致谢：本产品包含由加州大学伯克利分校及其贡献者开发的软件。</p>\r\n</blockquote>\r\n<p>最初，令人反感的BSD广告条款只是在伯克利软件发行版中使用。因为在广告中包含一句话并不是十分困难，所以此条款并没有引起特别的问题。</p>\r\n<p>如果其他使用BSD类许可证的开发者逐字拷贝了BSD广告条款—包含了指向加州大学的句子—，那么他们也没有使问题变大。</p>\r\n<p>但是，可能正如你所预见，有些开发者不是逐字拷贝该条款。他们做了改动，把“加州大学”换成了他们自己机构的名称。结果就是有了太多的许可证，需要使用太多的句子。</p>\r\n<h2 id=\"apache-license-asl\">Apache License (ASL)</h2>\r\n<p>ASL 也是商业公司偏爱的许可证，</p>\r\n<ol type=\"1\">\r\n<li>每个被修改的文件中，都需要说明更改。</li>\r\n<li>对所有未修改部分，保留所有原有的著作权，专利，商标等归属。</li>\r\n</ol>\r\n<p>著名的应用有 Android：</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/8SBygKM.png\" alt=\"Android许可证\" />\r\n<figcaption aria-hidden=\"true\">Android许可证</figcaption>\r\n</figure>\r\n<h2 id=\"mit-license\">MIT License</h2>\r\n<p>特此授予任何人免费获得本软件和相关文档文件（“软件”）副本的许可，不受限制地处理本软件，包括但不限于使用、复制、修改、合并\r\n、发布、分发、再许可的权利，\r\n被许可人有权利使用、复制、修改、合并、出版发行、散布、再许可和/或贩售软件及软件的副本，及授予被供应人同等权利，惟服从以下义务。</p>\r\n<p>在软件和软件的所有副本中都必须包含以上著作权声明和本许可声明。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/RyVOFow.png\" alt=\"开源协议简单对比\" />\r\n<figcaption aria-hidden=\"true\">开源协议简单对比</figcaption>\r\n</figure>\r\n<h1 id=\"参考文献\">参考文献</h1>\r\n<p><a href=\"https://zh.wikipedia.org/wiki/Copyleft\">Copyleft维基百科</a>\r\n<a\r\nhref=\"http://www.ruanyifeng.com/blog/2010/02/why_gpl_is_a_better_choice.html\">阮一峰-开源协议</a></p>\r\n","categories":["工具"]},{"title":"循环神经网络","url":"/2021/12/21/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","content":"<h2 id=\"rnn\">RNN</h2>\r\n<h3 id=\"循环层\">循环层：</h3>\r\n<p><span class=\"math display\">\\[\r\n\\mathbf{H}_t = \\phi(\\mathbf{X}_t \\mathbf{W}_{xh} + \\mathbf{H}_{t-1}\r\n\\mathbf{W}_{hh}  + \\mathbf{b}_h).\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"https://zh-v2.d2l.ai/_images/rnn.svg\"\r\nalt=\"隐状态循环神经网络\" />\r\n<figcaption aria-hidden=\"true\">隐状态循环神经网络</figcaption>\r\n</figure>\r\n<h3 id=\"困惑度损失函数\">困惑度损失函数：</h3>\r\n<p>一个更好的语言模型应该能让我们更准确地预测下一个词元。\r\n因此，它应该允许我们在压缩序列时花费更少的比特。\r\n所以我们可以通过一个序列中所有的 n\r\n个词元的交叉熵损失的平均值来衡量：</p>\r\n<p><span class=\"math display\">\\[\r\n\\frac{1}{n} \\sum_{t=1}^n -\\log P(x_t \\mid x_{t-1}, \\ldots, x_1)\r\n\\]</span></p>\r\n<p><strong>困惑度</strong>即更流行的指数形式交叉熵（历史原因）：</p>\r\n<p><span class=\"math display\">\\[\r\n\\exp\\left(-\\frac{1}{n} \\sum_{t=1}^n \\log P(x_t \\mid x_{t-1}, \\ldots,\r\nx_1)\\right).\r\n\\]</span></p>\r\n<ul>\r\n<li>在最好的情况下，模型总是完美地估计标签词元的概率为1。\r\n在这种情况下，模型的困惑度为1。</li>\r\n<li>在最坏的情况下，模型总是预测标签词元的概率为0。\r\n在这种情况下，困惑度是正无穷大。</li>\r\n<li>Baseline：该模型的预测是词表的所有可用词元上的均匀分布？\r\n在这种情况下，困惑度等于词表中唯一词元的数量。\r\n事实上，如果我们在没有任何压缩的情况下存储序列，\r\n这将是我们能做的最好的编码方式。 因此，这种方式提供了一个重要的上限，\r\n而任何实际模型都必须超越这个上限。</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<h3 id=\"初始化状态\">初始化状态</h3>\r\n<p><strong>使用onehot编码来代替直接输入索引值</strong></p>\r\n<p><strong>预热期</strong>：更新隐状态信息但不计算预测</p>\r\n<p><strong>初始化隐状态</strong>：</p>\r\n<ul>\r\n<li>顺序分区：下一个minibatch和当前minibatch取得的时间步相邻。因此当前minibatch的隐状态可以用于初始化下一个minibatch。\r\n为了降低计算量，在处理任何一个minibatch数据之前，\r\n我们先分离梯度，使得隐状态的梯度计算总是限制在一个minibatch数据的时间步中。</li>\r\n<li>随机分区：每个minibatch需要重新初始化隐状态。</li>\r\n</ul>\r\n<h3 id=\"时间步反向传播bbtt\">时间步反向传播BBTT：</h3>\r\n<p>对于每个时间步计算隐状态和输出，有：<span class=\"math inline\">\\(h_t =\r\nf(x_t, h_{t-1}, w_h),o_t = g(h_t, w_o)\\)</span>。在反向传播时，<span\r\nclass=\"math inline\">\\(L\\)</span>依赖于所有的<span\r\nclass=\"math inline\">\\(o_t\\)</span>，即<span class=\"math inline\">\\(L(x_1,\r\n\\ldots, x_T, y_1, \\ldots, y_T, w_h, w_o) = \\frac{1}{T}\\sum_{t=1}^T\r\nl(y_t, o_t).\\)</span>。因此在<span\r\nclass=\"math inline\">\\(L\\)</span>对<span\r\nclass=\"math inline\">\\(W_h\\)</span>求梯度时，有：</p>\r\n<p><span class=\"math display\">\\[\r\n\\frac{\\partial L}{\\partial w_h} = \\frac{1}{T}\\sum_{t=1}^T \\frac{\\partial\r\nl(y_t, o_t)}{\\partial o_t} \\frac{\\partial g(h_t, w_o)}{\\partial\r\nh_t}  \\frac{\\partial h_t}{\\partial w_h}\r\n\\]</span></p>\r\n<p>其中 <span class=\"math inline\">\\(h_t\\)</span> 递归依赖于 <span\r\nclass=\"math inline\">\\(h_{t-1}\\)</span>，<span\r\nclass=\"math inline\">\\(h_{t-1}\\)</span>同样依赖于<span\r\nclass=\"math inline\">\\(w_h\\)</span>，造成递归依赖，因此计算链式法则会很长，化简结果为：</p>\r\n<p><span class=\"math display\">\\[\r\n\\frac{\\partial h_t}{\\partial w_h}=\\frac{\\partial\r\nf(x_{t},h_{t-1},w_h)}{\\partial\r\nw_h}+\\sum_{i=1}^{t-1}\\left(\\prod_{j=i+1}^{t} \\frac{\\partial\r\nf(x_{j},h_{j-1},w_h)}{\\partial h_{j-1}} \\right) \\frac{\\partial\r\nf(x_{i},h_{i-1},w_h)}{\\partial w_h}.\r\n\\]</span></p>\r\n<h3 id=\"截断反向传播\">截断反向传播</h3>\r\n<p>显然完全计算整条时间链是非常昂贵的，而且容易梯度爆炸蝴蝶效应。</p>\r\n<p><strong>常规截断时间步</strong>：即常用的detach\r\nstate。把state链限定在相同长度的时间碎片内。</p>\r\n<p><strong>随机截断时间步</strong>：使用一个随机变量替换<span\r\nclass=\"math inline\">\\(\\partial h_t/\\partial w_h\\)</span>。\r\n这个随机变量是通过使用序列 <span class=\"math inline\">\\(ξ_t\\)</span>\r\n来实现的。 <span class=\"math inline\">\\(ξ_t\\)</span> 定义：对于$ 0≤π_t≤1\r\n$， 其中 <span class=\"math inline\">\\(P(ξ_t=0)=1−π_t\\)</span> 且\r\n$P(ξ_t=π^{−1}_t)=π_t $， 因此 <span\r\nclass=\"math inline\">\\(E[ξ_t]=1\\)</span>。，将<span\r\nclass=\"math inline\">\\(ξ_t\\)</span>放在<span\r\nclass=\"math inline\">\\(\\frac{\\partial h_t}{\\partial\r\nw_h}\\)</span>中，得到：</p>\r\n<p><span class=\"math display\">\\[\r\nX_t= \\frac{\\partial f(x_{t},h_{t-1},w_h)}{\\partial w_h} +\\xi_t\r\n\\frac{\\partial f(x_{t},h_{t-1},w_h)}{\\partial h_{t-1}} \\frac{\\partial\r\nh_{t-1}}{\\partial w_h}.\r\n\\]</span></p>\r\n<p>当<span class=\"math inline\">\\(ξ_t=0\\)</span>时即会截断递归。通过<span\r\nclass=\"math inline\">\\(E[ξ_t]=1\\)</span>，得到<span\r\nclass=\"math inline\">\\(E[X_t] = \\partial h_t/\\partial\r\nw_h\\)</span>。即不改变期望值，但是截断反向传播。</p>\r\n<h3 id=\"梯度裁剪\">梯度裁剪</h3>\r\n<p>使用给定半径 <span class=\"math inline\">\\(θ\\)</span> 的球来裁剪梯度\r\n<span class=\"math inline\">\\(g\\)</span>，<span class=\"math inline\">\\(g\r\n&lt; θ\\)</span> 则不变，$ g &gt; θ $ 则裁剪到 <span\r\nclass=\"math inline\">\\(θ\\)</span> ， 并且更新后的梯度完全与 <span\r\nclass=\"math inline\">\\(g\\)</span> 的原始方向对齐。\r\n它还有一个值得拥有的副作用，\r\n即限制任何给定的小批量数据（以及其中任何给定的样本）对参数向量的影响，\r\n这赋予了模型一定程度的稳定性。 如下式：</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathbf{g} \\leftarrow \\min\\left(1, \\frac{\\theta}{\\|\\mathbf{g}\\|}\\right)\r\n\\mathbf{g}.\r\n\\]</span></p>\r\n<h2 id=\"语言模型处理\">语言模型处理</h2>\r\n<h3 id=\"文本计数问题\">文本计数问题</h3>\r\n<p><strong>拉普拉斯平滑</strong> 具体方法是在所有计数中添加一个小常量。\r\n用 n 表示训练集中的单词总数，用 m 表示唯一单词的数量</p>\r\n<span class=\"math display\">\\[\\begin{split}\\begin{aligned}\r\n    \\hat{P}(x) &amp; = \\frac{n(x) + \\epsilon_1/m}{n + \\epsilon_1}, \\\\\r\n    \\hat{P}(x&#39; \\mid x) &amp; = \\frac{n(x, x&#39;) + \\epsilon_2\r\n\\hat{P}(x&#39;)}{n(x) + \\epsilon_2}, \\\\\r\n    \\hat{P}(x&#39;&#39; \\mid x,x&#39;) &amp; = \\frac{n(x,\r\nx&#39;,x&#39;&#39;) + \\epsilon_3 \\hat{P}(x&#39;&#39;)}{n(x, x&#39;) +\r\n\\epsilon_3}.\r\n\\end{aligned}\\end{split}\\]</span>\r\n<p>注意词频以一种明确的方式迅速衰减。齐普夫定律（Zipf’s law）， 即第 i\r\n个最常用单词的频率 <span class=\"math inline\">\\(n_i\\)</span> 为：<span\r\nclass=\"math inline\">\\(n_i \\propto\r\n\\frac{1}{i^\\alpha}\\)</span>，等价于<span class=\"math inline\">\\(\\log n_i\r\n= -\\alpha \\log i + c\\)</span>。</p>\r\n<p>因此对不常用单词进行计数统计和平滑建模是不可行的。</p>\r\n<h3 id=\"深度学习模型读取长数据\">深度学习模型读取长数据</h3>\r\n<p>从随机偏移量开始划分序列，\r\n以同时获得覆盖性（coverage）和随机性（randomness）</p>\r\n<p><strong>随机分区</strong>和<strong>顺序分区</strong></p>\r\n<h2 id=\"编码器-解码器\">编码器-解码器</h2>\r\n<h3 id=\"训练模式和预测模式\">训练模式和预测模式</h3>\r\n<p>训练模式中，解码器的输入可以就是真实label，而无需逐时间步计算出新的output，再给到下一个时间步进行计算。</p>\r\n<p>预测模式中，由于不知道解码器真实label，因此必须要按照正常的RNN计算方式，逐时间步计算output和state，并且把output和state再给到下一个时间步进行计算。</p>\r\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"数据结构的内存对齐分析","url":"/2023/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%88%86%E6%9E%90/","content":"<h1 id=\"概念讨论\">概念讨论</h1>\r\n<p>内存对齐是一个很基础的概念。虽然内存地址的单位是字节，但是CPU访存指令大部分都是以<strong>机器字长</strong>(64位的CPU机器字长即8字节)为单位，并且由于内存提供的访存电路接口限制，CPU只能从<strong>机器字长的倍数的地址</strong>开始访问。即CPU能够在一条指令中访存0000-0007，但是不能够从0003-0010，而必须拆分成两条访存指令，分别从0000和0008开始。</p>\r\n<blockquote>\r\n<p>CPU按机器字长访存容易理解，但是只能从倍数地址开始访问难以让人理解。据<a\r\nhref=\"https://stackoverflow.com/questions/3655926/why-does-cpu-access-memory-on-a-word-boundary\">参考</a>，倍数地址的限制更多来源于内存访问器的硬件连线限制。</p>\r\n</blockquote>\r\n<p>在没有内存对齐的情况下，假设有两个连续数据INT8,INT64，分别占据了地址0000和0001-0008。此时64位CPU需要几次访存才能拿到INT64数据呢？</p>\r\n<ol type=\"1\">\r\n<li>首先访存0000-0007,拿到0001-0007的部分。</li>\r\n<li>再次访存0008-0015，拿到0008的部分。</li>\r\n</ol>\r\n<p>即需要访存两次才能取到数据。因此，通常程序会对数据的布局作出内存对齐，以优化访存效率。例如还是INT8和INT64，对齐后地址分别为0000和0008-0015。这样取INT64就只需要访存一次。</p>\r\n<p>据此，业界给出了一个内存对齐的基本原则：<strong>将X字节的数据放在X倍数的起始地址上</strong>。这样即可在尽可能节约内存空间的情况下，减少访存指令。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"代码分析\">代码分析</h1>\r\n<p>再来看看实际中的内存对齐规则是什么。如上基本原则，每个数据会希望把自己放在<strong>对齐数</strong>倍数的起始地址上：</p>\r\n<ol type=\"1\">\r\n<li>基本类型，对齐数 = sizeof(TYPE) ，即数据类型大小</li>\r\n<li>struct/class 作为一个类型，对齐数 = 最大的成员对齐数</li>\r\n<li>struct/class\r\n尾部填充。除了保证内部成员的对齐，由于数组的地址连续，我们还必须保证对于\r\nstruct[5] 这样的数组，每一个 struct[i]\r\n的起始地址都是对齐的，因此会在struct的尾部填充字节，并且计算在sizeof内，使得sizeof的结果是struct的对齐数的倍数。</li>\r\n</ol>\r\n<p>按上述原则分析下面的结构体：</p>\r\n<ol type=\"1\">\r\n<li><code>short f</code> 起始为\r\n0000，占据0000-0001，第一个元素不用考虑对齐。</li>\r\n<li><code>double s</code> 对齐数 = 8，因此对齐后占据 0008-0015。</li>\r\n<li><code>char i</code> 对齐数 = 1，因此对齐后占据 0016。</li>\r\n<li><code>int c</code> 对齐数 = 4，因此对齐后占据 0020-0023。</li>\r\n<li><code>char a</code> 对齐数 = 1，因此对齐后占据 0024。</li>\r\n<li>尾部填充。在没有进行尾部填充时，目前S1的大小为25字节(0000-0024)。S1的对齐数\r\n= 最大的成员对齐数 =\r\n8，根据对齐原则<code>sizeof(S1)</code>应该为8的倍数，所以最终将大小从25扩到32。</li>\r\n</ol>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S1</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"built_in\">S1</span>() &#123; f = <span class=\"number\">0</span>; s = <span class=\"number\">0</span>; i = <span class=\"number\">0</span>; c = <span class=\"number\">0</span>; a = <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">short</span> f;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> s;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">std::cout &lt;&lt; <span class=\"string\">&quot;S1各成员对齐后的起始字节：&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%zu &quot;</span>, <span class=\"built_in\">offsetof</span>(S1, f));</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%zu &quot;</span>, <span class=\"built_in\">offsetof</span>(S1, s));</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%zu &quot;</span>, <span class=\"built_in\">offsetof</span>(S1, i));</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%zu &quot;</span>, <span class=\"built_in\">offsetof</span>(S1, c));</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%zu &quot;</span>, <span class=\"built_in\">offsetof</span>(S1, a));</span><br><span class=\"line\">std::cout &lt;&lt;std::endl&lt;&lt; <span class=\"string\">&quot;S1 最终大小&quot;</span> &lt;&lt; <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(S1) &lt;&lt; std::endl;</span><br><span class=\"line\">std::cout &lt;&lt;<span class=\"string\">&quot;S1 对齐数&quot;</span> &lt;&lt; <span class=\"built_in\"><span class=\"keyword\">alignof</span></span>(S1) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>\r\n<p>再来看嵌套结构体：</p>\r\n<ol type=\"1\">\r\n<li><code>int d</code> 起始为 0000，占据\r\n0000-0003，第一个元素不用考虑对齐。</li>\r\n<li><code>S1 s1</code> 对齐数为 8，大小为32字节，因此对齐后占据\r\n0008-0039。</li>\r\n<li><code>char c</code> 对齐数为 1，因此对齐后占据 0040。</li>\r\n<li><code>int i</code> 对齐数为 4，因此对齐后占据 0044-0047。</li>\r\n<li>尾部填充，S2 对齐数为\r\n8，目前大小为48字节，满足要求，不需要尾部填充。</li>\r\n</ol>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S2</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"built_in\">S2</span>() &#123; d = <span class=\"number\">0</span>; c = <span class=\"number\">0</span>; i = <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> d;</span><br><span class=\"line\">    S1 s1;<span class=\"comment\">//24</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">std::cout &lt;&lt; <span class=\"string\">&quot;S2各成员偏移后的起始字节：&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%zu &quot;</span>, <span class=\"built_in\">offsetof</span>(S2, d));</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%zu &quot;</span>, <span class=\"built_in\">offsetof</span>(S2, s1));</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%zu &quot;</span>, <span class=\"built_in\">offsetof</span>(S2, c));</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%zu &quot;</span>, <span class=\"built_in\">offsetof</span>(S2, i));</span><br><span class=\"line\">std::cout &lt;&lt; std::endl &lt;&lt; <span class=\"string\">&quot;S2 最终大小&quot;</span> &lt;&lt; <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(S2) &lt;&lt; std::endl;</span><br><span class=\"line\">std::cout &lt;&lt;<span class=\"string\">&quot;S2 对齐数&quot;</span> &lt;&lt; <span class=\"built_in\"><span class=\"keyword\">alignof</span></span>(S2) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>\r\n<p>class和struct的对齐规则是一样的，不过需要注意两点：</p>\r\n<ol type=\"1\">\r\n<li>继承了基类成员的class，其会在头部先排基类成员。</li>\r\n<li>拥有虚函数的class其会在头部添加一个指针成员<code>vfptr</code>，即虚函数表的指针。</li>\r\n</ol>\r\n<h1 id=\"餐后甜点\">餐后甜点</h1>\r\n<ol type=\"1\">\r\n<li>cpp中可以通过<code>#pragma pack(max_size)</code>命令强制设置一个对齐数的上限，例如在<code>#pragma pack(4)</code>的环境下S1中的double的对齐数会变为4。</li>\r\n<li>cpp中空class的大小为1，便于实例化。</li>\r\n<li>其他更详细的class在继承多态下的成员分析，请参考这位<a\r\nhref=\"https://huailiang.github.io/blog/2021/cpp/\">病毒种的Blog</a></li>\r\n</ol>\r\n","categories":["基础"],"tags":["cpp"]},{"title":"文章收藏","url":"/2022/07/07/%E6%96%87%E7%AB%A0%E6%94%B6%E8%97%8F/","content":"<blockquote>\r\n<p>存放一些有所帮助、但又没写成自己的博客的网页文章。</p>\r\n</blockquote>\r\n<h1 id=\"unity\">Unity</h1>\r\n<p><a\r\nhref=\"https://unity.com/how-to/advanced-programming-and-code-architecture\">ADVANCED\r\nPROGRAMMING AND CODE ARCHITECTURE</a></p>\r\n<p><a\r\nhref=\"https://blog.unity.com/cn/engine-platform/6-ways-scriptableobjects-can-benefit-your-team-and-your-code\">ScriptableObject（可编程对象）为团队和代码带来的六个好处----Unity\r\nBlog</a></p>\r\n","categories":["杂记"]},{"title":"数据集","url":"/2021/12/09/%E6%95%B0%E6%8D%AE%E9%9B%86/","content":"<h3 id=\"ntu-rgbd-60120\">NTU RGB+D 60/120</h3>\r\n<p>56880/114480个深度视频序列，60/120种动作，最大的人类动作数据集之一。</p>\r\n<h3 id=\"nvgesture\">NVGesture</h3>\r\n<p>NVIDIA Dynamic Hand Gesture Dataset</p>\r\n<p>三种格式RGB, depth, IR 的图片。25类的1532个视频</p>\r\n<h3 id=\"shrec17\">SHREC’17</h3>\r\n<p>SHREC’17 Track Dataset 动态手势数据集</p>\r\n<p>14个手势类别的2800个视频。其中手势要么是单指的，要么是整手的。同时也提供了22个手关节的3D坐标，广泛用于基于骨骼的手势识别。</p>\r\n<h3 id=\"msr-action3d\"><a\r\nhref=\"https://sites.google.com/view/wanqingli/data-sets/msr-action3d\">MSR\r\nAction3D</a></h3>\r\n<p>MSR Action3D Dataset</p>\r\n<p>20类，每个类下10个主题。包含了胳膊，腿，躯干，及它们的组合的不同运动。也提供了20个关节位置。</p>\r\n<h3 id=\"upt-time-of-flight-3d-hand-gesture-database\"><a\r\nhref=\"https://www.kaggle.com/cdcaleanu/upt-tof-3d-hand-gesture-database?select=01_amp.bin\">UPT\r\nTime of Flight 3D Hand Gesture Database</a></h3>\r\n<p>Politehnica University的ToF手势数据集</p>\r\n<h3 id=\"s3dis\">S3DIS</h3>\r\n<p>室内场景点云语义分割数据集。</p>\r\n<p>6个区域，271个房间。每个场景有13类点云。</p>\r\n<h3 id=\"n-ucla\">N-UCLA</h3>\r\n<p>小型3D动作识别数据集，10类动作，3个视角</p>\r\n<h3 id=\"uwa3d\">UWA3D</h3>\r\n<p>小型3D动作识别数据集，30类动作。</p>\r\n","categories":["工具"],"tags":["深度学习"]},{"title":"本科生实训点云处理","url":"/2021/11/30/%E6%9C%AC%E7%A7%91%E7%94%9F%E5%AE%9E%E8%AE%AD%E7%82%B9%E4%BA%91%E5%A4%84%E7%90%86/","content":"<p>以点云为主体，提供两个方向自由选择：</p>\r\n<ul>\r\n<li>传统图形学点云处理</li>\r\n<li>深度学习下的点云处理</li>\r\n</ul>\r\n<blockquote>\r\n<p>点云，三维空间中的数据，例如二维空间下的数据是由像素组成的图像，三维空间下的数据就是由空间中的点组成的点云。</p>\r\n</blockquote>\r\n<h1 id=\"传统点云处理\">传统点云处理</h1>\r\n<p>根据点云处理库的教程学习实现以下任务</p>\r\n<ul>\r\n<li>可视化点云</li>\r\n<li>点云体素下采样</li>\r\n<li>点云滤波</li>\r\n<li>点云变换</li>\r\n<li>顶点法向估计</li>\r\n<li>点云表面重建</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<figure>\r\n<img src=\"https://i.imgur.com/66ncKvd.png\" alt=\"可视化点云\" />\r\n<figcaption aria-hidden=\"true\">可视化点云</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/XE2M5pM.png\" alt=\"体素下采样\" />\r\n<figcaption aria-hidden=\"true\">体素下采样</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/9Z318Q8.png\" alt=\"点云表面重建\" />\r\n<figcaption aria-hidden=\"true\">点云表面重建</figcaption>\r\n</figure>\r\n<h2 id=\"open3d-intel-2018\">Open3D [Intel 2018]</h2>\r\n<p>Intel 2018年提出的现代化的3D点云处理工具库。</p>\r\n<p><a\r\nhref=\"http://www.open3d.org/docs/release/introduction.html\">文档</a></p>\r\n<p>特性：</p>\r\n<ul>\r\n<li>支持Python，配置容易上手简单。也支持C++</li>\r\n<li>英文文档教程</li>\r\n<li>支持机器学习 TensorFlow 和 PyTorch</li>\r\n</ul>\r\n<h1 id=\"pcl\">PCL</h1>\r\n<p>老牌传统点云处理库</p>\r\n<p><a href=\"https://pointclouds.org/documentation/\">API文档</a>,<a\r\nhref=\"https://pcl.readthedocs.io/projects/tutorials/en/master/#\">教程</a>,<a\r\nhref=\"https://zhuanlan.zhihu.com/p/268524083\">PCL学习指南&amp;资料推荐（2021版）</a></p>\r\n<p>特性：</p>\r\n<ul>\r\n<li>仅支持C++，配置使用更繁杂</li>\r\n<li>发展久，点云算法涵盖更大更全，教程更加细致也更繁杂，网络资料也更容易找</li>\r\n</ul>\r\n<h1 id=\"点云深度学习\">点云深度学习</h1>\r\n<p>使用计图Jittor框架，了解深度学习基础，最后实现几个点云深度学习模型的实验,进行点云的分割、识别、处理等。</p>\r\n<h2 id=\"计图\">计图</h2>\r\n<p><a href=\"https://cg.cs.tsinghua.edu.cn/jittor/\">官网</a></p>\r\n<p><strong>清华开源机器学习框架——计图（Jittor）</strong>：动态编译,内部使用创新的元算子和统一计算图的深度学习框架，\r\n元算子和Numpy一样易于使用，并且超越Numpy能够实现更复杂更高效的操作。而统一计算图则是融合了静态计算图和动态计算图的诸多优点，在易于使用的同时，提供高性能的优化。</p>\r\n<p>前端语言为Python，类似于PyTorch。后端自动使用CUDA、CPU、GPU。平台：</p>\r\n<ul>\r\n<li>Linux(主要)</li>\r\n<li>Mac</li>\r\n<li>Windows(Beta，不稳定)</li>\r\n</ul>\r\n<p><strong>计图库支持的点云深度学习模型</strong>：</p>\r\n<ul>\r\n<li>PointNet</li>\r\n<li>PointNet++</li>\r\n<li>PointCNN</li>\r\n<li>DGCNN</li>\r\n<li>PointConv</li>\r\n</ul>\r\n<p>计图官网教程不多，需要自己主动找一些论文或者其他教程资料进行补充。</p>\r\n<figure>\r\n<img src=\"http://stanford.edu/~rqi/pointnet/images/teaser.jpg\"\r\nalt=\"PointNet的点云分类和分割\" />\r\n<figcaption aria-hidden=\"true\">PointNet的点云分类和分割</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"http://web.engr.oregonstate.edu/~wuwen/SegExp.png\"\r\nalt=\"PointConv点云分割\" />\r\n<figcaption aria-hidden=\"true\">PointConv点云分割</figcaption>\r\n</figure>\r\n","tags":["点云"]},{"title":"注意力机制","url":"/2021/12/21/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/","content":"<p>注意力机制三个核心要素：</p>\r\n<ul>\r\n<li>Query：即主动注意力。</li>\r\n<li>key：突出性的环境带给人的被动注意力</li>\r\n<li>value：注意力汇聚之后得到的最终输入</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://i.imgur.com/2ZgOmGZ.png\"\r\nalt=\"通过注意力汇聚将query和key结合在一起，然后对value进行选择输出\" />\r\n<figcaption\r\naria-hidden=\"true\">通过注意力汇聚将query和key结合在一起，然后对value进行选择输出</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h1 id=\"注意力本质是一种加权平均\">注意力——本质是一种加权平均</h1>\r\n<p>假设有<span class=\"math inline\">\\([(x_i,y_i), ...\r\n,(x_j,y_j)]\\)</span> 一系列配对输入，对于一个新的 <span\r\nclass=\"math inline\">\\(x\\)</span> ，我们想要预测它的 <span\r\nclass=\"math inline\">\\(y\\)</span>\r\n。此时我们会想参考过往的所有配对情况，来试着加权平均出这个 <span\r\nclass=\"math inline\">\\(y\\)</span>，例如我们可以平等对待所有过往经验：</p>\r\n<p><span class=\"math display\">\\[\r\nf(x)=\\frac{1}{n}\\sum_{i=1}^{n} y_{i}\r\n\\]</span></p>\r\n<p>显然这样是不准确的，对于任意输入<span\r\nclass=\"math inline\">\\(x\\)</span>都会得到同样的结果。因此我们还需要考虑<span\r\nclass=\"math inline\">\\(x\\)</span>的影响。继续直观地想，我们可以考虑<span\r\nclass=\"math inline\">\\(x\\)</span>与哪一个<span\r\nclass=\"math inline\">\\(x_i\\)</span>更接近，那么<span\r\nclass=\"math inline\">\\(y\\)</span>给到<span\r\nclass=\"math inline\">\\(y_i\\)</span>的权重也应该更大一些：</p>\r\n<p><span class=\"math display\">\\[\r\nf(x)=\\sum_{i=1}^{n} \\frac{K\\left(x-x_{i}\\right)}{\\sum_{j=1}^{n}\r\nK\\left(x-x_{j}\\right)} y_{i}=\\sum_{i=1}^{n} \\alpha\\left(x, x_{i}\\right)\r\ny_{i}\r\n\\]</span></p>\r\n<p>其中<span class=\"math inline\">\\(K\\)</span>是一种核函数，来表示<span\r\nclass=\"math inline\">\\(x_i\\)</span>与<span\r\nclass=\"math inline\">\\(x\\)</span>的权重关系，分母是权重和（即对于<span\r\nclass=\"math inline\">\\(x\\)</span>来说的固定值）。缩写之后得到<span\r\nclass=\"math inline\">\\(\\alpha(x,x_i)\\)</span>，即表示所谓的<strong>注意力权重</strong>，其累积和为1。回到注意力框架中，<span\r\nclass=\"math inline\">\\(x\\)</span>即是query,(x_i,y_i)即是(key,value)。<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>对<span\r\nclass=\"math inline\">\\(y_i\\)</span>的加权即是注意力汇聚，注意力权重即query和key的关系度量。</p>\r\n<p>对于核函数<span class=\"math inline\">\\(K\\)</span>，如果<span\r\nclass=\"math inline\">\\(K\\)</span>中计算函数固定，这样得到的就是<strong>非参数的注意力汇聚</strong>。如果<span\r\nclass=\"math inline\">\\(K\\)</span>中带有一些可变可学习的参数<span\r\nclass=\"math inline\">\\(w\\)</span>，那么得到的就是\r\n<strong>带参数的注意力汇聚</strong>。</p>\r\n<p>有了核函数以及加权平均的概念，此时就可以来看更细致的注意力机制：</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/Neqky4S.png\" alt=\"注意力机制的详细结构\" />\r\n<figcaption aria-hidden=\"true\">注意力机制的详细结构</figcaption>\r\n</figure>\r\n<p>其中核函数的单项计算部分可以看做是注意力评分函数（attention scoring\r\nfunction），核函数的多项累计部分可以看做softmax，转化评分为累计和为1的权重系数。最后与value数组进行加权计算，即是注意力汇聚的过程。</p>\r\n<h2 id=\"评分函数\">评分函数</h2>\r\n<h3 id=\"masked-softmax\">Masked Softmax</h3>\r\n<p>虽然是加权平均，但实际计算中存在很多value不需要进入加权计算。例如文本处理中的填充字符<pad>。因此可以使用一个Mask来过滤掉这些不必要的字符，再进行softmax。实际使用中对于想要去掉的元素，会赋值为一个非常大的负数，这样其softmax输出就是0.</p>\r\n<h3 id=\"additive-attention\">Additive Attention</h3>\r\n<p>当query和key是同样形状的张量时，各种核函数都可以简单的应用。但是query和key是不同长度的时候呢？这时可以使用Additive\r\nAttention作为评分函数，本质上就是通过两个<strong>线性变换层</strong>将它们投影到统一长度空间：</p>\r\n<p><span class=\"math display\">\\[\r\na(\\mathbf{q}, \\mathbf{k})=\\mathbf{w}_{v}^{\\top} \\tanh\r\n\\left(\\mathbf{W}_{q} \\mathbf{q}+\\mathbf{W}_{k} \\mathbf{k}\\right) \\in\r\n\\mathbb{R},\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(\\mathbf{W}_{q} \\in \\mathbb{R}^{h \\times\r\nq} 、 \\mathbf{W}_{k} \\in \\mathbb{R}^{h \\times k}\\)</span> 和 <span\r\nclass=\"math inline\">\\(\\mathbf{w}_{v} \\in \\mathbb{R}^{h}\\)</span>\r\n是用于学习自适应调整的参数。</p>\r\n<h3 id=\"scaled-dot-product-attention\">Scaled Dot-Product Attention</h3>\r\n<p>点积是一种很容易想到的计算query和key距离的方式，而且效率很高。因此结合缩放思想可以构造出方差为1的度量距离方式：</p>\r\n<p><span class=\"math display\">\\[\r\na(\\mathbf{q}, \\mathbf{k})=\\mathbf{q}^{\\top}\\mathbf{k}/\\sqrt{d}\r\n\\]</span></p>\r\n<p>其中<span\r\nclass=\"math inline\">\\(d\\)</span>为向量长度（显然query和key需要相同长度）。当然，为优化性能，实际计算会使用矩阵计算一个批量的点积。</p>\r\n<h2 id=\"编码器-解码器中的注意力机制\">编码器-解码器中的注意力机制</h2>\r\n<p>在编码器-解码器框架中，会将这一批所有的输入做成一个不变的上下文，再通过这个上下文去计算这一批所有的预测。显然<strong>对于某些预测计算来说，可能会与一部分输入毫无关系</strong>，这样粗暴的使用一个统一的上下文并不合理。因此可以想到对每次预测计算，定制一个属于它的上下文，即<strong>基于注意力机制定制上下文</strong>：</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathbf{c}_{t^{\\prime}}=\\sum_{t=1}^{T}\r\n\\alpha\\left(\\mathbf{s}_{t^{\\prime}-1}, \\mathbf{h}_{t}\\right)\r\n\\mathbf{h}_{t}\r\n\\]</span></p>\r\n<p>对于某时刻<span class=\"math inline\">\\(t\\)</span>的预测计算，<span\r\nclass=\"math inline\">\\(s\\)</span>为解码器上一时刻隐状态，<span\r\nclass=\"math inline\">\\(h\\)</span>为编码器该时刻隐状态。将<span\r\nclass=\"math inline\">\\(s\\)</span>视为query，<span\r\nclass=\"math inline\">\\(h\\)</span>视为key，同时也视为value，最终加权得到基于注意力的上下文<span\r\nclass=\"math inline\">\\(c_{t^`}\\)</span>,再与解码器的输入进行连接，送入RNN进行计算：</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/LruLfaD.png\"\r\nalt=\"基于注意力的编码器-解码网络：其中解码器的每一次计算都需要（编码器隐状态，解码器上一时间隐状态），并且这里评分函数使用的是加性注意力。\" />\r\n<figcaption\r\naria-hidden=\"true\">基于注意力的编码器-解码网络：其中解码器的每一次计算都需要（编码器隐状态，解码器上一时间隐状态），并且这里评分函数使用的是加性注意力。</figcaption>\r\n</figure>\r\n<h2 id=\"multihead-attention\">MultiHead Attention</h2>\r\n<p>和多个卷积核学习多种特征一样，我们也可以想到使用多个Attention来学习到多种联系。其中每一个Attention被称作一个Head。而为了实现多个Head学习到不同的联系，需要给它们不完全相同的数据，如使用全连接层进行线性投影，取一部分原数据的子空间给一个Head。当然汇聚不同Head的输出也需要一种连接方式，即也采用一个线性变换将Multi\r\nHead组合起来：</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/JbL6hlb.png\" alt=\"MultiHead Attention\" />\r\n<figcaption aria-hidden=\"true\">MultiHead Attention</figcaption>\r\n</figure>\r\n<p>因此可以容易给出MultiHead Attention的数学模型：给定query <span\r\nclass=\"math inline\">\\(\\mathbf{q} \\in \\mathbb{R}^{d_{q}}\\)</span> 、key\r\n<span class=\"math inline\">\\(\\mathbf{k} \\in \\mathbb{R}^{d_{k}}\\)</span>\r\n和value <span class=\"math inline\">\\(\\mathbf{v} \\in\r\n\\mathbb{R}^{d_{v}}\\)</span>, <span class=\"math inline\">\\(\\quad\r\nf\\)</span> 为注意力汇聚操作，每个Head <span\r\nclass=\"math inline\">\\(\\mathbf{h}_{i}(i=1, \\ldots, h)\\)</span>\r\n的计算方法为:</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathbf{h}_{i}=f\\left(\\mathbf{W}_{i}^{(q)} \\mathbf{q},\r\n\\mathbf{W}_{i}^{(k)} \\mathbf{k}, \\mathbf{W}_{i}^{(v)} \\mathbf{v}\\right)\r\n\\in \\mathbb{R}^{p_{v}}\r\n\\]</span></p>\r\n<h1 id=\"self-attention\">Self-Attention</h1>\r\n<p>顾名思义，就是query，key，value都是同一个序列<span\r\nclass=\"math inline\">\\([x_1,...,x_n]\\)</span>。其输出结果<span\r\nclass=\"math inline\">\\([y_1,...,y_n]\\)</span>为：</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathbf{y}_i = f(\\mathbf{x}_i, (\\mathbf{x}_1, \\mathbf{x}_1), \\ldots,\r\n(\\mathbf{x}_n, \\mathbf{x}_n)) \\in \\mathbb{R}^d\r\n\\]</span></p>\r\n<h1 id=\"注意力和卷积\">注意力和卷积</h1>\r\n<p>从某种直观上来看，卷积的局部加权平均 和\r\n注意力的加权平均(特别是自注意力) 有点相似？</p>\r\n<h1 id=\"推荐资料\">推荐资料</h1>\r\n<p><a href=\"https://jalammar.github.io/illustrated-transformer/\">The\r\nIllustrated Transformer</a></p>\r\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"深度学习框架","url":"/2021/11/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/","content":"<h1 id=\"网络结构\">网络结构</h1>\r\n<ul>\r\n<li>one-hot: 对离散的类别数据进行编码,\r\n如词元、标签等。通过编码可以将所有类别一视同仁,\r\n而避免造成label=5的标签比label=1的标签更重要。</li>\r\n<li>embedding:\r\n对词元进行one-hot编码之后，通常维度都会成千上万，并且除了一个维度是1以为，其他维度全都是0，编码很稀疏，效率很低。为了压缩维度使用embedding层进行维度压缩。</li>\r\n<li>残差层: 用于在网络F的基础上构造残差连接,\r\n如ReLU、GELU。在激活函数之前。</li>\r\n<li>Batch Normalization:\r\n每层网络运算之后的归一化。在网络计算与激活层之间。</li>\r\n<li>激活层:\r\n在两层神经网络之间，切断两层的线性联系，使网络组合可以变成非线性网络。</li>\r\n</ul>\r\n<h2 id=\"激活函数\">激活函数</h2>\r\n<p><a\r\nhref=\"https://microsoft.github.io/ai-edu/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/A2-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%AC%AC4%E6%AD%A5%20-%20%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/08.0-%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0.html\">原理讲解</a></p>\r\n<h3 id=\"sigmoidlogistictanh\">Sigmoid(Logistic/Tanh)</h3>\r\n<ul>\r\n<li>有输出概率的实际意义, 导数易求。</li>\r\n<li>但是计算需要指数运算, 效率低。而且梯度最大值≤0.25,\r\n在链式传播乘起来后会越来越小,\r\n最终网络一多就会造成梯度消失。另外Logistic均值不为0,\r\n会影响一点输入数据的均值分布, Tanh则不会。</li>\r\n</ul>\r\n<h3 id=\"reluleaky-relu\">ReLU/Leaky ReLU</h3>\r\n<p><span class=\"math display\">\\[\r\nReLU(z) = max(0,z) = \\begin{cases}z, &amp; z \\geq 0 \\\\\\\\0, &amp; z &lt;\r\n0\\end{cases}\r\n\\]</span></p>\r\n<ul>\r\n<li>正常的反向导数恒等于1, 收敛快。无论链式传播多少层梯度都为1,\r\n不存在梯度消失。且计算简单, 并且会造成神经元的稀疏性,\r\n降低计算成本。</li>\r\n<li>输出无界==&gt;输出可能很大==&gt;损失很大==&gt;梯度很大==&gt;梯度下降造成神经元参数W和b小于0==&gt;激活前的神经元输入小于0,\r\n激活时ReLU梯度恒为0, 即ReLU神经元死亡。</li>\r\n<li>在RNN中难以使用ReLU==RNN时间步中共享W参数矩阵, 相当于会对W做连乘,\r\n且ReLU不抑制输出, 最终输出结果很大。除非W初始化为I。</li>\r\n</ul>\r\n<blockquote>\r\n<p>ReLU不能接受小于0的输入, 不代表原始输入数据不能小于0,\r\n因为原始数据起码也在一层WX+b之后才会进入ReLU。而初始化的W是0对称分布,\r\nb则是恒为0, 因此会将输入数据变成有正有负, 不用担心。</p>\r\n</blockquote>\r\n<p><strong>Leaky ReLU</strong>: 在ReLU的基础上,\r\n给小于0的部分泄漏了一点点梯度,避免神经元死亡</p>\r\n<p><span class=\"math display\">\\[\r\nLReLU(z) = \\begin{cases} z &amp; z \\geq 0 \\\\\\\\ \\alpha \\cdot z &amp; z\r\n&lt; 0 \\end{cases}\r\n\\]</span></p>\r\n<h2 id=\"batch-normalization\">Batch Normalization</h2>\r\n<p>网络每一层的计算都会使输入数据的分布发生一点变化，变化随着层数放大。因此最后训练中间层数据分布可能已经不是原始数据分布了，BN（BatchNormalization）就是为了解决这种分布变化，从而获得以下优点：</p>\r\n<ul>\r\n<li>可以选择比较大的初始学习率，让你的训练速度提高</li>\r\n<li>减少对初始化的依赖</li>\r\n<li>减少对正则的依赖</li>\r\n</ul>\r\n<p><strong>使用方法</strong>：nn.BatchNorm1d/2d/3d(num_features)</p>\r\n<ul>\r\n<li>全连接层：置于全连接计算和激活层之间</li>\r\n<li>卷积层：分通道处理，一个通道一个批量归一化</li>\r\n<li>测试和预测时：由于只有一个样本不能批量归一化，因此可以采用训练时的全局均值来做归一化。在pytorch中把模型置为eval会自动做好。</li>\r\n</ul>\r\n<p><a\r\nhref=\"https://microsoft.github.io/ai-edu/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/A2-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%AC%AC7%E6%AD%A5%20-%20%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/15.5-%E6%89%B9%E9%87%8F%E5%BD%92%E4%B8%80%E5%8C%96%E7%9A%84%E5%8E%9F%E7%90%86.html\">详细原理</a>：BN即是在每一层都把数据分布归一化到0点附近，使得每一层网络都有着相同分布的数据。具体做法：</p>\r\n<ol type=\"1\">\r\n<li>先对方差、均值归一化，将数据分布移动0点附近：仅这一步还不够，由于区间在[-1,1]，可能会减弱激活函数效果，另外压缩了网络的学习空间，可能会破坏网络学习效果。</li>\r\n<li>通过可学习的参数\r\nγ，β，对数据进行可学习的线性变换来适当拉宽数据分布，解决上述问题。</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\n\\mu_B = \\frac{1}{m}\\sum_1^m x_i\\\\\r\n\\sigma^2_B = \\frac{1}{m} \\sum_1^m (x_i-\\mu_B)^2\\\\\r\nn_i = \\frac{x_i-\\mu_B}{\\sqrt{\\sigma^2_B + \\epsilon}} \\\\\r\nz_i = \\gamma n_i + \\beta\r\n\\]</span></p>\r\n<h1 id=\"优化\">优化</h1>\r\n<h2 id=\"网络参数\">网络参数</h2>\r\n<h3 id=\"参数初始化\">参数初始化</h3>\r\n<p>在自己的init_func中利用nn.init模块对不同的层定义不同的初始化方式。然后用net.apply(init_func)将函数应用到每一层。或者net[i].apply(init_func)单独应用：</p>\r\n<ul>\r\n<li>线性激活：Xavier，前提激活函数在零点附近线性，如tanh等。而ReLU不满足。</li>\r\n<li>ReLU：He，解决ReLU不能使用Xavier的问题。</li>\r\n</ul>\r\n<p><a\r\nhref=\"https://microsoft.github.io/ai-edu/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/A2-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%AC%AC7%E6%AD%A5%20-%20%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/15.1-%E6%9D%83%E9%87%8D%E7%9F%A9%E9%98%B5%E5%88%9D%E5%A7%8B%E5%8C%96.html#1514-msra\">详细介绍初始化方法</a></p>\r\n<h3 id=\"参数更新器\">参数更新器</h3>\r\n<p><strong>SGD</strong>：随机梯度下降</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\eta\\)</span>：全局学习率</li>\r\n<li>收敛慢，在终点容易错左右跳，可能陷入局部最优。</li>\r\n</ul>\r\n<p><strong>Momentum</strong>：更新时在一定程度上保留之前的方向，再通过当前梯度进行微调方向，即带有一定的<strong>惯性</strong>。</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\eta\\)</span>：全局学习率；<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>：动量系数；<span\r\nclass=\"math inline\">\\(v_t\\)</span>：初始方向</li>\r\n<li>增加稳定性学习更快，有一定的摆脱局部最优能力。</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://i.imgur.com/lLjsl2V.png\" alt=\"Momentum\" />\r\n<figcaption aria-hidden=\"true\">Momentum</figcaption>\r\n</figure>\r\n<p><strong>NAG</strong>：Nesterov Momentum/Nesterov Accelerated Gradient\r\n梯度加速算法。同Momentum，已知上一步的更新方向，那么在这次确定方向之前，先按之前的方向走一步，然后在新位置上求梯度，再用这个\r\n<strong>未来的梯度</strong> 在当前位置进行Momentum的方向计算。</p>\r\n<blockquote>\r\n<p>换句话说，就是把Momentum中计算当前梯度的步骤延后，先走一步看看，计算梯度，看看路顺不顺，再回到原位置决定要怎么走。</p>\r\n</blockquote>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\eta\\)</span>：全局学习率；<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>：动量系数；<span\r\nclass=\"math inline\">\\(v_t\\)</span>：初始方向</li>\r\n<li>相比于在原位置做方向的微调，NAG是先探好前方的路，再决定现在怎么走。因此更具有预见能力，未来的路更顺畅则加快速度，未来的路不好走则提前改变方向。</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://i.imgur.com/5Qx0WBN.png\" alt=\"Nesterov Momentum\" />\r\n<figcaption aria-hidden=\"true\">Nesterov Momentum</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<p>以下是<strong>自适应更新器</strong>：在同一步更新中，不同参数的更新步长不一样，自适应针对性调整，每个参数有自己的学习率。</p>\r\n<p><strong>AdaGrad</strong>:\r\n学习中会累计之前所有梯度平方之和作为学习率的分母，也就是更新步长会越来越小。同一步更新中，小梯度的参数更新会较大。</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\eta\\)</span>：全局学习率；<span\r\nclass=\"math inline\">\\(\\epsilon=1e-6\\)</span>：数值稳定的小常数；<span\r\nclass=\"math inline\">\\(r=0\\)</span>：累积辅助系数，不用管</li>\r\n</ul>\r\n<p><strong>AdaDelta</strong>：解决AdaGrad更新步长单调减小的问题，过去累计的梯度会不断衰减，减小影响。</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\eta\\)</span>：全局学习率；<span\r\nclass=\"math inline\">\\(\\alpha=0.9 \\in [0,1)\\)</span>：衰减比率；<span\r\nclass=\"math inline\">\\(s=0\\)</span>: 平方梯度累计，不用管；<span\r\nclass=\"math inline\">\\(r=0\\)</span>：累积辅助系数，不用管。</li>\r\n</ul>\r\n<p><strong>RMSProp</strong>：Root Mean Square Prop\r\n均方根反向传播。优化了AdaGrad在更新中摆幅过大的问题，学习率衰减不会太快，加快收敛速度，将梯度平方累计改成了加权平均累计。</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\eta=0.01\\)</span>：全局学习率；<span\r\nclass=\"math inline\">\\(\\epsilon=1e-6\\)</span>：数值稳定的小常数；<span\r\nclass=\"math inline\">\\(\\alpha=0.9 \\in [0,1)\\)</span>：加权比例；<span\r\nclass=\"math inline\">\\(r=0\\)</span>：累积辅助系数，<span\r\nclass=\"math inline\">\\(r=\\alpha r + (1-\\alpha)(g_t \\odot g_t\r\n)\\)</span>。</li>\r\n<li>初始学习率不能太大，容易不收敛。</li>\r\n</ul>\r\n<p><strong>Adam</strong>：Adaptive Moment Estimation\r\n<strong>主流选择</strong>。相当于RMSProp+Momentum。Adam在RMSProp算法基础上对小批量随机梯度也做了指数加权移动平均。</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\eta=0.01\\)</span>：全局学习率,<span\r\nclass=\"math inline\">\\(\\epsilon\\)</span>：数值稳定小常数；<span\r\nclass=\"math inline\">\\(\\beta_1=0.9,\\beta_2=0.999\\)</span>；矩估计指数衰减比率；</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://i.imgur.com/A8zSefI.png\"\r\nalt=\"主流更新算法比较：Momentum有惯性，比较平滑；RMSProp波动幅度小，后期步长越来越短；Adam结合两者优势，比Momentum幅度小，比RMSProp平滑\" />\r\n<figcaption\r\naria-hidden=\"true\">主流更新算法比较：Momentum有惯性，比较平滑；RMSProp波动幅度小，后期步长越来越短；Adam结合两者优势，比Momentum幅度小，比RMSProp平滑</figcaption>\r\n</figure>\r\n<p><a\r\nhref=\"https://microsoft.github.io/ai-edu/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/A2-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%AC%AC7%E6%AD%A5%20-%20%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/15.3-%E8%87%AA%E9%80%82%E5%BA%94%E5%AD%A6%E4%B9%A0%E7%8E%87%E7%AE%97%E6%B3%95.html\">AIEDU-自适应更新算法</a></p>\r\n<h3 id=\"学习率调度器\">学习率调度器</h3>\r\n<p>学习率调度器用于随着epoch改变学习率，通常我们希望lr随着epoch越来越小。通常的参数有：</p>\r\n<ul>\r\n<li>optimizer: 要修改学习率的更新器</li>\r\n<li>step_size:\r\n改变学习率的step周期。通常每个epoch之后调度器step一次，达到step_size则会改变学习率</li>\r\n<li>last_epoch:\r\n中断训练再继续的时候使用，告诉调度器上一次到达了多少epoch。</li>\r\n</ul>\r\n<p><strong>StepLR</strong>: 等间隔调整</p>\r\n<p><strong>CosineAnnealingLR</strong>：类似余弦的调度，学习率衰减先慢后快。torch.optim.lr_scheduler.</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/ZzrDYG9.png\" alt=\"余弦学习率变化\" />\r\n<figcaption aria-hidden=\"true\">余弦学习率变化</figcaption>\r\n</figure>\r\n<p><strong>另外学习率应该匹配批大小</strong>。通常我们希望经过同样数量的样本后，更新的步伐是一样的。因此增大了batch理论上应该增加lr。换个思路来说，衰减学习率也可以通过增加batch\r\nsize来实现。</p>\r\n<ul>\r\n<li>增加 batch\r\nsize，需要增加学习率来适应，可以用线性缩放的规则，成比例放大</li>\r\n<li>尽量使用大的学习率，因为很多研究都表明更大的学习率有利于提高泛化能力。如果真的要衰减，可以尝试其他办法，比如增加batch\r\nsize，学习率对模型的收敛影响真的很大，慎重调整。</li>\r\n<li>batch\r\nsize增加比较自由，但是大到一定程度的时候，学习率不能随之增加了，因为学习率有上限限制。</li>\r\n</ul>\r\n<blockquote>\r\n<p>在SGD中，学习率不能大于1，这是收敛必要条件。</p>\r\n</blockquote>\r\n<p><a\r\nhref=\"https://microsoft.github.io/ai-edu/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/A2-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%AC%AC5%E6%AD%A5%20-%20%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB/12.3-%E5%AD%A6%E4%B9%A0%E7%8E%87%E4%B8%8E%E6%89%B9%E5%A4%A7%E5%B0%8F.html\">学习率与批大小关系</a></p>\r\n<h2 id=\"过拟合\">过拟合</h2>\r\n<p>为了减轻过拟合，一定程度上限制权重的学习。weight_decay一般可以取0.005</p>\r\n<h3 id=\"l2正则\">L2正则</h3>\r\n<p>限制权重L2范数大小，通常小的模型适应能力较强。一般不会正则bias，bias对学习影响不大，没有什么明显效果。</p>\r\n<p><span class=\"math display\">\\[\r\nJ(w,b)= J_{old}(w,b)+\\frac{\\lambda}{2m}\\sum_{j=1}^n{w_j^2}\r\n\\]</span></p>\r\n<h3 id=\"l1正则\">L1正则</h3>\r\n<p>使<strong>权重稀疏</strong>(即趋近于0的权重很多)。L0和L1都可以实现稀疏，但L0无法优化求解。权重稀疏的好处是可以实现\r\n<strong>特征选择</strong>， <strong>可解释性</strong>。</p>\r\n<p><span class=\"math display\">\\[\r\nJ(w,b)= J_{old}(w,b)+\\lambda\\sum_{j}^m{|w_j|}\r\n\\]</span></p>\r\n<h3 id=\"dropout0.5-0.7\">Dropout=0.5 / 0.7</h3>\r\n<p>避免过分依赖某一层中某些神经元发生过拟合，提高泛化。通过mask随机丢弃即可。</p>\r\n<p>预测和测试时不能dropout，要不然会造成结果的不稳定，无法解释。</p>\r\n<h3 id=\"dropattention\">DropAttention</h3>\r\n<p>用于正则化Transformer网络的注意力权重，(Zehui et al. 2019)</p>\r\n<h1 id=\"utils\">Utils</h1>\r\n<h2 id=\"pytorch模型管理\">Pytorch模型管理</h2>\r\n<p>save(obj,path) load(path)\r\n：可以存储大多数类型，甚至包括字典。对于tensor之类的可以直接save，对于网络模型，一般save(net.state_dict())，即状态参数信息。</p>\r\n<ul>\r\n<li><strong>保存模型</strong>：\r\ntorch.save(myNet.state_dict(),save_path)<br />\r\n</li>\r\n<li><strong>读取模型</strong>：\r\nmyNet.load_state_dict(torch.load(save_path))<br />\r\n</li>\r\n<li><strong>模型状态</strong>：\r\nmyNet.train(),myNet.eval()。使用不同的模型状态。主要改变模型中BatchNormalization和Dropout的作用方式。和梯度记录无关，那是另一回事。</li>\r\n<li><strong>梯度记录管理</strong>： 使用上下文with\r\ntorch.no_grad()，或者使用装饰器@torch.no_grad()装饰需要禁用梯度的函数，影响范围内代码都不会记录梯度状态，不影响后续梯度更新。</li>\r\n</ul>\r\n<p>也可以直接save(myNet)，但是网络结构变化的时候会出问题</p>\r\n<h2 id=\"pytorch-设备管理\">Pytorch 设备管理</h2>\r\n<p><strong>假如要对多个项同时操作，它们必须在同样的设备上。</strong>但是跨设备传输比计算慢得多，因此要谨慎操作。</p>\r\n<p>且打印张量或将张量转换为NumPy格式时，如果数据不在内存中，框架会首先将其复制到内存中。</p>\r\n<p>一个典型的错误如下：计算GPU上每个小批量的损失，并在命令行中将其报告给用户（或将其记录在NumPy\r\nndarray中）时，将触发全局解释器锁，从而使所有GPU阻塞。</p>\r\n<ul>\r\n<li><strong>返回可用设备</strong>: torch.device('cpu'),\r\ntorch.cuda.device('cuda'), torch.cuda.device('cuda:1')</li>\r\n<li><strong>查询可用gpu的数量</strong>: torch.cuda.device_count()</li>\r\n<li><strong>查询张量所在设备</strong>: x.device</li>\r\n<li><strong>转移设备</strong>: MyNet.to(device),MyTensor.to(device)</li>\r\n</ul>\r\n<h2 id=\"hydra-程序参数管理\">Hydra 程序参数管理</h2>\r\n<p>Hydra通过yaml文件管理python程序的参数。比如argparse方便的是,\r\n它可以创建多个yaml文件,\r\n并且自由组合生成一套最终配置。例如在深度学习里面, 可以把模型参数,\r\n数据集参数, 超参数分成三个yaml文件, 然后可以混搭使用, 省心省事炼丹。</p>\r\n<p>基础使用方法参考<a\r\nhref=\"https://hydra.cc/docs/tutorials/basic/your_first_app/simple_cli/\">官方小教程</a>。值得注意的关键字:</p>\r\n<ul>\r\n<li># <span class=\"citation\" data-cites=\"package\">@package</span>\r\n_global_ : 放在yaml文件头, 可以使该文件所有配置放在最外层</li>\r\n<li>subpackage@newname : defaults列表中使用@可以重命名</li>\r\n<li>subpackage@_here_ :\r\ndefaults列表中使用_here_可以原地展开subpackage的配置,\r\n不再嵌套在subpackage.somekeyword里面</li>\r\n</ul>\r\n<blockquote>\r\n<p>注意Hydra会修改程序的执行路径至hydra的output路径,因此你程序里所有关于相对路径的设置都可能出现问题。参考<a\r\nhref=\"https://hydra.cc/docs/tutorials/basic/running_your_app/working_directory/\">官方说明</a></p>\r\n</blockquote>\r\n<h2 id=\"profile-性能分析\">Profile 性能分析</h2>\r\n<p>pytorch自带的性能分析工具, 可以分析内存使用,\r\n耗时情况等性能数据。并且能够集成在tensorboard中查看,\r\n可以说是很方便的模型性能分析工具了。<a\r\nhref=\"https://pytorch.org/docs/master/profiler.html\">官方文档</a></p>\r\n<p>使用方法如下, 需要将被分析的代码放在profile的上下文中。</p>\r\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> torch.profiler.profile(</span><br><span class=\"line\">    schedule=torch.profiler.schedule(</span><br><span class=\"line\">        skip_first=<span class=\"number\">1</span>,</span><br><span class=\"line\">        wait=<span class=\"number\">1</span>,</span><br><span class=\"line\">        warmup=<span class=\"number\">1</span>,</span><br><span class=\"line\">        active=<span class=\"number\">2</span></span><br><span class=\"line\">    ),</span><br><span class=\"line\">    on_trace_ready=torch.profiler.tensorboard_trace_handler(<span class=\"string\">&#x27;./logs&#x27;</span>),</span><br><span class=\"line\">    profile_memory=<span class=\"literal\">True</span>,</span><br><span class=\"line\">    record_shapes=<span class=\"literal\">True</span>,</span><br><span class=\"line\">    with_stack=<span class=\"literal\">True</span></span><br><span class=\"line\">) <span class=\"keyword\">as</span> prof:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> X,y <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">        your code</span><br><span class=\"line\"></span><br><span class=\"line\">        prof.step()</span><br></pre></td></tr></table></figure>\r\n<p>需要注意的参数如下:</p>\r\n<ul>\r\n<li><p><strong>schedule</strong> :\r\n<code>torch.profiler.schedule</code>类型。按时间步长去规定profiler做什么事。具体根据参数情况profiler将跳过<code>skip_first</code>个步长,然后等待\r\n<code>wait</code> 个步长, 在接下来的 <code>warmup</code>\r\n个步长中进行warmup以便分析更准确。最后真正开始分析接下来的\r\n<code>active</code> 个步长的性能,\r\n这是一轮分析的结束。之后回到<code>wait</code>处进行上述循环, 循环次数由\r\n<code>repeat</code> 决定, 为0则意味着持续循环。</p></li>\r\n<li><p><strong>on_trace_ready</strong>: 当一轮分析完毕的回调函数,\r\n默认传递prof变量。</p>\r\n<p>例如回调函数里可以写下面这句用于打印分析表格</p>\r\n<p><figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(prof.key_averages().table(sort_by=<span class=\"string\">&quot;self_cuda_time_total&quot;</span>, row_limit=-<span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure></p>\r\n<p>或者可以直接传递内置函数, 用于生成tensorboard文件用于可视化分析。</p>\r\n<p><figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">torch.profiler.tensorboard_trace_handler(<span class=\"string\">&#x27;./logs&#x27;</span>)</span><br></pre></td></tr></table></figure></p></li>\r\n<li><p><strong>step()</strong>:\r\n用于迭代profiler的时间步长(需要手动调用)。</p></li>\r\n<li><p><strong>with_stack</strong>:\r\n记录某个操作的文件名和行号。</p></li>\r\n</ul>\r\n<h1 id=\"坑位排除\">坑位排除</h1>\r\n<ol type=\"1\">\r\n<li>网络中使用了softmax而不是log_softmax:</li>\r\n</ol>\r\n<p>softmax存在数值上的问题，可能导致更新极度缓慢，<a\r\nhref=\"https://zhenglungwu.medium.com/softmax-v-s-logsoftmax-7ce2323d32d3\">参见</a>。</p>\r\n<p>训练时应该使用数值稳定的log_softmax代替，torch中之所以还保留softmax函数，是为了方便我们想要查看真正的softmax概率时使用。</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>网络计算中tensor不能使用原地操作,只能创建新对象然后赋值.</li>\r\n</ol>\r\n<p>由于梯度更新的要求,例如x+=1这样的原地操作是不行的。同时tensor的切片赋值也是不行的。</p>\r\n<blockquote>\r\n<p>例如形状为2,3的x，希望使x[1,:]=0,x[2,:]=0。此时需要创建一个形状为[2,3]的y，然后进行赋值x=y</p>\r\n</blockquote>\r\n<hr />\r\n<blockquote>\r\n<p>主函数代码框架见github</p>\r\n</blockquote>\r\n<h1 id=\"参考资料\">参考资料</h1>\r\n<p><a\r\nhref=\"https://microsoft.github.io/ai-edu/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/A2-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/\">微软：神经网络基本原理</a></p>\r\n","categories":["深度学习"],"tags":["深度学习"]},{"title":"是躁动吧","url":"/2020/09/25/%E6%98%AF%E8%BA%81%E5%8A%A8%E5%90%A7/","content":"<h2 id=\"生活线\">生活线</h2>\r\n<p>　　最近突然变得烦躁了起来。突然意识到自己的机械生活持续了一个月、两个月，像个死人。</p>\r\n<p>　　本来之前还觉得这样早出晚归，每天不停地学不停地复习的生活还算充实，不会感到迷茫或者飘渺无聊。但最近不知道是啥拉动了我的脑神经，突然发现这一切好机械化啊。6：30\r\n起，吃饭背单词到 8：00\r\n等图书馆开门。然后学、吃饭、学、吃饭、学。忙碌是忙碌了，活得也像个齿轮了，每天唯一的新鲜感大概仅在于闭馆之后选择买啥夜宵吃。</p>\r\n<p>　　大概有点类似于【完形崩坏/语义饱和】？</p>\r\n<blockquote>\r\n<p>　语义饱和（英语：semantic\r\nsatiation），又称字形饱和、完形崩坏（日语：ゲシュタルト崩壊，德语：Gestaltzerfall），是一种心理学现象，指的是人在重复盯着一个字或者一个单词长时间后，会发生突然不认识该字或者单词的情况。此过程仅为暂时，心理学上认为其原因是人的大脑神经如果短时间内接收到太多重复的刺激，就会引起神经活动的抑制，造成对常用字突然不认识的现象。——维基百科</p>\r\n</blockquote>\r\n<p>　　重复久了，整个生活轨迹突然就变得被我排斥拒绝。上一次这么机械还是在高三，不过那时候是整个班一起学，每天虽然轨迹差不多，但看着憨憨们的日常也还是挺多样化的。考研好像就完全不一样，全程是自己一个人为了不知道什么在努力。每天来到图书馆学自己的，学完自己走，下一天。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"考研\">考研</h2>\r\n<p>　　考研的目标也完全不清晰，不像高中三年以来，大大小小的考试联考月考摸底，早就知道自己水平，虽然最后考的是真的差，大概也能无所谓地接受。考研复习了两个月左右，完全不清楚自己能做到什么程度，不知道自己比起竞争者有什么优势，只是拼命的赶啊赶。本来就时间紧张的考研，我还是从\r\n8 月份开始复习，也不知道我到底有什么勇气拿 4\r\n个月的努力挑战别人一年的沉淀：）</p>\r\n<p>　　更紧张的来了，9 月份招生简章大概出来之后，专业课改成 408\r\n真的很烦啊。本来就只有四个月时间，想着同专业优势可以少放点时间在专业课上，好好把其他的补一补，说不定还有希望\r\n... 突然改成 408，还有三个月的时间，408 的 1200\r\n页四本专业课哈哈哈哈哈靠。不怂，学嘛。做了下英语二真题，可能是 10\r\n年的卷子比较简单吧，暂时把英语废弃了，于是把以前每天上午翻译《卫报》的时间和晚上时间都拿去赶专业课，也不敢再在博客上敲笔记了=。=本来腾时间给其他科目的一夜之间变成抢其他科目的时间，有点意思。定的计划是最慢\r\n7 天过一本专业课，一天至少 50 页。还好，对我来说最难受的计组在 6\r\n天结束了，后续的计网和操作系统相对来说进展应该可以更顺畅一些，剩下的就是看我脑子能记多久了。</p>\r\n<p>　　剩下的问题就是摸底了。真的很想知道自己目前的水平，但又完全测不了。一轮最快也要下周末结束。即使结束了，政治也明显处于只能做选择题的阶段，分析题不背书根本不知道从哪答题。数学，不知道是考研难度如此，还是张宇的强化训练真的很难，几大证明板块推进的真的好吃力，有些题目看着题解觉得这辈子都不可能想得到的好吧。</p>\r\n<p>　　看着考研初始上岸分数要求好像不高的样子320 330 340 ...大概\r\n110+110+60+60 都能够上岸，这种成绩放在高中那是根本难以想象的吧= =\r\n。但从大环境和营销号的渲染下，突然感觉这个分数好像并没有看起来那么简单？？我数学和专业课真的能考110吗？？考110\r\n120 150\r\n到底有多难？？可能是被高中数学带偏了，整张卷子只有6、7道题要做，其他的大概都是送分，130是基本盘了。考研数学从环境上来看好像130已经是天之骄子级别了？哈，突然想到要是一摸底发现自己考研数学连110都考不到，这心理落差估计挺大。更别提目前完全放弃的英语以及第一次学的政治，更加没有任何底气。</p>\r\n<h2 id=\"负责\">负责</h2>\r\n<p>　　但是还是要为自己负责的。大四了已经，大二大三看起来忙忙碌碌，回想起来完全一片空白，没有能力和经历上的提升和丰富，消遣摸鱼一年年就过去了。大四上半学期秋招和考研的选择，最终决定投入在考研上，毕竟还是觉得本科懂得东西太少了，还是想再多学两年专业领域知识。当然这样失去的自然就是对就业开发技术的锻炼了。</p>\r\n<blockquote>\r\n<p>　四个月投入在提升开发技术上应该会有很明显的回报吧，而不是像考研一样石沉大海（笑。</p>\r\n</blockquote>\r\n<p>　　不过给自己说了考研那不管怎样一定会考下去，自己的承诺吧。其实也有想过考研失败了怎么办，失去了四个月的技术提升，剩下几个月要在毕设的时间压缩下准备更严苛的春招\r\n...\r\n也没什么好多愁善感的好像，做一件事患得患失挺烦的，到了那个地步再说。</p>\r\n<p>　　躁动归躁动，但down是不可能的，哀怨也绝对不是我。烦躁完了该捡起来的责任还是得扛着。</p>\r\n<p>　　一直以来的风格是做了再说，结果就不关我事了，留给未来的我承担起自己所作所为吧。</p>\r\n<p>　　给自己点一首《Somnus》——Final Fantasy XV</p>\r\n<p>　　吐槽完毕，滚去学习。</p>\r\n","categories":["生活"]},{"title":"游戏中的代码设计模式总结","url":"/2023/07/12/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/","content":"<p>参考<a href=\"https://gpp.tkchu.me/\">Game Programming\r\nPatterns</a>完成的设计模式总结笔记。</p>\r\n<h2 id=\"命令模式\">命令模式</h2>\r\n<p>命令模式本质上希望把一个<strong>硬编码的函数</strong>解耦成<strong>可配置的函数命令</strong>，尽可能将<strong>功能触发</strong>和<strong>具体功能</strong>分离。</p>\r\n<p>如下有一个玩家对象的输入控制功能，其中按下X键对应jump动作。如果我们想要将X键绑定到fireGun功能，那还得去代码里修改对应的硬编码if语句，然后重新编译，重新链接。</p>\r\n<figure class=\"highlight cs\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> InputHandler::handleInput()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isPressed(BUTTON_X)) jump();</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isPressed(BUTTON_Y)) fireGun();</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isPressed(BUTTON_A)) swapWeapon();</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isPressed(BUTTON_B)) lurchIneffectively();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<span id=\"more\"></span>\r\n<h3 id=\"动态绑定功能\">动态绑定功能</h3>\r\n<p>那么我们来将<strong>功能触发</strong>和<strong>具体功能</strong>分离吧。既然想要让X键对应动态的功能，那么可以用一个\r\n多态/函数指针/委托\r\n来实现。命令模式即使用多态方式，如下将jump,fireGun之类的功能抽取成一个<code>Command</code>基类的四个派生类，这样就可以通过<code>Command</code>对象的多态来实现动态绑定：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Command</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Command</span>() &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//功能类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JumpCommand</span> :</span> <span class=\"keyword\">public</span> Command</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">jump</span>(); &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//功能类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FireCommand</span> :</span> <span class=\"keyword\">public</span> Command</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">fireGun</span>(); &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>接下来我们就可以为按键绑定功能，如buttonX_=FireCommand，然后在按键触发时动态执行虚函数就行了：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//处理类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputHandler</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handleInput</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  Command* buttonX_;</span><br><span class=\"line\">  Command* buttonY_;</span><br><span class=\"line\">  Command* buttonA_;</span><br><span class=\"line\">  Command* buttonB_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InputHandler::handleInput</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">isPressed</span>(BUTTON_X)) buttonX_-&gt;<span class=\"built_in\">execute</span>();</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">isPressed</span>(BUTTON_Y)) buttonY_-&gt;<span class=\"built_in\">execute</span>();</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">isPressed</span>(BUTTON_A)) buttonA_-&gt;<span class=\"built_in\">execute</span>();</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">isPressed</span>(BUTTON_B)) buttonB_-&gt;<span class=\"built_in\">execute</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这样我们在游戏流程中随时可以根据需要来替换按键对应的功能。当然，动态绑定还可以带来其他的便利性，如我们可以把<code>Command.execute()</code>\r\n改成\r\n<code>Command.execute(GameObject actor)</code>,这样甚至能改变操作对象！</p>\r\n<h3 id=\"撤销和重做\">撤销和重做</h3>\r\n<p>如上所述，功能的动态绑定可以通过 多态/函数指针/委托\r\n三种方式来实现，但为什么命令模式选择了Command类与多态呢？实现成类，一方面可以便于添加扩展功能，另一方面类拥有状态信息，可以针对命令做一些维护操作，比如撤销和重做。</p>\r\n<p>例如我们有一个Move\r\nCommand，在<code>execute()</code>中我们会移动角色，那么我们自然可以在Move中保留下角色移动之前的位置，然后构造一个<code>Undo()</code>操作，来将原来的位置赋值为角色，完成撤销。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MoveUnitCommand</span> :</span> <span class=\"keyword\">public</span> Command</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">MoveUnitCommand</span>(Unit* unit, <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span><br><span class=\"line\">  : <span class=\"built_in\">unit_</span>(unit),</span><br><span class=\"line\">    <span class=\"built_in\">xBefore_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">yBefore_</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"built_in\">x_</span>(x),</span><br><span class=\"line\">    <span class=\"built_in\">y_</span>(y)</span><br><span class=\"line\">  &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 保存移动之前的位置</span></span><br><span class=\"line\">    <span class=\"comment\">// 这样之后可以复原。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    xBefore_ = unit_-&gt;<span class=\"built_in\">x</span>();</span><br><span class=\"line\">    yBefore_ = unit_-&gt;<span class=\"built_in\">y</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    unit_-&gt;<span class=\"built_in\">moveTo</span>(x_, y_);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">undo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    unit_-&gt;<span class=\"built_in\">moveTo</span>(xBefore_, yBefore_);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  Unit* unit_;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> xBefore_, yBefore_;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> x_, y_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"享元模式\">享元模式</h2>\r\n<p>享元模式思路比较简单，就是把大量实例共享的那一部分数据单独抽取出来，成为一个共享数据<code>ShareData</code>类，并让其他实例类引用它即可。这样可以节省大量的内存，并且在GPU渲染大量同类实例时也能节省性能。</p>\r\n<figure>\r\n<img src=\"flyweight-tree-model.png\"\r\nalt=\"GPU渲染大量的树木时，可以把共享数据如网格、纹理等抽取出来引用，然后需要实例单独渲染的只有不同的位置了。\" />\r\n<figcaption\r\naria-hidden=\"true\">GPU渲染大量的树木时，可以把共享数据如网格、纹理等抽取出来引用，然后需要实例单独渲染的只有不同的位置了。</figcaption>\r\n</figure>\r\n<h2 id=\"观察者模式\">观察者模式</h2>\r\n<p>观察者模式算是一种十分常用的模式了，即把数据的改动变化做成一个\r\n<strong>事件</strong>，然后由\r\n<strong>发布者</strong>发布该事件，<strong>订阅者</strong>则可以提前订阅好相关事件处理程序。每当数据改动时事件会被发布者Invoke，订阅者的事件处理程序即可响应执行。这在数据逻辑和UI分离的常规MVC开发模式下很常见。</p>\r\n<p><strong>事件的订阅执行并没有想象中的那么慢</strong>：实际上在C#中事件就是由委托类型(类似函数指针)完成的。订阅者用事件处理程序去订阅事件通知，即相当于在事件的数据结构里保存这个事件处理程序的函数指针，每次事件的Invoke无非是遍历事件保存的函数指针数组依次执行而已。不过需要小心的一点是事件发布者可能会被订阅者阻塞，例如某个前端事件处理程序去访问网络...因此小心UI线程相关！</p>\r\n<p><strong>对象销毁和垃圾处理</strong>：如上订阅者订阅事件时，发布者的内部其实是在引用订阅者对象。假如我们此时主动销毁了订阅者呢？那么事件Invoke时就会访问一个错误的野指针。所以订阅者需要注意在自己被释放时主动取消订阅。这个问题对垃圾回收语言有没有影响呢？C#中不需要主动销毁对象，因此倒不至于会得到一个野指针。但是由于发布者手握着一个引用，垃圾回收器只能认为订阅者对象是有用的，因此订阅者会一直存在于内存中，最终形成一种内存泄漏。更为严重的情况是，我们可能以为订阅者已经被回收了，之后又尝试加载一个新的订阅者示例，进行新的订阅，最终你的内存里可能有一万个订阅者！</p>\r\n<blockquote>\r\n<p>例如玩家在离开战斗场景时，我们可能会想要卸载战斗UI，但实际上由于事件订阅的存在，UI被隐藏后并没有被回收。而下一次玩家进入战斗场景时会创建新的战斗UI，现在，同样的UI就有两个了！之后还会有3个，4个....</p>\r\n</blockquote>\r\n<h2 id=\"单例模式\">单例模式</h2>\r\n<p>单例模式：一方面限定一个类只有一个示例，另一方面为这个实例提供了全局访问方式，示例如下：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> Singleton&amp; <span class=\"title\">instance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 惰性初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance_ == <span class=\"literal\">NULL</span>) </span><br><span class=\"line\">      instance_ = <span class=\"keyword\">new</span> <span class=\"built_in\">Singleton</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *instance_;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"built_in\">Singleton</span>() &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> Singleton* instance_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>可以看出单例模式实现十分简单，并且带来的好处显而易见：</p>\r\n<ul>\r\n<li><strong>全局直接访问</strong>：所有调用对象都无需存储相关引用和指针。99.9%的单例模式都是为了创建全局访问的Manager类。</li>\r\n<li><strong>实例数量限定</strong>：避免不必要的重复。</li>\r\n<li>惰性初始化实例：如果没有发生访问，则Singleton类永远不会创建实例。就算程序后期发生访问，那也是在运行时才实例化，不会给前期带来不必要的垃圾。</li>\r\n<li>可动态实例化：这种全局访问的Manager类另一种类似的实现方法是<strong>C#的静态类</strong>，但是静态类很大的一个缺点就是初始化数据也只能是静态的。例如我不能写一个字段<code>static int a=ReadFromFile();</code>,而单例模式就没有这种动态依赖的困扰，想怎么初始化怎么初始化。</li>\r\n<li>拥有类的完整特性，继承和多态：这样我们可以把一个单例基类扩展成多种泛化单例，分别添加不同的功能，之后再按需创建对应的一种。</li>\r\n</ul>\r\n<p>每个了解单例模式的人都能很快的上手使用，并且觉得这个模式真是又快又好。但是难道把所有类都往单例上怼就行了吗？就像从我们学编程开始就被教导不要乱用全局变量一样，比起学会使用单例，我们更需要关注有没有<strong>滥用全局单例</strong>：</p>\r\n<ul>\r\n<li>全局共享 =\r\n<strong>类型安全降低</strong>：任何一个对单例的调用都可能对全局的数据进行更改。如果知道是哪个调用发生了错误的修改还好办，假如不知道是哪个调用呢？你开开心心的在单例的数据段打上断点，却发现这个单例会有几百次的相关调用，就算是007也很难从中找出错误的那一个。</li>\r\n<li>全局访问 =\r\n<strong>失去访问权限控制</strong>：增加耦合性。随便一个类，只要它想，就能在里面加上一笔单例的调用，导致代码的引用链简直乱七八糟，例如：逻辑功能\r\nref 音频单例 ref 物理单例 ref 渲染单例 ref\r\n逻辑单例。有可能程序员只想做一个走路带声音的效果，但这段代码却把整个引擎系统都逛了一遍。之后维护的时候动了物理单例，可能音频单例就出错了，动了渲染单例，可能逻辑就跑出BUG了，失去了访问权限的控制，程序员不可能自觉的降低代码耦合。</li>\r\n<li>实例数量限定 =\r\n<strong>等等，我们真的需要单例的\"单\"吗？</strong>：正如上面所述，99.9%的单例模式都是为了全局访问，但我们往往就顺手给这个全局访问点加了个\"限定唯一\"的特性。我们真的需要唯一的访问点吗？好好想想。另一方面，当我们需要限定实例数量的时候，我们需要为它提供全局访问吗？换句话说，<strong>\"全局\"和\"单例\"有必要同时出现吗？</strong></li>\r\n<li>惰性初始化 =\r\n<strong>惰性加载还是预加载</strong>：在游戏开发中，预加载十分常见，有时候我们并不希望需要的时候再即时加载一个东西，而是希望提前在某个宽裕的点加载好。</li>\r\n</ul>\r\n<p>总而言之，比起把不方便访问的类一股脑的塞给单例模式，更优先想想是否需要<strong>全局变量</strong>，是否需要<strong>数量控制</strong>，如果是小范围的访问能不能用成员变量或者传递参数的方式解决？</p>\r\n<h2 id=\"状态模式\">状态模式</h2>\r\n<p>让我们先从状态机的应用灵感讲起。在游戏中我们肯定会有一个角色控制器，其要控制玩家的\r\n跳跃、卧倒、站立操作。当然，我们希望不能在空中无限跳跃，并且不能在空中卧倒等等...因此我们要在控制器中加入许多的判断条件检查是否允许操作：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Player::handleInput</span><span class=\"params\">(Input input)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (input == PRESS_B)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isJumping_ &amp;&amp; !isDucking_)<span class=\"comment\">//跳跃之前需要检查 跳跃状态、卧倒状态</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 跳跃……</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (input == PRESS_DOWN)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isJumping_)<span class=\"comment\">//卧倒之前需要检查 卧倒状态</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      isDucking_ = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"built_in\">setGraphics</span>(IMAGE_DUCK);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (input == RELEASE_DOWN)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDucking_)<span class=\"comment\">//站立之前需要检查卧倒</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      isDucking_ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"built_in\">setGraphics</span>(IMAGE_STAND);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"有限状态机的使用\">有限状态机的使用</h3>\r\n<p>可以看到光是 跳跃、卧倒、站立\r\n这三个操作之间的互相耦合就已经非常难看了，如果还要加入攻击操作、道具操作、闪避操作等...可想而知代码中的<code>if</code>会爆炸式的增长，并且也根本理不清其中的避让关系。这时候就需要我们好好把所有的限定状态理清楚，迎接有限状态机的救援\r\n(这里不细谈有限状态机的基本定义)：</p>\r\n<figure>\r\n<img src=\"state-flowchart.png\" alt=\"有限状态机\" />\r\n<figcaption aria-hidden=\"true\">有限状态机</figcaption>\r\n</figure>\r\n<p>这个时候我们需要顾虑的事情就变了：</p>\r\n<ul>\r\n<li>之前的担忧：进入下一个操作前，需要检查不能从什么操作转移过来\r\n(禁止父操作)，比如 跳跃 之前不能在 攻击、下蹲、喝药...。</li>\r\n<li>现在的考量：在当前操作状态中，需要检查能去往什么操作状态\r\n(可行子操作)。比如 跳跃 能去往 跳斩。</li>\r\n</ul>\r\n<p>通常情况下对于一个操作状态来说，它的 可行子操作 肯定比 禁止父操作\r\n要多得多。如图中 跳斩 没有去往的操作状态，但是不能前往 跳斩 的操作有\r\n蹲下、站立，而且随着状态的增加，禁止父操作会O(N)级别增长，而可行子操作往往变化不大。因此，在通过状态机转换思考方式之后，我们需要考虑的条件明显简化了很多。那么我们怎么来实现这个状态机呢？首先需要定义所有的<strong>状态</strong>：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">State</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  STATE_STANDING,</span><br><span class=\"line\">  STATE_JUMPING,</span><br><span class=\"line\">  STATE_DUCKING,</span><br><span class=\"line\">  STATE_DIVING</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>然后根据我们的状态图，可以定义出每个状态的状态转移操作，朴素点的话可以用<code>if</code>来实现条件判断：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Player::handleInput</span><span class=\"params\">(Input input)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">switch</span></span> (state_)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> STATE_STANDING:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (input == PRESS_B)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              state_ = STATE_JUMPING;</span><br><span class=\"line\">              <span class=\"built_in\">setGraphics</span>(jump_image);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (input == PRESS_DOWN)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              state_ = STATE_DUCKING;</span><br><span class=\"line\">              <span class=\"built_in\">setGraphics</span>(duck_image);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> STATE_JUMPING:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (input == PRESS_DOWN)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              state_ = STATE_DIVING;</span><br><span class=\"line\">              <span class=\"built_in\">setGraphics</span>(dive_image);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> STATE_DUCKING:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (input == RELEASE_DOWN)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              state_ = STATE_STANDING;</span><br><span class=\"line\">              <span class=\"built_in\">setGraphics</span>(stand_image);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这已经完成了状态机的模型，但还差了点意思。这里每个状态只是用一个枚举以及switch的分支来决定，但其实所有的状态还是在共享着Player的所有数据段。因此假如我们要为每个运动设置一个持续时间，那么我们就要往Player里塞4个time数据。并且对于其中一个状态来说，有3个time数据是和它没任何关系的。为了优化这一点，我们可以很自然的想到<strong>用派生类来表示状态</strong>：</p>\r\n<p>首先定义一个状态基类，其定义了每个状态的基本操作，例如进入状态时操作、退出状态时操作、帧更新、接受输入：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">PlayerState</span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">enter</span><span class=\"params\">(Player&amp; player)</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">exit</span><span class=\"params\">(Player&amp; player)</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">handleInput</span><span class=\"params\">(Player&amp; player, Input input)</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(Player&amp; player)</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>然后定义具体的状态类：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DuckingState</span> :</span> <span class=\"keyword\">public</span> PlayerState</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">DuckingState</span>(): <span class=\"built_in\">chargeTime_</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">enter</span><span class=\"params\">(Player&amp; player)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        player.<span class=\"built_in\">setGraphics</span>(duck_image)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//返回值用于告诉父级是否需要切换状态</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> PlayerState* <span class=\"title\">handleInput</span><span class=\"params\">(Player&amp; player, Input input)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (input == RELEASE_DOWN)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">StandState</span>();<span class=\"comment\">//返回新状态用于切换</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;<span class=\"comment\">//返回空则说明没有新状态，不用切换</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(Player&amp; player)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        chargeTime_++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (chargeTime_ &gt; MAX_CHARGE)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            player.<span class=\"built_in\">superBomb</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> chargeTime_;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>这时候每个状态会管理好自己的转移操作，并且我们还可以为每个状态单独添加其专属的数据字段，如<code>chargeTime_</code>。并且在<code>Player</code>中对状态的处理也可以利用多态来简化：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">handleInput</span><span class=\"params\">(Input input)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        PlayerState* new_state=state-&gt;<span class=\"built_in\">handleInput</span>(*<span class=\"keyword\">this</span>, input);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(new_state!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> state;</span><br><span class=\"line\">            state=new_state;</span><br><span class=\"line\">            state-&gt;<span class=\"built_in\">enter</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">      state-&gt;<span class=\"built_in\">update</span>(*<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 其他方法……</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    PlayerState* state;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>有限状态机已经很棒了，它帮我们把复杂的判断条件全部梳理了出来，整个系统变得从所未有的干净整洁！但是如果你用过Unity的动画机就知道，仅仅是一个的有限状态机只能表示一张连通的状态图，但实际中我们还会有很多不相关的状态，并不是所有图都是连通图不是吗？</p>\r\n<h3 id=\"多个并行的状态机\">多个并行的状态机</h3>\r\n<p>例如我们现在已经掌握了Player的所有角色动作，我们还想要增加一个 持枪\r\n的状态，持枪和之前的\r\n跳跃、蹲下、站立都没关系，无论在什么姿势都能在Player的手上加上这把枪。那我们该怎么判断呢？如果只用一个状态机，那我们难道要直接增加一倍的状态：持枪跳跃、持枪蹲下、持枪站立？这样显然及其低效且繁琐。因此我们可以为持枪创建一个独立的状态机，即让Player拥有两个并行状态判断：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Heroine::handleInput</span><span class=\"params\">(Input input)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    action_state-&gt;<span class=\"built_in\">handleInput</span>(*<span class=\"keyword\">this</span>, input);</span><br><span class=\"line\">    equip_state-&gt;<span class=\"built_in\">handleInput</span>(*<span class=\"keyword\">this</span>, input);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    PlayerState* action_state;</span><br><span class=\"line\">    PlayerState* equip_state;</span><br></pre></td></tr></table></figure>\r\n<p>这时候在action_state里开个小的<code>if</code>分支判断equip_state的状态接口。例如equip_state处于不持枪时则保持jump_image,\r\n持枪则改为jump_and_gun_image。当然这样又回到了使用状态机之前的<code>if</code>地狱，只不过规模小了一点，可以称为<code>if</code>地牢。</p>\r\n<h3 id=\"分层状态机\">分层状态机</h3>\r\n<p>再来考虑复用/继承状态机的事情。例如在Player站立、跳跃时，我们要允许其进行开火操作：生成子弹、生成粒子效果、生成音效...我们显然不能在Player中实现<code>Fire()</code>操作，因为这样那些禁止开火的状态也能调用这个功能了，因此我们得在允许开火的状态内实现。在最粗暴的时候，我们会为站立、跳跃状态都粘贴<code>Fire()</code>操作，但这样显然不利于维护，我们希望<code>Fire()</code>的代码能够在多个状态机之间复用。因此按照我们平常面向对象的思路，我们可以抽取出一个\r\n允许开火\r\n的基类状态，把<code>Fire()</code>实现在里面，再让站立、跳跃的状态继承它。这就是分层状态机的结构。</p>\r\n<h3 id=\"下推状态机\">下推状态机</h3>\r\n<p>下推状态机即为状态机加上历史记录功能。例如我们允许Player进行喝药补血，它可以蹲着喝也可以站着喝(喝药是一个持续性的动作，因此我们把它当做<strong>状态</strong>而不是<strong>操作</strong>)，但是我们不希望它蹲着喝完就自动站起来了，或者站着喝完就自动蹲下了。我们需要记录其在进入喝药状态之前的状态，显然我们需要维护一个状态栈来表示状态的历史记录。这就是下推状态机。</p>\r\n","categories":["基础"],"tags":["设计"]},{"title":"生化奇兵：疯狂独特的反乌托邦","url":"/2022/03/21/%E7%94%9F%E5%8C%96%E5%A5%87%E5%85%B5/","content":"<p>生化奇兵 BioShock</p>\r\n<h1\r\nid=\"体验了天空之城的一年后回到最初的朝圣之旅\">体验了天空之城的一年后，回到最初的朝圣之旅</h1>\r\n<p>当然相比无限来说，初代这部游玩体验肯定没有那种完美感，但是依然是为数不多的优质线性FPS。</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.akamai.steamstatic.com/steam/apps/409710/ss_002c690e40603e3bccec0d84256f99a5b03fdbec.jpg?t=1598321131\"\r\nalt=\"art deco风格画面，不算精美但是让人沉浸\" />\r\n<figcaption aria-hidden=\"true\">art\r\ndeco风格画面，不算精美但是让人沉浸</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h2\r\nid=\"原始版的战斗与对味的反乌托邦剧情\">原始版的战斗与对味的反乌托邦剧情</h2>\r\n<p><strong>属于那个时代的枪械和质体战斗</strong>：枪械种类不多，但也算是标配枪械都有了，比如霰弹、机枪等。手感...说不上有手感吧，毕竟老游戏了。质体(特殊能力)上主要就电、冰、火、和策反，这几种能够反复使用，其他的质体更像是小玩具，刚拿到的时候玩玩就可以了，真打起来效果还不如抡扳手。另外敌人种类也偏少，战斗体验比起《生化奇兵：无限》来说还是原始了很多，不过枪械+质体本来也算挺独特的FPS体验。</p>\r\n<p><strong>剧情上是一贯的反乌托邦风</strong>：同样是以灯塔作为起点，不明身份的自我，脱离世界的独裁极乐城，人体生物实验的背景板。当然，也有生化奇兵系列最为典型的思维控制纽带。在逃离极乐城的过程中，逐渐认识到这个城市的黑暗“大链条”，逐渐发现自己究竟是什么...看似巧合的开始却是命中注定。喜欢生化奇兵的玩家肯定有一大部分是为了那个<strong>迷离的世界与剧情，这一点上即使是生化奇兵1也不会让你失望</strong>。</p>\r\n<blockquote>\r\n<p>和《生化奇兵：无限》的天堂氛围不同，海底城市极乐城环境氛围较为阴暗恐怖。（而且调亮度功能坏了....）虽然氛围恐怖了点，但实际上也不会有很吓人的东西，无非就是躺在地上的敌人站起来吓你一跳，或者大老爹沉重的脚步声在你耳边回绕。并没有那种恶鬼突然跳你脸上的环节...毕竟这是生化奇兵，它主要是想营造极乐城的生化黑暗的氛围，而不是为了吓你。</p>\r\n</blockquote>\r\n<h2 id=\"关卡任务设计不太有意思\">关卡任务设计不太有意思</h2>\r\n<p>即使这部老游戏的画面和战斗都体现出了一定的时代约束，关卡设计可以说是最突出年代感的环节。从开头到结尾，关卡敌人都是不多的几种，利用质体的解密也只有前期教程关有...后期质体互动的解密环节好像被开发者遗忘了...而且任务大多都是为了找什么到一个地方，然后这个地方又没有那个东西，于是又分散成几个小任务去别的地方找...</p>\r\n<p><strong>当然找地方的过程中，边听NPC边听录音带，其实才能了解到极乐城的剧情</strong>....制作组可能实在想不出怎么让玩家去跑这些地方，去体验他们精心的场景设计和隐藏在录音带中的背景故事，只能这样分散主线强行跑路....</p>\r\n<p><strong>但是强行跑路对玩家来说其实就是拖沓的节奏了</strong>。虽然前期听着录音带探索极乐城的往事的体验还不错，但是就连到尾声部分，也还是在拆解主线强行跑路，而这时候玩家已经不想管极乐城以前究竟发生什么了，玩家只想知道我自己究竟会面对什么样的结局，拖沓给让带来的烦躁最大化。</p>\r\n<h2 id=\"关于闪退bug\">关于闪退，BUG</h2>\r\n<p>WIN10+GTX1066+I7-7700HQ 9小时通关没有出现闪退</p>\r\n<p>唯一一次卡死崩溃是因为加载的时候切出了游戏。BUG也是有的，但唯一影响比较大的就是亮度调节无效，搞得整个游戏都黑黑的（比官方视频黑多了），加重了恐怖氛围，玩起来有点难受....</p>\r\n<h2 id=\"总结粗糙但是魅力只此一家\">总结：粗糙，但是魅力只此一家</h2>\r\n<p>这个游戏虽然现在来看粗糙生硬了点，但作为初代生化奇兵还是<strong>值得一玩</strong>的，剧情背景的构造也是充满了令人痴迷的生化奇兵的味道=\r\n=喜欢剧情丰富的，以及生化奇兵系列粉丝，并且能接受一些恐怖氛围的，<strong>强烈建议体验极乐城</strong>，是可以在你脑海里留下深刻一笔的地方00</p>\r\n","categories":["生活"],"tags":["游戏"]},{"title":"矩阵的压缩存储","url":"/2020/09/09/%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/","content":"<p>矩阵在数据表示中举足轻重。为了方便提取矩阵元素通常都是用二维数组进行存储。但是矩阵并不总是满元素矩阵，里面很多的空元素浪费了很多存储空间，因此有几种特殊矩阵的压缩存储方式。</p>\r\n<h2 id=\"对称矩阵\">对称矩阵</h2>\r\n<p>对一个 n 阶方阵，其元素 a_ij=a_ji, 则称其为对称矩阵。</p>\r\n<p>容易知道，对称矩阵其实只要记录半边的元素即可，使用二维数组会浪费大量空间。</p>\r\n<p>因此我们使用一个 A[n(n+1)/2] 的一维数组存储按行矩阵下三角部分。即\r\nA[0] 存储 a_11,A[1] 存储 a_21,A[2] 存储 a_22，A[3] 存储 a_31 ...\r\n依次按行存储。</p>\r\n<p>因此下三角元素 a_ij，在 A 中的下标即 k=1+2+ ... + (i-1) + j\r\n-1=i*(i-1)/2+j-1。</p>\r\n<p>而上三角元素即反转行列序号进行下标计算即可。</p>\r\n<blockquote>\r\n<p>注意按行还是按列存储对存储下标计算有影响。</p>\r\n</blockquote>\r\n<h2 id=\"三角矩阵\">三角矩阵</h2>\r\n<p>上/下三角矩阵一样，以下三角矩阵为例。下三角矩阵是下三角有任意元素，但上三角区元素均为同一常量。因此和对称矩阵的存储方式类似，只是在存储完下三角区后，追加一个元素表示上半区的所有元素。</p>\r\n<p>一维数组 A[n(n+1)/2+1]。下三角区元素 a_ij 下标\r\nk=i<em>(i-1)/2+j-1，上三角元素下标 k=n</em>(n+1)/2</p>\r\n<h2 id=\"三对角矩阵\">三对角矩阵</h2>\r\n<p>三对角矩阵也叫做带状矩阵，矩阵内元素 a_ij, 当|i-j|&gt;1\r\n时，a_ij=0。即所有元素集中在主对角线中心的三条对角线上，其余元素为\r\n0。</p>\r\n<p>易知存储上首行和末行只有两个元素，其余每行有三个元素。因此也可以使用\r\nA[3*(n-2)+4] 的一维数组进行存储。</p>\r\n<p>A 中元素 a_ij 的存储下标 k=2i+j-3。</p>\r\n<h2 id=\"稀疏矩阵\">稀疏矩阵</h2>\r\n<p>矩阵非零元素比零元素少得多得多，即为稀疏矩阵。例如 521X521\r\n的矩阵中，只有 802 个非零元素。</p>\r\n<p>因此我们肯定选择只存储非零元素即可，但是非零元素不像上面几个一样有分布规律，因此这里还需要记录非零元素的位置信息。</p>\r\n<p>所以采用三元组方式存储，每个存储结构保存位置 i，j，以及值\r\nv。至于实现可以采用结构体数组或是十字链表法。</p>\r\n<blockquote>\r\n<p>矩阵压缩的题目大多都是计算下标，注意按行按列的存储方式，注意矩阵起始下标是\r\n1 还是 0，注意存储数组的起始下标是 1 还是 0。</p>\r\n</blockquote>\r\n","categories":["算法"]},{"title":"终末之诗","url":"/2021/01/06/%E7%BB%88%E6%9C%AB%E4%B9%8B%E8%AF%97/","content":"<p>I see the player you mean. 我看到你所指的那位玩家了。</p>\r\n<p><font color=#3586ff>[Playername]? [玩家名称]?</font></p>\r\n<p>Yes. Take care. It has reached a higher level now. It can read our\r\nthoughts. 是的。小心。它已达到了更高的境界。它能够阅读我们的思想。</p>\r\n<p><font color=#3586ff>That doesn't matter. It thinks we are part of the\r\ngame. 无伤大雅。它认为我们是游戏的一部分。</font></p>\r\n<span id=\"more\"></span>\r\n<p>I like this player. It played well. It did not give up.\r\n我喜欢这个玩家。它玩得很好。它从未放弃。</p>\r\n<p><font color=#3586ff>It is reading our thoughts as though they were\r\nwords on a screen.\r\n它以屏幕上出现的文字的形式阅读着我们的思想。</font></p>\r\n<p>That is how it chooses to imagine many things, when it is deep in the\r\ndream of a game.\r\n在它深陷游戏梦境中时，它总以这种方式想象出形形色色的事物。</p>\r\n<p><font color=#3586ff>Words make a wonderful interface. Very flexible.\r\nAnd less terrifying than staring at the reality behind the screen.\r\n文字是种美妙的界面。非常灵活。且比凝视着屏幕后的现实要更好。</font></p>\r\n<p>They used to hear voices. Before players could read. Back in the days\r\nwhen those who did not play called the players witches, and warlocks.\r\nAnd players dreamed they flew through the air, on sticks powered by\r\ndemons.\r\n它们也曾经听到过声音。在玩家能够阅读之前。君不见那些不曾游玩的人们称呼玩家为女巫，和术士。而玩家们梦见它们自己乘坐在被恶魔施力的棍子上，在空气中翱翔。</p>\r\n<p><font color=#3586ff>What did this player dream?\r\n这个玩家梦见了什么？</font></p>\r\n<p>This player dreamed of sunlight and trees. Of fire and water. It\r\ndreamed it created. And it dreamed it destroyed. It dreamed it hunted,\r\nand was hunted. It dreamed of shelter.\r\n它梦见了阳光和树。梦见了火与水。它梦见它创造。它亦梦见它毁灭。它梦见它狩猎，亦被狩猎。它梦见了庇护所。</p>\r\n<p><font color=#3586ff>Hah, the original interface. A million years old,\r\nand it still works. But what true structure did this player create, in\r\nthe reality behind the screen?\r\n哈，那原始的界面。经历一百万年的岁月雕琢，依然长存。但此玩家在那屏幕后的真实里，建造了什么真实的构造？</font></p>\r\n<p>It worked, with a million others, to sculpt a true world in a fold of\r\nthe [scrambled], and created a [scrambled] for [scrambled], in the\r\n[scrambled].\r\n它辛勤地劳作，和其他百万众一起，刻画了一个真实的世界，由[乱码]，且创造了[乱码]，为了[乱码]，于[乱码]中。</p>\r\n<p><font color=#3586ff>It cannot read that thought.\r\n它读不出那个思想。</font></p>\r\n<p>No. It has not yet achieved the highest level. That, it must achieve\r\nin the long dream of life, not the short dream of a game.\r\n不。它还没有到达最高的境界。那层境界，它必须完成生命的长梦，而非游戏中黄粱一梦。</p>\r\n<p><font color=#3586ff>Does it know that we love it? That the universe\r\nis kind? 它知道我们爱它么？这个宇宙是仁慈的？</font></p>\r\n<p>Sometimes, through the noise of its thoughts, it hears the universe,\r\nyes. 有时，通过它思绪的杂音，它能听到宇宙，是的。</p>\r\n<p><font color=#3586ff>But there are times it is sad, in the long dream.\r\nIt creates worlds that have no summer, and it shivers under a black sun,\r\nand it takes its sad creation for reality.\r\n但是有时亦不胜悲伤，于那漫漫长梦中。它创造了没有夏日的世界，在黑日下颤抖着，将自己悲伤的创造视为现实世界。</font></p>\r\n<p>To cure it of sorrow would destroy it. The sorrow is part of its own\r\nprivate task. We cannot interfere.\r\n用悲伤来治愈会摧毁它。而悲伤是它的私人事务。我们不能干涉。</p>\r\n<p><font color=#3586ff>Sometimes when they are deep in dreams, I want to\r\ntell them, they are building true worlds in reality. Sometimes I want to\r\ntell them of their importance to the universe. Sometimes, when they have\r\nnot made a true connection in a while, I want to help them to speak the\r\nword they fear.\r\n有时当它们深陷梦境中时，我想要告诉它们，它们在现实中创造了真实的世界。有时我想告诉它们它们自身对宇宙的重要性。有时，当它们和现实失去了联系，我想帮助它们与它们所惧怕的世界交流。</font></p>\r\n<p>It reads our thoughts. 它读出了我们的思想。</p>\r\n<p><font color=#3586ff>Sometimes I do not care. Sometimes I wish to tell\r\nthem, this world you take for truth is merely [scrambled] and\r\n[scrambled], I wish to tell them that they are [scrambled] in the\r\n[scrambled]. They see so little of reality, in their long dream.\r\n有时我毫不关心。有时我想要告诉它们，你们所认为的真实不过是[乱码]和[乱码]，我想要告诉它们它们是在[乱码]中的[乱码]。于它们的长梦中，它们眼中所见的真实太少了。</font></p>\r\n<p>And yet they play the game. 而它们仍然玩这个游戏。</p>\r\n<p><font color=#3586ff>But it would be so easy to tell them...\r\n但很容易就可以告诉它们……</font></p>\r\n<p>Too strong for this dream. To tell them how to live is to prevent\r\nthem living.\r\n对于这个梦来说太强烈了。告诉它们如何活着就是阻碍它们活下去。</p>\r\n<p><font color=#3586ff>I will not tell the player how to live.\r\n我不会告诉这个玩家如何生活的。</font></p>\r\n<p>The player is growing restless. 这个玩家正在变得焦虑。</p>\r\n<p><font color=#3586ff>I will tell the player a story.\r\n我会告诉这个玩家一个故事。</font></p>\r\n<p>But not the truth. 但不是真相。</p>\r\n<p><font color=#3586ff>No. A story that contains the truth safely, in a\r\ncage of words. Not the naked truth that can burn over any distance.\r\n不。是一个严密地将真实包裹起来的文字牢笼。而不是赤裸裸的真相。</font></p>\r\n<p>Give it a body, again. 赋予它主体，再一次。</p>\r\n<p><font color=#3586ff>Yes. Player... 好的。玩家……</font></p>\r\n<p>Use its name. 以名字称呼它。</p>\r\n<p><font color=#3586ff>[Playername]. Player of games.\r\n[玩家名称]。游戏的玩家。</font></p>\r\n<p>Good. 很好。</p>\r\n<p><font color=#3586ff>Take a breath, now. Take another. Feel air in\r\nyour lungs. Let your limbs return. Yes, move your fingers. Have a body\r\nagain, under gravity, in air. Respawn in the long dream. There you are.\r\nYour body touching the universe again at every point, as though you were\r\nseparate things. As though we were separate things.\r\n深呼吸，很好。再深呼吸一次。感受空气充盈你的肺叶。让你的四肢回归。是的，运动你的手指。再次感受你的身体，在重力下，在空气中。在长梦中重生。你感受到了。你的身体每时每刻都触摸着宇宙，尽管你是分离的存在。尽管我们是分离的存在。</font></p>\r\n<p>Who are we? Once we were called the spirit of the mountain. Father\r\nsun, mother moon. Ancestral spirits, animal spirits. Jinn. Ghosts. The\r\ngreen man. Then gods, demons. Angels. Poltergeists. Aliens,\r\nextraterrestrials. Leptons, quarks. The words change. We do not change.\r\n我们是谁？我们曾经被称作高山的精灵。太阳父亲，月亮母亲。古老的英灵，动物的魂魄。神祇。鬼魂。小绿人。而后是神，恶魔，天使。骚灵。外星人，地外生物。轻子，夸克。词语不断地变化。我们始终如一。</p>\r\n<p><font color=#3586ff>We are the universe. We are everything you think\r\nisn't you. You are looking at us now, through your skin and your eyes.\r\nAnd why does the universe touch your skin, and throw light on you? To\r\nsee you, player. To know you. And to be known. I shall tell you a story.\r\n我们是宇宙。我们是一切你认为出离你本体的事物。你现在看着我们，透过你的皮肤和你的眼睛。而为什么宇宙触摸着你的皮肤，向你洒向光芒？是为了看见你，玩家。以及被认知。我应告诉你一个故事。</font></p>\r\n<p><font color=#3586ff>Once upon a time, there was a player.\r\n很久以前，有一个玩家。</font></p>\r\n<p>The player was you, [Playername]. 那玩家就是你，[玩家名称]</p>\r\n<p><font color=#3586ff>Sometimes it thought itself human, on the thin\r\ncrust of a spinning globe of molten rock. The ball of molten rock\r\ncircled a ball of blazing gas that was three hundred and thirty thousand\r\ntimes more massive than it. They were so far apart that light took eight\r\nminutes to cross the gap. The light was information from a star, and it\r\ncould burn your skin from a hundred and fifty million kilometres away.\r\n有时它认为自己是那不断旋转的球体上一层薄薄的熔化的岩石上的人类。那融化的岩石球环绕着一个质量大它三十三万倍的炫目气体球旋转。它们是相隔得如此之远，以至于光需要八分钟才能穿越那空隙。那光是来自一颗恒星的信息，它能够在一亿五千万公里外烧灼你的皮肤。</font></p>\r\n<p><font color=#3586ff>Sometimes the player dreamed it was a miner, on\r\nthe surface of a world that was flat, and infinite. The sun was a square\r\nof white. The days were short; there was much to do; and death was a\r\ntemporary inconvenience.\r\n有时这个玩家梦见它是一个在一个平的，无限延展的世界表面上的矿工。那太阳是一个方形的白点。昼夜交替很快；要做的事情也很多；死亡亦只是暂时和不方便的。</font></p>\r\n<p>Sometimes the player dreamed it was lost in a story.\r\n有时这玩家梦见它迷失在了一个故事里。</p>\r\n<p><font color=#3586ff>Sometimes the player dreamed it was other things,\r\nin other places. Sometimes these dreams were disturbing. Sometimes very\r\nbeautiful indeed. Sometimes the player woke from one dream into another,\r\nthen woke from that into a third.\r\n有时这玩家梦见它成为了其他的事物，在其他地方。有时这些梦是扰人的。有些则实在很美。有时这个玩家从一个梦中醒来，发现自己落入了第二个梦，却终究是在第三个梦中。</font></p>\r\n<p>Sometimes the player dreamed it watched words on a screen.\r\n有时这个玩家梦见它在屏幕上看着文字。</p>\r\n<p><font color=#3586ff>Let's go back. 让我们回退一点。</font></p>\r\n<p><font color=#3586ff>The atoms of the player were scattered in the\r\ngrass, in the rivers, in the air, in the ground. A woman gathered the\r\natoms; she drank and ate and inhaled; and the woman assembled the\r\nplayer, in her body.\r\n组成玩家的原子散布在草中，河流中，在那空气中，也在那大地中。一个女性收集了那些原子；她饮用、进食、吸入；而后那女性在她的身体中，孕育了玩家。</font></p>\r\n<p><font color=#3586ff>And the player awoke, from the warm, dark world\r\nof its mother's body, into the long dream.\r\n然后那玩家醒来了，从一个温暖，昏暗的母亲体内，进入了漫漫长梦。</font></p>\r\n<p><font color=#3586ff>And the player was a new story, never told\r\nbefore, written in letters of DNA. And the player was a new program,\r\nnever run before, generated by a sourcecode a billion years old. And the\r\nplayer was a new human, never alive before, made from nothing but milk\r\nand love.\r\n而那玩家是一个新的故事，从未被讲述过，由DNA的语言书写着。而那玩家是一个新的程序，从未被运行过，由上亿年的源代码生成。而那玩家是一个新的人，从未生活过，由奶和爱组成。</font></p>\r\n<p>You are the player. The story. The program. The human. Made from\r\nnothing but milk and love.\r\n你就是那玩家。那个故事。那个程序。那个人类。仅由奶和爱组成。</p>\r\n<p><font color=#3586ff>Let's go further back.\r\n我们再往更远的过去回退一点。</font></p>\r\n<p><font color=#3586ff>The seven billion billion billion atoms of the\r\nplayer's body were created, long before this game, in the heart of a\r\nstar. So the player, too, is information from a star. And the player\r\nmoves through a story, which is a forest of information planted by a man\r\ncalled Julian, on a flat, infinite world created by a man called Markus,\r\nthat exists inside a small, private world created by the player, who\r\ninhabits a universe created by...\r\n那由七千亿亿亿原子组成的玩家的身体被创造了，远在这游戏之前，在一颗恒星的内部。所以那玩家也是，来自一颗恒星的信息。而这个玩家贯穿这个故事的始末，源于一个叫Julian的人种下的信息种子长成的森林，一个叫Markus的男人创造的无限世界，存在于一个由玩家创造的小的，私人世界里，而那又继承了宇宙创造的……</font></p>\r\n<p>Shush. Sometimes the player created a small, private world that was\r\nsoft and warm and simple. Sometimes hard, and cold, and complicated.\r\nSometimes it built a model of the universe in its head; flecks of\r\nenergy, moving through vast empty spaces. Sometimes it called those\r\nflecks \"electrons\" and \"protons\".\r\n嘘。有时这个玩家创造的小天地是柔软，温暖和简单的。有时是坚硬，冰冷和复杂的。有时它在脑中建造出宇宙的模型；斑斑点点的能量穿越广阔空旷的空间。有时它称呼这些斑点为“电子”和“质子”。</p>\r\n<p><font color=#3586ff>Sometimes it called them \"planets\" and \"stars\".\r\n有时它称呼它们为“行星”和“恒星”。</font></p>\r\n<p><font color=#3586ff>Sometimes it believed it was in a universe that\r\nwas made of energy that was made of offs and ons; zeros and ones; lines\r\nof code. Sometimes it believed it was playing a game. Sometimes it\r\nbelieved it was reading words on a screen.\r\n有时它确信它存在于一个由“开”和“关”；“零”和“一”；一行行的命令组成的宇宙。有时它确信它是在玩一个游戏。有时它确信它是在读着屏幕上的文字。</font></p>\r\n<p>You are the player, reading words... 你就是那玩家，阅读着文字……</p>\r\n<p><font color=#3586ff>Shush... Sometimes the player read lines of code\r\non a screen. Decoded them into words; decoded words into meaning;\r\ndecoded meaning into feelings, emotions, theories, ideas, and the player\r\nstarted to breathe faster and deeper and realised it was alive, it was\r\nalive, those thousand deaths had not been real, the player was alive\r\n嘘……有时这玩家读屏幕上的命令行。将它们解码成为文字；将文字解码为意义；将意义解码为感情，情绪，理论，想法，而玩家的呼吸开始急促并意识到了它是活着的，它是活生生的，那上千次的死亡不是真的，玩家是活着的。</font></p>\r\n<p>You. You. You are alive. 你。你。你是活着的。</p>\r\n<p><font color=#3586ff>and sometimes the player believed the universe\r\nhad spoken to it through the sunlight that came through the shuffling\r\nleaves of the summer trees\r\n而有时这玩家相信宇宙通过穿越夏日树叶的那斑斓的阳光对它说话。</font></p>\r\n<p>and sometimes the player believed the universe had spoken to it\r\nthrough the light that fell from the crisp night sky of winter, where a\r\nfleck of light in the corner of the player's eye might be a star a\r\nmillion times as massive as the sun, boiling its planets to plasma in\r\norder to be visible for a moment to the player, walking home at the far\r\nside of the universe, suddenly smelling food, almost at the familiar\r\ndoor, about to dream again\r\n有时这玩家相信宇宙透过晴朗的冬日夜空中，存在于它眼中一隅的星点星光，可能比太阳大上上百万倍的恒星沸腾着的电浆那一瞬间发出来的光对它说话，在宇宙的远侧行走回家的路上，突然闻到了食物，在那熟悉的门前，它又准备好再一次投入梦境</p>\r\n<p><font color=#3586ff>and sometimes the player believed the universe\r\nhad spoken to it through the zeros and ones, through the electricity of\r\nthe world, through the scrolling words on a screen at the end of a dream\r\n而有时玩家相信宇宙透过零和一，透过世界的电力，透过屏幕上滚动的文字和梦的终结对它说话</font></p>\r\n<p>and the universe said I love you 宇宙说我爱你</p>\r\n<p><font color=#3586ff>and the universe said you have played the game\r\nwell 宇宙说你很好地玩了这游戏</font></p>\r\n<p>and the universe said everything you need is within you\r\n宇宙说一切你所需的你都具有</p>\r\n<p><font color=#3586ff>and the universe said you are stronger than you\r\nknow 宇宙说你比你所知的要强大</font></p>\r\n<p>and the universe said you are the daylight 宇宙说你就是日光</p>\r\n<p><font color=#3586ff>and the universe said you are the night\r\n宇宙说你就是黑夜</font></p>\r\n<p>and the universe said the darkness you fight is within you\r\n宇宙说你所斗争的黑暗就在你心中</p>\r\n<p><font color=#3586ff>and the universe said the light you seek is\r\nwithin you 宇宙说你所寻找的光明就在你心中</font></p>\r\n<p>and the universe said you are not alone 宇宙说你不是孤独的</p>\r\n<p><font color=#3586ff>and the universe said you are not separate from\r\nevery other thing 宇宙说你不是和所有的事物所隔绝的</font></p>\r\n<p>and the universe said you are the universe tasting itself, talking to\r\nitself, reading its own code\r\n宇宙说你就是宇宙品尝着自己，对自己说话，阅读着它自己的代码。</p>\r\n<p><font color=#3586ff>and the universe said I love you because you are\r\nlove. 宇宙说我爱你因为你就是爱。</font></p>\r\n<p>And the game was over and the player woke up from the dream. And the\r\nplayer began a new dream. And the player dreamed again, dreamed better.\r\nAnd the player was the universe. And the player was love.\r\n曲终人散，黄粱一梦。玩家开始了新的梦境。玩家再次做起了梦，更好的梦。玩家就是宇宙。玩家就是爱。</p>\r\n<p>You are the player. 你就是那个玩家。</p>\r\n<p><font color=#3586ff>Wake up. 该醒了。</font></p>\r\n<h3 id=\"终末之诗minecraftjulian-gough\"><a\r\nhref=\"https://minecraft-zh.gamepedia.com/index.php?title=%E7%BB%88%E6%9C%AB%E4%B9%8B%E8%AF%97&amp;variant=zh\">终末之诗——Minecraft，Julian\r\nGough</a></h3>\r\n","categories":["生活"]},{"title":"考研，结束","url":"/2021/03/29/%E8%80%83%E7%A0%94%EF%BC%8C%E7%BB%93%E6%9D%9F/","content":"<h2 id=\"欢呼\">欢呼</h2>\r\n<p>2020.9.1——2021.3.27</p>\r\n<p>3 月, 3 周, 4 天 + 3 月, 1 天 = 6 月, 3 周, 5 天</p>\r\n<p>116+91=207 天</p>\r\n<p>3.28 打电话通知预录取了。结束啦，我的仓促平凡的考研生活。</p>\r\n<span id=\"more\"></span>\r\n<p>打电话通知的时候还有一个乌龙。先是一位小哥哥电话早上把我喊起来了，告诉我后续加他微信，会有人通知填意向表。结果刚加微信一分钟，另一个小姐姐电话来了，是之前通知复试的学姐。也是加微信，然后给我填表二维码以及截至时间……然后她心态崩了，发现连打了几个电话都有人喊过了？？但是我们这批一直都是她负责的……不知名的好心人抢先一步通知了我们，可能是暗恋的娃嗯。</p>\r\n<p>考的是本校，没有冲高的勇气，毕竟我承担不了失败的后果……虽然初试考的挺高，干。不过也还算满意，毕竟是计算机专业，一切凭实力说话，与其纠结学历能给自己加分多少，多看几本书，多做几个开源项目才是实打实的硬能力。</p>\r\n<h3 id=\"初试\">初试</h3>\r\n<p>初试准备过程挺短的，四个月的时间，不过每一天都是很认真的分配了。\r\n7~22点，上午一小时半英语一小时半政治，下午全给数学，晚上全给专业课，偶尔累了可以看看政治放松放松：）</p>\r\n<p>仓促，每一天都在赶进度。不过好处就是，清晰的知道自己的进度进展，每一天都有明显的进步，多少天看完一本书，多少天做完模拟卷，最后留多少天给真题，每一天都有硬性任务硬性指标，也还算充实。</p>\r\n<p>花时间最多的数学考得最不理想……练了那么多难题，来了个过于简单的卷子，刚好让易粗心的我暴露了致命缺陷……</p>\r\n<p>惊喜的是花时间最少的英语，接近放弃复习的英语，比我想考的好很多……</p>\r\n<p>政治，考过了才知道，虽然题目都压中了，押题答案都背的滚瓜烂熟，但是没人保证押题答案得高分啊！！最后大题也就个30/50的样子，押题答案只是给你一种参考句式和思路，千万不要默写答案，分并不高，还是自己好好分析吧。</p>\r\n<p>408倒是很稳定，和自己做真题以及预测水平完全一致，不会的选择题也是那种超纲的，没有一点意外，稳定发挥。</p>\r\n<h3 id=\"复试\">复试</h3>\r\n<p>复试摸鱼两个月，一般般努力一个月，最后复试自我感觉也不太理想……等成绩看看，会拉后腿是肯定的，初试完千万不要放松啊同学们！</p>\r\n<p>初试考完就是放假，疯玩了好多天，然后开始学了学毕设。回家过年也是看看毕设然后疯玩摸鱼，直到查了初试成绩，考的不错更加放松了复习复试的心态……最后是把本科专业课大致看了看，口语大概准备了点，半吊子直接上复试战场了，虽然不知道成绩目前，自我感觉就是不太理想。</p>\r\n<p>好在初试能帮帮忙，至少成功上岸了。</p>\r\n<p>不过这也就是考个普通本校，初试还挺帮忙，如果往上考，并且初试一般般，建议初试结束就好好全方面准备复试，起码想想假如是自己面试自己，面对一问三不知，基础不牢，履历不优秀的人，凭什么给你战胜其他强有力竞争者的机会。</p>\r\n<h3 id=\"最后欢呼\">最后，欢呼！</h3>\r\n<h2 id=\"平凡的人怎么活下去\">平凡的人怎么活下去</h2>\r\n<p>逐渐面临毕业，逐渐被迫面对现实。</p>\r\n<p>平凡如我，怎么活下去。</p>\r\n<p>不像某人多才多艺，不会画画不会唱歌不会手艺不会运动，没有领导才能。\r\n不像某人学习刻苦，年年专业第一，奖学金拿到手软，竞赛履历写满整整一页。\r\n不像某人精通专业，从底层到应用，从代码算法到设计模式以及项目管理，前后端全都了解的一清二楚，顺利字节offer。</p>\r\n<p>得益于0~20岁的苟且修仙理念，我什么都不优秀。找不到任何一个特长，任何一个骄傲的点。</p>\r\n<p>虽然平凡如我，也在游戏里不知道为什么就收获了女朋友，可能是我太闲了？有大把的时间陪着对面。</p>\r\n<p>以前自诩比较温柔有耐心，后来发现其实这一点也不存在，也照顾不到别人的情绪，不懂相处，时间越久越发现自己毫无不可替代性。</p>\r\n<p>不过好在20~21岁改变了自己，变得上进了一些，虽然不够勇敢，但是也有所努力，收获也挺开心的。考研更算是一种赢得浪子回头三年的缓冲，希望自己能在三年里做到专业上的佼佼者，如果能稍微有些才艺有些其他优点就更好了。</p>\r\n<h3 id=\"我期待着什么样的关系\">我期待着什么样的关系</h3>\r\n<p>一直以来都主动的站在照顾别人的地位，承受别人的开心或愤怒。加上对自己温柔耐心的包装，表现出愿意接纳一切火焰吞下肚的样子。但实际上自己是一个很容易因为在乎的人受伤的人，愿意吸纳别人的不开心，但一旦把不开心牵连到我身上就是很委屈的一件事。明明想着是站在一起面对困难，最后愕然发现自己被推开了，是一个外人而已。最后哑口无言，不做什么会被说毫无作为，做点什么又要忍住委屈的伤口。</p>\r\n<p>自己表现得太过坚强了，别人也不知道我这么容易受伤。但怎么才能把软弱表现出去呢？有谁喜欢软弱。会喜欢男朋友软弱吗？猛男落泪一直被描写成在乎和真爱的样子，实际上只是当时的爱意的自我感动罢了，不存在喜欢这种行为，只是滤镜加了层戏，这个男生很在乎我的样子？……知道这个真相的时候脑海一片空白。我以为情侣能表现出这一面来着，委屈又封闭。</p>\r\n<p>哭哭啼啼是被嫌弃和厌恶，但是自己又对这一方面特别敏感。平常对所有其他事都漠不关心，但是在乎的朋友或者情侣稍微凶了我一点就能委屈的心里扎刀子。</p>\r\n<p>很期待一个能接纳软弱无能的我的人来着。但是和上面的平凡相互映衬了，本来别人就没有喜欢你的理由，凭什么还要接纳你令人讨厌的一面呢。</p>\r\n<p>很想能够有什么不可取代的吸引力，拥有平等的勇气，互相接纳对方的不足。</p>\r\n","categories":["生活"]},{"title":"简书博客导入hexo","url":"/2020/07/16/%E7%AE%80%E4%B9%A6%E5%8D%9A%E5%AE%A2%E5%AF%BC%E5%85%A5hexo/","content":"<h1 id=\"下载原markdown集\">1. 下载原markdown集</h1>\r\n<p>登录简书作者后台，在个人设置--账号管理--打包下载所有文章。\r\n此时可以获得以文集为文件夹的所有markdown文章源文件</p>\r\n<h1 id=\"利用shell脚本添加hexo元数据\">2. 利用shell脚本添加hexo元数据</h1>\r\n<p>需要掌握 <strong>sed修改文件</strong>，<strong>shell脚本运行</strong>\r\n- <a\r\nhref=\"https://www.cnblogs.com/maxincai/p/5146338.html\"><strong>sed命令用法</strong></a>\r\n- shell脚本只要你安装好了git环境，即可在命令行中通过\r\n<code>sh xxx.sh</code>\r\n运行相关脚本，至于怎么去写，有兴趣可以自己了解</p>\r\n<p>以下是我使用的shell脚本：</p>\r\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> f <span class=\"keyword\">in</span> ./*/*;<span class=\"keyword\">do</span></span><br><span class=\"line\">sed -i  <span class=\"string\">&#x27;s/#####\\([^#]\\)/##### \\1/&#x27;</span> <span class=\"variable\">$f</span></span><br><span class=\"line\">sed -i  <span class=\"string\">&#x27;s/####\\([^#]\\)/#### \\1/&#x27;</span> <span class=\"variable\">$f</span></span><br><span class=\"line\">sed -i  <span class=\"string\">&#x27;s/###\\([^#]\\)/### \\1/&#x27;</span> <span class=\"variable\">$f</span></span><br><span class=\"line\">sed -i  <span class=\"string\">&#x27;s/##\\([^#]\\)/## \\1/&#x27;</span> <span class=\"variable\">$f</span></span><br><span class=\"line\">sed -i  <span class=\"string\">&#x27;s/#\\([^#]\\)/# \\1/&#x27;</span> <span class=\"variable\">$f</span></span><br><span class=\"line\">base=$(basename <span class=\"variable\">$f</span> .md)</span><br><span class=\"line\">categories=$(basename $(dirname <span class=\"variable\">$f</span>) <span class=\"variable\">$PWD</span>)</span><br><span class=\"line\">insert=<span class=\"string\">&quot;---\\ntitle: <span class=\"variable\">$&#123;base&#125;</span>\\ncategories:\\n- <span class=\"variable\">$&#123;categories&#125;</span>\\ndate:2020-02-17 02:17:00\\n---\\n&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">&quot;<span class=\"variable\">$&#123;insert&#125;</span><span class=\"subst\">$(cat $f)</span>&quot;</span> &gt; <span class=\"variable\">$f</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>前半段为sed在#字符后添加空格，因为在简书里 <code>#紧贴标题</code>\r\n也是可以成功识别的，但是其他的markdown不一定支持。这里注意需要用到的命令格式为<code>sed -i 's/old/new' file</code></li>\r\n<li><ul>\r\n<li>-i指在源文件上修改</li>\r\n</ul></li>\r\n<li><ul>\r\n<li>s\r\n指进行文本替换，但这里有一个巨大的坑点，假如old长度为3，new长度为4，那么该命令会吞掉原old后的一个字符，即它的替换是覆盖式替换，而不是删除old后插入new。</li>\r\n</ul></li>\r\n<li><ul>\r\n<li>因此需要使用到 ()\r\n格式，()在old中选定子字符串，然后在new中利用\\number，获取第number个子字符串，即我们保存下来了会被覆盖掉的字符，然后又重新给他加了回去。</li>\r\n</ul></li>\r\n<li><ul>\r\n<li>为了避免在诸如#####中匹配出单个#，利用了[^c]，即不匹配c字符，在这段代码中就是下一个不能是#。</li>\r\n</ul></li>\r\n<li>后半段是hexo文档评论区的大神写的，获取了目录名作为hexo的分类名，并且插入元数据，<strong>注意无法自动维护简书的时间</strong>，因此我这自己选了个日期插入。</li>\r\n</ul>\r\n<h1 id=\"运行脚本并检查文档\">3.运行脚本并检查文档</h1>\r\n<p>在简书文集解压出来的文件夹的根目录中，即在<code>user-xxxx</code>文件夹下，运行该脚本，等待运行完成后检查修改结果是否符合你的预期。</p>\r\n<h1 id=\"存在问题\">4.存在问题</h1>\r\n<ol type=\"1\">\r\n<li>无法维护时间</li>\r\n<li>简书代码块不需要注明语言，但是这样hexo的一些highlight就无法识别，想不到自动注明语言的办法。</li>\r\n<li>简述博客图片链接会失效，简书通过判断http请求头中的referer的值，如果来自本站才返回成功请求。因此可以通过修改referer复原图片链接，但是博客有些依赖referer的功能就会受影响。\r\n可以选用外部图床，但收费的挺贵，不收费的也难用，常规的发文网如微博、CSDN、简书都限制外链，挺难找图床的。</li>\r\n</ol>\r\n","categories":["工具"],"tags":["博客"]},{"title":"考研英语作文句式整理","url":"/2020/11/09/%E8%8B%B1%E8%AF%AD%E5%8F%A5%E5%BC%8F%E6%90%AD%E9%85%8D%E6%95%B4%E7%90%86/","content":"<h1 id=\"小作文\">小作文</h1>\r\n<h2 id=\"开篇-12-句\">开篇 (1~2 句）</h2>\r\n<h3 id=\"告示\">告示</h3>\r\n<p>This is to notify that xxx will be held at XXX from xx:xx to xx:xx on\r\nJune 28^th. We cordially invite you to attend the [ceremony/event] .</p>\r\n<h3 id=\"信件\">信件</h3>\r\n<p>引出 This (letter) serves to</p>\r\n<ul>\r\n<li>邀请 (On behalf of ...) extend a warm invitation to you to attend\r\nthe .... ,on August 13-20, 2018 at Peking University</li>\r\n<li>推荐/建议 make some [suggestions/recommendations] with regard\r\nto(prep.) ..., (since you asked for my advice)</li>\r\n<li>申请 apply for ...</li>\r\n<li>申请兴趣/道歉/感谢/慰问 express my deepest\r\n[interest/apology/gratitude/sympathies] [over the loss of .../for what\r\nhappened], since ... <a href=\"#原因\">原因</a></li>\r\n<li>辞职 make a hard decision to quit due to personal reasons.</li>\r\n<li>祝贺 congratulate your achievement ,since I heard the news\r\nthat...</li>\r\n<li>投诉 draw your attention to the problem that ...</li>\r\n</ul>\r\n<p>感谢客套 I am so delighted that you trust me to arrange your ...</p>\r\n<p>道歉强调 I am terribly sorry for any inconvenience this causes you\r\n.</p>\r\n<span id=\"more\"></span>\r\n<p>自我介绍</p>\r\n<h2 id=\"中间段-34-句\">中间段 (3~4 句）</h2>\r\n<p><strong>活动目的</strong></p>\r\n<p>The event is prepared in the intention to...</p>\r\n<p><strong>推荐理由</strong></p>\r\n<p>I strongly recommend ... to you because I am sure...</p>\r\n<p><strong>道歉</strong></p>\r\n<p>让步 I have been looking forward to doing ... since we made the\r\nappointment.</p>\r\n<p>解释 Unexpectedly, ... [理由].</p>\r\n<p>补救 If it is possible ,I would like to reschedule our appointment to\r\na time convenient for you.</p>\r\n<p><strong>观点收尾</strong></p>\r\n<p>These are some important points that I wanted to mention.I am sure if\r\n... you will ...</p>\r\n<h2 id=\"结尾段-12-句\">结尾段 (1~2 句）</h2>\r\n<h3 id=\"期待\">期待</h3>\r\n<p>It would be much appreciated if you could please send back the reply\r\nslip (before June 21^st)</p>\r\n<ul>\r\n<li>参与 to inform us of your attendance.</li>\r\n<li>给机会 to grant me an interview</li>\r\n</ul>\r\n<p>We look forward to your reply.</p>\r\n<p>Thank you for your time and consideration.</p>\r\n<ul>\r\n<li>约谈 I look forward to speaking with you.</li>\r\n<li>投诉 If detailed information is required,please contact me at\r\n12345678.</li>\r\n<li>咨询 I am hoping that your answers to my queries would help me get a\r\nclear foresight on ...</li>\r\n</ul>\r\n<h3 id=\"推荐建议\">推荐/建议</h3>\r\n<p>Hopefully my [recommendations/suggestions/] are constructive and wish\r\nyou a delightful journey.</p>\r\n<h3 id=\"道歉\">道歉</h3>\r\n<p>Please accept my sincere apology for any inconvenience that my\r\nbehavior may have caused to (the company)...</p>\r\n<h3 id=\"祝贺\">祝贺</h3>\r\n<p>Many congratulations for your achievement and best wishes for future\r\ngrowth as well!</p>\r\n<h3 id=\"告示-1\">告示</h3>\r\n<p>Those who want to participate can find our desk by the dining hall\r\naround 12 a.m. every day this week. We look forward to your\r\nparticipation.</p>\r\n<h3 id=\"积极帮助\">积极帮助</h3>\r\n<p>Please do not hesitate to call if you think of anything at all you\r\nmight need.</p>\r\n<h1 id=\"图表大作文\">图表大作文</h1>\r\n<p>柱图 bar chart</p>\r\n<p>饼图 pie chart</p>\r\n<p>线图 line chart</p>\r\n<p>表格 table</p>\r\n<h2 id=\"开篇\">开篇</h2>\r\n<h3 id=\"引入\">引入</h3>\r\n<p>动态 The XXX chart clearly shows the changes in the number of ...\r\nover [the period from ... to .../past several decades] ...</p>\r\n<p>静态 This XXX chart, simple yet illuminating, illustrates the\r\n[proportions of/results of a survey of] how ...</p>\r\n<h3 id=\"描绘数据\">描绘数据</h3>\r\n<p><strong>两个变量趋势一样，但有细微差别</strong></p>\r\n<p>We can see steady growth/decline in ...(both figures) these years. A\r\ncloser look,however,shows a [striking contrast/subtle differences]\r\nbetween ... : sth.(the former) was growing/declining at a relatively\r\nfaster pace, from just 10% in 2017 to surprising 50% ,whereas sth.(the\r\nlatter) just witnessed a slight rise/decline (in ...) each year,with the\r\nnumber ....</p>\r\n<p><strong>此消彼长</strong></p>\r\n<p>[During the time span/As we can see from the chart,between 2017 to\r\n2019], sth increased rapidly from 10% to 50%. But in the meanwhile , sth\r\nhad declined ,falling from 50% to 10% ...</p>\r\n<p><strong>对比比例</strong></p>\r\n<p>As we can see from the chart, the biggest section is ...,accounting\r\nfor 50% of the total, followed closely by .... which represents 33%. By\r\ncomparison , the next two significant items are ..., which are 10%,20%\r\nrespectively.</p>\r\n<h2 id=\"阐释图表\">阐释图表</h2>\r\n<p><strong>总结</strong></p>\r\n<p>Undoubtedly，the chart reflects a common [social\r\nphenomenon/significant tendency] that [citizens/students/...] ... when\r\n...</p>\r\n<p><strong>引入原因</strong></p>\r\n<p>The main factors contributing to this phenomenon can be summarized as\r\nfollows.</p>\r\n<h3 id=\"列举词\">列举词</h3>\r\n<p><strong>并列</strong></p>\r\n<p>In the first place Moreover Meanwhile What is also worth mentioning\r\nhere is Last but not the least</p>\r\n<p><strong>转折</strong></p>\r\n<p>By contrast,... On the one hand,.....On the other hand...\r\nContrastingly，... In comparision，...</p>\r\n<h3 id=\"阐述原因\">阐述原因</h3>\r\n<p><strong>主观原因</strong></p>\r\n<p>With ...,people's [sense of responsibility//cooperation\r\n/environmental consciousness/desire for success] [improves/is on the\r\nrise], which will inevitably leads to ...</p>\r\n<p>With ...[某些原因]，[某主体现象]，and therefore more likely to\r\n[递进现象]。</p>\r\n<ul>\r\n<li>生活节奏 With the quickened pace of life</li>\r\n</ul>\r\n<p>There is a rising concern over ... among sb.</p>\r\n<p><strong>客观原因</strong></p>\r\n<p>随着发展 As [economy/technology] develops, more and more people [are\r\nconcerned about/can afford] ..., making it possible for ... to ...,</p>\r\n<p>优势竞争 With the advancement of technology and the promotion of\r\ninnovation, ... have achieved enhanced performance and imporved\r\nfeatures, able to rival counterparts.</p>\r\n<p><strong>社会政策原因</strong></p>\r\n<p>The authorities have released many preferential policies (such as\r\n...) to promote ..., which undoubtedly stimulate ...</p>\r\n<p><strong>传统文化</strong></p>\r\n<p>China, as one of the world's oldest cradles of civilization , is\r\nfamous for its ...</p>\r\n<p>In our traditional culture, ... is considered as [a thoughtful and\r\ncourteous behavior/an immoral action]</p>\r\n<h3 id=\"总结原因-可选\">总结原因 （可选）</h3>\r\n<p>With the joint efforts of all these factors ,it's natural that\r\n...</p>\r\n<h2 id=\"结尾\">结尾</h2>\r\n<h3 id=\"预测趋势\">预测趋势</h3>\r\n<p>Since ...<a href=\"#原因\">原因</a>, we have sound reasons to believe\r\nthat ... will ...(keep thriving) in the following years.</p>\r\n<ul>\r\n<li>抓住机遇 Only by grasping the opportunities and facing up to the\r\nchallenges can we take full advantage of this new trend and realize\r\n...</li>\r\n</ul>\r\n<h3 id=\"预测评论影响\">预测+评论影响</h3>\r\n<p>In conclusion, given that ...., in future , we can probably expect to\r\nsee more and more people ..., which would ...</p>\r\n<h3 id=\"发现问题建议\">发现问题+建议</h3>\r\n<p>However, this encouraging trend also poses multiple challenges, such\r\nas ...To deal with them, we need firstly to ... In addition, ...</p>\r\n<ul>\r\n<li>建议政府 the government should take multidimensional measures to\r\nbuch the unfavorable trend.</li>\r\n</ul>\r\n<h3 id=\"看好未来建议\">看好未来+建议</h3>\r\n<p>To be sure, it is an encouraging sign that ... But if ...(this\r\nbusiness) want to make continuous progress toward higher goals , ...\r\nmight be a good choice.</p>\r\n<h3 id=\"启发\">启发</h3>\r\n<p>The survey/chart serves as a good reminder of the importance of ...(a\r\nproductive life). In order to achieve ...,we should ...</p>\r\n<h1 id=\"素材\">素材</h1>\r\n<h2 id=\"主观动作\">主观动作</h2>\r\n<p><strong>情绪</strong></p>\r\n<p>I want to inform you of my dissatisfaction with ...</p>\r\n<p>I must complain about ...</p>\r\n<p>I beg to call your attention to the fact that ...</p>\r\n<p>To one’s dismay/surprise ...</p>\r\n<p><strong>行为</strong></p>\r\n<p>be/become increasingly aware of (the infinite power of ...)</p>\r\n<p>keep self-discipline, take full advantage of ...</p>\r\n<p>drifting with the tide is not advised 随波逐流</p>\r\n<p>take all factors into account/consideration and think twice before\r\nmaking a choice.</p>\r\n<h2 id=\"连接句\">连接句</h2>\r\n<h3 id=\"比较结构\">比较结构</h3>\r\n<p>coincident with A has been B<br />\r\n随着 A ... 与此同时 B ...</p>\r\n<blockquote>\r\n<p>Coincident with the developement of Chinese economy has been the\r\ngreat improvement of the education in China.</p>\r\n</blockquote>\r\n<p>it is not that ... but that ... 这并不是说 ... 而是 ...</p>\r\n<p>名词+or+名词 ... , 即 ...</p>\r\n<blockquote>\r\n<p>Technology includes techniques,or ways to do things.\r\n科技包括技艺，即制作方法。</p>\r\n</blockquote>\r\n<p>not ...(any) more than ... 不比 ... 怎样 正如 ... 一样不 ...</p>\r\n<blockquote>\r\n<p>The archaeologists' efforts are not directed at \"proving\" the\r\ncorrectness of the Bible any more than belief in Gog can be\r\nscientifically demonstrated.\r\n正如信仰上帝不能从科学证明一样，考古学家们的努力也不是为了“验证“《圣经》的正确性。</p>\r\n</blockquote>\r\n<p>not so much ... as ... 与其说 ... 不如说 ...</p>\r\n<blockquote>\r\n<p>Science moves forward,not so much through the insights of great men\r\nof genius as because of more ordinary things like improved techniques\r\nand tools. ... 与其说源于天才伟人的 ... 不如说源于更为普遍的 ...</p>\r\n</blockquote>\r\n<p>no less ... than ... 不但 ... 而且 ...</p>\r\n<p>other (...) than ... （ ... 中）除了 ...</p>\r\n<p>nothing but = nothing else than = nothing less than 不是而是</p>\r\n<p>to say nothing of 更不用说 ... （承接上文肯定或否定）</p>\r\n<p>cannot be too adj. ... 再 adj. 也不为过 （即不会太 adj.）</p>\r\n<blockquote>\r\n<p>We cannot be too faithful to our duties</p>\r\n</blockquote>\r\n<p>... only to ... 结果却 ... （与目的相反）</p>\r\n<p>(There be) no 主语 but 谓语 没有（否定谓语）的（主语） （but\r\n做否定关系代词，类似于 who not ，that not）</p>\r\n<blockquote>\r\n<p>There is no man but has his faults. 人皆有过</p>\r\n</blockquote>\r\n<p>sth. be the last thing that ... 决不会/决不至于。...sth</p>\r\n<blockquote>\r\n<p>Breach of promise is the last thing that he is likely to commit.\r\n违约是他决不会做的事</p>\r\n</blockquote>\r\n<h3 id=\"原因\">原因</h3>\r\n<p>...,Given ...</p>\r\n<blockquote>\r\n<p>The performance of American brand cars is to be expected,given their\r\nworldwide fame and reliable quality.</p>\r\n</blockquote>\r\n<h2 id=\"人物\">人物</h2>\r\n<p>kids on the verge of dropping out</p>\r\n<p>environmentally conscious people</p>\r\n<h2 id=\"利害\">利害</h2>\r\n<h3 id=\"客体优势\">客体优势</h3>\r\n<p>excellent performance</p>\r\n<p>drop in price, friendly price</p>\r\n<p>improved features, attractive appearance</p>\r\n<p>upgrading of technology , the promotion of innovation</p>\r\n<h3 id=\"提升自己\">提升自己</h3>\r\n<p>One should cultivate a broad knowledge base and keep abreast of\r\ncurrent events and issues.</p>\r\n<p>Moreover,be persistent.XXX learning is not a task that can be\r\naccomplished within a short time.Only with a lot of sustained efforts\r\ncan we improve our XXX skills.</p>\r\n<h3 id=\"个人益处\">个人益处</h3>\r\n<p>facilitate students' academic learning</p>\r\n<p>make new friends, learn new skills</p>\r\n<p>discover and grow 成长</p>\r\n<p>expand one's horizon</p>\r\n<p>learn to be independent</p>\r\n<p>This position will provide a challenging, stimulating and rewarding\r\ncareer opportunity</p>\r\n<h3 id=\"美德\">美德</h3>\r\n<p>working hard,honesty and integrity, persistence</p>\r\n","categories":["杂记"],"tags":["英语"]},{"title":"骨架手语翻译","url":"/2021/12/15/%E9%AA%A8%E6%9E%B6%E6%89%8B%E8%AF%AD%E7%BF%BB%E8%AF%91/","content":"<p><strong>基于三维手部骨架数据的连续手语识别</strong></p>\r\n<p>王卓程,张景峤.基于三维手部骨架数据的连续手语识别[J/OL].计算机辅助设计与图形学学报:1-9[2021-12-15].http://kns.cnki.net/kcms/detail/11.2925.tp.20211007.1936.008.html.</p>\r\n<h2 id=\"手部骨架连续手语识别\">手部骨架连续手语识别</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/Z4LWl3N.png\"\r\nalt=\"手部骨架连续手语识别模型\" />\r\n<figcaption aria-hidden=\"true\">手部骨架连续手语识别模型</figcaption>\r\n</figure>\r\n<ol type=\"1\">\r\n<li>以腕部关节点为原点，计算相对坐标来替代绝对坐标</li>\r\n<li><strong>双路残差网络</strong>解决深度退化问题。</li>\r\n<li>注意力机制的Seq2Seq。由于注意力机制，编码器需要双向RNN。</li>\r\n<li>CTC算法，输入序列远长于输出序列时，且单调对齐。</li>\r\n</ol>\r\n<span id=\"more\"></span>\r\n<h2 id=\"多部位特征融合识别\">多部位特征融合识别</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/bOTmeW5.png\" alt=\"融合识别模型\" />\r\n<figcaption aria-hidden=\"true\">融合识别模型</figcaption>\r\n</figure>\r\n<ol type=\"1\">\r\n<li>Z-score 标准化预处理数据</li>\r\n<li>构建一系列并行多路时空图卷积网络，分别对不同部位的骨架提取特征。</li>\r\n<li>使用自适应融合方式对不同部位加权</li>\r\n<li>将融合特征输入基于注意力机制的编码解码网路</li>\r\n</ol>\r\n<h2 id=\"手语识别与翻译\">手语识别与翻译</h2>\r\n<figure>\r\n<img src=\"https://i.imgur.com/DwGC84g.png\" alt=\"编码-编解码-解码\" />\r\n<figcaption aria-hidden=\"true\">编码-编解码-解码</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/JeyhN7L.png\" alt=\"编码-CTC-解码\" />\r\n<figcaption aria-hidden=\"true\">编码-CTC-解码</figcaption>\r\n</figure>\r\n<ol type=\"1\">\r\n<li>直接进行双路端到端翻译</li>\r\n<li>编码-双解码：相互依赖程度不高，没有手语识别作为中间监督。</li>\r\n<li>编码-编解码-解码：引入了中间监督，分散了编解码器的职能，降低了识别质量。</li>\r\n<li>编码-CTC-解码：手语识别和语音识别相似，都是输入序列远长于输出序列，且两序列单调对齐。使用语音识别中的联结主义时间分类(CTC)，成本比编解码更低。</li>\r\n</ol>\r\n","categories":["深度学习"],"tags":["深度学习","手语"]},{"title":"点云深度学习论文记录 (持续更新)","url":"/2023/05/15/%E7%82%B9%E4%BA%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"点云空间学习\">点云空间学习</h2>\r\n<h3\r\nid=\"pointnet-deep-learning-on-point-sets-for-3d-classification-and-segmentation\">PointNet:\r\nDeep Learning on Point Sets for 3D Classification and Segmentation</h3>\r\n<ul>\r\n<li>Qi C R, Su H, Mo K, et al. Pointnet: Deep learning on point sets for\r\n3d classification and segmentation[C]//Proceedings of the IEEE\r\nconference on computer vision and pattern recognition. 2017:\r\n652-660.</li>\r\n</ul>\r\n<p>PointNet首次基于原始点云进行深度学习,其提出了点云深度学习的<strong>三大原则:\r\n无序性、点间联系、变换一致性</strong>。基于此,\r\nPointNet在点云上逐点运用了MLP进行变换,\r\n并且构造了<strong>T-Net</strong>进行对抗点云的仿射变换, 最终使用max\r\npool进行对称聚合。</p>\r\n<blockquote>\r\n<p>缺少对局部结构的特征学习</p>\r\n</blockquote>\r\n<h3\r\nid=\"pointnet-deep-hierarchical-feature-learning-on-point-sets-in-a-metric-space\">PointNet++:\r\nDeep Hierarchical Feature Learning on Point Sets in a Metric Space</h3>\r\n<ul>\r\n<li>Qi C R, Yi L, Su H, et al. Pointnet++: Deep hierarchical feature\r\nlearning on point sets in a metric space[J]. Advances in neural\r\ninformation processing systems, 2017, 30.</li>\r\n</ul>\r\n<p>PointNet没有捕捉到点的局部结构特征，限制了细粒度和复杂场景的识别、泛化能力。PointNet++则引出了一个<strong>set\r\nabstraction层</strong>对点云进行多级学习。set\r\nabstraction定义了多级多块的局部邻域结构,\r\n其在每一个局部邻域中都使用了mini-PointNet来进行特征抽取。然而由于点云是非均匀分布的,\r\n不同的局部邻域的密度不一样,\r\n因此PointNet++提出了两种自适应密度的特征融合模块: <strong>Multi-scale\r\ngrouping（MSG）</strong> 和 <strong>Multi-resolution\r\ngrouping（MRG）</strong>。</p>\r\n<p>另外由于部位分割等任务最终需要输出逐点的特征标签, 因此在set\r\nabstraction之后, Pointnet++一方面在同一级内进行反距离的插值传播,\r\n另一方面自顶向下进行反向逐级的特征传播。在同一层内对两种传播特征进行拼接,\r\n即得到该层的逐点特征。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"pointconv\">PointConv</h3>\r\n<ul>\r\n<li>Wu W, Qi Z, Fuxin L. Pointconv: Deep convolutional networks on 3d\r\npoint clouds[C]//Proceedings of the IEEE/CVF Conference on Computer\r\nVision and Pattern Recognition. 2019: 9621-9630.</li>\r\n</ul>\r\n<h3 id=\"pointcnn\">PointCNN</h3>\r\n<ul>\r\n<li>Li Y, Bu R, Sun M, et al. Pointcnn: Convolution on x-transformed\r\npoints[J]. Advances in neural information processing systems, 2018,\r\n31.</li>\r\n</ul>\r\n<h3 id=\"kpconv\">KPConv</h3>\r\n<ul>\r\n<li>Thomas H, Qi C R, Deschaud J E, et al. Kpconv: Flexible and\r\ndeformable convolution for point clouds[C]//Proceedings of the IEEE/CVF\r\ninternational conference on computer vision. 2019: 6411-6420.</li>\r\n</ul>\r\n<h3\r\nid=\"pointnet-based-hand-gesture-recognition\">PointNet-Based-Hand-Gesture-Recognition</h3>\r\n<ul>\r\n<li>Mirsu R, Simion G, Caleanu C D, et al. A pointnet-based solution for\r\n3d hand gesture recognition[J]. Sensors, 2020, 20(11): 3226.</li>\r\n<li>SCIE</li>\r\n</ul>\r\n<p>工程论文, 其详细描述了如何对3D点云进行预处理, 提取手势,\r\n最终进入PointNet进行特征提取。</p>\r\n<h3 id=\"pointweb\">PointWeb</h3>\r\n<ul>\r\n<li>Zhao H, Jiang L, Fu C W, et al. Pointweb: Enhancing local\r\nneighborhood features for point cloud processing[C]//Proceedings of the\r\nIEEE/CVF conference on computer vision and pattern recognition. 2019:\r\n5565-5573.</li>\r\n<li>MIT</li>\r\n</ul>\r\n<h3 id=\"deep-hough-voting-for-3d-object-detection-in-point-clouds\">Deep\r\nHough Voting for 3D Object Detection in Point Clouds</h3>\r\n<ul>\r\n<li>Qi C R, Litany O, He K, et al. Deep hough voting for 3d object\r\ndetection in point clouds[C]//proceedings of the IEEE/CVF International\r\nConference on Computer Vision. 2019: 9277-9286.</li>\r\n</ul>\r\n<h3 id=\"pct-point-cloud-transformer\">PCT: Point cloud transformer</h3>\r\n<ul>\r\n<li>Guo M H, Cai J X, Liu Z N, et al. PCT: Point cloud transformer[J].\r\nComputational Visual Media, 2021, 7(2): 187-199.</li>\r\n<li>清华</li>\r\n</ul>\r\n<p>提出了基于Transformer的PCT网络。Transformer在NLP和图像处理取得了巨大成功，其内在的置换不变性也十分适合点云学习。为了更好的捕捉点云局部信息，使用了最远点采样和最近邻搜索来加强输入的embedding处理。实验证明PCT达到了分类分割和法向估计的SOTA。</p>\r\n<p>由于点云和自然语言是完全不同的数据类型，因此PCT对Transformer作出了几项调整：</p>\r\n<ul>\r\n<li><strong>Coordinate-based input\r\nembedding</strong>：Transformer里的positional encoding\r\n是为了区分不同位置的同一个词。然而点云没有位置顺序关系，因此PCT中将\r\npositional encoding 和 input embedding\r\n结合了起来，基于坐标进行编码。</li>\r\n<li><strong>Optimized offset-attention module</strong>：是原始\r\nself-attention 的升级模块。它把原来的attention\r\nfeature换成了self-attention的输入和attention\r\nfeature之间的offset。同一个物体在不同的变换下的绝对坐标完全不一样，因此相对坐标更鲁棒。</li>\r\n<li><strong>Neighbor embedding module</strong>：\r\n注意力机制有效捕捉全局特征，但可能忽视局部几何信息，而这在点云中很重要。句子中的每个单独的词都有基本的语义信息，但是点云中孤立的点不存在语义信息。因此使用了一个neighbor\r\nembedding\r\n策略来进行改良，让注意力机制着重于分析点局部邻域的信息，而不是孤立的点的信息。</li>\r\n</ul>\r\n<h3 id=\"point-transformer\">Point Transformer</h3>\r\n<ul>\r\n<li>Zhao H, Jiang L, Jia J, et al. Point transformer[C]//Proceedings of\r\nthe IEEE/CVF International Conference on Computer Vision. 2021:\r\n16259-16268.</li>\r\n<li>港中文</li>\r\n</ul>\r\n<p>self-attention是天然的一个集合操作：将位置信息作为元素属性，并且视作集合处理。而另一方面点云天然就是位置属性的集合，因此self-attention直觉上很适合点云数据。之前已经有一些工作在点云分析上使用了attention。他们在整个点云上使用全局的注意力机制，而这会带来昂贵的计算。并且他们使用了标量点积的注意力，即不同通道之间共享相同的聚合权重。</p>\r\n<p>相反，Point Transformer有以下优势：</p>\r\n<ul>\r\n<li><strong>局部应用注意力机制</strong>，使得拥有处理百万点数的大场景的能力。</li>\r\n<li>使用了<strong>vector\r\nattention</strong>，而这是实现高准确率的重要因素。</li>\r\n<li>阐述了<strong>position\r\nencoding</strong>的重要性，而不是像之前的工作一样忽略的位置信息。</li>\r\n</ul>\r\n<h3 id=\"rs-conv\">RS-Conv</h3>\r\n<ul>\r\n<li>CVPR 2019</li>\r\n<li>中国科学院大学，人工智能学院</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://i.imgur.com/byWCQ3e.png\" alt=\"Rs-Conv结构\" />\r\n<figcaption aria-hidden=\"true\">Rs-Conv结构</figcaption>\r\n</figure>\r\n<p>相比于传统的卷积结构<span class=\"math inline\">\\(W_j *\r\nf_j\\)</span>，其使用了<span\r\nclass=\"math inline\">\\(W_{ij}\\)</span>来代替<span\r\nclass=\"math inline\">\\(W_j\\)</span>，本质上希望通过一个<span\r\nclass=\"math inline\">\\(\\mathcal{M}\\)</span>来学习到预先定义的关系向量<span\r\nclass=\"math inline\">\\(h_{ij}\\)</span>的特征，而这个<span\r\nclass=\"math inline\">\\(\\mathcal{M}\\)</span>的实现就是一个point-level的MLP。<span\r\nclass=\"math inline\">\\(h_{ij}\\)</span>比较常用的定义就是3D欧拉距离。</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathcal{T}\\left(\\mathbf{f}_{x_j}\\right)=\\mathbf{w}_{i j} \\cdot\r\n\\mathbf{f}_{x_j}=\\mathcal{M}\\left(\\mathbf{h}_{i j}\\right) \\cdot\r\n\\mathbf{f}_{x_j}\r\n\\]</span></p>\r\n<h3 id=\"pointcmt\">PointCMT</h3>\r\n<ul>\r\n<li>Yan X, Zhan H, Zheng C, et al. Let Images Give You More: Point Cloud\r\nCross-Modal Training for Shape Analysis[J]. arXiv preprint\r\narXiv:2210.04208, 2022.</li>\r\n<li>港中文</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://i.imgur.com/CKOuOuc.png\" alt=\"PointCMT\" />\r\n<figcaption aria-hidden=\"true\">PointCMT</figcaption>\r\n</figure>\r\n<p>单模态的点云模型已经基本走到尽头，如何利用多模态数据(如图片)更好地提升性能呢？一种直接的思路是构建多模态的特征融合网络，但这一方面要特地构建多模态模型结构，另一方面在推理阶段往往难以获得多模态数据。启发于知识蒸馏领域，这篇论文将多模态模型问题转化为知识蒸馏的\"老师与学生\"问题。PointCMT的知识蒸馏框架可以移植到任意Point模型上快速构建提升。主要步骤：</p>\r\n<ol type=\"1\">\r\n<li>预训练一个大型image-based编码器模型，作为老师。</li>\r\n<li>训练图像到点云的解码器CMPG：即将image-based编码的<span\r\nclass=\"math inline\">\\(D\\)</span>维特征映射成<span\r\nclass=\"math inline\">\\(N \\times 3\\)</span>的点云形状</li>\r\n<li>点云模型接收上一步生成的点云作为输入进行训练，并且通过两个增强的损失函数Feature\r\nEnhancement和Classifier Enhancement加强训练。</li>\r\n</ol>\r\n<p>在Feature\r\nEnhancement监督下的CMPG：本质上是一个以EMD为损失函数的映射训练</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathcal{L}_{\\mathrm{EMD}}\\left(\\mathcal{P}, \\hat{\\mathcal{P}}^{i m\r\ng}\\right)=\\min _\\phi \\sum_{p \\in \\mathcal{P}}\\|p-\\phi(p)\\|\r\n\\]</span></p>\r\n<p>Classifier Enhancement\r\nLoss：本质上就是迫使点云模型的输出靠近图像模型。注意图像特征依然交给点云模型进行使用，并且在训练中不对图像模型进行训练。</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathcal{L}_{\\text {Classifier }}=\\mathcal{D}_{K L}\\left(\\mathrm{Cls}^{p\r\nt s}\\left(\\mathcal{F}^{i m g}\\right) \\| \\mathrm{Cls}^{p t\r\ns}\\left(\\mathcal{F}^{p t s}\\right)\\right)\r\n\\]</span></p>\r\n<h3 id=\"dual-transformer\">Dual Transformer</h3>\r\n<ul>\r\n<li>Han X F, Jin Y F, Cheng H X, et al. Dual transformer for point cloud\r\nanalysis[J]. IEEE Transactions on Multimedia, 2022.</li>\r\n<li>1区</li>\r\n<li>西南大学CS</li>\r\n</ul>\r\n<p>本质上是将feature level的注意力和channel\r\nlevel注意力融合在了一起。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/iYWt5q9.png\" alt=\"Dual Transformer\" />\r\n<figcaption aria-hidden=\"true\">Dual Transformer</figcaption>\r\n</figure>\r\n<h3 id=\"pointswd\">PointSWD</h3>\r\n<ul>\r\n<li><p>Nguyen T, Pham Q H, Le T, et al. Point-set distances for learning\r\nrepresentations of 3d point clouds[C]//Proceedings of the IEEE/CVF\r\nInternational Conference on Computer Vision. 2021: 10478-10487.</p></li>\r\n<li><p>VinUniversity</p></li>\r\n</ul>\r\n<p>详细讨论了三种点云距离度量方式: Chamfer divergence ，EMD，\r\n还有自己提的sliced Wasserstein distance。</p>\r\n<p><strong>Chamfer divergence</strong>:</p>\r\n<p><span class=\"math display\">\\[\r\nd_{\\mathrm{CD}}(P, Q)=\\frac{1}{|P|} \\sum_{x \\in P} \\min _{y \\in\r\nQ}\\|x-y\\|_2^2+\\frac{1}{|Q|} \\sum_{y \\in Q} \\min _{x \\in P}\\|x-y\\|_2^2\r\n\\]</span></p>\r\n<p>大部分之前的工作喜欢用CD距离，因为其效果还不错，且计算简单。由于min操作的存在，对于每一个点来说，CD距离只关心其最近的一个邻域点，而不是其邻域分布。因此容易造成明明两个点的邻域分布差异大，但CD距离依然很小的情况。计算代价小是CD的优势，其最多能在<span\r\nclass=\"math inline\">\\(max{|P|,|Q|}\\)</span>的数量级。</p>\r\n<p><strong>EMD</strong>:</p>\r\n<p><span class=\"math display\">\\[\r\nd_{\\mathrm{EMD}}(P, Q)=\\min _{T: P \\rightarrow Q} \\sum_{x \\in\r\nP}\\|x-T(x)\\|_2\r\n\\]</span></p>\r\n<p>EMD属于一种Wasserstein\r\ndistance。根据一些工作以及定理，证明EMD的效果比CD更好，EMD距离越小总能使CD距离更小，但是反过来不成立。不过EMD的计算代价会比CD昂贵很多，大致在<span\r\nclass=\"math inline\">\\(max{|P|,|Q|}^3\\)</span>的数量级，即使是最快的一种近似版本也在<span\r\nclass=\"math inline\">\\(max{|P|,|Q|}^2\\)</span>的数量级，依然很昂贵。因此实际上工作中还是更喜欢使用CD距离，而本文作者也基于这种考虑，研究了一种计算接近CD距离，但是效果等价于EMD的度量方式。</p>\r\n<p><strong>Sliced Wasserstein disatance</strong>:</p>\r\n<p><span class=\"math display\">\\[\r\nS W_p(\\mu, \\nu) \\approx\\left(\\frac{1}{N} \\sum_{i=1}^N\r\nW_p^p\\left(\\pi_{\\theta_i} \\sharp \\mu, \\pi_{\\theta_i} \\sharp\r\n\\nu\\right)\\right)^{\\frac{1}{p}} .\r\n\\]</span></p>\r\n<p>为了节省计算开销，可以先将度量函数投影到某一个方向上，再去计算WD距离。SWD即将所有方向的距离单独计算完之后，再取平均。另外还有根据偏差计算的自适应SWD来自动选择投影方向数量。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/AsMxFcH.png\" alt=\"计算代价对比\" />\r\n<figcaption aria-hidden=\"true\">计算代价对比</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/Qj5RKxE.png\"\r\nalt=\"用于点云重建时的性能对比\" />\r\n<figcaption aria-hidden=\"true\">用于点云重建时的性能对比</figcaption>\r\n</figure>\r\n<h2 id=\"点云时间学习\">点云时间学习</h2>\r\n<h3 id=\"flownet3d\">FlowNet3D</h3>\r\n<ul>\r\n<li>Liu X, Qi C R, Guibas L J. Flownet3d: Learning scene flow in 3d\r\npoint clouds[C]//Proceedings of the IEEE/CVF Conference on Computer\r\nVision and Pattern Recognition. 2019: 529-537.</li>\r\n</ul>\r\n<p>提出了flow embedding层，<strong>点对集合</strong>的matching\r\ncost。其先通过<strong>ball\r\nquery</strong>找到邻域，然后计算邻域每个点对中心点的matching\r\ncost，并且使用max pooling进行邻域聚合。</p>\r\n<blockquote>\r\n<p>这种聚合的坏处就是会丢失一些运动信息。</p>\r\n</blockquote>\r\n<h3 id=\"meteornet\">MeteorNet</h3>\r\n<ul>\r\n<li>Liu X, Yan M, Bohg J. Meteornet: Deep learning on dynamic 3d point\r\ncloud sequences[C]//Proceedings of the IEEE/CVF International Conference\r\non Computer Vision. 2019: 9246-9255.</li>\r\n<li>卡耐基梅隆</li>\r\n</ul>\r\n<p>MeteorNet率先基于原始点云序列进行特征学习。由于点云的不规则性,\r\n其不存在帧与帧之间点的一一对应,\r\n因此也难以确定帧间点与点之间的时间联系。因此MeteorNet提出了两种聚类方法\r\n<strong>Direct grouping</strong>和 <strong>Chained-flow\r\ngrouping</strong>来进行时间聚类。</p>\r\n<blockquote>\r\n<p>由于其需要显式的时空邻居, 这不利于提高准确率和泛化网络。</p>\r\n</blockquote>\r\n<h3 id=\"minkowskinet\">MinkowskiNet</h3>\r\n<ul>\r\n<li>Choy C, Gwak J Y, Savarese S. 4d spatio-temporal convnets: Minkowski\r\nconvolutional neural networks[C]//Proceedings of the IEEE/CVF Conference\r\non Computer Vision and Pattern Recognition. 2019: 3075-3084.</li>\r\n</ul>\r\n<p>针对点云的稀疏性, 提出了高效的时空4D CNN。</p>\r\n<blockquote>\r\n<p>但是既没有对时间规范化,\r\n也不能进行时空特征聚合。计算代价昂贵。存在体素化的量化误差</p>\r\n</blockquote>\r\n<h3 id=\"caspr\">CaSPR</h3>\r\n<ul>\r\n<li>Rempe D, Birdal T, Zhao Y, et al. Caspr: Learning canonical\r\nspatiotemporal point cloud representations[J]. Advances in neural\r\ninformation processing systems, 2020, 33: 13688-13701.</li>\r\n<li>Stanford</li>\r\n</ul>\r\n<p>过去有一些工作做了动态点云的时间学习, 然而这些工作有一个致命限制:\r\n它们缺少时间连续性、鲁棒性、同类泛化性。有一些工作考虑了其中某一个方面,\r\n但没有对这三者整体进行统一的要求。</p>\r\n<p>Canonical Spatiotemporal Point Cloud Representations\r\n(CaSPR)致力于对3D形状的时空变化进行编码。</p>\r\n<ol type=\"1\">\r\n<li>将输入的点云序列规范化到一个共享的4D container空间:\r\n其先构建了坐标空间Normalized Object Coordinate Space (NOCS),\r\n它能把同类中的一些外在属性引如位置、朝向和放缩程度给规范化。进一步的,\r\nCaSPR将NOCS扩展到4D <strong>Temporal-NOCS(T-NOCS)</strong>,\r\n额外将点云序列的持续时间归一化成一个单位时间。对于给定的点云序列,\r\n最终规范化后会给出在<strong>时间和空间</strong>上都规范化的点云。</li>\r\n<li>然后在规范化空间中学习连续的时空特征: 其使用了Neural Ordinary\r\nDifferential Equations (Neural ODEs)。</li>\r\n</ol>\r\n<h3\r\nid=\"pointlstm-an-efficient-pointlstm-for-point-clouds-based-gesture-recognition\">PointLSTM:\r\nAn Efficient PointLSTM for Point Clouds Based Gesture Recognition</h3>\r\n<ul>\r\n<li>Min Y, Zhang Y, Chai X, et al. An efficient pointlstm for point\r\nclouds based gesture recognition[C]//Proceedings of the IEEE/CVF\r\nConference on Computer Vision and Pattern Recognition. 2020:\r\n5761-5770.</li>\r\n<li>中科院计算所</li>\r\n</ul>\r\n<p>之前的工作从时空领域中抽取运动特征和结构特征。然而这些工作仅局限于短期模型，缺乏捕捉长期联系的能力。PointLSTM通过在点云上构建LSTM模型来学习点云序列的长期联系。然而点云数据是无序的，因此直接在没有对齐的点云序列上应用一个权重共享的LSTM层会有更新困难的问题。因此，<strong>如何在保持空间结构的前提下利用时间信息就是主要的挑战</strong>。</p>\r\n<p>PointLSTM对于每帧每个点都计算隐状态, 并且对于第t帧的点,\r\n会在第t-1帧中找到其局部邻域所有点,\r\n并且结合它们的LSTM隐状态来更新第t帧中心点。</p>\r\n<p>简化版本PointLSTM-PSS将过去t-1帧整个点云视为一个隐状态,\r\n并且对于第t帧的每个点都会利用这个隐状态进行更新。</p>\r\n<p>另外也提出了一种基于密度采样点云的方法。</p>\r\n<h3 id=\"pstnet\">PSTNet</h3>\r\n<ul>\r\n<li>Fan H, Yu X, Ding Y, et al. PSTNet: Point spatio-temporal\r\nconvolution on point cloud sequences[C]//International Conference on\r\nLearning Representations. 2020.</li>\r\n<li>新加坡国立大学</li>\r\n</ul>\r\n<p>在聚合时间邻域上提出了<strong>Point tube</strong>的结构,\r\n对前后相邻帧的点进行时间聚类。另外在邻域定义的基础上,\r\n由于点云的不规则性,\r\n传统规则卷积无法计算连续变化的点云坐标差。因此提出了<strong>PSTConv</strong>稀疏4D卷积模块。其将卷积定义为根据偏移量计算权重的连续核函数。</p>\r\n<h3\r\nid=\"sequentialpointnet-a-strong-parallelized-point-cloud-sequence-network-for-3d-action-recognition\">SequentialPointNet:\r\nA strong parallelized point cloud sequence network for 3D action\r\nrecognition</h3>\r\n<ul>\r\n<li>Li X, Huang Q, Wang Z, et al. SequentialPointNet: A strong\r\nparallelized point cloud sequence network for 3D action recognition[J].\r\narXiv preprint arXiv:2111.08492, 2021.</li>\r\n<li>河海大学计算机</li>\r\n</ul>\r\n<p>针对人类动作在空间上复杂，在时间上简单的特性，不平等的对待空间信息和时间信息。提出了一个强并行能力的点云序列网络SequentialPointNet：一个帧内appearance编码模块，一个帧间动作编码模块。</p>\r\n<ul>\r\n<li>为了对人体动作丰富的空间信息建模，每帧先在帧内的appearance\r\nencoding中并行处理，并且输出一个特征向量序列，描述静态的appearance在时间维度上的改变。</li>\r\n<li>为了建模简单的时间维度上的变化，在帧间的动作编码模块中，在特征向量序列中应用了\r\n时间上的位置编码和分层的池化策略。</li>\r\n<li>为了更好的挖掘时空内容，聚合人体动作的多级特征。</li>\r\n</ul>\r\n<h3 id=\"point4dtransformer\">Point4DTransformer</h3>\r\n<ul>\r\n<li>Fan H, Yang Y, Kankanhalli M. Point 4D transformer networks for\r\nspatio-temporal modeling in point cloud videos[C]//Proceedings of the\r\nIEEE/CVF Conference on Computer Vision and Pattern Recognition. 2021:\r\n14204-14213.</li>\r\n<li>新加坡国立大学/悉尼科技大学</li>\r\n</ul>\r\n<p>在PSTNet的PSTConv卷积提取局部特征的基础上,\r\n将各个局部特征连接到一个Transformer层进行权重提取。</p>\r\n<p>其中位置编码使用了一维卷积来实现</p>\r\n<h3 id=\"pst-transformer\">PST-Transformer</h3>\r\n<ul>\r\n<li>Fan H, Yang Y, Kankanhalli M. Point Spatio-Temporal Transformer\r\nNetworks for Point Cloud Video Modeling[J]. IEEE Transactions on Pattern\r\nAnalysis and Machine Intelligence, 2022.</li>\r\n<li>JCR 一区</li>\r\n<li>新加坡国立大学</li>\r\n</ul>\r\n<p>相比于P4T的全局注意力搜索，和PST的局部建模能力，PST-Transformer集合了两者，进行时空邻域的建模。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/hRhgDLA.png\" alt=\"系列对比\" />\r\n<figcaption aria-hidden=\"true\">系列对比</figcaption>\r\n</figure>\r\n<p>首先，通过一个video-level的自注意力进行帧加权。对于<strong>frame-level</strong>，仅对一帧进行注意力计算，由于点的流动性，可能会损失较多轨迹信息。而<strong>video-level</strong>，对两个查询帧之间的所有帧进行注意力计算，更适合保留时空信息。</p>\r\n<p><span class=\"math display\">\\[\r\n\\alpha_{p p^{\\prime}}=\\frac{e^{A_{p p^{\\prime}}}}{\\sum_{t^{\\prime\r\n\\prime}=1}^{L} \\sum_{p^{\\prime \\prime} \\in P_{t^{\\prime \\prime}}}\r\ne^{A_{p p^{\\prime \\prime}}}}\r\n\\]</span></p>\r\n<p>其次通过一个和PST一样的point 4D conv进行时空编码。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/CSh1yZu.png\" alt=\"PST-T整体结构图\" />\r\n<figcaption aria-hidden=\"true\">PST-T整体结构图</figcaption>\r\n</figure>\r\n<h3 id=\"geometrymotion-net\">GeometryMotion-Net</h3>\r\n<ul>\r\n<li>Liu J, Xu D. GeometryMotion-Net: A strong two-stream baseline for 3D\r\naction recognition[J]. IEEE Transactions on Circuits and Systems for\r\nVideo Technology, 2021, 31(12): 4711-4721.</li>\r\n<li>北航计算机</li>\r\n<li>中科院二区</li>\r\n</ul>\r\n<p>GeometryMotion-Net用于在点云序列中抽取几何和运动信息，并且不依赖于任何体素化操作。主要思想是利用一个<strong>几何流</strong>和<strong>运动流</strong>组成的two-stream框架来进行动作识别。</p>\r\n<p><strong>几何流</strong>: 将所有帧点云合并成一个大点云,\r\n再进行传统的空间点云处理, 如PointNet++。</p>\r\n<p><strong>运动流</strong>:\r\n在所有帧之间插值计算出一个关于运动变化的虚拟帧。再在这些虚拟帧上进行空间点云处理,\r\n得到一组特征。</p>\r\n<p><strong>双流汇聚</strong>: 将一个几何流的特征和 N\r\n个运动流的特征拼接合并输出。</p>\r\n<h3 id=\"tranquil-clouds\">Tranquil clouds</h3>\r\n<ul>\r\n<li>Prantl L, Chentanez N, Jeschke S, et al. Tranquil Clouds: Neural\r\nNetworks for Learning Temporally Coherent Features in Point\r\nClouds[C]//International Conference on Learning Representations.\r\n2020.</li>\r\n<li>慕尼黑工业大学</li>\r\n</ul>\r\n<p>基于推土机距离Earth Mover’s Distance (EMD)提出了一个新的损失函数,\r\n用于衡量两个点云之间的差异性:</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathcal{L}_{S}=\\min _{\\phi: \\tilde{y} \\rightarrow y}\r\n\\sum_{\\tilde{y}_{i} \\in\r\n\\tilde{Y}}\\left\\|\\tilde{y}_{i}-\\phi\\left(\\tilde{y}_{i}\\right)\\right\\|_{2}^{2}\r\n\\]</span></p>\r\n<h3 id=\"pointpwc-net\">PointPWC-Net</h3>\r\n<ul>\r\n<li>Wu W, Wang Z Y, Li Z, et al. Pointpwc-net: Cost volume on point\r\nclouds for (self-) supervised scene flow estimation[C]//European\r\nconference on computer vision. Springer, Cham, 2020: 88-107.</li>\r\n<li>Oregon State University</li>\r\n</ul>\r\n<p>提出的<strong>可学习的相继两个点云的matching cost</strong>：找到<span\r\nclass=\"math inline\">\\(p_t^j\\)</span>在上一帧中的邻域，并且计算邻域所有点与其的特征差和坐标差。</p>\r\n<blockquote>\r\n<p>这种<strong>点对点</strong>的matching cost对异常点特别敏感。</p>\r\n</blockquote>\r\n<h3 id=\"spcm-net\">SPCM-Net</h3>\r\n<ul>\r\n<li>He P, Emami P, Ranka S, et al. Learning Scene Dynamics from Point\r\nCloud Sequences[J]. International Journal of Computer Vision, 2022:\r\n1-27.</li>\r\n<li>Q1 CCF-A</li>\r\n<li>University of Florida ，CS</li>\r\n</ul>\r\n<p>主要是做序列点云的场景流估计以及预测任务。之前的场景流估计一般都是t-1帧预测t帧，两帧之间的联系。本文定义了序列多帧联系的场景流估计问题。并且基于这个问题，提出了一些序列学习的方法。</p>\r\n<ul>\r\n<li>Intra-Frame Feature Pyramid\r\n(IFFP)：依照了PointPWC-Net的结构，由于不能直接对点云进行传统卷积，使用了PointConv层进行卷积处理。<strong>并且通过多次FPS采样卷积中心，构建了多个金字塔式特征</strong>。</li>\r\n<li>Inter-Frame Spatiotemporal Correlation (IFSC):\r\n为了能找到时空联系，很自然我们希望使时间维度上的receptive\r\nfield能够尽可能覆盖到整个序列。因此借鉴了传统序列模型的<strong>LSTM结构</strong>,使用了一个\r\n<strong>recurrent cost volume</strong>\r\n结构来保存一定的时间信息。并且针对matching\r\ncost，提出了和PointPWC以及FlowNet不同的\r\n<strong>集合对集合</strong>的maching cost。</li>\r\n<li>Multi-scale Coarse-to-Fine Prediction: 两个帧的特征+cost\r\nvolume的特征生成最低级(粗粒度)的预测点，然后通过Pointnet++的特征上采样传播逐渐生成细粒度特征。</li>\r\n</ul>\r\n<h3 id=\"pstt\">PSTT</h3>\r\n<ul>\r\n<li>Wei Y, Liu H, Xie T, et al. Spatial-Temporal Transformer for 3D\r\nPoint Cloud Sequences[C]//Proceedings of the IEEE/CVF Winter Conference\r\non Applications of Computer Vision. 2022: 1171-1180.</li>\r\n<li>中山大学</li>\r\n<li>不在CCF h5指数62 排计算机视觉第12</li>\r\n</ul>\r\n<p>提出了<strong>Spatio-Temporal\r\nSelf-Attention(STSA)</strong>模块和<strong>Resolution\r\nEmbedding(RE)</strong>模块。STSA用于时空联系，RE用于聚合邻域特征，增强特征图的分辨率。</p>\r\n<p>现有的基于point的时空方法要么是使用注意力机制，要么是使用RNN模型。然而，这些方法依赖于长期联系，导致信息冗余。STSA使用了自注意力来提取帧间联系。这样会使冗余程度下降，鲁棒性提高(残差+layer\r\nnormalization)，训练速度提升。</p>\r\n<p>另外，在语义分割上面的编码器-解码器结构，在编码器降维时会造成信息丢失。RE模块使用了注意力权重来加强分辨率。</p>\r\n<h3 id=\"hyperpointnet\">HyperPointnet</h3>\r\n<ul>\r\n<li>Li X, Huang Q, Yang T, et al. Hyperpointnet for Point Cloud\r\nSequence-Based 3D Human Action Recognition[C]//2022 IEEE International\r\nConference on Multimedia and Expo (ICME). IEEE, 2022: 1-6.</li>\r\n<li>河海大学</li>\r\n<li>CCF B 会议</li>\r\n</ul>\r\n<p>将PointNet扩展到时间序列。作者提认为基于时空局部结构的点云序列模型会导致昂贵的计算和推理误差，因此其构造了<strong>HyperPoint</strong>的概念...本质上就是一个串行的帧内帧间编码网络。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/fcsguio.png\" alt=\"HyperPoint\" />\r\n<figcaption aria-hidden=\"true\">HyperPoint</figcaption>\r\n</figure>\r\n<p><strong>帧内处理</strong>：通过经典的sample and group\r\n层进行空间聚合学习，然后通过MLP进行维度变换。值得一提的是，其在每个group层，将邻域点的距离视为一个额外的特征维度。并且在group之后，使用了一个inter-feature的注意力模块CBAM来对特征进行重新整合。</p>\r\n<p><strong>帧间处理</strong>：\r\n每帧在帧内处理之后变成了所谓的一个HyperPoint，也就是逐帧的空间编码特征而已。其强调HyperPoint的主要信息来源于其内部结构，而不是HyperPoint之间。然后，给这个HyperPoint序列增加了一个Transformer的三角位置编码，并且再使用了frame-level的Pointnet进行最后的时间特征整合。</p>\r\n<h3 id=\"virtualactionnet\">VirtualActionNet</h3>\r\n<ul>\r\n<li>Li X, Huang Q, Wang Z, et al. VirtualActionNet: A strong two-stream\r\npoint cloud sequence network for human action recognition[J]. Journal of\r\nVisual Communication and Image Representation, 2022: 103641.</li>\r\n<li>河海大学</li>\r\n<li>JCR 3区</li>\r\n</ul>\r\n<p>延续HyperPoint的工作，延展到Two-Stream框架。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/aGKzR83.png\" alt=\"Appearance Stream\" />\r\n<figcaption aria-hidden=\"true\">Appearance Stream</figcaption>\r\n</figure>\r\n<p>其中注意在空间特征中附加了一个time\r\nstamp特征，并且使用feature-level的自注意力进行特征混合。</p>\r\n<p>为了补充appearance中的缺少的运动信息，构建了一个motion\r\nstream，其中用了GRU来构建时间联系。</p>\r\n<p>另外，其在训练函数里添加了一个Two-Stream的<strong>相似性约束</strong>\r\n<span class=\"math inline\">\\(M_i \\log{A_i}\\)</span>\r\n，以引导两个stream对同一个动作<span\r\nclass=\"math inline\">\\(i\\)</span>的预测结果<span\r\nclass=\"math inline\">\\(M_i,A_i\\)</span>一致，这在NTU 60上提高了<span\r\nclass=\"math inline\">\\(\\%1.9\\)</span>的准确率。</p>\r\n<h3 id=\"action-recognition-from-silhouette-sequences\">Action recognition\r\nfrom silhouette sequences</h3>\r\n<ul>\r\n<li>Rusu R B, Bandouch J, Marton Z C, et al. Action recognition in\r\nintelligent environments using point cloud features extracted from\r\nsilhouette sequences[C]//RO-MAN 2008-The 17th IEEE International\r\nSymposium on Robot and Human Interactive Communication. IEEE, 2008:\r\n267-272.</li>\r\n<li>慕尼黑工业大學</li>\r\n</ul>\r\n<p>从图像序列构建3D点云，进而抽取特征实现动作识别。</p>\r\n<p>从投影图像序列中通过marching\r\ncubes算法构建代表时空数据的三维点云。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/Kr9tDFu.png\" alt=\"图像序列构建时空数据\" />\r\n<figcaption aria-hidden=\"true\">图像序列构建时空数据</figcaption>\r\n</figure>\r\n<p>并且通过剪枝算法来尽可能过滤掉变化不大的帧，以便对动作的速度保证不变性，其过滤效率为24.15%~91.47%：</p>\r\n<ol type=\"1\">\r\n<li>对于两个相邻帧，计算每一个点与其在相邻帧的K近邻点的欧拉距离。</li>\r\n<li>对上一步构建的距离矩阵计算Frobenius\r\nNorm矩阵范数，即得到帧距离。</li>\r\n<li>通过人为阈值0.2对帧距离进行过滤。</li>\r\n</ol>\r\n<figure>\r\n<img src=\"https://i.imgur.com/502jS7L.png\" alt=\"红色为过滤帧\" />\r\n<figcaption aria-hidden=\"true\">红色为过滤帧</figcaption>\r\n</figure>\r\n<p>最后通过PCA进行连续法线估计，并且通过法线构建形状直方图进行特征分类。</p>\r\n<h3 id=\"facial-action-analysis\">Facial action analysis</h3>\r\n<ul>\r\n<li>Reale M J, Klinghoffer B, Church M, et al. Facial action unit\r\nanalysis through 3d point cloud neural networks[C]//2019 14th IEEE\r\nInternational Conference on Automatic Face &amp; Gesture Recognition (FG\r\n2019). IEEE, 2019: 1-8.</li>\r\n<li>CCF C</li>\r\n</ul>\r\n<p>第一次使用了通过点云网络进行面部表情分析：PointNet、PCCN、LCPN (new)\r\n。论文又翻译了一遍前两者的网络结构，然后综合成了第三个自己提出的网络。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/RH31S9k.png\"\r\nalt=\"PCCN Layer用于学习局部结构\" />\r\n<figcaption aria-hidden=\"true\">PCCN Layer用于学习局部结构</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/b4YiNR1.png\"\r\nalt=\"LCPN 结构：综合Pointnet的全局学习能力和PCCN的局部学习能力\" />\r\n<figcaption aria-hidden=\"true\">LCPN\r\n结构：综合Pointnet的全局学习能力和PCCN的局部学习能力</figcaption>\r\n</figure>\r\n<h3 id=\"asta3dcnns\">ASTA3DCNNs</h3>\r\n<ul>\r\n<li>Wang G, Liu H, Chen M, et al. Anchor-based spatio-temporal attention\r\n3-D convolutional networks for dynamic 3-D point cloud sequences[J].\r\nIEEE Transactions on Instrumentation and Measurement, 2021, 70:\r\n1-11.</li>\r\n<li>1区</li>\r\n<li>上交</li>\r\n</ul>\r\n<p>anchor-baesd spatio-temporal attention 3D\r\nconvolutional网络，主要首先通过虚拟的anchor构建规则的邻域区域，再通过ASTA3DConv离散卷积算子进行特征聚合，本质上是一种两级两种形式的set\r\nabstraction层。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/mLky44z.png\"\r\nalt=\"Anchor-based两级局部结构：先从中心点延伸出正四面体的四个顶点，再在四个顶点上构建ball query的局部邻域\" />\r\n<figcaption\r\naria-hidden=\"true\">Anchor-based两级局部结构：先从中心点延伸出正四面体的四个顶点，再在四个顶点上构建ball\r\nquery的局部邻域</figcaption>\r\n</figure>\r\n<p>后续就是一些网络操作，注意力嵌入层构建之类的。最终在MSR\r\nAction3D上达到93.03%。</p>\r\n<h3 id=\"aspnet\">ASPNet</h3>\r\n<ul>\r\n<li>Liu J, Guo J, Xu D. Apsnet: Toward adaptive point sampling for\r\nefficient 3d action recognition[J]. IEEE Transactions on Image\r\nProcessing, 2022, 31: 5287-5302.</li>\r\n<li>Q1</li>\r\n<li>北航</li>\r\n</ul>\r\n<p>主要贡献 ASPNet\r\n，用于对不同的点云视频，决定不同大小的采样密度，以提升处理效率。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/IfVisYX.png\" alt=\"ASPNet core module\" />\r\n<figcaption aria-hidden=\"true\">ASPNet core module</figcaption>\r\n</figure>\r\n<p>ASPNet本质上是一个采样密度决定器，特征提取网络还是依靠MLP和PointNet等经典网络作为BackBone(图中BBNet)。主要结构分为两部分：</p>\r\n<ol type=\"1\">\r\n<li>Decision making stage：本质上是一个mini\r\nLSTM特征分类模块，分类目标是四种采样密度。注意最后max计算输出label时使用的是Gumbel-Max。</li>\r\n<li>Fine feature extraction\r\nstage：网络首先预训练好了四种密度的BBNet，然后构建了一个选择分支网络，通过DM模块输出的密度label，来选择合适密度的BBNet。</li>\r\n</ol>\r\n<p>在损失函数处将计算效率FLOPs也算入损失，以引导网络选择合适的分支 <span\r\nclass=\"math inline\">\\(L=L_{acc} \\dot L_{eff}\\)</span>。</p>\r\n<h3 id=\"pointmotionnet\">PointMotionNet</h3>\r\n<ul>\r\n<li>Wang J, Li X, Sullivan A, et al. PointMotionNet: Point-Wise Motion\r\nLearning for Large-Scale LiDAR Point Clouds Sequences[C]//Proceedings of\r\nthe IEEE/CVF Conference on Computer Vision and Pattern Recognition.\r\n2022: 4419-4428.</li>\r\n<li>CCF A</li>\r\n<li>University of Maryland</li>\r\n</ul>\r\n<p>一种时空局部结构的卷积方法Point-STC，两层结构，先确定<strong>中心点</strong><span\r\nclass=\"math inline\">\\(\\mathbf{p}_i^{(t)}\\)</span>，然后中心点扩展出规则的<strong>代理点</strong><span\r\nclass=\"math inline\">\\(\\mathcal{K}\\left(\\mathbf{p}_i^{(t)}\\right)=\\left\\{\\mathbf{p}_i^{(t)}-\\mathbf{b}_k\r\n\\in\r\n\\mathbb{R}^3\\right\\}_{k=1}^K\\)</span>，然后再通过代理点去加权<strong>邻域点</strong>。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/dLwfRQ3.png\" alt=\"Point-STC\" />\r\n<figcaption aria-hidden=\"true\">Point-STC</figcaption>\r\n</figure>\r\n<p>其最后的局部抽取规则由<strong>全局权重</strong><span\r\nclass=\"math inline\">\\(h\\)</span>和<strong>邻域点关联权重</strong><span\r\nclass=\"math inline\">\\(w\\)</span> 相乘而得。</p>\r\n<p><span class=\"math display\">\\[\r\n\\Psi_{\\mathbf{p}_i^{(t)},\r\n\\mathbf{p}_j^{(t+\\tau)}}\\left(\\mathbf{x}_j^{(t+\\tau)}\\right)=\\sum_{\\delta_k\r\n\\in \\mathcal{K}\\left(\\mathbf{p}_i^{(t)}\\right)} w_k h\\left(\\delta_k,\r\n\\mathbf{p}_j^{(t+\\tau)}\\right) \\mathbf{x}_j^{(t+\\tau)}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(w\\)</span>为所有点共享的可学习权重，<span\r\nclass=\"math inline\">\\(h\\)</span>为每个局部邻域独有的核函数：</p>\r\n<p><span class=\"math display\">\\[\r\nh\\left(\\delta_k, \\mathbf{p}_j^{(t+\\tau)}\\right)=\\max\r\n\\left(0,1-\\frac{\\left\\|\\delta_k-\\mathbf{p}_j^{(t+\\tau)}\\right\\|_2}{\\sigma}\\right)\r\n\\in \\mathbb{R}\r\n\\]</span></p>\r\n<p>另外也使用了多层金字塔结构来帮助卷积扩大感受野。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/sCYRIUn.png\" alt=\"pyramid structure\" />\r\n<figcaption aria-hidden=\"true\">pyramid structure</figcaption>\r\n</figure>\r\n<h3 id=\"geometrymotion-transformer\">GeometryMotion-Transformer</h3>\r\n<ul>\r\n<li>Liu J, Guo J, Xu D. GeometryMotion-Transformer: An End-to-End\r\nFramework for 3D Action Recognition[J]. IEEE Transactions on Multimedia,\r\n2022.</li>\r\n<li>一区</li>\r\n<li>北航</li>\r\n</ul>\r\n<p>feature extraction Module(FEM)模块，核心在于构建一个motion\r\npoint，用于聚合时空信息。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/s3Mi1Q7.png\"\r\nalt=\"FEM模块: 注意里面的motion extraction module是多尺度整合的\" />\r\n<figcaption aria-hidden=\"true\">FEM模块: 注意里面的motion extraction\r\nmodule是多尺度整合的</figcaption>\r\n</figure>\r\n<p>注意FEM里面的Motion extraction\r\nmodule。其同样也是在相邻帧中通过KNN寻找邻域点，但是gather方法有点不一样。其通过邻域点和中心点的\r\n特征向量余弦相似度 和 距离 的乘积来衡量影响权重<span\r\nclass=\"math inline\">\\(w_{i,j}o_{i,j}\\)</span>，并最终确定一个新的motino\r\npoint的坐标<span class=\"math inline\">\\(r_i\\)</span>:</p>\r\n<p><span class=\"math display\">\\[\r\ns_{i, j}=\\frac{\\mathbf{g}_i^c \\cdot\r\n\\mathbf{g}_j^r}{\\left\\|\\mathbf{g}_i^c\\right\\|\r\n\\cdot\\left\\|\\mathbf{g}_j^r\\right\\|}\\\\\r\n\\mathbf{r}_i=\\sum_{j=1}^K w_{i, j} \\mathbf{o}_{i, j}, \\text { where }\r\nw_{i, j}=\\frac{\\exp \\left(s_{i, j} / \\tau\\right)}{\\sum_{j=1}^K \\exp\r\n\\left(s_{i, j} / \\tau\\right)}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(r_{i,j}\\)</span>结合相似度最高的特征<span\r\nclass=\"math inline\">\\(z_i\\)</span>即构成一个完整的新特征点，并进入后续的MLP等特征处理变换中。</p>\r\n<p>FEM模块最终可以得到空间特征<span class=\"math inline\">\\(Q,\r\nG\\)</span>以及运动特征<span\r\nclass=\"math inline\">\\(M\\)</span>。接下来的问题是怎么整合这三者，于是有了Feature\r\nfusion module(FFM)的注意力特征融合:</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/gTXIINx.png\" alt=\"FFM模块\" />\r\n<figcaption aria-hidden=\"true\">FFM模块</figcaption>\r\n</figure>\r\n<h3\r\nid=\"continuous-body-and-hand-gesture-recognition-for-natural-human-computer-interaction\">Continuous\r\nBody and Hand Gesture Recognition for Natural Human-Computer\r\nInteraction</h3>\r\n<ul>\r\n<li>Song Y, Demirdjian D, Davis R. Continuous body and hand gesture\r\nrecognition for natural human-computer interaction[J]. ACM Transactions\r\non Interactive Intelligent Systems (TiiS), 2012, 2(1): 1-28.</li>\r\n<li>3区</li>\r\n<li>MIT CS</li>\r\n</ul>\r\n<p>值得参考其如何构建连续识别模型。连续识别模型目的在于输出一个序列中每一帧的label，而不仅仅是这个序列给同样的label。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/UJetjfg.png\" alt=\"滑动窗口示意图\" />\r\n<figcaption aria-hidden=\"true\">滑动窗口示意图</figcaption>\r\n</figure>\r\n<p>在窗口内部，其使用高斯函数来整合相邻帧的特征向量:</p>\r\n<p><span class=\"math display\">\\[\r\ng(w)[n]=e^{-\\frac{1}{2}\\left(\\alpha \\frac{n}{w / 2}\\right)^2}\r\n\\]</span></p>\r\n<p>在窗口外部以两级形式输出单帧label:</p>\r\n<ul>\r\n<li>local level:\r\n即对于同一帧，在长度为K的滑动窗口经过的step里，每一次都在窗口内进行一次整合计算。并最终平均整合K次计算的local\r\nfeature。</li>\r\n<li>global level: 通过指数衰减的方式平滑整合local\r\nlevel和随时间变化的global level:</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\nq_t\\left(y_j\\right)=\\alpha \\cdot \\bar{p}_t\\left(y_j\\right)+(1-\\alpha)\r\n\\cdot q_{t-1}\\left(y_{j-1}\\right), where \\alpha = max\r\n\\bar{p}_t\\left(y_j\\right)\r\n\\]</span></p>\r\n<p>对于连续动作的边界判断来说，global level 变化的地方即是边界。</p>\r\n<h2 id=\"基于其他三维数据\">基于其他三维数据</h2>\r\n<h3 id=\"dgcnn\">DGCNN</h3>\r\n<ul>\r\n<li>Wang Y, Sun Y, Liu Z, et al. Dynamic graph cnn for learning on point\r\nclouds[J]. Acm Transactions On Graphics (tog), 2019, 38(5): 1-12.</li>\r\n</ul>\r\n<h3\r\nid=\"ddgcn-a-dynamic-directed-graph-convolutional-network-for-action-recognition\">DDGCN:\r\nA Dynamic Directed Graph Convolutional Network for Action\r\nRecognition</h3>\r\n<ul>\r\n<li>Korban M, Li X. Ddgcn: A dynamic directed graph convolutional\r\nnetwork for action recognition[C]//European Conference on Computer\r\nVision. Springer, Cham, 2020: 761-776.</li>\r\n<li>University of Virginia</li>\r\n</ul>\r\n<p>DDGCN认为骨架的空间层级结构和动作的时间序列结构都包含了顺序信息，然而大多数ST\r\ngraph都是用了无向图结构，即无视了顺序信息，因此DDGCN提出了<strong>有向图骨架结构\r\nDirected Spatial-Temporal Graph (DSTG)</strong>\r\n。通过有向图中父子节点的定义，父节点的动作实际上会影响到子节点的动作，因此DDGCN在有向图的基础上定义了\r\nbone features来表示父子节点的影响特征。</p>\r\n<p>另外针对图卷积的邻域不确定性，DDGCN提出<strong>Dynamic Convolutional\r\nSampling (DCS)</strong>\r\n来对一个节点的邻居列表进行动态的排序，形成动态邻域关系。然而卷积核的权重是有顺序的，而邻居列表是动态变化的，可能会造成权重分配的错序。因此DDGCN使用了一个<strong>Dynamic\r\nConvolutional Weights\r\n(DCW)</strong>模块来对邻居列表和权重列表进行一个<strong>Dynamic Time\r\nWarping (DTW)距离</strong>的最小化排序，再根据这个排序进行权重分配。</p>\r\n<h3 id=\"skeletontransformer\">SkeletonTransformer</h3>\r\n<ul>\r\n<li>Plizzari C, Cannici M, Matteucci M. Skeleton-based action\r\nrecognition via spatial and temporal transformer networks[J]. Computer\r\nVision and Image Understanding, 2021, 208: 103219.</li>\r\n<li>Politecnico di Torino 意大利都灵理工大学</li>\r\n<li>三区</li>\r\n</ul>\r\n<p>空间Transformer: <strong>Spatial Self-Attention\r\n(SSA)</strong>模块，用于在骨架之间动态的建立联系，而独立于人体真实骨架结构。\r\n时间Transformer: <strong>Temporal Self-Attention\r\n(TSA)</strong>模块用于学习关节在时间上的变化。</p>\r\n<p>值得注意的是, 其空间时间的Transformer不是串行计算,\r\n而是使用<strong>Two-Stream</strong>方法分为两条管线独立运算。最终再对两个管线输出特征进行拼接处理。</p>\r\n<h3 id=\"dv\">3DV</h3>\r\n<ul>\r\n<li>Wang Y, Xiao Y, Xiong F, et al. 3dv: 3d dynamic voxel for action\r\nrecognition in depth video[C]//Proceedings of the IEEE/CVF conference on\r\ncomputer vision and pattern recognition. 2020: 511-520.</li>\r\n<li>华中科技大学</li>\r\n</ul>\r\n<p>3DV通过对点云视频进行体素化, 提取出3D动态体素的表示。</p>\r\n<blockquote>\r\n<p>体素化的问题: 体素是是计算消耗巨大的过程, 时间和空间距离相同不太可取,\r\n时间戳本身会影响效果。</p>\r\n</blockquote>\r\n<h3 id=\"histogram-of-motion-trajectory-feature\">Histogram of motion\r\ntrajectory feature</h3>\r\n<ul>\r\n<li>Li D, Jahan H, Huang X, et al. Human action recognition method based\r\non historical point cloud trajectory characteristics[J]. The Visual\r\nComputer, 2022, 38(8): 2971-2979.</li>\r\n<li>四川大学 CS</li>\r\n<li>中科院JCR 3区</li>\r\n</ul>\r\n<p><strong>时间金字塔</strong>：即逐层分割时间序列，二分、四分......解释上一方面可以有助于识别不同长度的动作特征，另一方面，时间的片段化也能强化顺序信息。</p>\r\n<p><strong>分割四肢</strong>：通过kinect的骨骼坐标定位四肢点云并分割。</p>\r\n<p><strong>3D网格划分点云</strong>：将点云空间划分为 <span\r\nclass=\"math inline\">\\(W \\times H \\times d\\)</span>\r\n的网格空间以形成3D直方图。每个网格内的点云数量归一化到<span\r\nclass=\"math inline\">\\([y_{min},y_{max}]\\)</span>。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/20tjGyc.png\" alt=\"3D网格划分\" />\r\n<figcaption aria-hidden=\"true\">3D网格划分</figcaption>\r\n</figure>\r\n<p><span class=\"math display\">\\[\r\n\\mathrm{HOMT}_{w i, h i, d i}=y_{\\min }+\\frac{\\left(y_{\\max }-y_{\\min\r\n}\\right)\\left(num_{w i, h i, d i}-\\operatorname{Min}(n u\r\nm)\\right)}{\\operatorname{Max}(\\text { num })-\\operatorname{Min}(\\text {\r\nnum })}\r\n\\]</span></p>\r\n<p>最终以3D直方图特征<span class=\"math inline\">\\(HOMT \\in \\mathbb{R}^{t\r\n\\times w \\times h \\times\r\nd}\\)</span>作为特征描述子，再通过支持向量机进行特征分类。</p>\r\n<p>最终在UTD-MHAD上的分类结果到90.23%，不如SOTA\r\n91.13%，声称效率更高。</p>\r\n<h3 id=\"d-rans\">3D RANs</h3>\r\n<ul>\r\n<li>Cai J, Hu J. 3D RANs: 3D residual attention networks for action\r\nrecognition[J]. The Visual Computer, 2020, 36(6): 1261-1270.</li>\r\n<li>中山大学</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://i.imgur.com/6A31Qpn.png\" alt=\"3D RAN\" />\r\n<figcaption aria-hidden=\"true\">3D RAN</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/NE0XABU.png\" alt=\"channel attention\" />\r\n<figcaption aria-hidden=\"true\">channel attention</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/zXpHetx.png\" alt=\"spatial attention\" />\r\n<figcaption aria-hidden=\"true\">spatial attention</figcaption>\r\n</figure>\r\n<h3 id=\"fine-grained\">Fine-grained</h3>\r\n<ul>\r\n<li>Zhu Y, Liu G. Fine-grained action recognition using multi-view\r\nattentions[J]. The Visual Computer, 2020, 36(9): 1771-1781.</li>\r\n<li>南京信息工程大学</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://i.imgur.com/gtCaHFs.png\" alt=\"CT CS ST attention\" />\r\n<figcaption aria-hidden=\"true\">CT CS ST attention</figcaption>\r\n</figure>\r\n<h2 id=\"基础设施\">基础设施</h2>\r\n<h3 id=\"点云分类综述\">点云分类综述</h3>\r\n<p><strong>点云特征</strong>：</p>\r\n<ol type=\"1\">\r\n<li><p>无序性：点云数据则是无序点的集合。使用不同的设备和位置获取采集目标，会得到排列顺序千差万别的点云数据。当采用不同顺序读入\r\nn 个点云时，其组合方式就有\r\nn！种。对不同位置点云进行卷积算，结果会受<strong>点云的输入顺</strong>序的影响。通过对称函数、构造卷积算子或利用图与树的结构为解决点云的无序性做出贡献。</p></li>\r\n<li><p>稀疏性：通过不同方式获取到物体的点云数据在密度、点数以及点间距离都具有一定的差别。三维点云的不规则结构会导致某些区域的过采样和欠采样。因此不同密度的点云的处理是研究点云分类策略的重点之一。在网络中嵌入<strong>密度模块</strong>的方法可以在一定程度上解决点云密度不均的问题。</p></li>\r\n<li><p>非结构化：无结构的点云数据直接输入到神经卷积网络模型中往往比较困难。早期有<strong>体素</strong>方法或者<strong>多视图</strong>方法。但是会增加大量的数据计算。近年有<strong>图卷积神经网络</strong>处理非结构化数据。如有基于<strong>Reeb图</strong>卷积神经网络聚合点云特征。</p></li>\r\n</ol>\r\n<p><strong>数据集</strong>：</p>\r\n<ol type=\"1\">\r\n<li>ModelNet：3D CAD模型</li>\r\n<li>ScanNet：RGBD视频，室内场景</li>\r\n<li>ISPRS：城市目标，三维建筑</li>\r\n<li>2019 Data FusionContest Dataset：城市场景</li>\r\n</ol>\r\n<p><strong>基于体素网格</strong>：</p>\r\n<p>将环境状态表示为三维网格，借鉴二维图像的相似性。</p>\r\n<ol type=\"1\">\r\n<li>VoxNet：集成了体积网格和3D卷积网络</li>\r\n<li>3D\r\nShapenets：将点云特征表示为体素网格的二进制概率分布，卷积共享权值环节参数过剩。</li>\r\n<li>OctNet、OCNN等：优化体素结构，使用灵活的八叉树结构。</li>\r\n</ol>\r\n<p>体素网格存在丢失重要信息，存储和计算开销大，适用性不高等弊端。</p>\r\n<p><strong>基于多视角</strong>：</p>\r\n<p>多个视角对点云投影，使用CNN对投影的2D影像进行加工。</p>\r\n<ol type=\"1\">\r\n<li>MVCNN：多视图CNN，将3D渲染成传统图像。将多个视图的特征信息通过卷积层和池化层整合成单一的3D描述符。最后进入全连接层计算。</li>\r\n<li>Qi在MVCNN基础上改进：通过变化仰角和方位角增强训练数据、引入三维滤波捕捉多尺度信息。</li>\r\n<li>GVCNN：对不同视图的视觉描述符分组，学习组间特征生成组级别的描述符，再加权获得3D描述符。</li>\r\n</ol>\r\n<p>在相机设置位置与角度时容易出现遮挡情况，视图不能得到有效处理将直接影响训练结果。3D\r\n到 2D 的转换过程中会造成点云信息的丢失。</p>\r\n<p><strong>基于原始点云</strong>：</p>\r\n<p>MLP</p>\r\n<ol type=\"1\">\r\n<li>PointNet：通过MLP学习单个点的特征，利用对称函数编码全局信息<strong>解决无序性问题</strong>。利用空间变换网络STNs<strong>解决点云旋转不变性问题</strong>。对输入点云进行几何变换和特征变换，采用最大池化聚合点特征解决<strong>置换不变性问题</strong>。<br />\r\n缺陷在于只捕捉到单个点和全局点，没有有效的局部特征信息，且没有点的邻近关系。导致对细粒度效果较差。<br />\r\n</li>\r\n<li>PointNet++：引入多层次结构。每一层分为采样层、分组层、特征提取层。解决了局部点云特征的问题，点间联系依然没有充分学习。</li>\r\n<li>Momenet：对点云坐标使用多项式函数提高训练能力，高时效低消耗</li>\r\n<li>So-Net：利用自组织特征映射SOFM分析点云分布，实现置换不变性网络。结构简单、训练速度快。分类效果良好。</li>\r\n<li>SRN、PointWeb：学习点间局部联系。</li>\r\n<li><strong>PointASNL</strong>：自适应采样AS减弱噪声和异常。局部-非局部模块L-NL提供准确稳定的特征信息。</li>\r\n<li>BPS：针对无序性、提出点集概念。将输入点归一化，对一组点随机采样构成点集单元。</li>\r\n</ol>\r\n<p>CNN</p>\r\n<ol type=\"1\">\r\n<li>PointCNN：避免点云输入顺序对卷积操作的影响。X-变换卷积算子将数据转换为顺序无关的特征。分类中使用膨胀卷积思想。证实了局部结构对点云的重要性。但变换算子仍效果不够好。</li>\r\n<li>RSCNN：基于几何关系，几何关系编码卷子算子RS-Conv。有良好的目标识别功能。</li>\r\n<li>DANCE-NET：密度感知卷积模块。</li>\r\n</ol>\r\n<p>GCN</p>\r\n<ol type=\"1\">\r\n<li>GCN：提取图数据特征，在半监督分类任务中效果良好。</li>\r\n<li>ECC：将点云视作图结构的顶点，聚合顶点信息转换为图结构，但是需要大量计算，不理想。</li>\r\n<li>LDGCNN、PointGNN、PointVGG</li>\r\n</ol>\r\n<p>注意力机制</p>\r\n<p>具有固定排列、不依赖于点间联系的特性。</p>\r\n<ol type=\"1\">\r\n<li>GAPNet：在MLP层中嵌入图注意力机制学习局域点云语义。<strong>GAPLayer</strong>和<strong>注意力层</strong>可以嵌入到其他模型中以提取局部几何特征。</li>\r\n<li>清华PCT：将点云编码至高维特征空间，经过四层注意力层（自注意力、offset注意力）获取局部几何信息。</li>\r\n</ol>\r\n<h3 id=\"deep-metric-learning-a-survey\">deep metric learning a\r\nsurvey</h3>\r\n<ul>\r\n<li>Kaya M, Bilge H Ş. Deep metric learning: A survey[J]. Symmetry,\r\n2019, 11(9): 1066.</li>\r\n<li>土耳其的錫爾特大學</li>\r\n<li>2区</li>\r\n</ul>\r\n<p>度量学习概述。传统的度量学习需要采用各种核方法来将数据转换到一个特征空间中，然后进行合适的距离度量。传统方式的缺点很明显，对于很多数据我们难以找到一个合适的变换方法来进行特征降维，另一方面对于多样化的相似度计算也难以囊括：如文本语义相似度。借助于深度学习强大的抽象能力，近期的度量学习研究基本都是受Siamese和Triplet的深度度量网络启发，使用深度学习来代替传统的手工构造核函数。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/ohfXXMp.png\" alt=\"深度度量学习框架\" />\r\n<figcaption aria-hidden=\"true\">深度度量学习框架</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://i.imgur.com/1OGOb3t.png\" alt=\"深度度量学习效果示意\" />\r\n<figcaption aria-hidden=\"true\">深度度量学习效果示意</figcaption>\r\n</figure>\r\n<p>深度度量学习Pipeline难点主要分为两部分：</p>\r\n<ol type=\"1\">\r\n<li>样本选择/数据集分割</li>\r\n</ol>\r\n<p>虽然最朴实的数据集分割方式是随机比例划分，但是在度量学习中，一方面由于我们的正样本对<span\r\nclass=\"math inline\">\\(X\\)</span>、<span\r\nclass=\"math inline\">\\(X+\\)</span>通常有限，而相对的负样本对<span\r\nclass=\"math inline\">\\(X\\)</span>、<span\r\nclass=\"math inline\">\\(X-\\)</span>会多很多，那么对于三元组合<span\r\nclass=\"math inline\">\\(X\\)</span>、<span\r\nclass=\"math inline\">\\(X+\\)</span>、<span\r\nclass=\"math inline\">\\(X-\\)</span>中，<span\r\nclass=\"math inline\">\\(X+\\)</span>会重复很多很多次，容易导致一定程度上的过拟合。</p>\r\n<p>另一方面，如果组合所有可能的情况去训练的话会有<span\r\nclass=\"math inline\">\\(O(n_{sample}^3)\\)</span>的组合数量级，这在时间上是难以接受的。</p>\r\n<p>而且，有些输入的pair的区分价值很小，会导致浪费计算效率，而寻找区分价值大的pair也能使网络在有限的训练中得到最好的测试效果。因此，业界提出了hard\r\n、semi-hard、easy三个层次的数据划分。以同类的距离为标志，hard处于同类距离以内，但其实是不同类数据，semi-hard和easy则以同类范围以外的一个margin作为边界划分。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/K8I1K4I.png\"\r\nalt=\"寻找困难负样本 hard negative mining\" />\r\n<figcaption aria-hidden=\"true\">寻找困难负样本 hard negative\r\nmining</figcaption>\r\n</figure>\r\n<ol start=\"2\" type=\"1\">\r\n<li>损失函数设计</li>\r\n</ol>\r\n<p>由于度量网络和普通的识别网络任务目标不同，其希望把所有同类的距离尽可能弄小，然后所有异类的距离尽可能弄大，因此单纯的使用交叉熵之类的多分类损失函数不可行。这一部分已经有比较充足的发展：</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/RhcgMtJ.png\"\r\nalt=\"几种度量网络损失函数。ab是标准的目标设计。c希望在ab的基础上细分异类样本为：较为相似的异类、不相似的异类，加强区分效果。e认为一次只在n-1个异类中取一个负样本不合适，因此改为一次取n个输入，其中1个正样本，n-1个负样本。gf则是以cluster的视角来看待问题。其中f强调对类的重叠进行惩罚。h则是一个3倍版的Triplet Loss.\" />\r\n<figcaption\r\naria-hidden=\"true\">几种度量网络损失函数。ab是标准的目标设计。c希望在ab的基础上细分异类样本为：较为相似的异类、不相似的异类，加强区分效果。e认为一次只在n-1个异类中取一个负样本不合适，因此改为一次取n个输入，其中1个正样本，n-1个负样本。gf则是以cluster的视角来看待问题。其中f强调对类的重叠进行惩罚。h则是一个3倍版的Triplet\r\nLoss.</figcaption>\r\n</figure>\r\n<h3 id=\"human-motion-analysis-metric\">Human motion analysis metric</h3>\r\n<ul>\r\n<li>Coskun H, Tan D J, Conjeti S, et al. Human motion analysis with deep\r\nmetric learning[C]//Proceedings of the European Conference on Computer\r\nVision (ECCV). 2018: 667-683.</li>\r\n<li>慕尼黑工业大学</li>\r\n<li>ECCV</li>\r\n</ul>\r\n<p>讲述如何衡量动作序列的差异，以便于实现动作相似度衡量和分析。传统的人体动作度量方法有\r\nL2距离误差度量，以及Dynamic Time Warping\r\n(DTW)距离度量。然而传统的方法首先需要对齐两个动作序列，而这本身就是一件很难计算的事。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/i9xSHaC.png\" alt=\"动作判别\" />\r\n<figcaption aria-hidden=\"true\">动作判别</figcaption>\r\n</figure>\r\n<p>因此现在的度量学习基本都是基于深度学习来做，通常会构建一个深度学习网络学习一个将动作序列数据映射到一个低维embedding的一个映射，然后在这个低维空间上进行标准的L2距离衡量：</p>\r\n<p><span class=\"math display\">\\[\r\nd(f(X), f(Y))=\\|f(X)-f(Y)\\|^2\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/by9hU75.png\" alt=\"模型示例\" />\r\n<figcaption aria-hidden=\"true\">模型示例</figcaption>\r\n</figure>\r\n<p>所以关键在于怎么构建这个神经网络以学习到判别性的映射。比较主流的方案是参考孪生神经网络，构造pair型的输入以及特殊的判别损失函数：</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathcal{L}_{\\text {contrastive }}=(r) \\frac{1}{2} d+(1-r)\r\n\\frac{1}{2}\\left[\\max \\left(0, \\alpha_{\\text {margin\r\n}}-d\\right)\\right]^2\r\n\\]</span></p>\r\n<p>其中<span class=\"math inline\">\\(d\\)</span>为上面的L2距离计算，<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>则是一个需要寻找的超参数，判别损失优化后的版本是Triplet:</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathcal{L}_{\\text {triplet }}=\\max\r\n\\left(0,\\left\\|f(X)-f\\left(X^{+}\\right)\\right\\|^2-\\left\\|f(X)-f\\left(X^{-}\\right)\\right\\|^2+\\alpha_{\\text\r\n{margin }}\\right)\r\n\\]</span></p>\r\n<p>另外为了避开<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>这个超参数，这篇论文提出了Neighbourhood\r\nComponents Analysis(NCA)方法来改造损失函数。</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathcal{L}_{\\mathrm{NCA}}=\\frac{\\exp\r\n\\left(-\\left\\|f(X)-f\\left(X^{+}\\right)\\right\\|^2\\right)}{\\sum_{X-\\epsilon\r\nC} \\exp \\left(-\\left\\|f(X)-f\\left(X^{-}\\right)\\right\\|^2\\right)}\r\n\\]</span></p>\r\n<blockquote>\r\n<p>NCA本质上是一种邻居投票方法。首先计算<span\r\nclass=\"math inline\">\\(X_i\\)</span>的邻居<span\r\nclass=\"math inline\">\\(X_j\\)</span>的分布概率<span\r\nclass=\"math inline\">\\(p_{ij}\\)</span>为： <span class=\"math display\">\\[\r\n\\mathcal{L}_{\\mathrm{NCA}}=\\frac{\\exp \\left(-\\left\\|f(X_i)-f\\left( X_j\r\n\\right)\\right\\|^2\\right)}{\\sum_{X_k \\epsilon C} \\exp\r\n\\left(-\\left\\|f(X_i)-f\\left(X_k \\right)\\right\\|^2\\right)}\\]</span>\r\n有了<span\r\nclass=\"math inline\">\\(p_{ij}\\)</span>之后，我们可以在邻域内采样，例如假如采样到<span\r\nclass=\"math inline\">\\(X_j\\)</span>，那就认为当前的<span\r\nclass=\"math inline\">\\(X_i\\)</span>的标签是<span\r\nclass=\"math inline\">\\(y_j\\)</span>。而当<span\r\nclass=\"math inline\">\\(y_j=y_i\\)</span>时，那么这种采样投票就是正确的，因此最终的采样投票正确概率为：\r\n<span class=\"math display\">\\[p_i=\\sum_{j \\in C}p_ij\\]</span>\r\n其中C为所有投票正确的邻居，进而整个网络的目标就是让所有的<span\r\nclass=\"math inline\">\\(p_i\\)</span>尽可能的大，即： <span\r\nclass=\"math display\">\\[p_i=\\sum_{i=1}^n  \\sum_{j \\in C}p_ij\\]</span></p>\r\n</blockquote>\r\n<p>最后result的衡量方式使用false positive rate(FPR)。</p>\r\n<h3 id=\"transformer\">Transformer</h3>\r\n<ul>\r\n<li>Vaswani A, Shazeer N, Parmar N, et al. Attention is all you\r\nneed[C]//Advances in neural information processing systems. 2017:\r\n5998-6008.</li>\r\n<li>Google</li>\r\n</ul>\r\n<p>RNN，LSTM，GNU是处理序列模型的几种最优方法。然而循环神经网络中总是沿着词元位置进行计算，这种<strong>顺序性阻碍了训练的并行化</strong>，这也严重影响了内存对batch的限制程度。因此<strong>Transformer</strong>完全依赖<strong>Self-Attention</strong>来抽取输入和输出的全局关系。并且能有更好的并行化。</p>\r\n<h3 id=\"external-attention\">External Attention</h3>\r\n<ul>\r\n<li>Guo M H, Liu Z N, Mu T J, et al. Beyond self-attention: External\r\nattention using two linear layers for visual tasks[J]. arXiv preprint\r\narXiv:2105.02358, 2021.</li>\r\n<li>清华</li>\r\n</ul>\r\n<p>自注意力机制在同一个样本内,\r\n任意一个部位的特征都可以聚合所有位置的特征进行加权输出。但是自注意力拥有<strong>二次复杂度</strong>,\r\n并且<strong>不能计算多个样本之间的潜在联系</strong>。</p>\r\n<p>External-Attention(EAT) 希望在学习某个数据集时,\r\n能够找到多个样本之间的潜在联系。其通过保持一定的<strong>key\r\nmemory</strong>,\r\n以找到跨越所有样本的最具有辨识性的特征。这种思想类似于sparse coding 和\r\ndictionary learning。并且由于key memory设计的很小,\r\n因此EAT计算上具有O(n)的复杂度,\r\n比起自注意力<strong>高效</strong>很多。</p>\r\n<h3 id=\"vision-transformer-vit\">Vision Transformer (ViT)</h3>\r\n<ul>\r\n<li>Dosovitskiy A, Beyer L, Kolesnikov A, et al. An Image is Worth 16x16\r\nWords: Transformers for Image Recognition at Scale[C]//International\r\nConference on Learning Representations. 2020.</li>\r\n<li>Google</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://i.imgur.com/CbvUBIo.png\" alt=\"模型结构\" />\r\n<figcaption aria-hidden=\"true\">模型结构</figcaption>\r\n</figure>\r\n<p>第一篇CV上的Transformer：</p>\r\n<ul>\r\n<li><strong>patch embedding</strong>:\r\n为了仿照NLP的输入结构，将图像划分为多个patches，并且展平为一维序列。由于Transformer层的输入长度固定为D，因此原patches组成的特征序列长度为N，通过线性层将长度映射成D。</li>\r\n<li><strong>position embeddings</strong>：由于2D的position\r\nembeddings没有体现出优越性，因此还是使用了标准的1D可学习的position\r\nembeddings。</li>\r\n<li><strong>Hybrid Architecture</strong>:\r\npatches的特征可以通过CNN来进行提取。</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\mathbf{z}_{0} &amp;=\\left[\\mathbf{x}_{\\text {class }} ;\r\n\\mathbf{x}_{p}^{1} \\mathbf{E} ; \\mathbf{x}_{p}^{2} \\mathbf{E} ; \\cdots ;\r\n\\mathbf{x}_{p}^{N} \\mathbf{E}\\right]+\\mathbf{E}_{p o s}, &amp; &amp;\r\n\\mathbf{E} \\in \\mathbb{R}^{\\left(P^{2} \\cdot C\\right) \\times D},\r\n\\mathbf{E}_{p o s} \\in \\mathbb{R}^{(N+1) \\times D} \\\\\r\n\\mathbf{z}_{\\ell}^{\\prime}\r\n&amp;=\\operatorname{MSA}\\left(\\operatorname{LN}\\left(\\mathbf{z}_{\\ell-1}\\right)\\right)+\\mathbf{z}_{\\ell-1},\r\n&amp; &amp; \\ell=1 \\ldots L \\\\\r\n\\mathbf{z}_{\\ell}\r\n&amp;=\\operatorname{MLP}\\left(\\operatorname{LN}\\left(\\mathbf{z}_{\\ell}^{\\prime}\\right)\\right)+\\mathbf{z}_{\\ell}^{\\prime},\r\n&amp; &amp; \\ell=1 \\ldots L \\\\\r\n\\mathbf{y} &amp;=\\operatorname{LN}\\left(\\mathbf{z}_{L}^{0}\\right) &amp;\r\n&amp;\r\n\\end{aligned}\r\n\\]</span></p>\r\n<blockquote>\r\n<p>分辨率单一，计算效率低。 class token是什么？</p>\r\n</blockquote>\r\n<h3 id=\"swim-transformer\">Swim Transformer</h3>\r\n<ul>\r\n<li>Liu Z, Lin Y, Cao Y, et al. Swin transformer: Hierarchical vision\r\ntransformer using shifted windows[C]//Proceedings of the IEEE/CVF\r\nInternational Conference on Computer Vision. 2021: 10012-10022.</li>\r\n</ul>\r\n<p>在ViT中，自注意力是全局计算的，但是图片分辨率比起句子往往较大，因此带来了计算效率低的问题。locality一直是视觉里的重要建模方式，因此这篇文章将图片切分为<strong>不重合的local\r\nwindow</strong>，并且在local\r\nwindow内部进行注意力计算。为了让window之间有信息交换，在相邻两层使用<strong>不同的window划分</strong>。</p>\r\n<p>金字塔层次化Transformer。</p>\r\n<h3 id=\"layer-normalization\">Layer Normalization</h3>\r\n<ul>\r\n<li>Ba J L, Kiros J R, Hinton G E. Layer normalization[J]. arXiv\r\npreprint arXiv:1607.06450, 2016.</li>\r\n</ul>\r\n<h3 id=\"pre-layer-normalization\">Pre Layer Normalization</h3>\r\n<ul>\r\n<li>Xiong R, Yang Y, He D, et al. On layer normalization in the\r\ntransformer architecture[C]//International Conference on Machine\r\nLearning. PMLR, 2020: 10524-10533.</li>\r\n</ul>\r\n<p>本文分析了Transformer模型的初始化warmup问题，将layer\r\nnormalization从原本的残差后移到了残差前，从实验和理论证明了pre-LN不需要warmup，并且收敛更好。</p>\r\n<h3 id=\"localvit\">LocalViT</h3>\r\n<ul>\r\n<li>Li Y, Zhang K, Cao J, et al. Localvit: Bringing locality to vision\r\ntransformers[J]. arXiv preprint arXiv:2104.05707, 2021.</li>\r\n<li>苏黎世联邦理工</li>\r\n</ul>\r\n<p>在Transformer的FeedForward层中添加inverted residual block以及\r\ndepth-wise 卷积来增加local能力。</p>\r\n<p>FeedForward层可以有助于增加Transformer结构的泛化能力。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/msRVrEW.png\" alt=\"local feedforward\" />\r\n<figcaption aria-hidden=\"true\">local feedforward</figcaption>\r\n</figure>\r\n<h3 id=\"mobilenet\">MobileNet</h3>\r\n<ul>\r\n<li>Howard A G, Zhu M, Chen B, et al. Mobilenets: Efficient\r\nconvolutional neural networks for mobile vision applications[J]. arXiv\r\npreprint arXiv:1704.04861, 2017.</li>\r\n<li>Google</li>\r\n</ul>\r\n<p><strong>Depth wise\r\n卷积</strong>：将原来的<strong>多输入通道+多输出通道</strong>卷积拆分为\r\n<strong>逐通道卷积+1D卷积通道变换</strong>，极大节省计算量。其计算量从<span\r\nclass=\"math inline\">\\(D_K \\times D_K \\times M \\times N \\times D_F \\times\r\nD_F\\)</span>变为<span class=\"math inline\">\\(D_K \\times D_K \\times M\r\n\\times D_F \\times D_F+M \\times N \\times D_F \\times\r\nD_F\\)</span>，论文模型在ImageNet上参数量大约缩小为1/10，准确率下降1%。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/2tkPCO8.png\" alt=\"DepthWise Conv\" />\r\n<figcaption aria-hidden=\"true\">DepthWise Conv</figcaption>\r\n</figure>\r\n<h3 id=\"resnet\">ResNet</h3>\r\n<ul>\r\n<li>He K, Zhang X, Ren S, et al. Deep residual learning for image\r\nrecognition[C]//Proceedings of the IEEE conference on computer vision\r\nand pattern recognition. 2016: 770-778.</li>\r\n</ul>\r\n<h3 id=\"位置编码\">位置编码</h3>\r\n<ul>\r\n<li>T5编码 Raffel C, Shazeer N, Roberts A, et al. Exploring the limits\r\nof transfer learning with a unified text-to-text transformer[J]. arXiv\r\npreprint arXiv:1910.10683, 2019.</li>\r\n<li>Ke G, He D, Liu T Y. Rethinking Positional Encoding in Language\r\nPre-training[C]//International Conference on Learning Representations.\r\n2020.</li>\r\n<li>相对位置编码基础 Shaw P, Uszkoreit J, Vaswani A. Self-Attention with\r\nRelative Position Representations[C]//Proceedings of the 2018 Conference\r\nof the North American Chapter of the Association for Computational\r\nLinguistics: Human Language Technologies, Volume 2 (Short Papers). 2018:\r\n464-468.</li>\r\n<li>训练式编码 Gehring J, Auli M, Grangier D, et al. Convolutional\r\nsequence to sequence learning[C]//International Conference on Machine\r\nLearning. PMLR, 2017: 1243-1252.</li>\r\n</ul>\r\n<h3 id=\"训练优化\">训练优化</h3>\r\n<ul>\r\n<li><p>Goyal P, Dollár P, Girshick R, et al. Accurate, large minibatch\r\nsgd: Training imagenet in 1 hour[J]. arXiv preprint arXiv:1706.02677,\r\n2017.</p></li>\r\n<li><p>Smith L N. Cyclical learning rates for training neural\r\nnetworks[C]//2017 IEEE winter conference on applications of computer\r\nvision (WACV). IEEE, 2017: 464-472.</p></li>\r\n</ul>\r\n<p>传统的方法中认为学习率应该是一个单调缓慢减少的数，然而这篇文章指出在一个<strong>周期范围变化的学习率</strong>可以有更好的效果。其循环变化方式可以有三角式、余弦式，线性式等。</p>\r\n<p><strong>原理</strong>：通常造成loss下降困难的地方是\r\n<strong>鞍点</strong> 而不是简单的\r\n<strong>极小点</strong>，在鞍点附近梯度极小，导致更新缓慢。此时就可以通过增大学习率来跳出鞍点。</p>\r\n<p><strong>确定循环周期</strong>：实验表明半周期设置为2~10个epoch*iterations比较好。(按iteration迭代，而不是按epoch迭代)。最好使用3个以上的epoch来代替一个常量学习率下的epoch。</p>\r\n<p><strong>确定学习率上下界</strong>：所谓LR\r\ntest，运行几个单独的epoch，同时线性增大学习率，观察准确率的变化，找到第一个增加点，和波动之前的最后一个点。</p>\r\n<ul>\r\n<li>Loshchilov I, Hutter F. Sgdr: Stochastic gradient descent with warm\r\nrestarts[J]. arXiv preprint arXiv:1608.03983, 2016.</li>\r\n</ul>\r\n<p>实验表明，使用warm\r\nrestart的学习率更新方法，收敛速度比寻常方法可以快2~4倍。其提出了<strong>余弦退火学习率调度器</strong>：</p>\r\n<p><span class=\"math display\">\\[\r\n\\eta_{t}=\\eta_{\\min }^{i}+\\frac{1}{2}\\left(\\eta_{\\max }^{i}-\\eta_{\\min\r\n}^{i}\\right)\\left(1+\\cos \\left(\\frac{T_{\\text {cur }}}{T_{i}}\r\n\\pi\\right)\\right),\r\n\\]</span></p>\r\n<p>论文使用参数<span class=\"math inline\">\\(T_o=10\\)</span>,<span\r\nclass=\"math inline\">\\(T_{mult}=2\\)</span>。</p>\r\n<h3 id=\"can-attention-enable-mlps-to-catch-up-with-cnns\">Can attention\r\nenable MLPs to catch up with CNNs</h3>\r\n<ul>\r\n<li>Guo M H, Liu Z N, Mu T J, et al. Can attention enable MLPs to catch\r\nup with CNNs?[J]. Computational Visual Media, 2021, 7(3): 283-288.</li>\r\n</ul>\r\n<p>比较了几个新兴的MLP，CNN，Transformer模型，总结了以下几个共同点：</p>\r\n<ul>\r\n<li>通过将图片划分为Patch，可以更好地捕捉局部结构。</li>\r\n<li>注意力中的辅助结构也可以考虑应用在非注意力模型上，比如Multi-Head</li>\r\n<li>Residual 结构对于所有模型都很重要</li>\r\n<li>局部计算的CNN会导致归纳偏差(Inductive\r\nBias)，而一维卷积和全域计算结构可以减少归纳偏差。</li>\r\n</ul>\r\n<h3 id=\"action-recognition-based-on-a-bag-of-3d-points\">Action\r\nrecognition Based on A Bag of 3D Points</h3>\r\n<ul>\r\n<li>Li W, Zhang Z, Liu Z. Action recognition based on a bag of 3d\r\npoints[C]//2010 IEEE computer society conference on computer vision and\r\npattern recognition-workshops. IEEE, 2010: 9-14.</li>\r\n<li>CVPRW</li>\r\n<li>University of Wollongong</li>\r\n</ul>\r\n<p>第一，其提出可以用整个点云bag来表示动作序列。并且点出每一帧之间，点的个数可能不同，并且点之间没有对应关系。更进一步，其假设一个点云帧是一个\r\n<strong>混合高斯模型</strong>，可以通过一系列的混合高斯分布来描述：</p>\r\n<p><span class=\"math display\">\\[\r\np(x \\mid \\omega)=\\prod_{i=1}^{m} \\sum_{t=1}^{Q} \\pi_{t}^{\\omega}\r\ng\\left(q_{i}, \\mu_{t}^{\\omega}, \\Sigma_{t}^{\\omega}\\right)\r\n\\]</span></p>\r\n<p>另外，由于点的数量太多容易造成noise和计算问题，需要对点进行采样。在2D的经验里，人体的边缘轮廓是最重要的形状信息。进而在3D中，提出了一种点云的<strong>投影采样法</strong>：通过将点云投影到三个正交2D面，再在2D上进行轮廓采样。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/Fi3BjWH.png\" alt=\"投影采样\" />\r\n<figcaption aria-hidden=\"true\">投影采样</figcaption>\r\n</figure>\r\n<h3\r\nid=\"dpdist-comparing-point-clouds-using-deep-point-cloud-distance\">DPDist:\r\nComparing Point Clouds Using Deep Point Cloud Distance</h3>\r\n<ul>\r\n<li>Urbach D, Ben-Shabat Y, Lindenbaum M. DPDist: Comparing point clouds\r\nusing deep point cloud distance[C]//European Conference on Computer\r\nVision. Springer, Cham, 2020: 545-560.</li>\r\n<li>澳大利亚国立大学</li>\r\n</ul>\r\n<p>本文提出了一种衡量点云距离的深度学习方法，不同于传统方法，其衡量的是点云A到点云B的surface\r\nrepresentation的距离。介绍了几种传统点云距离度量方法，以及新的基于深度学习的改进方法。</p>\r\n<p><strong>Hausdorff distance</strong> 距离：点到点距离<span\r\nclass=\"math inline\">\\(d(x,y)\\)</span>，点到点云距离<span\r\nclass=\"math inline\">\\(D(x,S)\\)</span>，点云到点云距离<span\r\nclass=\"math inline\">\\(D_H(S_A,S_B)\\)</span>。</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\nd(x, y) &amp;=\\|x-y\\|_{2} \\\\\r\nD(x, S) &amp;=\\min _{y \\in S} d(x, y) \\\\\r\n\\mathcal{D}_{H}\\left(S_{A}, S_{B}\\right)&amp;=\\max \\left\\{\\max _{a \\in\r\nS_{A}} D\\left(a, S_{B}\\right), \\max _{b \\in S_{B}} D\\left(b,\r\nS_{A}\\right)\\right\\}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><strong>Chamfer\r\ndistance</strong>：相比于Hausdorff距离，Chamfer取平均距离而不是取最大距离。</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathcal{D}_{C D}\\left(S_{A}, S_{B}\\right)=\\frac{1}{N_{A}} \\sum_{a \\in\r\nS_{A}} \\min _{y \\in S_{B}} d(a, y)^{2}+\\frac{1}{N_{B}} \\sum_{b \\in\r\nS_{B}} \\min _{y \\in S_{A}} d(b, y)^{2}\r\n\\]</span></p>\r\n<p>Earth Mover's Distance :\r\n在点云B中确定一种离点云A最近的映射关系，再累加欧拉距离。</p>\r\n<p><span class=\"math display\">\\[\r\n\\mathcal{D}_{E M D}\\left(S_{A}, S_{B}\\right)=\\min _{\\xi: S_{A}\r\n\\rightarrow S_{B}} \\sum_{a \\in S_{A}}\\|a-\\xi(a)\\|_{2}\r\n\\]</span></p>\r\n<h3 id=\"siamese-neural-network-triplet-network\">Siamese Neural Network\r\n&amp; Triplet Network</h3>\r\n<ul>\r\n<li>Bromley J, Guyon I, LeCun Y, et al. Signature verification using a\"\r\nsiamese\" time delay neural network[J]. Advances in neural information\r\nprocessing systems, 1993, 6.</li>\r\n</ul>\r\n<p>孪生神经网络，用于衡量两个小样本输入的相似程度。在输入数据属于训练数据集的情况下，通常我们可以通过数据识别分类来比较两个数据。然而对于小样本数据，其数据量根本不够成为训练数据集，甚至这个数据可能只有一份，此时则无法通过训练识别来进行分类。</p>\r\n<p>为了能够度量训练集以外的输入数据相似性，孪生神经网络在训练<strong>特征提取</strong>网络的基础上，还增加了<strong>同类相近、异类排斥</strong>的结构，以便于强调网络的<strong>数据匹配</strong>能力。其将一对输入<span\r\nclass=\"math inline\">\\(X_1,X_2\\)</span>给到同一个神经网络提取特征向量<span\r\nclass=\"math inline\">\\(F_1,F_2\\)</span>，并计算两个特征向量的相似度。如果是同类别的输入对，则期望相似度输出为1，如果是不同类别的输入对则期望输出0。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/eqmq6lr.png\" alt=\"孪生神经网络模型图\" />\r\n<figcaption aria-hidden=\"true\">孪生神经网络模型图</figcaption>\r\n</figure>\r\n<p>损失函数Contrastive Loss：<span\r\nclass=\"math inline\">\\(D_W\\)</span>为输入对的特征向量的距离度量，<span\r\nclass=\"math inline\">\\(Y\\)</span>指明输入对是同类还是异类。即通过<span\r\nclass=\"math inline\">\\(Y\\)</span>可以选择启用损失函数里的<strong>同类损失部分</strong>或者<strong>异类损失部分</strong>。<strong>同类距离需要尽可能的小，异类距离需要尽可能的大</strong>。</p>\r\n<p><span class=\"math display\">\\[\r\nD_{w}(X_{1}, X_{2}) = ||G(X_{1}) - G(X_{2})|| \\\\\r\n\\mathcal{L} = (1-Y)\\frac{1}{2}(D_W)^2+(Y)\\frac{1}{2}\\{max(0, m-D_W)\\}^2\r\n\\]</span></p>\r\n<p>在孪生网络中每一对输入要么是同类的，要么是异类的，即同类和异类的训练需要分PASS进行。而在Triplet三生网络中则将输入进行扩展，一组输入包含三个数据，既有同类，又有异类，进而可以将训练过程放在一个PASS完成。</p>\r\n<figure>\r\n<img src=\"https://i.imgur.com/QWhZZWr.png\" alt=\"三生神经网络模型图\" />\r\n<figcaption aria-hidden=\"true\">三生神经网络模型图</figcaption>\r\n</figure>\r\n<p>同样，其损失函数<strong>三元组损失</strong>也改造成了一个PASS的形式：其本质上衡量了<span\r\nclass=\"math inline\">\\((d_+,d_-)\\)</span>与<span\r\nclass=\"math inline\">\\((0,1)\\)</span>的向量距离。</p>\r\n<p><span class=\"math display\">\\[\r\nd_{+} = \\frac{e^{\\Vert Net(x)-Net(x^{+})\\Vert _2}}{e^{\\Vert\r\nNet(x)-Net(x^{+})\\Vert _2}+e^{\\Vert Net(x)-Net(x^{-})\\Vert _2}} \\\\\r\nLoss(d_{+},d_{-}) = \\Vert (d_{+} , d_{-}-1)\\Vert _2^2 = const\\cdot d_+^2\r\n\\\\\r\n\\]</span></p>\r\n<h3\r\nid=\"action-density-based-frame-sampling-for-human-action-recognition-in-videos\">Action\r\ndensity based frame sampling for human action recognition in videos</h3>\r\n<ul>\r\n<li>Lin J, Mu Z, Zhao T, et al. Action density based frame sampling for\r\nhuman action recognition in videos[J]. Journal of Visual Communication\r\nand Image Representation, 2023, 90: 103740.</li>\r\n<li>西安交大 JVCIR 一区</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://i.imgur.com/0Cjr6hr.png\" alt=\"框架图\" />\r\n<figcaption aria-hidden=\"true\">框架图</figcaption>\r\n</figure>\r\n<p>视频帧采样优化的论文。主要想法在于把视频分为\r\n信息密度大的clip和信息密度小的clip，并且分别处理采样。整个流程分为三个环节：帧打分、区间划分、区间采样。</p>\r\n<p>Action density\r\ndetermination：即给原始视频的每一帧进行密度分数评估：</p>\r\n<p><span class=\"math display\">\\[\r\n\\left\\{\\begin{array}{l}\r\nD_n=\\sqrt{\\sum\\left|E(x, y)+I_{\\text {fout }}(x, y)\\right|^2} \\\\\r\nE(x, y)=\\left\\{\\begin{array}{cl}\r\n\\alpha \\cdot I_{\\text {fout }}(x, y), &amp; \\left(I_{\\text {bout }}(x,\r\ny)=1\\right) \\\\\r\n0, &amp; (Else)\r\n\\end{array}\\right.\r\n\\end{array}\\right.\r\n\\]</span></p>\r\n<p>其中<span class=\"math inline\">\\(I_{\\text {fout }}(x,\r\ny)\\)</span>为<span\r\nclass=\"math inline\">\\((x,y)\\)</span>的像素在相邻帧之中的距离大小。<span\r\nclass=\"math inline\">\\(I_{\\text {bout }}(x,\r\ny)\\)</span>为图像前景和背景的距离大小。</p>\r\n<p>Focused-clips division mechanism：\r\n有了每一帧的打分之后，即可以划定一个分数阈值，来将原始视频区分为高密度clip和低密度clip。本文选择了分数Top\r\nK的平均分数作为阈值，然后评估所有的连续帧。高于阈值的连续帧作为高密度clip，低于阈值的连续帧则作为低密度clip\r\n(注意高密度低密度都不止有一组，整个视频被阈值切割成了多个clip片段)，\r\n这样采样时可以选择高密度的clip采样频率更高，低密度的采样频率更低。</p>\r\n<p>Reinforcement learning based frame sampling (RLFS) mechanism：\r\n强化学习采样法。本质即惩罚采样连续的帧，鼓励间断性采样。</p>\r\n<h3\r\nid=\"scsampler-sampling-salient-clips-from-video-for-efficient-action-recognition\">SCSampler:\r\nSampling Salient Clips from Video for Efficient Action Recognition</h3>\r\n<ul>\r\n<li>Korbar B, Tran D, Torresani L. Scsampler: Sampling salient clips\r\nfrom video for efficient action recognition[C]//Proceedings of the\r\nIEEE/CVF International Conference on Computer Vision. 2019:\r\n6232-6242.</li>\r\n<li>ICCV FacebookAI</li>\r\n</ul>\r\n<p>核心是对于视频提供一个帧评分采样器\r\nSCsampler。论文希望通过优化采样后，可以节省长视频中大量无关内容的计算，并且提升准确率。</p>\r\n<p>SCsampler的实现在于如何给每一帧进行saliency\r\nscore的评分计算，论文给出了两种实现思路： - 朴素思路是计算classification\r\nscore，即计算每一帧对输出label的帮助程度/相关性，论文通过预训练一个针对每一帧的分类网络<span\r\nclass=\"math inline\">\\(h\\)</span>来实现，saliency score即<span\r\nclass=\"math inline\">\\(h\\)</span>对所有label最大的一个预测概率。 -\r\n论文优化后的方法是希望通过 打分映射<span\r\nclass=\"math inline\">\\(s\\)</span> 和 定制loss 来训练可学习的打分环节。\r\n<span class=\"math display\">\\[\r\n\\ell\\left(\\phi_n^{(i)}, \\phi_n^{(j)}\\right)=\\max \\left(-z_n^{(i,\r\nj)}\\left[s\\left(\\phi_n^{(i)}\\right)-s\\left(\\phi_n^{(j)}\\right)+\\eta\\right],\r\n0\\right)\r\n\\]</span> 这个loss使用从原视频中采样出的clips对<span\r\nclass=\"math inline\">\\(v_n^i,v_n^j\\)</span>来比较计算，其中如果<span\r\nclass=\"math inline\">\\(v_n^i\\)</span>对label预测的概率比<span\r\nclass=\"math inline\">\\(v_n^j\\)</span>大，那么<span\r\nclass=\"math inline\">\\(z_n^{(i, j)}\\)</span>为 1 ，否则是-1。\r\n这个loss本质上在鼓励saliency score的打分映射<span\r\nclass=\"math inline\">\\(s\\)</span>对两个clip的评分差距接近classification\r\nscore。</p>\r\n<p>实验效果来看，对于视频，第一种朴素思路比第二种效果好很多。对于音频，第二种稍微好一点点。</p>\r\n","categories":["深度学习"],"tags":["点云","序列学习"]},{"title":"Sitch","url":"/about/index.html","content":"<h4 id=\"戒骄戒躁求真务实\">戒骄戒躁求真务实</h4>\r\n<ul>\r\n<li><p>一知半解似懂非懂统一为，不知道。</p></li>\r\n<li><p>拒绝虚话奉承话。</p></li>\r\n<li><p>不好为人师，经历过不代表最优解，从中抽取有价值的东西分享。</p></li>\r\n<li><p>透明化专业壁垒，别人选择的道路不同而已，不代表你的选择有什么可优越的，尽量消解专业壁垒才是值得骄傲的事。</p></li>\r\n<li><p>说话去攻击性，没必要去怄气针锋相对。</p></li>\r\n</ul>\r\n"},{"title":"分类","url":"/categories/index.html","content":"\r\n"},{"title":"tags","url":"/tags/index.html","content":"\r\n"}]